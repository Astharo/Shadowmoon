/******/ (function(modules) { // webpackBootstrap
/******/ 	var parentHotUpdateCallback = this["webpackHotUpdate"];
/******/ 	this["webpackHotUpdate"] = 
/******/ 	function webpackHotUpdateCallback(chunkId, moreModules) { // eslint-disable-line no-unused-vars
/******/ 		hotAddUpdateChunk(chunkId, moreModules);
/******/ 		if(parentHotUpdateCallback) parentHotUpdateCallback(chunkId, moreModules);
/******/ 	}
/******/ 	
/******/ 	function hotDownloadUpdateChunk(chunkId) { // eslint-disable-line no-unused-vars
/******/ 		var head = document.getElementsByTagName("head")[0];
/******/ 		var script = document.createElement("script");
/******/ 		script.type = "text/javascript";
/******/ 		script.charset = "utf-8";
/******/ 		script.src = __webpack_require__.p + "" + chunkId + "." + hotCurrentHash + ".hot-update.js";
/******/ 		head.appendChild(script);
/******/ 	}
/******/ 	
/******/ 	function hotDownloadManifest(callback) { // eslint-disable-line no-unused-vars
/******/ 		if(typeof XMLHttpRequest === "undefined")
/******/ 			return callback(new Error("No browser support"));
/******/ 		try {
/******/ 			var request = new XMLHttpRequest();
/******/ 			var requestPath = __webpack_require__.p + "" + hotCurrentHash + ".hot-update.json";
/******/ 			request.open("GET", requestPath, true);
/******/ 			request.timeout = 10000;
/******/ 			request.send(null);
/******/ 		} catch(err) {
/******/ 			return callback(err);
/******/ 		}
/******/ 		request.onreadystatechange = function() {
/******/ 			if(request.readyState !== 4) return;
/******/ 			if(request.status === 0) {
/******/ 				// timeout
/******/ 				callback(new Error("Manifest request to " + requestPath + " timed out."));
/******/ 			} else if(request.status === 404) {
/******/ 				// no update available
/******/ 				callback();
/******/ 			} else if(request.status !== 200 && request.status !== 304) {
/******/ 				// other failure
/******/ 				callback(new Error("Manifest request to " + requestPath + " failed."));
/******/ 			} else {
/******/ 				// success
/******/ 				try {
/******/ 					var update = JSON.parse(request.responseText);
/******/ 				} catch(e) {
/******/ 					callback(e);
/******/ 					return;
/******/ 				}
/******/ 				callback(null, update);
/******/ 			}
/******/ 		};
/******/ 	}
/******/
/******/ 	
/******/ 	
/******/ 	// Copied from https://github.com/facebook/react/blob/bef45b0/src/shared/utils/canDefineProperty.js
/******/ 	var canDefineProperty = false;
/******/ 	try {
/******/ 		Object.defineProperty({}, "x", {
/******/ 			get: function() {}
/******/ 		});
/******/ 		canDefineProperty = true;
/******/ 	} catch(x) {
/******/ 		// IE will fail on defineProperty
/******/ 	}
/******/ 	
/******/ 	var hotApplyOnUpdate = true;
/******/ 	var hotCurrentHash = "40d5658d716d1df426e7"; // eslint-disable-line no-unused-vars
/******/ 	var hotCurrentModuleData = {};
/******/ 	var hotCurrentParents = []; // eslint-disable-line no-unused-vars
/******/ 	
/******/ 	function hotCreateRequire(moduleId) { // eslint-disable-line no-unused-vars
/******/ 		var me = installedModules[moduleId];
/******/ 		if(!me) return __webpack_require__;
/******/ 		var fn = function(request) {
/******/ 			if(me.hot.active) {
/******/ 				if(installedModules[request]) {
/******/ 					if(installedModules[request].parents.indexOf(moduleId) < 0)
/******/ 						installedModules[request].parents.push(moduleId);
/******/ 					if(me.children.indexOf(request) < 0)
/******/ 						me.children.push(request);
/******/ 				} else hotCurrentParents = [moduleId];
/******/ 			} else {
/******/ 				console.warn("[HMR] unexpected require(" + request + ") from disposed module " + moduleId);
/******/ 				hotCurrentParents = [];
/******/ 			}
/******/ 			return __webpack_require__(request);
/******/ 		};
/******/ 		for(var name in __webpack_require__) {
/******/ 			if(Object.prototype.hasOwnProperty.call(__webpack_require__, name)) {
/******/ 				if(canDefineProperty) {
/******/ 					Object.defineProperty(fn, name, (function(name) {
/******/ 						return {
/******/ 							configurable: true,
/******/ 							enumerable: true,
/******/ 							get: function() {
/******/ 								return __webpack_require__[name];
/******/ 							},
/******/ 							set: function(value) {
/******/ 								__webpack_require__[name] = value;
/******/ 							}
/******/ 						};
/******/ 					}(name)));
/******/ 				} else {
/******/ 					fn[name] = __webpack_require__[name];
/******/ 				}
/******/ 			}
/******/ 		}
/******/ 	
/******/ 		function ensure(chunkId, callback) {
/******/ 			if(hotStatus === "ready")
/******/ 				hotSetStatus("prepare");
/******/ 			hotChunksLoading++;
/******/ 			__webpack_require__.e(chunkId, function() {
/******/ 				try {
/******/ 					callback.call(null, fn);
/******/ 				} finally {
/******/ 					finishChunkLoading();
/******/ 				}
/******/ 	
/******/ 				function finishChunkLoading() {
/******/ 					hotChunksLoading--;
/******/ 					if(hotStatus === "prepare") {
/******/ 						if(!hotWaitingFilesMap[chunkId]) {
/******/ 							hotEnsureUpdateChunk(chunkId);
/******/ 						}
/******/ 						if(hotChunksLoading === 0 && hotWaitingFiles === 0) {
/******/ 							hotUpdateDownloaded();
/******/ 						}
/******/ 					}
/******/ 				}
/******/ 			});
/******/ 		}
/******/ 		if(canDefineProperty) {
/******/ 			Object.defineProperty(fn, "e", {
/******/ 				enumerable: true,
/******/ 				value: ensure
/******/ 			});
/******/ 		} else {
/******/ 			fn.e = ensure;
/******/ 		}
/******/ 		return fn;
/******/ 	}
/******/ 	
/******/ 	function hotCreateModule(moduleId) { // eslint-disable-line no-unused-vars
/******/ 		var hot = {
/******/ 			// private stuff
/******/ 			_acceptedDependencies: {},
/******/ 			_declinedDependencies: {},
/******/ 			_selfAccepted: false,
/******/ 			_selfDeclined: false,
/******/ 			_disposeHandlers: [],
/******/ 	
/******/ 			// Module API
/******/ 			active: true,
/******/ 			accept: function(dep, callback) {
/******/ 				if(typeof dep === "undefined")
/******/ 					hot._selfAccepted = true;
/******/ 				else if(typeof dep === "function")
/******/ 					hot._selfAccepted = dep;
/******/ 				else if(typeof dep === "object")
/******/ 					for(var i = 0; i < dep.length; i++)
/******/ 						hot._acceptedDependencies[dep[i]] = callback;
/******/ 				else
/******/ 					hot._acceptedDependencies[dep] = callback;
/******/ 			},
/******/ 			decline: function(dep) {
/******/ 				if(typeof dep === "undefined")
/******/ 					hot._selfDeclined = true;
/******/ 				else if(typeof dep === "number")
/******/ 					hot._declinedDependencies[dep] = true;
/******/ 				else
/******/ 					for(var i = 0; i < dep.length; i++)
/******/ 						hot._declinedDependencies[dep[i]] = true;
/******/ 			},
/******/ 			dispose: function(callback) {
/******/ 				hot._disposeHandlers.push(callback);
/******/ 			},
/******/ 			addDisposeHandler: function(callback) {
/******/ 				hot._disposeHandlers.push(callback);
/******/ 			},
/******/ 			removeDisposeHandler: function(callback) {
/******/ 				var idx = hot._disposeHandlers.indexOf(callback);
/******/ 				if(idx >= 0) hot._disposeHandlers.splice(idx, 1);
/******/ 			},
/******/ 	
/******/ 			// Management API
/******/ 			check: hotCheck,
/******/ 			apply: hotApply,
/******/ 			status: function(l) {
/******/ 				if(!l) return hotStatus;
/******/ 				hotStatusHandlers.push(l);
/******/ 			},
/******/ 			addStatusHandler: function(l) {
/******/ 				hotStatusHandlers.push(l);
/******/ 			},
/******/ 			removeStatusHandler: function(l) {
/******/ 				var idx = hotStatusHandlers.indexOf(l);
/******/ 				if(idx >= 0) hotStatusHandlers.splice(idx, 1);
/******/ 			},
/******/ 	
/******/ 			//inherit from previous dispose call
/******/ 			data: hotCurrentModuleData[moduleId]
/******/ 		};
/******/ 		return hot;
/******/ 	}
/******/ 	
/******/ 	var hotStatusHandlers = [];
/******/ 	var hotStatus = "idle";
/******/ 	
/******/ 	function hotSetStatus(newStatus) {
/******/ 		hotStatus = newStatus;
/******/ 		for(var i = 0; i < hotStatusHandlers.length; i++)
/******/ 			hotStatusHandlers[i].call(null, newStatus);
/******/ 	}
/******/ 	
/******/ 	// while downloading
/******/ 	var hotWaitingFiles = 0;
/******/ 	var hotChunksLoading = 0;
/******/ 	var hotWaitingFilesMap = {};
/******/ 	var hotRequestedFilesMap = {};
/******/ 	var hotAvailibleFilesMap = {};
/******/ 	var hotCallback;
/******/ 	
/******/ 	// The update info
/******/ 	var hotUpdate, hotUpdateNewHash;
/******/ 	
/******/ 	function toModuleId(id) {
/******/ 		var isNumber = (+id) + "" === id;
/******/ 		return isNumber ? +id : id;
/******/ 	}
/******/ 	
/******/ 	function hotCheck(apply, callback) {
/******/ 		if(hotStatus !== "idle") throw new Error("check() is only allowed in idle status");
/******/ 		if(typeof apply === "function") {
/******/ 			hotApplyOnUpdate = false;
/******/ 			callback = apply;
/******/ 		} else {
/******/ 			hotApplyOnUpdate = apply;
/******/ 			callback = callback || function(err) {
/******/ 				if(err) throw err;
/******/ 			};
/******/ 		}
/******/ 		hotSetStatus("check");
/******/ 		hotDownloadManifest(function(err, update) {
/******/ 			if(err) return callback(err);
/******/ 			if(!update) {
/******/ 				hotSetStatus("idle");
/******/ 				callback(null, null);
/******/ 				return;
/******/ 			}
/******/ 	
/******/ 			hotRequestedFilesMap = {};
/******/ 			hotAvailibleFilesMap = {};
/******/ 			hotWaitingFilesMap = {};
/******/ 			for(var i = 0; i < update.c.length; i++)
/******/ 				hotAvailibleFilesMap[update.c[i]] = true;
/******/ 			hotUpdateNewHash = update.h;
/******/ 	
/******/ 			hotSetStatus("prepare");
/******/ 			hotCallback = callback;
/******/ 			hotUpdate = {};
/******/ 			var chunkId = 0;
/******/ 			{ // eslint-disable-line no-lone-blocks
/******/ 				/*globals chunkId */
/******/ 				hotEnsureUpdateChunk(chunkId);
/******/ 			}
/******/ 			if(hotStatus === "prepare" && hotChunksLoading === 0 && hotWaitingFiles === 0) {
/******/ 				hotUpdateDownloaded();
/******/ 			}
/******/ 		});
/******/ 	}
/******/ 	
/******/ 	function hotAddUpdateChunk(chunkId, moreModules) { // eslint-disable-line no-unused-vars
/******/ 		if(!hotAvailibleFilesMap[chunkId] || !hotRequestedFilesMap[chunkId])
/******/ 			return;
/******/ 		hotRequestedFilesMap[chunkId] = false;
/******/ 		for(var moduleId in moreModules) {
/******/ 			if(Object.prototype.hasOwnProperty.call(moreModules, moduleId)) {
/******/ 				hotUpdate[moduleId] = moreModules[moduleId];
/******/ 			}
/******/ 		}
/******/ 		if(--hotWaitingFiles === 0 && hotChunksLoading === 0) {
/******/ 			hotUpdateDownloaded();
/******/ 		}
/******/ 	}
/******/ 	
/******/ 	function hotEnsureUpdateChunk(chunkId) {
/******/ 		if(!hotAvailibleFilesMap[chunkId]) {
/******/ 			hotWaitingFilesMap[chunkId] = true;
/******/ 		} else {
/******/ 			hotRequestedFilesMap[chunkId] = true;
/******/ 			hotWaitingFiles++;
/******/ 			hotDownloadUpdateChunk(chunkId);
/******/ 		}
/******/ 	}
/******/ 	
/******/ 	function hotUpdateDownloaded() {
/******/ 		hotSetStatus("ready");
/******/ 		var callback = hotCallback;
/******/ 		hotCallback = null;
/******/ 		if(!callback) return;
/******/ 		if(hotApplyOnUpdate) {
/******/ 			hotApply(hotApplyOnUpdate, callback);
/******/ 		} else {
/******/ 			var outdatedModules = [];
/******/ 			for(var id in hotUpdate) {
/******/ 				if(Object.prototype.hasOwnProperty.call(hotUpdate, id)) {
/******/ 					outdatedModules.push(toModuleId(id));
/******/ 				}
/******/ 			}
/******/ 			callback(null, outdatedModules);
/******/ 		}
/******/ 	}
/******/ 	
/******/ 	function hotApply(options, callback) {
/******/ 		if(hotStatus !== "ready") throw new Error("apply() is only allowed in ready status");
/******/ 		if(typeof options === "function") {
/******/ 			callback = options;
/******/ 			options = {};
/******/ 		} else if(options && typeof options === "object") {
/******/ 			callback = callback || function(err) {
/******/ 				if(err) throw err;
/******/ 			};
/******/ 		} else {
/******/ 			options = {};
/******/ 			callback = callback || function(err) {
/******/ 				if(err) throw err;
/******/ 			};
/******/ 		}
/******/ 	
/******/ 		function getAffectedStuff(module) {
/******/ 			var outdatedModules = [module];
/******/ 			var outdatedDependencies = {};
/******/ 	
/******/ 			var queue = outdatedModules.slice();
/******/ 			while(queue.length > 0) {
/******/ 				var moduleId = queue.pop();
/******/ 				var module = installedModules[moduleId];
/******/ 				if(!module || module.hot._selfAccepted)
/******/ 					continue;
/******/ 				if(module.hot._selfDeclined) {
/******/ 					return new Error("Aborted because of self decline: " + moduleId);
/******/ 				}
/******/ 				if(moduleId === 0) {
/******/ 					return;
/******/ 				}
/******/ 				for(var i = 0; i < module.parents.length; i++) {
/******/ 					var parentId = module.parents[i];
/******/ 					var parent = installedModules[parentId];
/******/ 					if(parent.hot._declinedDependencies[moduleId]) {
/******/ 						return new Error("Aborted because of declined dependency: " + moduleId + " in " + parentId);
/******/ 					}
/******/ 					if(outdatedModules.indexOf(parentId) >= 0) continue;
/******/ 					if(parent.hot._acceptedDependencies[moduleId]) {
/******/ 						if(!outdatedDependencies[parentId])
/******/ 							outdatedDependencies[parentId] = [];
/******/ 						addAllToSet(outdatedDependencies[parentId], [moduleId]);
/******/ 						continue;
/******/ 					}
/******/ 					delete outdatedDependencies[parentId];
/******/ 					outdatedModules.push(parentId);
/******/ 					queue.push(parentId);
/******/ 				}
/******/ 			}
/******/ 	
/******/ 			return [outdatedModules, outdatedDependencies];
/******/ 		}
/******/ 	
/******/ 		function addAllToSet(a, b) {
/******/ 			for(var i = 0; i < b.length; i++) {
/******/ 				var item = b[i];
/******/ 				if(a.indexOf(item) < 0)
/******/ 					a.push(item);
/******/ 			}
/******/ 		}
/******/ 	
/******/ 		// at begin all updates modules are outdated
/******/ 		// the "outdated" status can propagate to parents if they don't accept the children
/******/ 		var outdatedDependencies = {};
/******/ 		var outdatedModules = [];
/******/ 		var appliedUpdate = {};
/******/ 		for(var id in hotUpdate) {
/******/ 			if(Object.prototype.hasOwnProperty.call(hotUpdate, id)) {
/******/ 				var moduleId = toModuleId(id);
/******/ 				var result = getAffectedStuff(moduleId);
/******/ 				if(!result) {
/******/ 					if(options.ignoreUnaccepted)
/******/ 						continue;
/******/ 					hotSetStatus("abort");
/******/ 					return callback(new Error("Aborted because " + moduleId + " is not accepted"));
/******/ 				}
/******/ 				if(result instanceof Error) {
/******/ 					hotSetStatus("abort");
/******/ 					return callback(result);
/******/ 				}
/******/ 				appliedUpdate[moduleId] = hotUpdate[moduleId];
/******/ 				addAllToSet(outdatedModules, result[0]);
/******/ 				for(var moduleId in result[1]) {
/******/ 					if(Object.prototype.hasOwnProperty.call(result[1], moduleId)) {
/******/ 						if(!outdatedDependencies[moduleId])
/******/ 							outdatedDependencies[moduleId] = [];
/******/ 						addAllToSet(outdatedDependencies[moduleId], result[1][moduleId]);
/******/ 					}
/******/ 				}
/******/ 			}
/******/ 		}
/******/ 	
/******/ 		// Store self accepted outdated modules to require them later by the module system
/******/ 		var outdatedSelfAcceptedModules = [];
/******/ 		for(var i = 0; i < outdatedModules.length; i++) {
/******/ 			var moduleId = outdatedModules[i];
/******/ 			if(installedModules[moduleId] && installedModules[moduleId].hot._selfAccepted)
/******/ 				outdatedSelfAcceptedModules.push({
/******/ 					module: moduleId,
/******/ 					errorHandler: installedModules[moduleId].hot._selfAccepted
/******/ 				});
/******/ 		}
/******/ 	
/******/ 		// Now in "dispose" phase
/******/ 		hotSetStatus("dispose");
/******/ 		var queue = outdatedModules.slice();
/******/ 		while(queue.length > 0) {
/******/ 			var moduleId = queue.pop();
/******/ 			var module = installedModules[moduleId];
/******/ 			if(!module) continue;
/******/ 	
/******/ 			var data = {};
/******/ 	
/******/ 			// Call dispose handlers
/******/ 			var disposeHandlers = module.hot._disposeHandlers;
/******/ 			for(var j = 0; j < disposeHandlers.length; j++) {
/******/ 				var cb = disposeHandlers[j];
/******/ 				cb(data);
/******/ 			}
/******/ 			hotCurrentModuleData[moduleId] = data;
/******/ 	
/******/ 			// disable module (this disables requires from this module)
/******/ 			module.hot.active = false;
/******/ 	
/******/ 			// remove module from cache
/******/ 			delete installedModules[moduleId];
/******/ 	
/******/ 			// remove "parents" references from all children
/******/ 			for(var j = 0; j < module.children.length; j++) {
/******/ 				var child = installedModules[module.children[j]];
/******/ 				if(!child) continue;
/******/ 				var idx = child.parents.indexOf(moduleId);
/******/ 				if(idx >= 0) {
/******/ 					child.parents.splice(idx, 1);
/******/ 				}
/******/ 			}
/******/ 		}
/******/ 	
/******/ 		// remove outdated dependency from module children
/******/ 		for(var moduleId in outdatedDependencies) {
/******/ 			if(Object.prototype.hasOwnProperty.call(outdatedDependencies, moduleId)) {
/******/ 				var module = installedModules[moduleId];
/******/ 				var moduleOutdatedDependencies = outdatedDependencies[moduleId];
/******/ 				for(var j = 0; j < moduleOutdatedDependencies.length; j++) {
/******/ 					var dependency = moduleOutdatedDependencies[j];
/******/ 					var idx = module.children.indexOf(dependency);
/******/ 					if(idx >= 0) module.children.splice(idx, 1);
/******/ 				}
/******/ 			}
/******/ 		}
/******/ 	
/******/ 		// Not in "apply" phase
/******/ 		hotSetStatus("apply");
/******/ 	
/******/ 		hotCurrentHash = hotUpdateNewHash;
/******/ 	
/******/ 		// insert new code
/******/ 		for(var moduleId in appliedUpdate) {
/******/ 			if(Object.prototype.hasOwnProperty.call(appliedUpdate, moduleId)) {
/******/ 				modules[moduleId] = appliedUpdate[moduleId];
/******/ 			}
/******/ 		}
/******/ 	
/******/ 		// call accept handlers
/******/ 		var error = null;
/******/ 		for(var moduleId in outdatedDependencies) {
/******/ 			if(Object.prototype.hasOwnProperty.call(outdatedDependencies, moduleId)) {
/******/ 				var module = installedModules[moduleId];
/******/ 				var moduleOutdatedDependencies = outdatedDependencies[moduleId];
/******/ 				var callbacks = [];
/******/ 				for(var i = 0; i < moduleOutdatedDependencies.length; i++) {
/******/ 					var dependency = moduleOutdatedDependencies[i];
/******/ 					var cb = module.hot._acceptedDependencies[dependency];
/******/ 					if(callbacks.indexOf(cb) >= 0) continue;
/******/ 					callbacks.push(cb);
/******/ 				}
/******/ 				for(var i = 0; i < callbacks.length; i++) {
/******/ 					var cb = callbacks[i];
/******/ 					try {
/******/ 						cb(outdatedDependencies);
/******/ 					} catch(err) {
/******/ 						if(!error)
/******/ 							error = err;
/******/ 					}
/******/ 				}
/******/ 			}
/******/ 		}
/******/ 	
/******/ 		// Load self accepted modules
/******/ 		for(var i = 0; i < outdatedSelfAcceptedModules.length; i++) {
/******/ 			var item = outdatedSelfAcceptedModules[i];
/******/ 			var moduleId = item.module;
/******/ 			hotCurrentParents = [moduleId];
/******/ 			try {
/******/ 				__webpack_require__(moduleId);
/******/ 			} catch(err) {
/******/ 				if(typeof item.errorHandler === "function") {
/******/ 					try {
/******/ 						item.errorHandler(err);
/******/ 					} catch(err) {
/******/ 						if(!error)
/******/ 							error = err;
/******/ 					}
/******/ 				} else if(!error)
/******/ 					error = err;
/******/ 			}
/******/ 		}
/******/ 	
/******/ 		// handle errors in accept handlers and self accepted module load
/******/ 		if(error) {
/******/ 			hotSetStatus("fail");
/******/ 			return callback(error);
/******/ 		}
/******/ 	
/******/ 		hotSetStatus("idle");
/******/ 		callback(null, outdatedModules);
/******/ 	}
/******/
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false,
/******/ 			hot: hotCreateModule(moduleId),
/******/ 			parents: hotCurrentParents,
/******/ 			children: []
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, hotCreateRequire(moduleId));
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/public/";
/******/
/******/ 	// __webpack_hash__
/******/ 	__webpack_require__.h = function() { return hotCurrentHash; };
/******/
/******/ 	// Load entry module and return exports
/******/ 	return hotCreateRequire(0)(0);
/******/ })
/************************************************************************/
/******/ ((function(modules) {
	// Check all modules for deduplicated modules
	for(var i in modules) {
		if(Object.prototype.hasOwnProperty.call(modules, i)) {
			switch(typeof modules[i]) {
			case "function": break;
			case "object":
				// Module can be created from a template
				modules[i] = (function(_m) {
					var args = _m.slice(1), fn = modules[_m[0]];
					return function (a,b,c) {
						fn.apply(this, [a,b,c].concat(args));
					};
				}(modules[i]));
				break;
			default:
				// Module is a copy of another module
				modules[i] = modules[modules[i]];
				break;
			}
		}
	}
	return modules;
}([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

	__webpack_require__(283);
	__webpack_require__(286);
	module.exports = __webpack_require__(160);


/***/ }),
/* 1 */
/***/ (function(module, exports) {

	/*
	object-assign
	(c) Sindre Sorhus
	@license MIT
	*/
	
	'use strict';
	/* eslint-disable no-unused-vars */
	var getOwnPropertySymbols = Object.getOwnPropertySymbols;
	var hasOwnProperty = Object.prototype.hasOwnProperty;
	var propIsEnumerable = Object.prototype.propertyIsEnumerable;
	
	function toObject(val) {
		if (val === null || val === undefined) {
			throw new TypeError('Object.assign cannot be called with null or undefined');
		}
	
		return Object(val);
	}
	
	function shouldUseNative() {
		try {
			if (!Object.assign) {
				return false;
			}
	
			// Detect buggy property enumeration order in older V8 versions.
	
			// https://bugs.chromium.org/p/v8/issues/detail?id=4118
			var test1 = new String('abc');  // eslint-disable-line no-new-wrappers
			test1[5] = 'de';
			if (Object.getOwnPropertyNames(test1)[0] === '5') {
				return false;
			}
	
			// https://bugs.chromium.org/p/v8/issues/detail?id=3056
			var test2 = {};
			for (var i = 0; i < 10; i++) {
				test2['_' + String.fromCharCode(i)] = i;
			}
			var order2 = Object.getOwnPropertyNames(test2).map(function (n) {
				return test2[n];
			});
			if (order2.join('') !== '0123456789') {
				return false;
			}
	
			// https://bugs.chromium.org/p/v8/issues/detail?id=3056
			var test3 = {};
			'abcdefghijklmnopqrst'.split('').forEach(function (letter) {
				test3[letter] = letter;
			});
			if (Object.keys(Object.assign({}, test3)).join('') !==
					'abcdefghijklmnopqrst') {
				return false;
			}
	
			return true;
		} catch (err) {
			// We don't expect any of the above to throw, but better to be safe.
			return false;
		}
	}
	
	module.exports = shouldUseNative() ? Object.assign : function (target, source) {
		var from;
		var to = toObject(target);
		var symbols;
	
		for (var s = 1; s < arguments.length; s++) {
			from = Object(arguments[s]);
	
			for (var key in from) {
				if (hasOwnProperty.call(from, key)) {
					to[key] = from[key];
				}
			}
	
			if (getOwnPropertySymbols) {
				symbols = getOwnPropertySymbols(from);
				for (var i = 0; i < symbols.length; i++) {
					if (propIsEnumerable.call(from, symbols[i])) {
						to[symbols[i]] = from[symbols[i]];
					}
				}
			}
		}
	
		return to;
	};


/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;'use strict';var _assign=__webpack_require__(1);var _typeof=typeof Symbol==="function"&&typeof Symbol.iterator==="symbol"?function(obj){return typeof obj;}:function(obj){return obj&&typeof Symbol==="function"&&obj.constructor===Symbol&&obj!==Symbol.prototype?"symbol":typeof obj;};/* eslint-disable */(function(global,factory){( false?'undefined':_typeof(exports))==='object'&&typeof module!=='undefined'?factory(exports): true?!(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)):factory(global.THREE=global.THREE||{});})(undefined,function(exports){'use strict';// Polyfills
	if(Number.EPSILON===undefined){Number.EPSILON=Math.pow(2,-52);}if(Number.isInteger===undefined){// Missing in IE
	// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/isInteger
	Number.isInteger=function(value){return typeof value==='number'&&isFinite(value)&&Math.floor(value)===value;};}//
	if(Math.sign===undefined){// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/sign
	Math.sign=function(x){return x<0?-1:x>0?1:+x;};}if(Function.prototype.name===undefined){// Missing in IE
	// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/name
	Object.defineProperty(Function.prototype,'name',{get:function get(){return this.toString().match(/^\s*function\s*([^\(\s]*)/)[1];}});}if(_assign===undefined){// Missing in IE
	// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign
	(function(){_assign=function _assign(target){'use strict';if(target===undefined||target===null){throw new TypeError('Cannot convert undefined or null to object');}var output=Object(target);for(var index=1;index<arguments.length;index++){var source=arguments[index];if(source!==undefined&&source!==null){for(var nextKey in source){if(Object.prototype.hasOwnProperty.call(source,nextKey)){output[nextKey]=source[nextKey];}}}}return output;};})();}var REVISION='85dev';var MOUSE={LEFT:0,MIDDLE:1,RIGHT:2};var CullFaceNone=0;var CullFaceBack=1;var CullFaceFront=2;var CullFaceFrontBack=3;var FrontFaceDirectionCW=0;var FrontFaceDirectionCCW=1;var BasicShadowMap=0;var PCFShadowMap=1;var PCFSoftShadowMap=2;var FrontSide=0;var BackSide=1;var DoubleSide=2;var FlatShading=1;var SmoothShading=2;var NoColors=0;var FaceColors=1;var VertexColors=2;var NoBlending=0;var NormalBlending=1;var AdditiveBlending=2;var SubtractiveBlending=3;var MultiplyBlending=4;var CustomBlending=5;var AddEquation=100;var SubtractEquation=101;var ReverseSubtractEquation=102;var MinEquation=103;var MaxEquation=104;var ZeroFactor=200;var OneFactor=201;var SrcColorFactor=202;var OneMinusSrcColorFactor=203;var SrcAlphaFactor=204;var OneMinusSrcAlphaFactor=205;var DstAlphaFactor=206;var OneMinusDstAlphaFactor=207;var DstColorFactor=208;var OneMinusDstColorFactor=209;var SrcAlphaSaturateFactor=210;var NeverDepth=0;var AlwaysDepth=1;var LessDepth=2;var LessEqualDepth=3;var EqualDepth=4;var GreaterEqualDepth=5;var GreaterDepth=6;var NotEqualDepth=7;var MultiplyOperation=0;var MixOperation=1;var AddOperation=2;var NoToneMapping=0;var LinearToneMapping=1;var ReinhardToneMapping=2;var Uncharted2ToneMapping=3;var CineonToneMapping=4;var UVMapping=300;var CubeReflectionMapping=301;var CubeRefractionMapping=302;var EquirectangularReflectionMapping=303;var EquirectangularRefractionMapping=304;var SphericalReflectionMapping=305;var CubeUVReflectionMapping=306;var CubeUVRefractionMapping=307;var RepeatWrapping=1000;var ClampToEdgeWrapping=1001;var MirroredRepeatWrapping=1002;var NearestFilter=1003;var NearestMipMapNearestFilter=1004;var NearestMipMapLinearFilter=1005;var LinearFilter=1006;var LinearMipMapNearestFilter=1007;var LinearMipMapLinearFilter=1008;var UnsignedByteType=1009;var ByteType=1010;var ShortType=1011;var UnsignedShortType=1012;var IntType=1013;var UnsignedIntType=1014;var FloatType=1015;var HalfFloatType=1016;var UnsignedShort4444Type=1017;var UnsignedShort5551Type=1018;var UnsignedShort565Type=1019;var UnsignedInt248Type=1020;var AlphaFormat=1021;var RGBFormat=1022;var RGBAFormat=1023;var LuminanceFormat=1024;var LuminanceAlphaFormat=1025;var RGBEFormat=RGBAFormat;var DepthFormat=1026;var DepthStencilFormat=1027;var RGB_S3TC_DXT1_Format=2001;var RGBA_S3TC_DXT1_Format=2002;var RGBA_S3TC_DXT3_Format=2003;var RGBA_S3TC_DXT5_Format=2004;var RGB_PVRTC_4BPPV1_Format=2100;var RGB_PVRTC_2BPPV1_Format=2101;var RGBA_PVRTC_4BPPV1_Format=2102;var RGBA_PVRTC_2BPPV1_Format=2103;var RGB_ETC1_Format=2151;var LoopOnce=2200;var LoopRepeat=2201;var LoopPingPong=2202;var InterpolateDiscrete=2300;var InterpolateLinear=2301;var InterpolateSmooth=2302;var ZeroCurvatureEnding=2400;var ZeroSlopeEnding=2401;var WrapAroundEnding=2402;var TrianglesDrawMode=0;var TriangleStripDrawMode=1;var TriangleFanDrawMode=2;var LinearEncoding=3000;var sRGBEncoding=3001;var GammaEncoding=3007;var RGBEEncoding=3002;var LogLuvEncoding=3003;var RGBM7Encoding=3004;var RGBM16Encoding=3005;var RGBDEncoding=3006;var BasicDepthPacking=3200;var RGBADepthPacking=3201;/**
		 * @author alteredq / http://alteredqualia.com/
		 * @author mrdoob / http://mrdoob.com/
		 */var _Math={DEG2RAD:Math.PI/180,RAD2DEG:180/Math.PI,generateUUID:function(){// http://www.broofa.com/Tools/Math.uuid.htm
	var chars='0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'.split('');var uuid=new Array(36);var rnd=0,r;return function generateUUID(){for(var i=0;i<36;i++){if(i===8||i===13||i===18||i===23){uuid[i]='-';}else if(i===14){uuid[i]='4';}else{if(rnd<=0x02)rnd=0x2000000+Math.random()*0x1000000|0;r=rnd&0xf;rnd=rnd>>4;uuid[i]=chars[i===19?r&0x3|0x8:r];}}return uuid.join('');};}(),clamp:function clamp(value,min,max){return Math.max(min,Math.min(max,value));},// compute euclidian modulo of m % n
	// https://en.wikipedia.org/wiki/Modulo_operation
	euclideanModulo:function euclideanModulo(n,m){return(n%m+m)%m;},// Linear mapping from range <a1, a2> to range <b1, b2>
	mapLinear:function mapLinear(x,a1,a2,b1,b2){return b1+(x-a1)*(b2-b1)/(a2-a1);},// https://en.wikipedia.org/wiki/Linear_interpolation
	lerp:function lerp(x,y,t){return(1-t)*x+t*y;},// http://en.wikipedia.org/wiki/Smoothstep
	smoothstep:function smoothstep(x,min,max){if(x<=min)return 0;if(x>=max)return 1;x=(x-min)/(max-min);return x*x*(3-2*x);},smootherstep:function smootherstep(x,min,max){if(x<=min)return 0;if(x>=max)return 1;x=(x-min)/(max-min);return x*x*x*(x*(x*6-15)+10);},// Random integer from <low, high> interval
	randInt:function randInt(low,high){return low+Math.floor(Math.random()*(high-low+1));},// Random float from <low, high> interval
	randFloat:function randFloat(low,high){return low+Math.random()*(high-low);},// Random float from <-range/2, range/2> interval
	randFloatSpread:function randFloatSpread(range){return range*(0.5-Math.random());},degToRad:function degToRad(degrees){return degrees*_Math.DEG2RAD;},radToDeg:function radToDeg(radians){return radians*_Math.RAD2DEG;},isPowerOfTwo:function isPowerOfTwo(value){return(value&value-1)===0&&value!==0;},nearestPowerOfTwo:function nearestPowerOfTwo(value){return Math.pow(2,Math.round(Math.log(value)/Math.LN2));},nextPowerOfTwo:function nextPowerOfTwo(value){value--;value|=value>>1;value|=value>>2;value|=value>>4;value|=value>>8;value|=value>>16;value++;return value;}};/**
		 * @author mikael emtinger / http://gomo.se/
		 * @author alteredq / http://alteredqualia.com/
		 * @author WestLangley / http://github.com/WestLangley
		 * @author bhouston / http://clara.io
		 */function Quaternion(x,y,z,w){this._x=x||0;this._y=y||0;this._z=z||0;this._w=w!==undefined?w:1;}_assign(Quaternion,{slerp:function slerp(qa,qb,qm,t){return qm.copy(qa).slerp(qb,t);},slerpFlat:function slerpFlat(dst,dstOffset,src0,srcOffset0,src1,srcOffset1,t){// fuzz-free, array-based Quaternion SLERP operation
	var x0=src0[srcOffset0+0],y0=src0[srcOffset0+1],z0=src0[srcOffset0+2],w0=src0[srcOffset0+3],x1=src1[srcOffset1+0],y1=src1[srcOffset1+1],z1=src1[srcOffset1+2],w1=src1[srcOffset1+3];if(w0!==w1||x0!==x1||y0!==y1||z0!==z1){var s=1-t,cos=x0*x1+y0*y1+z0*z1+w0*w1,dir=cos>=0?1:-1,sqrSin=1-cos*cos;// Skip the Slerp for tiny steps to avoid numeric problems:
	if(sqrSin>Number.EPSILON){var sin=Math.sqrt(sqrSin),len=Math.atan2(sin,cos*dir);s=Math.sin(s*len)/sin;t=Math.sin(t*len)/sin;}var tDir=t*dir;x0=x0*s+x1*tDir;y0=y0*s+y1*tDir;z0=z0*s+z1*tDir;w0=w0*s+w1*tDir;// Normalize in case we just did a lerp:
	if(s===1-t){var f=1/Math.sqrt(x0*x0+y0*y0+z0*z0+w0*w0);x0*=f;y0*=f;z0*=f;w0*=f;}}dst[dstOffset]=x0;dst[dstOffset+1]=y0;dst[dstOffset+2]=z0;dst[dstOffset+3]=w0;}});Object.defineProperties(Quaternion.prototype,{x:{get:function get(){return this._x;},set:function set(value){this._x=value;this.onChangeCallback();}},y:{get:function get(){return this._y;},set:function set(value){this._y=value;this.onChangeCallback();}},z:{get:function get(){return this._z;},set:function set(value){this._z=value;this.onChangeCallback();}},w:{get:function get(){return this._w;},set:function set(value){this._w=value;this.onChangeCallback();}}});_assign(Quaternion.prototype,{set:function set(x,y,z,w){this._x=x;this._y=y;this._z=z;this._w=w;this.onChangeCallback();return this;},clone:function clone(){return new this.constructor(this._x,this._y,this._z,this._w);},copy:function copy(quaternion){this._x=quaternion.x;this._y=quaternion.y;this._z=quaternion.z;this._w=quaternion.w;this.onChangeCallback();return this;},setFromEuler:function setFromEuler(euler,update){if((euler&&euler.isEuler)===false){throw new Error('THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.');}var x=euler._x,y=euler._y,z=euler._z,order=euler.order;// http://www.mathworks.com/matlabcentral/fileexchange/
	// 	20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/
	//	content/SpinCalc.m
	var cos=Math.cos;var sin=Math.sin;var c1=cos(x/2);var c2=cos(y/2);var c3=cos(z/2);var s1=sin(x/2);var s2=sin(y/2);var s3=sin(z/2);if(order==='XYZ'){this._x=s1*c2*c3+c1*s2*s3;this._y=c1*s2*c3-s1*c2*s3;this._z=c1*c2*s3+s1*s2*c3;this._w=c1*c2*c3-s1*s2*s3;}else if(order==='YXZ'){this._x=s1*c2*c3+c1*s2*s3;this._y=c1*s2*c3-s1*c2*s3;this._z=c1*c2*s3-s1*s2*c3;this._w=c1*c2*c3+s1*s2*s3;}else if(order==='ZXY'){this._x=s1*c2*c3-c1*s2*s3;this._y=c1*s2*c3+s1*c2*s3;this._z=c1*c2*s3+s1*s2*c3;this._w=c1*c2*c3-s1*s2*s3;}else if(order==='ZYX'){this._x=s1*c2*c3-c1*s2*s3;this._y=c1*s2*c3+s1*c2*s3;this._z=c1*c2*s3-s1*s2*c3;this._w=c1*c2*c3+s1*s2*s3;}else if(order==='YZX'){this._x=s1*c2*c3+c1*s2*s3;this._y=c1*s2*c3+s1*c2*s3;this._z=c1*c2*s3-s1*s2*c3;this._w=c1*c2*c3-s1*s2*s3;}else if(order==='XZY'){this._x=s1*c2*c3-c1*s2*s3;this._y=c1*s2*c3-s1*c2*s3;this._z=c1*c2*s3+s1*s2*c3;this._w=c1*c2*c3+s1*s2*s3;}if(update!==false)this.onChangeCallback();return this;},setFromAxisAngle:function setFromAxisAngle(axis,angle){// http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm
	// assumes axis is normalized
	var halfAngle=angle/2,s=Math.sin(halfAngle);this._x=axis.x*s;this._y=axis.y*s;this._z=axis.z*s;this._w=Math.cos(halfAngle);this.onChangeCallback();return this;},setFromRotationMatrix:function setFromRotationMatrix(m){// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm
	// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)
	var te=m.elements,m11=te[0],m12=te[4],m13=te[8],m21=te[1],m22=te[5],m23=te[9],m31=te[2],m32=te[6],m33=te[10],trace=m11+m22+m33,s;if(trace>0){s=0.5/Math.sqrt(trace+1.0);this._w=0.25/s;this._x=(m32-m23)*s;this._y=(m13-m31)*s;this._z=(m21-m12)*s;}else if(m11>m22&&m11>m33){s=2.0*Math.sqrt(1.0+m11-m22-m33);this._w=(m32-m23)/s;this._x=0.25*s;this._y=(m12+m21)/s;this._z=(m13+m31)/s;}else if(m22>m33){s=2.0*Math.sqrt(1.0+m22-m11-m33);this._w=(m13-m31)/s;this._x=(m12+m21)/s;this._y=0.25*s;this._z=(m23+m32)/s;}else{s=2.0*Math.sqrt(1.0+m33-m11-m22);this._w=(m21-m12)/s;this._x=(m13+m31)/s;this._y=(m23+m32)/s;this._z=0.25*s;}this.onChangeCallback();return this;},setFromUnitVectors:function(){// http://lolengine.net/blog/2014/02/24/quaternion-from-two-vectors-final
	// assumes direction vectors vFrom and vTo are normalized
	var v1=new Vector3();var r;var EPS=0.000001;return function setFromUnitVectors(vFrom,vTo){if(v1===undefined)v1=new Vector3();r=vFrom.dot(vTo)+1;if(r<EPS){r=0;if(Math.abs(vFrom.x)>Math.abs(vFrom.z)){v1.set(-vFrom.y,vFrom.x,0);}else{v1.set(0,-vFrom.z,vFrom.y);}}else{v1.crossVectors(vFrom,vTo);}this._x=v1.x;this._y=v1.y;this._z=v1.z;this._w=r;return this.normalize();};}(),inverse:function inverse(){return this.conjugate().normalize();},conjugate:function conjugate(){this._x*=-1;this._y*=-1;this._z*=-1;this.onChangeCallback();return this;},dot:function dot(v){return this._x*v._x+this._y*v._y+this._z*v._z+this._w*v._w;},lengthSq:function lengthSq(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w;},length:function length(){return Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w);},normalize:function normalize(){var l=this.length();if(l===0){this._x=0;this._y=0;this._z=0;this._w=1;}else{l=1/l;this._x=this._x*l;this._y=this._y*l;this._z=this._z*l;this._w=this._w*l;}this.onChangeCallback();return this;},multiply:function multiply(q,p){if(p!==undefined){console.warn('THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead.');return this.multiplyQuaternions(q,p);}return this.multiplyQuaternions(this,q);},premultiply:function premultiply(q){return this.multiplyQuaternions(q,this);},multiplyQuaternions:function multiplyQuaternions(a,b){// from http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/code/index.htm
	var qax=a._x,qay=a._y,qaz=a._z,qaw=a._w;var qbx=b._x,qby=b._y,qbz=b._z,qbw=b._w;this._x=qax*qbw+qaw*qbx+qay*qbz-qaz*qby;this._y=qay*qbw+qaw*qby+qaz*qbx-qax*qbz;this._z=qaz*qbw+qaw*qbz+qax*qby-qay*qbx;this._w=qaw*qbw-qax*qbx-qay*qby-qaz*qbz;this.onChangeCallback();return this;},slerp:function slerp(qb,t){if(t===0)return this;if(t===1)return this.copy(qb);var x=this._x,y=this._y,z=this._z,w=this._w;// http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/slerp/
	var cosHalfTheta=w*qb._w+x*qb._x+y*qb._y+z*qb._z;if(cosHalfTheta<0){this._w=-qb._w;this._x=-qb._x;this._y=-qb._y;this._z=-qb._z;cosHalfTheta=-cosHalfTheta;}else{this.copy(qb);}if(cosHalfTheta>=1.0){this._w=w;this._x=x;this._y=y;this._z=z;return this;}var sinHalfTheta=Math.sqrt(1.0-cosHalfTheta*cosHalfTheta);if(Math.abs(sinHalfTheta)<0.001){this._w=0.5*(w+this._w);this._x=0.5*(x+this._x);this._y=0.5*(y+this._y);this._z=0.5*(z+this._z);return this;}var halfTheta=Math.atan2(sinHalfTheta,cosHalfTheta);var ratioA=Math.sin((1-t)*halfTheta)/sinHalfTheta,ratioB=Math.sin(t*halfTheta)/sinHalfTheta;this._w=w*ratioA+this._w*ratioB;this._x=x*ratioA+this._x*ratioB;this._y=y*ratioA+this._y*ratioB;this._z=z*ratioA+this._z*ratioB;this.onChangeCallback();return this;},equals:function equals(quaternion){return quaternion._x===this._x&&quaternion._y===this._y&&quaternion._z===this._z&&quaternion._w===this._w;},fromArray:function fromArray(array,offset){if(offset===undefined)offset=0;this._x=array[offset];this._y=array[offset+1];this._z=array[offset+2];this._w=array[offset+3];this.onChangeCallback();return this;},toArray:function toArray(array,offset){if(array===undefined)array=[];if(offset===undefined)offset=0;array[offset]=this._x;array[offset+1]=this._y;array[offset+2]=this._z;array[offset+3]=this._w;return array;},onChange:function onChange(callback){this.onChangeCallback=callback;return this;},onChangeCallback:function onChangeCallback(){}});/**
		 * @author mrdoob / http://mrdoob.com/
		 * @author *kile / http://kile.stravaganza.org/
		 * @author philogb / http://blog.thejit.org/
		 * @author mikael emtinger / http://gomo.se/
		 * @author egraether / http://egraether.com/
		 * @author WestLangley / http://github.com/WestLangley
		 */function Vector3(x,y,z){this.x=x||0;this.y=y||0;this.z=z||0;}_assign(Vector3.prototype,{isVector3:true,set:function set(x,y,z){this.x=x;this.y=y;this.z=z;return this;},setScalar:function setScalar(scalar){this.x=scalar;this.y=scalar;this.z=scalar;return this;},setX:function setX(x){this.x=x;return this;},setY:function setY(y){this.y=y;return this;},setZ:function setZ(z){this.z=z;return this;},setComponent:function setComponent(index,value){switch(index){case 0:this.x=value;break;case 1:this.y=value;break;case 2:this.z=value;break;default:throw new Error('index is out of range: '+index);}return this;},getComponent:function getComponent(index){switch(index){case 0:return this.x;case 1:return this.y;case 2:return this.z;default:throw new Error('index is out of range: '+index);}},clone:function clone(){return new this.constructor(this.x,this.y,this.z);},copy:function copy(v){this.x=v.x;this.y=v.y;this.z=v.z;return this;},add:function add(v,w){if(w!==undefined){console.warn('THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead.');return this.addVectors(v,w);}this.x+=v.x;this.y+=v.y;this.z+=v.z;return this;},addScalar:function addScalar(s){this.x+=s;this.y+=s;this.z+=s;return this;},addVectors:function addVectors(a,b){this.x=a.x+b.x;this.y=a.y+b.y;this.z=a.z+b.z;return this;},addScaledVector:function addScaledVector(v,s){this.x+=v.x*s;this.y+=v.y*s;this.z+=v.z*s;return this;},sub:function sub(v,w){if(w!==undefined){console.warn('THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.');return this.subVectors(v,w);}this.x-=v.x;this.y-=v.y;this.z-=v.z;return this;},subScalar:function subScalar(s){this.x-=s;this.y-=s;this.z-=s;return this;},subVectors:function subVectors(a,b){this.x=a.x-b.x;this.y=a.y-b.y;this.z=a.z-b.z;return this;},multiply:function multiply(v,w){if(w!==undefined){console.warn('THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead.');return this.multiplyVectors(v,w);}this.x*=v.x;this.y*=v.y;this.z*=v.z;return this;},multiplyScalar:function multiplyScalar(scalar){this.x*=scalar;this.y*=scalar;this.z*=scalar;return this;},multiplyVectors:function multiplyVectors(a,b){this.x=a.x*b.x;this.y=a.y*b.y;this.z=a.z*b.z;return this;},applyEuler:function(){var quaternion=new Quaternion();return function applyEuler(euler){if((euler&&euler.isEuler)===false){console.error('THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order.');}return this.applyQuaternion(quaternion.setFromEuler(euler));};}(),applyAxisAngle:function(){var quaternion=new Quaternion();return function applyAxisAngle(axis,angle){return this.applyQuaternion(quaternion.setFromAxisAngle(axis,angle));};}(),applyMatrix3:function applyMatrix3(m){var x=this.x,y=this.y,z=this.z;var e=m.elements;this.x=e[0]*x+e[3]*y+e[6]*z;this.y=e[1]*x+e[4]*y+e[7]*z;this.z=e[2]*x+e[5]*y+e[8]*z;return this;},applyMatrix4:function applyMatrix4(m){var x=this.x,y=this.y,z=this.z;var e=m.elements;this.x=e[0]*x+e[4]*y+e[8]*z+e[12];this.y=e[1]*x+e[5]*y+e[9]*z+e[13];this.z=e[2]*x+e[6]*y+e[10]*z+e[14];var w=e[3]*x+e[7]*y+e[11]*z+e[15];return this.divideScalar(w);},applyQuaternion:function applyQuaternion(q){var x=this.x,y=this.y,z=this.z;var qx=q.x,qy=q.y,qz=q.z,qw=q.w;// calculate quat * vector
	var ix=qw*x+qy*z-qz*y;var iy=qw*y+qz*x-qx*z;var iz=qw*z+qx*y-qy*x;var iw=-qx*x-qy*y-qz*z;// calculate result * inverse quat
	this.x=ix*qw+iw*-qx+iy*-qz-iz*-qy;this.y=iy*qw+iw*-qy+iz*-qx-ix*-qz;this.z=iz*qw+iw*-qz+ix*-qy-iy*-qx;return this;},project:function(){var matrix=new Matrix4();return function project(camera){matrix.multiplyMatrices(camera.projectionMatrix,matrix.getInverse(camera.matrixWorld));return this.applyMatrix4(matrix);};}(),unproject:function(){var matrix=new Matrix4();return function unproject(camera){matrix.multiplyMatrices(camera.matrixWorld,matrix.getInverse(camera.projectionMatrix));return this.applyMatrix4(matrix);};}(),transformDirection:function transformDirection(m){// input: THREE.Matrix4 affine matrix
	// vector interpreted as a direction
	var x=this.x,y=this.y,z=this.z;var e=m.elements;this.x=e[0]*x+e[4]*y+e[8]*z;this.y=e[1]*x+e[5]*y+e[9]*z;this.z=e[2]*x+e[6]*y+e[10]*z;return this.normalize();},divide:function divide(v){this.x/=v.x;this.y/=v.y;this.z/=v.z;return this;},divideScalar:function divideScalar(scalar){return this.multiplyScalar(1/scalar);},min:function min(v){this.x=Math.min(this.x,v.x);this.y=Math.min(this.y,v.y);this.z=Math.min(this.z,v.z);return this;},max:function max(v){this.x=Math.max(this.x,v.x);this.y=Math.max(this.y,v.y);this.z=Math.max(this.z,v.z);return this;},clamp:function clamp(min,max){// This function assumes min < max, if this assumption isn't true it will not operate correctly
	this.x=Math.max(min.x,Math.min(max.x,this.x));this.y=Math.max(min.y,Math.min(max.y,this.y));this.z=Math.max(min.z,Math.min(max.z,this.z));return this;},clampScalar:function(){var min=new Vector3();var max=new Vector3();return function clampScalar(minVal,maxVal){min.set(minVal,minVal,minVal);max.set(maxVal,maxVal,maxVal);return this.clamp(min,max);};}(),clampLength:function clampLength(min,max){var length=this.length();return this.multiplyScalar(Math.max(min,Math.min(max,length))/length);},floor:function floor(){this.x=Math.floor(this.x);this.y=Math.floor(this.y);this.z=Math.floor(this.z);return this;},ceil:function ceil(){this.x=Math.ceil(this.x);this.y=Math.ceil(this.y);this.z=Math.ceil(this.z);return this;},round:function round(){this.x=Math.round(this.x);this.y=Math.round(this.y);this.z=Math.round(this.z);return this;},roundToZero:function roundToZero(){this.x=this.x<0?Math.ceil(this.x):Math.floor(this.x);this.y=this.y<0?Math.ceil(this.y):Math.floor(this.y);this.z=this.z<0?Math.ceil(this.z):Math.floor(this.z);return this;},negate:function negate(){this.x=-this.x;this.y=-this.y;this.z=-this.z;return this;},dot:function dot(v){return this.x*v.x+this.y*v.y+this.z*v.z;},// TODO lengthSquared?
	lengthSq:function lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z;},length:function length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z);},lengthManhattan:function lengthManhattan(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z);},normalize:function normalize(){return this.divideScalar(this.length());},setLength:function setLength(length){return this.multiplyScalar(length/this.length());},lerp:function lerp(v,alpha){this.x+=(v.x-this.x)*alpha;this.y+=(v.y-this.y)*alpha;this.z+=(v.z-this.z)*alpha;return this;},lerpVectors:function lerpVectors(v1,v2,alpha){return this.subVectors(v2,v1).multiplyScalar(alpha).add(v1);},cross:function cross(v,w){if(w!==undefined){console.warn('THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead.');return this.crossVectors(v,w);}var x=this.x,y=this.y,z=this.z;this.x=y*v.z-z*v.y;this.y=z*v.x-x*v.z;this.z=x*v.y-y*v.x;return this;},crossVectors:function crossVectors(a,b){var ax=a.x,ay=a.y,az=a.z;var bx=b.x,by=b.y,bz=b.z;this.x=ay*bz-az*by;this.y=az*bx-ax*bz;this.z=ax*by-ay*bx;return this;},projectOnVector:function projectOnVector(vector){var scalar=vector.dot(this)/vector.lengthSq();return this.copy(vector).multiplyScalar(scalar);},projectOnPlane:function(){var v1=new Vector3();return function projectOnPlane(planeNormal){v1.copy(this).projectOnVector(planeNormal);return this.sub(v1);};}(),reflect:function(){// reflect incident vector off plane orthogonal to normal
	// normal is assumed to have unit length
	var v1=new Vector3();return function reflect(normal){return this.sub(v1.copy(normal).multiplyScalar(2*this.dot(normal)));};}(),angleTo:function angleTo(v){var theta=this.dot(v)/Math.sqrt(this.lengthSq()*v.lengthSq());// clamp, to handle numerical problems
	return Math.acos(_Math.clamp(theta,-1,1));},distanceTo:function distanceTo(v){return Math.sqrt(this.distanceToSquared(v));},distanceToSquared:function distanceToSquared(v){var dx=this.x-v.x,dy=this.y-v.y,dz=this.z-v.z;return dx*dx+dy*dy+dz*dz;},distanceToManhattan:function distanceToManhattan(v){return Math.abs(this.x-v.x)+Math.abs(this.y-v.y)+Math.abs(this.z-v.z);},setFromSpherical:function setFromSpherical(s){var sinPhiRadius=Math.sin(s.phi)*s.radius;this.x=sinPhiRadius*Math.sin(s.theta);this.y=Math.cos(s.phi)*s.radius;this.z=sinPhiRadius*Math.cos(s.theta);return this;},setFromCylindrical:function setFromCylindrical(c){this.x=c.radius*Math.sin(c.theta);this.y=c.y;this.z=c.radius*Math.cos(c.theta);return this;},setFromMatrixPosition:function setFromMatrixPosition(m){return this.setFromMatrixColumn(m,3);},setFromMatrixScale:function setFromMatrixScale(m){var sx=this.setFromMatrixColumn(m,0).length();var sy=this.setFromMatrixColumn(m,1).length();var sz=this.setFromMatrixColumn(m,2).length();this.x=sx;this.y=sy;this.z=sz;return this;},setFromMatrixColumn:function setFromMatrixColumn(m,index){return this.fromArray(m.elements,index*4);},equals:function equals(v){return v.x===this.x&&v.y===this.y&&v.z===this.z;},fromArray:function fromArray(array,offset){if(offset===undefined)offset=0;this.x=array[offset];this.y=array[offset+1];this.z=array[offset+2];return this;},toArray:function toArray(array,offset){if(array===undefined)array=[];if(offset===undefined)offset=0;array[offset]=this.x;array[offset+1]=this.y;array[offset+2]=this.z;return array;},fromBufferAttribute:function fromBufferAttribute(attribute,index,offset){if(offset!==undefined){console.warn('THREE.Vector3: offset has been removed from .fromBufferAttribute().');}this.x=attribute.getX(index);this.y=attribute.getY(index);this.z=attribute.getZ(index);return this;}});/**
		 * @author mrdoob / http://mrdoob.com/
		 * @author supereggbert / http://www.paulbrunt.co.uk/
		 * @author philogb / http://blog.thejit.org/
		 * @author jordi_ros / http://plattsoft.com
		 * @author D1plo1d / http://github.com/D1plo1d
		 * @author alteredq / http://alteredqualia.com/
		 * @author mikael emtinger / http://gomo.se/
		 * @author timknip / http://www.floorplanner.com/
		 * @author bhouston / http://clara.io
		 * @author WestLangley / http://github.com/WestLangley
		 */function Matrix4(){this.elements=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1];if(arguments.length>0){console.error('THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.');}}_assign(Matrix4.prototype,{isMatrix4:true,set:function set(n11,n12,n13,n14,n21,n22,n23,n24,n31,n32,n33,n34,n41,n42,n43,n44){var te=this.elements;te[0]=n11;te[4]=n12;te[8]=n13;te[12]=n14;te[1]=n21;te[5]=n22;te[9]=n23;te[13]=n24;te[2]=n31;te[6]=n32;te[10]=n33;te[14]=n34;te[3]=n41;te[7]=n42;te[11]=n43;te[15]=n44;return this;},identity:function identity(){this.set(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1);return this;},clone:function clone(){return new Matrix4().fromArray(this.elements);},copy:function copy(m){var te=this.elements;var me=m.elements;te[0]=me[0];te[1]=me[1];te[2]=me[2];te[3]=me[3];te[4]=me[4];te[5]=me[5];te[6]=me[6];te[7]=me[7];te[8]=me[8];te[9]=me[9];te[10]=me[10];te[11]=me[11];te[12]=me[12];te[13]=me[13];te[14]=me[14];te[15]=me[15];return this;},copyPosition:function copyPosition(m){var te=this.elements,me=m.elements;te[12]=me[12];te[13]=me[13];te[14]=me[14];return this;},extractBasis:function extractBasis(xAxis,yAxis,zAxis){xAxis.setFromMatrixColumn(this,0);yAxis.setFromMatrixColumn(this,1);zAxis.setFromMatrixColumn(this,2);return this;},makeBasis:function makeBasis(xAxis,yAxis,zAxis){this.set(xAxis.x,yAxis.x,zAxis.x,0,xAxis.y,yAxis.y,zAxis.y,0,xAxis.z,yAxis.z,zAxis.z,0,0,0,0,1);return this;},extractRotation:function(){var v1=new Vector3();return function extractRotation(m){var te=this.elements;var me=m.elements;var scaleX=1/v1.setFromMatrixColumn(m,0).length();var scaleY=1/v1.setFromMatrixColumn(m,1).length();var scaleZ=1/v1.setFromMatrixColumn(m,2).length();te[0]=me[0]*scaleX;te[1]=me[1]*scaleX;te[2]=me[2]*scaleX;te[4]=me[4]*scaleY;te[5]=me[5]*scaleY;te[6]=me[6]*scaleY;te[8]=me[8]*scaleZ;te[9]=me[9]*scaleZ;te[10]=me[10]*scaleZ;return this;};}(),makeRotationFromEuler:function makeRotationFromEuler(euler){if((euler&&euler.isEuler)===false){console.error('THREE.Matrix: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.');}var te=this.elements;var x=euler.x,y=euler.y,z=euler.z;var a=Math.cos(x),b=Math.sin(x);var c=Math.cos(y),d=Math.sin(y);var e=Math.cos(z),f=Math.sin(z);if(euler.order==='XYZ'){var ae=a*e,af=a*f,be=b*e,bf=b*f;te[0]=c*e;te[4]=-c*f;te[8]=d;te[1]=af+be*d;te[5]=ae-bf*d;te[9]=-b*c;te[2]=bf-ae*d;te[6]=be+af*d;te[10]=a*c;}else if(euler.order==='YXZ'){var ce=c*e,cf=c*f,de=d*e,df=d*f;te[0]=ce+df*b;te[4]=de*b-cf;te[8]=a*d;te[1]=a*f;te[5]=a*e;te[9]=-b;te[2]=cf*b-de;te[6]=df+ce*b;te[10]=a*c;}else if(euler.order==='ZXY'){var ce=c*e,cf=c*f,de=d*e,df=d*f;te[0]=ce-df*b;te[4]=-a*f;te[8]=de+cf*b;te[1]=cf+de*b;te[5]=a*e;te[9]=df-ce*b;te[2]=-a*d;te[6]=b;te[10]=a*c;}else if(euler.order==='ZYX'){var ae=a*e,af=a*f,be=b*e,bf=b*f;te[0]=c*e;te[4]=be*d-af;te[8]=ae*d+bf;te[1]=c*f;te[5]=bf*d+ae;te[9]=af*d-be;te[2]=-d;te[6]=b*c;te[10]=a*c;}else if(euler.order==='YZX'){var ac=a*c,ad=a*d,bc=b*c,bd=b*d;te[0]=c*e;te[4]=bd-ac*f;te[8]=bc*f+ad;te[1]=f;te[5]=a*e;te[9]=-b*e;te[2]=-d*e;te[6]=ad*f+bc;te[10]=ac-bd*f;}else if(euler.order==='XZY'){var ac=a*c,ad=a*d,bc=b*c,bd=b*d;te[0]=c*e;te[4]=-f;te[8]=d*e;te[1]=ac*f+bd;te[5]=a*e;te[9]=ad*f-bc;te[2]=bc*f-ad;te[6]=b*e;te[10]=bd*f+ac;}// last column
	te[3]=0;te[7]=0;te[11]=0;// bottom row
	te[12]=0;te[13]=0;te[14]=0;te[15]=1;return this;},makeRotationFromQuaternion:function makeRotationFromQuaternion(q){var te=this.elements;var x=q._x,y=q._y,z=q._z,w=q._w;var x2=x+x,y2=y+y,z2=z+z;var xx=x*x2,xy=x*y2,xz=x*z2;var yy=y*y2,yz=y*z2,zz=z*z2;var wx=w*x2,wy=w*y2,wz=w*z2;te[0]=1-(yy+zz);te[4]=xy-wz;te[8]=xz+wy;te[1]=xy+wz;te[5]=1-(xx+zz);te[9]=yz-wx;te[2]=xz-wy;te[6]=yz+wx;te[10]=1-(xx+yy);// last column
	te[3]=0;te[7]=0;te[11]=0;// bottom row
	te[12]=0;te[13]=0;te[14]=0;te[15]=1;return this;},lookAt:function(){var x=new Vector3();var y=new Vector3();var z=new Vector3();return function lookAt(eye,target,up){var te=this.elements;z.subVectors(eye,target);if(z.lengthSq()===0){// eye and target are in the same position
	z.z=1;}z.normalize();x.crossVectors(up,z);if(x.lengthSq()===0){// eye and target are in the same vertical
	z.z+=0.0001;x.crossVectors(up,z);}x.normalize();y.crossVectors(z,x);te[0]=x.x;te[4]=y.x;te[8]=z.x;te[1]=x.y;te[5]=y.y;te[9]=z.y;te[2]=x.z;te[6]=y.z;te[10]=z.z;return this;};}(),multiply:function multiply(m,n){if(n!==undefined){console.warn('THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead.');return this.multiplyMatrices(m,n);}return this.multiplyMatrices(this,m);},premultiply:function premultiply(m){return this.multiplyMatrices(m,this);},multiplyMatrices:function multiplyMatrices(a,b){var ae=a.elements;var be=b.elements;var te=this.elements;var a11=ae[0],a12=ae[4],a13=ae[8],a14=ae[12];var a21=ae[1],a22=ae[5],a23=ae[9],a24=ae[13];var a31=ae[2],a32=ae[6],a33=ae[10],a34=ae[14];var a41=ae[3],a42=ae[7],a43=ae[11],a44=ae[15];var b11=be[0],b12=be[4],b13=be[8],b14=be[12];var b21=be[1],b22=be[5],b23=be[9],b24=be[13];var b31=be[2],b32=be[6],b33=be[10],b34=be[14];var b41=be[3],b42=be[7],b43=be[11],b44=be[15];te[0]=a11*b11+a12*b21+a13*b31+a14*b41;te[4]=a11*b12+a12*b22+a13*b32+a14*b42;te[8]=a11*b13+a12*b23+a13*b33+a14*b43;te[12]=a11*b14+a12*b24+a13*b34+a14*b44;te[1]=a21*b11+a22*b21+a23*b31+a24*b41;te[5]=a21*b12+a22*b22+a23*b32+a24*b42;te[9]=a21*b13+a22*b23+a23*b33+a24*b43;te[13]=a21*b14+a22*b24+a23*b34+a24*b44;te[2]=a31*b11+a32*b21+a33*b31+a34*b41;te[6]=a31*b12+a32*b22+a33*b32+a34*b42;te[10]=a31*b13+a32*b23+a33*b33+a34*b43;te[14]=a31*b14+a32*b24+a33*b34+a34*b44;te[3]=a41*b11+a42*b21+a43*b31+a44*b41;te[7]=a41*b12+a42*b22+a43*b32+a44*b42;te[11]=a41*b13+a42*b23+a43*b33+a44*b43;te[15]=a41*b14+a42*b24+a43*b34+a44*b44;return this;},multiplyScalar:function multiplyScalar(s){var te=this.elements;te[0]*=s;te[4]*=s;te[8]*=s;te[12]*=s;te[1]*=s;te[5]*=s;te[9]*=s;te[13]*=s;te[2]*=s;te[6]*=s;te[10]*=s;te[14]*=s;te[3]*=s;te[7]*=s;te[11]*=s;te[15]*=s;return this;},applyToBufferAttribute:function(){var v1=new Vector3();return function applyToBufferAttribute(attribute){for(var i=0,l=attribute.count;i<l;i++){v1.x=attribute.getX(i);v1.y=attribute.getY(i);v1.z=attribute.getZ(i);v1.applyMatrix4(this);attribute.setXYZ(i,v1.x,v1.y,v1.z);}return attribute;};}(),determinant:function determinant(){var te=this.elements;var n11=te[0],n12=te[4],n13=te[8],n14=te[12];var n21=te[1],n22=te[5],n23=te[9],n24=te[13];var n31=te[2],n32=te[6],n33=te[10],n34=te[14];var n41=te[3],n42=te[7],n43=te[11],n44=te[15];//TODO: make this more efficient
	//( based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm )
	return n41*(+n14*n23*n32-n13*n24*n32-n14*n22*n33+n12*n24*n33+n13*n22*n34-n12*n23*n34)+n42*(+n11*n23*n34-n11*n24*n33+n14*n21*n33-n13*n21*n34+n13*n24*n31-n14*n23*n31)+n43*(+n11*n24*n32-n11*n22*n34-n14*n21*n32+n12*n21*n34+n14*n22*n31-n12*n24*n31)+n44*(-n13*n22*n31-n11*n23*n32+n11*n22*n33+n13*n21*n32-n12*n21*n33+n12*n23*n31);},transpose:function transpose(){var te=this.elements;var tmp;tmp=te[1];te[1]=te[4];te[4]=tmp;tmp=te[2];te[2]=te[8];te[8]=tmp;tmp=te[6];te[6]=te[9];te[9]=tmp;tmp=te[3];te[3]=te[12];te[12]=tmp;tmp=te[7];te[7]=te[13];te[13]=tmp;tmp=te[11];te[11]=te[14];te[14]=tmp;return this;},setPosition:function setPosition(v){var te=this.elements;te[12]=v.x;te[13]=v.y;te[14]=v.z;return this;},getInverse:function getInverse(m,throwOnDegenerate){// based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm
	var te=this.elements,me=m.elements,n11=me[0],n21=me[1],n31=me[2],n41=me[3],n12=me[4],n22=me[5],n32=me[6],n42=me[7],n13=me[8],n23=me[9],n33=me[10],n43=me[11],n14=me[12],n24=me[13],n34=me[14],n44=me[15],t11=n23*n34*n42-n24*n33*n42+n24*n32*n43-n22*n34*n43-n23*n32*n44+n22*n33*n44,t12=n14*n33*n42-n13*n34*n42-n14*n32*n43+n12*n34*n43+n13*n32*n44-n12*n33*n44,t13=n13*n24*n42-n14*n23*n42+n14*n22*n43-n12*n24*n43-n13*n22*n44+n12*n23*n44,t14=n14*n23*n32-n13*n24*n32-n14*n22*n33+n12*n24*n33+n13*n22*n34-n12*n23*n34;var det=n11*t11+n21*t12+n31*t13+n41*t14;if(det===0){var msg="THREE.Matrix4.getInverse(): can't invert matrix, determinant is 0";if(throwOnDegenerate===true){throw new Error(msg);}else{console.warn(msg);}return this.identity();}var detInv=1/det;te[0]=t11*detInv;te[1]=(n24*n33*n41-n23*n34*n41-n24*n31*n43+n21*n34*n43+n23*n31*n44-n21*n33*n44)*detInv;te[2]=(n22*n34*n41-n24*n32*n41+n24*n31*n42-n21*n34*n42-n22*n31*n44+n21*n32*n44)*detInv;te[3]=(n23*n32*n41-n22*n33*n41-n23*n31*n42+n21*n33*n42+n22*n31*n43-n21*n32*n43)*detInv;te[4]=t12*detInv;te[5]=(n13*n34*n41-n14*n33*n41+n14*n31*n43-n11*n34*n43-n13*n31*n44+n11*n33*n44)*detInv;te[6]=(n14*n32*n41-n12*n34*n41-n14*n31*n42+n11*n34*n42+n12*n31*n44-n11*n32*n44)*detInv;te[7]=(n12*n33*n41-n13*n32*n41+n13*n31*n42-n11*n33*n42-n12*n31*n43+n11*n32*n43)*detInv;te[8]=t13*detInv;te[9]=(n14*n23*n41-n13*n24*n41-n14*n21*n43+n11*n24*n43+n13*n21*n44-n11*n23*n44)*detInv;te[10]=(n12*n24*n41-n14*n22*n41+n14*n21*n42-n11*n24*n42-n12*n21*n44+n11*n22*n44)*detInv;te[11]=(n13*n22*n41-n12*n23*n41-n13*n21*n42+n11*n23*n42+n12*n21*n43-n11*n22*n43)*detInv;te[12]=t14*detInv;te[13]=(n13*n24*n31-n14*n23*n31+n14*n21*n33-n11*n24*n33-n13*n21*n34+n11*n23*n34)*detInv;te[14]=(n14*n22*n31-n12*n24*n31-n14*n21*n32+n11*n24*n32+n12*n21*n34-n11*n22*n34)*detInv;te[15]=(n12*n23*n31-n13*n22*n31+n13*n21*n32-n11*n23*n32-n12*n21*n33+n11*n22*n33)*detInv;return this;},scale:function scale(v){var te=this.elements;var x=v.x,y=v.y,z=v.z;te[0]*=x;te[4]*=y;te[8]*=z;te[1]*=x;te[5]*=y;te[9]*=z;te[2]*=x;te[6]*=y;te[10]*=z;te[3]*=x;te[7]*=y;te[11]*=z;return this;},getMaxScaleOnAxis:function getMaxScaleOnAxis(){var te=this.elements;var scaleXSq=te[0]*te[0]+te[1]*te[1]+te[2]*te[2];var scaleYSq=te[4]*te[4]+te[5]*te[5]+te[6]*te[6];var scaleZSq=te[8]*te[8]+te[9]*te[9]+te[10]*te[10];return Math.sqrt(Math.max(scaleXSq,scaleYSq,scaleZSq));},makeTranslation:function makeTranslation(x,y,z){this.set(1,0,0,x,0,1,0,y,0,0,1,z,0,0,0,1);return this;},makeRotationX:function makeRotationX(theta){var c=Math.cos(theta),s=Math.sin(theta);this.set(1,0,0,0,0,c,-s,0,0,s,c,0,0,0,0,1);return this;},makeRotationY:function makeRotationY(theta){var c=Math.cos(theta),s=Math.sin(theta);this.set(c,0,s,0,0,1,0,0,-s,0,c,0,0,0,0,1);return this;},makeRotationZ:function makeRotationZ(theta){var c=Math.cos(theta),s=Math.sin(theta);this.set(c,-s,0,0,s,c,0,0,0,0,1,0,0,0,0,1);return this;},makeRotationAxis:function makeRotationAxis(axis,angle){// Based on http://www.gamedev.net/reference/articles/article1199.asp
	var c=Math.cos(angle);var s=Math.sin(angle);var t=1-c;var x=axis.x,y=axis.y,z=axis.z;var tx=t*x,ty=t*y;this.set(tx*x+c,tx*y-s*z,tx*z+s*y,0,tx*y+s*z,ty*y+c,ty*z-s*x,0,tx*z-s*y,ty*z+s*x,t*z*z+c,0,0,0,0,1);return this;},makeScale:function makeScale(x,y,z){this.set(x,0,0,0,0,y,0,0,0,0,z,0,0,0,0,1);return this;},makeShear:function makeShear(x,y,z){this.set(1,y,z,0,x,1,z,0,x,y,1,0,0,0,0,1);return this;},compose:function compose(position,quaternion,scale){this.makeRotationFromQuaternion(quaternion);this.scale(scale);this.setPosition(position);return this;},decompose:function(){var vector=new Vector3();var matrix=new Matrix4();return function decompose(position,quaternion,scale){var te=this.elements;var sx=vector.set(te[0],te[1],te[2]).length();var sy=vector.set(te[4],te[5],te[6]).length();var sz=vector.set(te[8],te[9],te[10]).length();// if determine is negative, we need to invert one scale
	var det=this.determinant();if(det<0)sx=-sx;position.x=te[12];position.y=te[13];position.z=te[14];// scale the rotation part
	matrix.copy(this);var invSX=1/sx;var invSY=1/sy;var invSZ=1/sz;matrix.elements[0]*=invSX;matrix.elements[1]*=invSX;matrix.elements[2]*=invSX;matrix.elements[4]*=invSY;matrix.elements[5]*=invSY;matrix.elements[6]*=invSY;matrix.elements[8]*=invSZ;matrix.elements[9]*=invSZ;matrix.elements[10]*=invSZ;quaternion.setFromRotationMatrix(matrix);scale.x=sx;scale.y=sy;scale.z=sz;return this;};}(),makePerspective:function makePerspective(left,right,top,bottom,near,far){if(far===undefined){console.warn('THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.');}var te=this.elements;var x=2*near/(right-left);var y=2*near/(top-bottom);var a=(right+left)/(right-left);var b=(top+bottom)/(top-bottom);var c=-(far+near)/(far-near);var d=-2*far*near/(far-near);te[0]=x;te[4]=0;te[8]=a;te[12]=0;te[1]=0;te[5]=y;te[9]=b;te[13]=0;te[2]=0;te[6]=0;te[10]=c;te[14]=d;te[3]=0;te[7]=0;te[11]=-1;te[15]=0;return this;},makeOrthographic:function makeOrthographic(left,right,top,bottom,near,far){var te=this.elements;var w=1.0/(right-left);var h=1.0/(top-bottom);var p=1.0/(far-near);var x=(right+left)*w;var y=(top+bottom)*h;var z=(far+near)*p;te[0]=2*w;te[4]=0;te[8]=0;te[12]=-x;te[1]=0;te[5]=2*h;te[9]=0;te[13]=-y;te[2]=0;te[6]=0;te[10]=-2*p;te[14]=-z;te[3]=0;te[7]=0;te[11]=0;te[15]=1;return this;},equals:function equals(matrix){var te=this.elements;var me=matrix.elements;for(var i=0;i<16;i++){if(te[i]!==me[i])return false;}return true;},fromArray:function fromArray(array,offset){if(offset===undefined)offset=0;for(var i=0;i<16;i++){this.elements[i]=array[i+offset];}return this;},toArray:function toArray(array,offset){if(array===undefined)array=[];if(offset===undefined)offset=0;var te=this.elements;array[offset]=te[0];array[offset+1]=te[1];array[offset+2]=te[2];array[offset+3]=te[3];array[offset+4]=te[4];array[offset+5]=te[5];array[offset+6]=te[6];array[offset+7]=te[7];array[offset+8]=te[8];array[offset+9]=te[9];array[offset+10]=te[10];array[offset+11]=te[11];array[offset+12]=te[12];array[offset+13]=te[13];array[offset+14]=te[14];array[offset+15]=te[15];return array;}});/**
		 * https://github.com/mrdoob/eventdispatcher.js/
		 */function EventDispatcher(){}_assign(EventDispatcher.prototype,{addEventListener:function addEventListener(type,listener){if(this._listeners===undefined)this._listeners={};var listeners=this._listeners;if(listeners[type]===undefined){listeners[type]=[];}if(listeners[type].indexOf(listener)===-1){listeners[type].push(listener);}},hasEventListener:function hasEventListener(type,listener){if(this._listeners===undefined)return false;var listeners=this._listeners;return listeners[type]!==undefined&&listeners[type].indexOf(listener)!==-1;},removeEventListener:function removeEventListener(type,listener){if(this._listeners===undefined)return;var listeners=this._listeners;var listenerArray=listeners[type];if(listenerArray!==undefined){var index=listenerArray.indexOf(listener);if(index!==-1){listenerArray.splice(index,1);}}},dispatchEvent:function dispatchEvent(event){if(this._listeners===undefined)return;var listeners=this._listeners;var listenerArray=listeners[event.type];if(listenerArray!==undefined){event.target=this;var array=[],i=0;var length=listenerArray.length;for(i=0;i<length;i++){array[i]=listenerArray[i];}for(i=0;i<length;i++){array[i].call(this,event);}}}});/**
		 * @author mrdoob / http://mrdoob.com/
		 * @author philogb / http://blog.thejit.org/
		 * @author egraether / http://egraether.com/
		 * @author zz85 / http://www.lab4games.net/zz85/blog
		 */function Vector2(x,y){this.x=x||0;this.y=y||0;}Object.defineProperties(Vector2.prototype,{"width":{get:function get(){return this.x;},set:function set(value){this.x=value;}},"height":{get:function get(){return this.y;},set:function set(value){this.y=value;}}});_assign(Vector2.prototype,{isVector2:true,set:function set(x,y){this.x=x;this.y=y;return this;},setScalar:function setScalar(scalar){this.x=scalar;this.y=scalar;return this;},setX:function setX(x){this.x=x;return this;},setY:function setY(y){this.y=y;return this;},setComponent:function setComponent(index,value){switch(index){case 0:this.x=value;break;case 1:this.y=value;break;default:throw new Error('index is out of range: '+index);}return this;},getComponent:function getComponent(index){switch(index){case 0:return this.x;case 1:return this.y;default:throw new Error('index is out of range: '+index);}},clone:function clone(){return new this.constructor(this.x,this.y);},copy:function copy(v){this.x=v.x;this.y=v.y;return this;},add:function add(v,w){if(w!==undefined){console.warn('THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead.');return this.addVectors(v,w);}this.x+=v.x;this.y+=v.y;return this;},addScalar:function addScalar(s){this.x+=s;this.y+=s;return this;},addVectors:function addVectors(a,b){this.x=a.x+b.x;this.y=a.y+b.y;return this;},addScaledVector:function addScaledVector(v,s){this.x+=v.x*s;this.y+=v.y*s;return this;},sub:function sub(v,w){if(w!==undefined){console.warn('THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.');return this.subVectors(v,w);}this.x-=v.x;this.y-=v.y;return this;},subScalar:function subScalar(s){this.x-=s;this.y-=s;return this;},subVectors:function subVectors(a,b){this.x=a.x-b.x;this.y=a.y-b.y;return this;},multiply:function multiply(v){this.x*=v.x;this.y*=v.y;return this;},multiplyScalar:function multiplyScalar(scalar){this.x*=scalar;this.y*=scalar;return this;},divide:function divide(v){this.x/=v.x;this.y/=v.y;return this;},divideScalar:function divideScalar(scalar){return this.multiplyScalar(1/scalar);},min:function min(v){this.x=Math.min(this.x,v.x);this.y=Math.min(this.y,v.y);return this;},max:function max(v){this.x=Math.max(this.x,v.x);this.y=Math.max(this.y,v.y);return this;},clamp:function clamp(min,max){// This function assumes min < max, if this assumption isn't true it will not operate correctly
	this.x=Math.max(min.x,Math.min(max.x,this.x));this.y=Math.max(min.y,Math.min(max.y,this.y));return this;},clampScalar:function(){var min=new Vector2();var max=new Vector2();return function clampScalar(minVal,maxVal){min.set(minVal,minVal);max.set(maxVal,maxVal);return this.clamp(min,max);};}(),clampLength:function clampLength(min,max){var length=this.length();return this.multiplyScalar(Math.max(min,Math.min(max,length))/length);},floor:function floor(){this.x=Math.floor(this.x);this.y=Math.floor(this.y);return this;},ceil:function ceil(){this.x=Math.ceil(this.x);this.y=Math.ceil(this.y);return this;},round:function round(){this.x=Math.round(this.x);this.y=Math.round(this.y);return this;},roundToZero:function roundToZero(){this.x=this.x<0?Math.ceil(this.x):Math.floor(this.x);this.y=this.y<0?Math.ceil(this.y):Math.floor(this.y);return this;},negate:function negate(){this.x=-this.x;this.y=-this.y;return this;},dot:function dot(v){return this.x*v.x+this.y*v.y;},lengthSq:function lengthSq(){return this.x*this.x+this.y*this.y;},length:function length(){return Math.sqrt(this.x*this.x+this.y*this.y);},lengthManhattan:function lengthManhattan(){return Math.abs(this.x)+Math.abs(this.y);},normalize:function normalize(){return this.divideScalar(this.length());},angle:function angle(){// computes the angle in radians with respect to the positive x-axis
	var angle=Math.atan2(this.y,this.x);if(angle<0)angle+=2*Math.PI;return angle;},distanceTo:function distanceTo(v){return Math.sqrt(this.distanceToSquared(v));},distanceToSquared:function distanceToSquared(v){var dx=this.x-v.x,dy=this.y-v.y;return dx*dx+dy*dy;},distanceToManhattan:function distanceToManhattan(v){return Math.abs(this.x-v.x)+Math.abs(this.y-v.y);},setLength:function setLength(length){return this.multiplyScalar(length/this.length());},lerp:function lerp(v,alpha){this.x+=(v.x-this.x)*alpha;this.y+=(v.y-this.y)*alpha;return this;},lerpVectors:function lerpVectors(v1,v2,alpha){return this.subVectors(v2,v1).multiplyScalar(alpha).add(v1);},equals:function equals(v){return v.x===this.x&&v.y===this.y;},fromArray:function fromArray(array,offset){if(offset===undefined)offset=0;this.x=array[offset];this.y=array[offset+1];return this;},toArray:function toArray(array,offset){if(array===undefined)array=[];if(offset===undefined)offset=0;array[offset]=this.x;array[offset+1]=this.y;return array;},fromBufferAttribute:function fromBufferAttribute(attribute,index,offset){if(offset!==undefined){console.warn('THREE.Vector2: offset has been removed from .fromBufferAttribute().');}this.x=attribute.getX(index);this.y=attribute.getY(index);return this;},rotateAround:function rotateAround(center,angle){var c=Math.cos(angle),s=Math.sin(angle);var x=this.x-center.x;var y=this.y-center.y;this.x=x*c-y*s+center.x;this.y=x*s+y*c+center.y;return this;}});/**
		 * @author mrdoob / http://mrdoob.com/
		 * @author alteredq / http://alteredqualia.com/
		 * @author szimek / https://github.com/szimek/
		 */var textureId=0;function Texture(image,mapping,wrapS,wrapT,magFilter,minFilter,format,type,anisotropy,encoding){Object.defineProperty(this,'id',{value:textureId++});this.uuid=_Math.generateUUID();this.name='';this.image=image!==undefined?image:Texture.DEFAULT_IMAGE;this.mipmaps=[];this.mapping=mapping!==undefined?mapping:Texture.DEFAULT_MAPPING;this.wrapS=wrapS!==undefined?wrapS:ClampToEdgeWrapping;this.wrapT=wrapT!==undefined?wrapT:ClampToEdgeWrapping;this.magFilter=magFilter!==undefined?magFilter:LinearFilter;this.minFilter=minFilter!==undefined?minFilter:LinearMipMapLinearFilter;this.anisotropy=anisotropy!==undefined?anisotropy:1;this.format=format!==undefined?format:RGBAFormat;this.type=type!==undefined?type:UnsignedByteType;this.offset=new Vector2(0,0);this.repeat=new Vector2(1,1);this.generateMipmaps=true;this.premultiplyAlpha=false;this.flipY=true;this.unpackAlignment=4;// valid values: 1, 2, 4, 8 (see http://www.khronos.org/opengles/sdk/docs/man/xhtml/glPixelStorei.xml)
	// Values of encoding !== THREE.LinearEncoding only supported on map, envMap and emissiveMap.
	//
	// Also changing the encoding after already used by a Material will not automatically make the Material
	// update.  You need to explicitly call Material.needsUpdate to trigger it to recompile.
	this.encoding=encoding!==undefined?encoding:LinearEncoding;this.version=0;this.onUpdate=null;}Texture.DEFAULT_IMAGE=undefined;Texture.DEFAULT_MAPPING=UVMapping;Object.defineProperty(Texture.prototype,"needsUpdate",{set:function set(value){if(value===true)this.version++;}});_assign(Texture.prototype,EventDispatcher.prototype,{constructor:Texture,isTexture:true,clone:function clone(){return new this.constructor().copy(this);},copy:function copy(source){this.name=source.name;this.image=source.image;this.mipmaps=source.mipmaps.slice(0);this.mapping=source.mapping;this.wrapS=source.wrapS;this.wrapT=source.wrapT;this.magFilter=source.magFilter;this.minFilter=source.minFilter;this.anisotropy=source.anisotropy;this.format=source.format;this.type=source.type;this.offset.copy(source.offset);this.repeat.copy(source.repeat);this.generateMipmaps=source.generateMipmaps;this.premultiplyAlpha=source.premultiplyAlpha;this.flipY=source.flipY;this.unpackAlignment=source.unpackAlignment;this.encoding=source.encoding;return this;},toJSON:function toJSON(meta){if(meta.textures[this.uuid]!==undefined){return meta.textures[this.uuid];}function getDataURL(image){var canvas;if(image.toDataURL!==undefined){canvas=image;}else{canvas=document.createElementNS('http://www.w3.org/1999/xhtml','canvas');canvas.width=image.width;canvas.height=image.height;canvas.getContext('2d').drawImage(image,0,0,image.width,image.height);}if(canvas.width>2048||canvas.height>2048){return canvas.toDataURL('image/jpeg',0.6);}else{return canvas.toDataURL('image/png');}}var output={metadata:{version:4.5,type:'Texture',generator:'Texture.toJSON'},uuid:this.uuid,name:this.name,mapping:this.mapping,repeat:[this.repeat.x,this.repeat.y],offset:[this.offset.x,this.offset.y],wrap:[this.wrapS,this.wrapT],minFilter:this.minFilter,magFilter:this.magFilter,anisotropy:this.anisotropy,flipY:this.flipY};if(this.image!==undefined){// TODO: Move to THREE.Image
	var image=this.image;if(image.uuid===undefined){image.uuid=_Math.generateUUID();// UGH
	}if(meta.images[image.uuid]===undefined){meta.images[image.uuid]={uuid:image.uuid,url:getDataURL(image)};}output.image=image.uuid;}meta.textures[this.uuid]=output;return output;},dispose:function dispose(){this.dispatchEvent({type:'dispose'});},transformUv:function transformUv(uv){if(this.mapping!==UVMapping)return;uv.multiply(this.repeat);uv.add(this.offset);if(uv.x<0||uv.x>1){switch(this.wrapS){case RepeatWrapping:uv.x=uv.x-Math.floor(uv.x);break;case ClampToEdgeWrapping:uv.x=uv.x<0?0:1;break;case MirroredRepeatWrapping:if(Math.abs(Math.floor(uv.x)%2)===1){uv.x=Math.ceil(uv.x)-uv.x;}else{uv.x=uv.x-Math.floor(uv.x);}break;}}if(uv.y<0||uv.y>1){switch(this.wrapT){case RepeatWrapping:uv.y=uv.y-Math.floor(uv.y);break;case ClampToEdgeWrapping:uv.y=uv.y<0?0:1;break;case MirroredRepeatWrapping:if(Math.abs(Math.floor(uv.y)%2)===1){uv.y=Math.ceil(uv.y)-uv.y;}else{uv.y=uv.y-Math.floor(uv.y);}break;}}if(this.flipY){uv.y=1-uv.y;}}});/**
		 * @author alteredq / http://alteredqualia.com/
		 */function DataTexture(data,width,height,format,type,mapping,wrapS,wrapT,magFilter,minFilter,anisotropy,encoding){Texture.call(this,null,mapping,wrapS,wrapT,magFilter,minFilter,format,type,anisotropy,encoding);this.image={data:data,width:width,height:height};this.magFilter=magFilter!==undefined?magFilter:NearestFilter;this.minFilter=minFilter!==undefined?minFilter:NearestFilter;this.generateMipmaps=false;this.flipY=false;this.unpackAlignment=1;}DataTexture.prototype=Object.create(Texture.prototype);DataTexture.prototype.constructor=DataTexture;DataTexture.prototype.isDataTexture=true;/**
		 * @author mrdoob / http://mrdoob.com/
		 */function CubeTexture(images,mapping,wrapS,wrapT,magFilter,minFilter,format,type,anisotropy,encoding){images=images!==undefined?images:[];mapping=mapping!==undefined?mapping:CubeReflectionMapping;Texture.call(this,images,mapping,wrapS,wrapT,magFilter,minFilter,format,type,anisotropy,encoding);this.flipY=false;}CubeTexture.prototype=Object.create(Texture.prototype);CubeTexture.prototype.constructor=CubeTexture;CubeTexture.prototype.isCubeTexture=true;Object.defineProperty(CubeTexture.prototype,'images',{get:function get(){return this.image;},set:function set(value){this.image=value;}});/**
		 * @author tschw
		 *
		 * Uniforms of a program.
		 * Those form a tree structure with a special top-level container for the root,
		 * which you get by calling 'new WebGLUniforms( gl, program, renderer )'.
		 *
		 *
		 * Properties of inner nodes including the top-level container:
		 *
		 * .seq - array of nested uniforms
		 * .map - nested uniforms by name
		 *
		 *
		 * Methods of all nodes except the top-level container:
		 *
		 * .setValue( gl, value, [renderer] )
		 *
		 * 		uploads a uniform value(s)
		 *  	the 'renderer' parameter is needed for sampler uniforms
		 *
		 *
		 * Static methods of the top-level container (renderer factorizations):
		 *
		 * .upload( gl, seq, values, renderer )
		 *
		 * 		sets uniforms in 'seq' to 'values[id].value'
		 *
		 * .seqWithValue( seq, values ) : filteredSeq
		 *
		 * 		filters 'seq' entries with corresponding entry in values
		 *
		 *
		 * Methods of the top-level container (renderer factorizations):
		 *
		 * .setValue( gl, name, value )
		 *
		 * 		sets uniform with  name 'name' to 'value'
		 *
		 * .set( gl, obj, prop )
		 *
		 * 		sets uniform from object and property with same name than uniform
		 *
		 * .setOptional( gl, obj, prop )
		 *
		 * 		like .set for an optional property of the object
		 *
		 */var emptyTexture=new Texture();var emptyCubeTexture=new CubeTexture();// --- Base for inner nodes (including the root) ---
	function UniformContainer(){this.seq=[];this.map={};}// --- Utilities ---
	// Array Caches (provide typed arrays for temporary by size)
	var arrayCacheF32=[];var arrayCacheI32=[];// Float32Array caches used for uploading Matrix uniforms
	var mat4array=new Float32Array(16);var mat3array=new Float32Array(9);// Flattening for arrays of vectors and matrices
	function flatten(array,nBlocks,blockSize){var firstElem=array[0];if(firstElem<=0||firstElem>0)return array;// unoptimized: ! isNaN( firstElem )
	// see http://jacksondunstan.com/articles/983
	var n=nBlocks*blockSize,r=arrayCacheF32[n];if(r===undefined){r=new Float32Array(n);arrayCacheF32[n]=r;}if(nBlocks!==0){firstElem.toArray(r,0);for(var i=1,offset=0;i!==nBlocks;++i){offset+=blockSize;array[i].toArray(r,offset);}}return r;}// Texture unit allocation
	function allocTexUnits(renderer,n){var r=arrayCacheI32[n];if(r===undefined){r=new Int32Array(n);arrayCacheI32[n]=r;}for(var i=0;i!==n;++i){r[i]=renderer.allocTextureUnit();}return r;}// --- Setters ---
	// Note: Defining these methods externally, because they come in a bunch
	// and this way their names minify.
	// Single scalar
	function setValue1f(gl,v){gl.uniform1f(this.addr,v);}function setValue1i(gl,v){gl.uniform1i(this.addr,v);}// Single float vector (from flat array or THREE.VectorN)
	function setValue2fv(gl,v){if(v.x===undefined)gl.uniform2fv(this.addr,v);else gl.uniform2f(this.addr,v.x,v.y);}function setValue3fv(gl,v){if(v.x!==undefined)gl.uniform3f(this.addr,v.x,v.y,v.z);else if(v.r!==undefined)gl.uniform3f(this.addr,v.r,v.g,v.b);else gl.uniform3fv(this.addr,v);}function setValue4fv(gl,v){if(v.x===undefined)gl.uniform4fv(this.addr,v);else gl.uniform4f(this.addr,v.x,v.y,v.z,v.w);}// Single matrix (from flat array or MatrixN)
	function setValue2fm(gl,v){gl.uniformMatrix2fv(this.addr,false,v.elements||v);}function setValue3fm(gl,v){if(v.elements===undefined){gl.uniformMatrix3fv(this.addr,false,v);}else{mat3array.set(v.elements);gl.uniformMatrix3fv(this.addr,false,mat3array);}}function setValue4fm(gl,v){if(v.elements===undefined){gl.uniformMatrix4fv(this.addr,false,v);}else{mat4array.set(v.elements);gl.uniformMatrix4fv(this.addr,false,mat4array);}}// Single texture (2D / Cube)
	function setValueT1(gl,v,renderer){var unit=renderer.allocTextureUnit();gl.uniform1i(this.addr,unit);renderer.setTexture2D(v||emptyTexture,unit);}function setValueT6(gl,v,renderer){var unit=renderer.allocTextureUnit();gl.uniform1i(this.addr,unit);renderer.setTextureCube(v||emptyCubeTexture,unit);}// Integer / Boolean vectors or arrays thereof (always flat arrays)
	function setValue2iv(gl,v){gl.uniform2iv(this.addr,v);}function setValue3iv(gl,v){gl.uniform3iv(this.addr,v);}function setValue4iv(gl,v){gl.uniform4iv(this.addr,v);}// Helper to pick the right setter for the singular case
	function getSingularSetter(type){switch(type){case 0x1406:return setValue1f;// FLOAT
	case 0x8b50:return setValue2fv;// _VEC2
	case 0x8b51:return setValue3fv;// _VEC3
	case 0x8b52:return setValue4fv;// _VEC4
	case 0x8b5a:return setValue2fm;// _MAT2
	case 0x8b5b:return setValue3fm;// _MAT3
	case 0x8b5c:return setValue4fm;// _MAT4
	case 0x8b5e:return setValueT1;// SAMPLER_2D
	case 0x8b60:return setValueT6;// SAMPLER_CUBE
	case 0x1404:case 0x8b56:return setValue1i;// INT, BOOL
	case 0x8b53:case 0x8b57:return setValue2iv;// _VEC2
	case 0x8b54:case 0x8b58:return setValue3iv;// _VEC3
	case 0x8b55:case 0x8b59:return setValue4iv;// _VEC4
	}}// Array of scalars
	function setValue1fv(gl,v){gl.uniform1fv(this.addr,v);}function setValue1iv(gl,v){gl.uniform1iv(this.addr,v);}// Array of vectors (flat or from THREE classes)
	function setValueV2a(gl,v){gl.uniform2fv(this.addr,flatten(v,this.size,2));}function setValueV3a(gl,v){gl.uniform3fv(this.addr,flatten(v,this.size,3));}function setValueV4a(gl,v){gl.uniform4fv(this.addr,flatten(v,this.size,4));}// Array of matrices (flat or from THREE clases)
	function setValueM2a(gl,v){gl.uniformMatrix2fv(this.addr,false,flatten(v,this.size,4));}function setValueM3a(gl,v){gl.uniformMatrix3fv(this.addr,false,flatten(v,this.size,9));}function setValueM4a(gl,v){gl.uniformMatrix4fv(this.addr,false,flatten(v,this.size,16));}// Array of textures (2D / Cube)
	function setValueT1a(gl,v,renderer){var n=v.length,units=allocTexUnits(renderer,n);gl.uniform1iv(this.addr,units);for(var i=0;i!==n;++i){renderer.setTexture2D(v[i]||emptyTexture,units[i]);}}function setValueT6a(gl,v,renderer){var n=v.length,units=allocTexUnits(renderer,n);gl.uniform1iv(this.addr,units);for(var i=0;i!==n;++i){renderer.setTextureCube(v[i]||emptyCubeTexture,units[i]);}}// Helper to pick the right setter for a pure (bottom-level) array
	function getPureArraySetter(type){switch(type){case 0x1406:return setValue1fv;// FLOAT
	case 0x8b50:return setValueV2a;// _VEC2
	case 0x8b51:return setValueV3a;// _VEC3
	case 0x8b52:return setValueV4a;// _VEC4
	case 0x8b5a:return setValueM2a;// _MAT2
	case 0x8b5b:return setValueM3a;// _MAT3
	case 0x8b5c:return setValueM4a;// _MAT4
	case 0x8b5e:return setValueT1a;// SAMPLER_2D
	case 0x8b60:return setValueT6a;// SAMPLER_CUBE
	case 0x1404:case 0x8b56:return setValue1iv;// INT, BOOL
	case 0x8b53:case 0x8b57:return setValue2iv;// _VEC2
	case 0x8b54:case 0x8b58:return setValue3iv;// _VEC3
	case 0x8b55:case 0x8b59:return setValue4iv;// _VEC4
	}}// --- Uniform Classes ---
	function SingleUniform(id,activeInfo,addr){this.id=id;this.addr=addr;this.setValue=getSingularSetter(activeInfo.type);// this.path = activeInfo.name; // DEBUG
	}function PureArrayUniform(id,activeInfo,addr){this.id=id;this.addr=addr;this.size=activeInfo.size;this.setValue=getPureArraySetter(activeInfo.type);// this.path = activeInfo.name; // DEBUG
	}function StructuredUniform(id){this.id=id;UniformContainer.call(this);// mix-in
	}StructuredUniform.prototype.setValue=function(gl,value){// Note: Don't need an extra 'renderer' parameter, since samplers
	// are not allowed in structured uniforms.
	var seq=this.seq;for(var i=0,n=seq.length;i!==n;++i){var u=seq[i];u.setValue(gl,value[u.id]);}};// --- Top-level ---
	// Parser - builds up the property tree from the path strings
	var RePathPart=/([\w\d_]+)(\])?(\[|\.)?/g;// extracts
	// 	- the identifier (member name or array index)
	//  - followed by an optional right bracket (found when array index)
	//  - followed by an optional left bracket or dot (type of subscript)
	//
	// Note: These portions can be read in a non-overlapping fashion and
	// allow straightforward parsing of the hierarchy that WebGL encodes
	// in the uniform names.
	function addUniform(container,uniformObject){container.seq.push(uniformObject);container.map[uniformObject.id]=uniformObject;}function parseUniform(activeInfo,addr,container){var path=activeInfo.name,pathLength=path.length;// reset RegExp object, because of the early exit of a previous run
	RePathPart.lastIndex=0;for(;;){var match=RePathPart.exec(path),matchEnd=RePathPart.lastIndex,id=match[1],idIsIndex=match[2]===']',subscript=match[3];if(idIsIndex)id=id|0;// convert to integer
	if(subscript===undefined||subscript==='['&&matchEnd+2===pathLength){// bare name or "pure" bottom-level array "[0]" suffix
	addUniform(container,subscript===undefined?new SingleUniform(id,activeInfo,addr):new PureArrayUniform(id,activeInfo,addr));break;}else{// step into inner node / create it in case it doesn't exist
	var map=container.map,next=map[id];if(next===undefined){next=new StructuredUniform(id);addUniform(container,next);}container=next;}}}// Root Container
	function WebGLUniforms(gl,program,renderer){UniformContainer.call(this);this.renderer=renderer;var n=gl.getProgramParameter(program,gl.ACTIVE_UNIFORMS);for(var i=0;i<n;++i){var info=gl.getActiveUniform(program,i),path=info.name,addr=gl.getUniformLocation(program,path);parseUniform(info,addr,this);}}WebGLUniforms.prototype.setValue=function(gl,name,value){var u=this.map[name];if(u!==undefined)u.setValue(gl,value,this.renderer);};WebGLUniforms.prototype.setOptional=function(gl,object,name){var v=object[name];if(v!==undefined)this.setValue(gl,name,v);};// Static interface
	WebGLUniforms.upload=function(gl,seq,values,renderer){for(var i=0,n=seq.length;i!==n;++i){var u=seq[i],v=values[u.id];if(v.needsUpdate!==false){// note: always updating when .needsUpdate is undefined
	u.setValue(gl,v.value,renderer);}}};WebGLUniforms.seqWithValue=function(seq,values){var r=[];for(var i=0,n=seq.length;i!==n;++i){var u=seq[i];if(u.id in values)r.push(u);}return r;};/**
		 * @author supereggbert / http://www.paulbrunt.co.uk/
		 * @author philogb / http://blog.thejit.org/
		 * @author mikael emtinger / http://gomo.se/
		 * @author egraether / http://egraether.com/
		 * @author WestLangley / http://github.com/WestLangley
		 */function Vector4(x,y,z,w){this.x=x||0;this.y=y||0;this.z=z||0;this.w=w!==undefined?w:1;}_assign(Vector4.prototype,{isVector4:true,set:function set(x,y,z,w){this.x=x;this.y=y;this.z=z;this.w=w;return this;},setScalar:function setScalar(scalar){this.x=scalar;this.y=scalar;this.z=scalar;this.w=scalar;return this;},setX:function setX(x){this.x=x;return this;},setY:function setY(y){this.y=y;return this;},setZ:function setZ(z){this.z=z;return this;},setW:function setW(w){this.w=w;return this;},setComponent:function setComponent(index,value){switch(index){case 0:this.x=value;break;case 1:this.y=value;break;case 2:this.z=value;break;case 3:this.w=value;break;default:throw new Error('index is out of range: '+index);}return this;},getComponent:function getComponent(index){switch(index){case 0:return this.x;case 1:return this.y;case 2:return this.z;case 3:return this.w;default:throw new Error('index is out of range: '+index);}},clone:function clone(){return new this.constructor(this.x,this.y,this.z,this.w);},copy:function copy(v){this.x=v.x;this.y=v.y;this.z=v.z;this.w=v.w!==undefined?v.w:1;return this;},add:function add(v,w){if(w!==undefined){console.warn('THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead.');return this.addVectors(v,w);}this.x+=v.x;this.y+=v.y;this.z+=v.z;this.w+=v.w;return this;},addScalar:function addScalar(s){this.x+=s;this.y+=s;this.z+=s;this.w+=s;return this;},addVectors:function addVectors(a,b){this.x=a.x+b.x;this.y=a.y+b.y;this.z=a.z+b.z;this.w=a.w+b.w;return this;},addScaledVector:function addScaledVector(v,s){this.x+=v.x*s;this.y+=v.y*s;this.z+=v.z*s;this.w+=v.w*s;return this;},sub:function sub(v,w){if(w!==undefined){console.warn('THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.');return this.subVectors(v,w);}this.x-=v.x;this.y-=v.y;this.z-=v.z;this.w-=v.w;return this;},subScalar:function subScalar(s){this.x-=s;this.y-=s;this.z-=s;this.w-=s;return this;},subVectors:function subVectors(a,b){this.x=a.x-b.x;this.y=a.y-b.y;this.z=a.z-b.z;this.w=a.w-b.w;return this;},multiplyScalar:function multiplyScalar(scalar){this.x*=scalar;this.y*=scalar;this.z*=scalar;this.w*=scalar;return this;},applyMatrix4:function applyMatrix4(m){var x=this.x,y=this.y,z=this.z,w=this.w;var e=m.elements;this.x=e[0]*x+e[4]*y+e[8]*z+e[12]*w;this.y=e[1]*x+e[5]*y+e[9]*z+e[13]*w;this.z=e[2]*x+e[6]*y+e[10]*z+e[14]*w;this.w=e[3]*x+e[7]*y+e[11]*z+e[15]*w;return this;},divideScalar:function divideScalar(scalar){return this.multiplyScalar(1/scalar);},setAxisAngleFromQuaternion:function setAxisAngleFromQuaternion(q){// http://www.euclideanspace.com/maths/geometry/rotations/conversions/quaternionToAngle/index.htm
	// q is assumed to be normalized
	this.w=2*Math.acos(q.w);var s=Math.sqrt(1-q.w*q.w);if(s<0.0001){this.x=1;this.y=0;this.z=0;}else{this.x=q.x/s;this.y=q.y/s;this.z=q.z/s;}return this;},setAxisAngleFromRotationMatrix:function setAxisAngleFromRotationMatrix(m){// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToAngle/index.htm
	// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)
	var angle,x,y,z,// variables for result
	epsilon=0.01,// margin to allow for rounding errors
	epsilon2=0.1,// margin to distinguish between 0 and 180 degrees
	te=m.elements,m11=te[0],m12=te[4],m13=te[8],m21=te[1],m22=te[5],m23=te[9],m31=te[2],m32=te[6],m33=te[10];if(Math.abs(m12-m21)<epsilon&&Math.abs(m13-m31)<epsilon&&Math.abs(m23-m32)<epsilon){// singularity found
	// first check for identity matrix which must have +1 for all terms
	// in leading diagonal and zero in other terms
	if(Math.abs(m12+m21)<epsilon2&&Math.abs(m13+m31)<epsilon2&&Math.abs(m23+m32)<epsilon2&&Math.abs(m11+m22+m33-3)<epsilon2){// this singularity is identity matrix so angle = 0
	this.set(1,0,0,0);return this;// zero angle, arbitrary axis
	}// otherwise this singularity is angle = 180
	angle=Math.PI;var xx=(m11+1)/2;var yy=(m22+1)/2;var zz=(m33+1)/2;var xy=(m12+m21)/4;var xz=(m13+m31)/4;var yz=(m23+m32)/4;if(xx>yy&&xx>zz){// m11 is the largest diagonal term
	if(xx<epsilon){x=0;y=0.707106781;z=0.707106781;}else{x=Math.sqrt(xx);y=xy/x;z=xz/x;}}else if(yy>zz){// m22 is the largest diagonal term
	if(yy<epsilon){x=0.707106781;y=0;z=0.707106781;}else{y=Math.sqrt(yy);x=xy/y;z=yz/y;}}else{// m33 is the largest diagonal term so base result on this
	if(zz<epsilon){x=0.707106781;y=0.707106781;z=0;}else{z=Math.sqrt(zz);x=xz/z;y=yz/z;}}this.set(x,y,z,angle);return this;// return 180 deg rotation
	}// as we have reached here there are no singularities so we can handle normally
	var s=Math.sqrt((m32-m23)*(m32-m23)+(m13-m31)*(m13-m31)+(m21-m12)*(m21-m12));// used to normalize
	if(Math.abs(s)<0.001)s=1;// prevent divide by zero, should not happen if matrix is orthogonal and should be
	// caught by singularity test above, but I've left it in just in case
	this.x=(m32-m23)/s;this.y=(m13-m31)/s;this.z=(m21-m12)/s;this.w=Math.acos((m11+m22+m33-1)/2);return this;},min:function min(v){this.x=Math.min(this.x,v.x);this.y=Math.min(this.y,v.y);this.z=Math.min(this.z,v.z);this.w=Math.min(this.w,v.w);return this;},max:function max(v){this.x=Math.max(this.x,v.x);this.y=Math.max(this.y,v.y);this.z=Math.max(this.z,v.z);this.w=Math.max(this.w,v.w);return this;},clamp:function clamp(min,max){// This function assumes min < max, if this assumption isn't true it will not operate correctly
	this.x=Math.max(min.x,Math.min(max.x,this.x));this.y=Math.max(min.y,Math.min(max.y,this.y));this.z=Math.max(min.z,Math.min(max.z,this.z));this.w=Math.max(min.w,Math.min(max.w,this.w));return this;},clampScalar:function(){var min=new Vector4();var max=new Vector4();return function clampScalar(minVal,maxVal){min.set(minVal,minVal,minVal,minVal);max.set(maxVal,maxVal,maxVal,maxVal);return this.clamp(min,max);};}(),floor:function floor(){this.x=Math.floor(this.x);this.y=Math.floor(this.y);this.z=Math.floor(this.z);this.w=Math.floor(this.w);return this;},ceil:function ceil(){this.x=Math.ceil(this.x);this.y=Math.ceil(this.y);this.z=Math.ceil(this.z);this.w=Math.ceil(this.w);return this;},round:function round(){this.x=Math.round(this.x);this.y=Math.round(this.y);this.z=Math.round(this.z);this.w=Math.round(this.w);return this;},roundToZero:function roundToZero(){this.x=this.x<0?Math.ceil(this.x):Math.floor(this.x);this.y=this.y<0?Math.ceil(this.y):Math.floor(this.y);this.z=this.z<0?Math.ceil(this.z):Math.floor(this.z);this.w=this.w<0?Math.ceil(this.w):Math.floor(this.w);return this;},negate:function negate(){this.x=-this.x;this.y=-this.y;this.z=-this.z;this.w=-this.w;return this;},dot:function dot(v){return this.x*v.x+this.y*v.y+this.z*v.z+this.w*v.w;},lengthSq:function lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w;},length:function length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w);},lengthManhattan:function lengthManhattan(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)+Math.abs(this.w);},normalize:function normalize(){return this.divideScalar(this.length());},setLength:function setLength(length){return this.multiplyScalar(length/this.length());},lerp:function lerp(v,alpha){this.x+=(v.x-this.x)*alpha;this.y+=(v.y-this.y)*alpha;this.z+=(v.z-this.z)*alpha;this.w+=(v.w-this.w)*alpha;return this;},lerpVectors:function lerpVectors(v1,v2,alpha){return this.subVectors(v2,v1).multiplyScalar(alpha).add(v1);},equals:function equals(v){return v.x===this.x&&v.y===this.y&&v.z===this.z&&v.w===this.w;},fromArray:function fromArray(array,offset){if(offset===undefined)offset=0;this.x=array[offset];this.y=array[offset+1];this.z=array[offset+2];this.w=array[offset+3];return this;},toArray:function toArray(array,offset){if(array===undefined)array=[];if(offset===undefined)offset=0;array[offset]=this.x;array[offset+1]=this.y;array[offset+2]=this.z;array[offset+3]=this.w;return array;},fromBufferAttribute:function fromBufferAttribute(attribute,index,offset){if(offset!==undefined){console.warn('THREE.Vector4: offset has been removed from .fromBufferAttribute().');}this.x=attribute.getX(index);this.y=attribute.getY(index);this.z=attribute.getZ(index);this.w=attribute.getW(index);return this;}});/**
		 * @author mrdoob / http://mrdoob.com/
		 */var ColorKeywords={'aliceblue':0xF0F8FF,'antiquewhite':0xFAEBD7,'aqua':0x00FFFF,'aquamarine':0x7FFFD4,'azure':0xF0FFFF,'beige':0xF5F5DC,'bisque':0xFFE4C4,'black':0x000000,'blanchedalmond':0xFFEBCD,'blue':0x0000FF,'blueviolet':0x8A2BE2,'brown':0xA52A2A,'burlywood':0xDEB887,'cadetblue':0x5F9EA0,'chartreuse':0x7FFF00,'chocolate':0xD2691E,'coral':0xFF7F50,'cornflowerblue':0x6495ED,'cornsilk':0xFFF8DC,'crimson':0xDC143C,'cyan':0x00FFFF,'darkblue':0x00008B,'darkcyan':0x008B8B,'darkgoldenrod':0xB8860B,'darkgray':0xA9A9A9,'darkgreen':0x006400,'darkgrey':0xA9A9A9,'darkkhaki':0xBDB76B,'darkmagenta':0x8B008B,'darkolivegreen':0x556B2F,'darkorange':0xFF8C00,'darkorchid':0x9932CC,'darkred':0x8B0000,'darksalmon':0xE9967A,'darkseagreen':0x8FBC8F,'darkslateblue':0x483D8B,'darkslategray':0x2F4F4F,'darkslategrey':0x2F4F4F,'darkturquoise':0x00CED1,'darkviolet':0x9400D3,'deeppink':0xFF1493,'deepskyblue':0x00BFFF,'dimgray':0x696969,'dimgrey':0x696969,'dodgerblue':0x1E90FF,'firebrick':0xB22222,'floralwhite':0xFFFAF0,'forestgreen':0x228B22,'fuchsia':0xFF00FF,'gainsboro':0xDCDCDC,'ghostwhite':0xF8F8FF,'gold':0xFFD700,'goldenrod':0xDAA520,'gray':0x808080,'green':0x008000,'greenyellow':0xADFF2F,'grey':0x808080,'honeydew':0xF0FFF0,'hotpink':0xFF69B4,'indianred':0xCD5C5C,'indigo':0x4B0082,'ivory':0xFFFFF0,'khaki':0xF0E68C,'lavender':0xE6E6FA,'lavenderblush':0xFFF0F5,'lawngreen':0x7CFC00,'lemonchiffon':0xFFFACD,'lightblue':0xADD8E6,'lightcoral':0xF08080,'lightcyan':0xE0FFFF,'lightgoldenrodyellow':0xFAFAD2,'lightgray':0xD3D3D3,'lightgreen':0x90EE90,'lightgrey':0xD3D3D3,'lightpink':0xFFB6C1,'lightsalmon':0xFFA07A,'lightseagreen':0x20B2AA,'lightskyblue':0x87CEFA,'lightslategray':0x778899,'lightslategrey':0x778899,'lightsteelblue':0xB0C4DE,'lightyellow':0xFFFFE0,'lime':0x00FF00,'limegreen':0x32CD32,'linen':0xFAF0E6,'magenta':0xFF00FF,'maroon':0x800000,'mediumaquamarine':0x66CDAA,'mediumblue':0x0000CD,'mediumorchid':0xBA55D3,'mediumpurple':0x9370DB,'mediumseagreen':0x3CB371,'mediumslateblue':0x7B68EE,'mediumspringgreen':0x00FA9A,'mediumturquoise':0x48D1CC,'mediumvioletred':0xC71585,'midnightblue':0x191970,'mintcream':0xF5FFFA,'mistyrose':0xFFE4E1,'moccasin':0xFFE4B5,'navajowhite':0xFFDEAD,'navy':0x000080,'oldlace':0xFDF5E6,'olive':0x808000,'olivedrab':0x6B8E23,'orange':0xFFA500,'orangered':0xFF4500,'orchid':0xDA70D6,'palegoldenrod':0xEEE8AA,'palegreen':0x98FB98,'paleturquoise':0xAFEEEE,'palevioletred':0xDB7093,'papayawhip':0xFFEFD5,'peachpuff':0xFFDAB9,'peru':0xCD853F,'pink':0xFFC0CB,'plum':0xDDA0DD,'powderblue':0xB0E0E6,'purple':0x800080,'red':0xFF0000,'rosybrown':0xBC8F8F,'royalblue':0x4169E1,'saddlebrown':0x8B4513,'salmon':0xFA8072,'sandybrown':0xF4A460,'seagreen':0x2E8B57,'seashell':0xFFF5EE,'sienna':0xA0522D,'silver':0xC0C0C0,'skyblue':0x87CEEB,'slateblue':0x6A5ACD,'slategray':0x708090,'slategrey':0x708090,'snow':0xFFFAFA,'springgreen':0x00FF7F,'steelblue':0x4682B4,'tan':0xD2B48C,'teal':0x008080,'thistle':0xD8BFD8,'tomato':0xFF6347,'turquoise':0x40E0D0,'violet':0xEE82EE,'wheat':0xF5DEB3,'white':0xFFFFFF,'whitesmoke':0xF5F5F5,'yellow':0xFFFF00,'yellowgreen':0x9ACD32};function Color(r,g,b){if(g===undefined&&b===undefined){// r is THREE.Color, hex or string
	return this.set(r);}return this.setRGB(r,g,b);}_assign(Color.prototype,{isColor:true,r:1,g:1,b:1,set:function set(value){if(value&&value.isColor){this.copy(value);}else if(typeof value==='number'){this.setHex(value);}else if(typeof value==='string'){this.setStyle(value);}return this;},setScalar:function setScalar(scalar){this.r=scalar;this.g=scalar;this.b=scalar;return this;},setHex:function setHex(hex){hex=Math.floor(hex);this.r=(hex>>16&255)/255;this.g=(hex>>8&255)/255;this.b=(hex&255)/255;return this;},setRGB:function setRGB(r,g,b){this.r=r;this.g=g;this.b=b;return this;},setHSL:function(){function hue2rgb(p,q,t){if(t<0)t+=1;if(t>1)t-=1;if(t<1/6)return p+(q-p)*6*t;if(t<1/2)return q;if(t<2/3)return p+(q-p)*6*(2/3-t);return p;}return function setHSL(h,s,l){// h,s,l ranges are in 0.0 - 1.0
	h=_Math.euclideanModulo(h,1);s=_Math.clamp(s,0,1);l=_Math.clamp(l,0,1);if(s===0){this.r=this.g=this.b=l;}else{var p=l<=0.5?l*(1+s):l+s-l*s;var q=2*l-p;this.r=hue2rgb(q,p,h+1/3);this.g=hue2rgb(q,p,h);this.b=hue2rgb(q,p,h-1/3);}return this;};}(),setStyle:function setStyle(style){function handleAlpha(string){if(string===undefined)return;if(parseFloat(string)<1){console.warn('THREE.Color: Alpha component of '+style+' will be ignored.');}}var m;if(m=/^((?:rgb|hsl)a?)\(\s*([^\)]*)\)/.exec(style)){// rgb / hsl
	var color;var name=m[1];var components=m[2];switch(name){case'rgb':case'rgba':if(color=/^(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(components)){// rgb(255,0,0) rgba(255,0,0,0.5)
	this.r=Math.min(255,parseInt(color[1],10))/255;this.g=Math.min(255,parseInt(color[2],10))/255;this.b=Math.min(255,parseInt(color[3],10))/255;handleAlpha(color[5]);return this;}if(color=/^(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(components)){// rgb(100%,0%,0%) rgba(100%,0%,0%,0.5)
	this.r=Math.min(100,parseInt(color[1],10))/100;this.g=Math.min(100,parseInt(color[2],10))/100;this.b=Math.min(100,parseInt(color[3],10))/100;handleAlpha(color[5]);return this;}break;case'hsl':case'hsla':if(color=/^([0-9]*\.?[0-9]+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(components)){// hsl(120,50%,50%) hsla(120,50%,50%,0.5)
	var h=parseFloat(color[1])/360;var s=parseInt(color[2],10)/100;var l=parseInt(color[3],10)/100;handleAlpha(color[5]);return this.setHSL(h,s,l);}break;}}else if(m=/^\#([A-Fa-f0-9]+)$/.exec(style)){// hex color
	var hex=m[1];var size=hex.length;if(size===3){// #ff0
	this.r=parseInt(hex.charAt(0)+hex.charAt(0),16)/255;this.g=parseInt(hex.charAt(1)+hex.charAt(1),16)/255;this.b=parseInt(hex.charAt(2)+hex.charAt(2),16)/255;return this;}else if(size===6){// #ff0000
	this.r=parseInt(hex.charAt(0)+hex.charAt(1),16)/255;this.g=parseInt(hex.charAt(2)+hex.charAt(3),16)/255;this.b=parseInt(hex.charAt(4)+hex.charAt(5),16)/255;return this;}}if(style&&style.length>0){// color keywords
	var hex=ColorKeywords[style];if(hex!==undefined){// red
	this.setHex(hex);}else{// unknown color
	console.warn('THREE.Color: Unknown color '+style);}}return this;},clone:function clone(){return new this.constructor(this.r,this.g,this.b);},copy:function copy(color){this.r=color.r;this.g=color.g;this.b=color.b;return this;},copyGammaToLinear:function copyGammaToLinear(color,gammaFactor){if(gammaFactor===undefined)gammaFactor=2.0;this.r=Math.pow(color.r,gammaFactor);this.g=Math.pow(color.g,gammaFactor);this.b=Math.pow(color.b,gammaFactor);return this;},copyLinearToGamma:function copyLinearToGamma(color,gammaFactor){if(gammaFactor===undefined)gammaFactor=2.0;var safeInverse=gammaFactor>0?1.0/gammaFactor:1.0;this.r=Math.pow(color.r,safeInverse);this.g=Math.pow(color.g,safeInverse);this.b=Math.pow(color.b,safeInverse);return this;},convertGammaToLinear:function convertGammaToLinear(){var r=this.r,g=this.g,b=this.b;this.r=r*r;this.g=g*g;this.b=b*b;return this;},convertLinearToGamma:function convertLinearToGamma(){this.r=Math.sqrt(this.r);this.g=Math.sqrt(this.g);this.b=Math.sqrt(this.b);return this;},getHex:function getHex(){return this.r*255<<16^this.g*255<<8^this.b*255<<0;},getHexString:function getHexString(){return('000000'+this.getHex().toString(16)).slice(-6);},getHSL:function getHSL(optionalTarget){// h,s,l ranges are in 0.0 - 1.0
	var hsl=optionalTarget||{h:0,s:0,l:0};var r=this.r,g=this.g,b=this.b;var max=Math.max(r,g,b);var min=Math.min(r,g,b);var hue,saturation;var lightness=(min+max)/2.0;if(min===max){hue=0;saturation=0;}else{var delta=max-min;saturation=lightness<=0.5?delta/(max+min):delta/(2-max-min);switch(max){case r:hue=(g-b)/delta+(g<b?6:0);break;case g:hue=(b-r)/delta+2;break;case b:hue=(r-g)/delta+4;break;}hue/=6;}hsl.h=hue;hsl.s=saturation;hsl.l=lightness;return hsl;},getStyle:function getStyle(){return'rgb('+(this.r*255|0)+','+(this.g*255|0)+','+(this.b*255|0)+')';},offsetHSL:function offsetHSL(h,s,l){var hsl=this.getHSL();hsl.h+=h;hsl.s+=s;hsl.l+=l;this.setHSL(hsl.h,hsl.s,hsl.l);return this;},add:function add(color){this.r+=color.r;this.g+=color.g;this.b+=color.b;return this;},addColors:function addColors(color1,color2){this.r=color1.r+color2.r;this.g=color1.g+color2.g;this.b=color1.b+color2.b;return this;},addScalar:function addScalar(s){this.r+=s;this.g+=s;this.b+=s;return this;},sub:function sub(color){this.r=Math.max(0,this.r-color.r);this.g=Math.max(0,this.g-color.g);this.b=Math.max(0,this.b-color.b);return this;},multiply:function multiply(color){this.r*=color.r;this.g*=color.g;this.b*=color.b;return this;},multiplyScalar:function multiplyScalar(s){this.r*=s;this.g*=s;this.b*=s;return this;},lerp:function lerp(color,alpha){this.r+=(color.r-this.r)*alpha;this.g+=(color.g-this.g)*alpha;this.b+=(color.b-this.b)*alpha;return this;},equals:function equals(c){return c.r===this.r&&c.g===this.g&&c.b===this.b;},fromArray:function fromArray(array,offset){if(offset===undefined)offset=0;this.r=array[offset];this.g=array[offset+1];this.b=array[offset+2];return this;},toArray:function toArray(array,offset){if(array===undefined)array=[];if(offset===undefined)offset=0;array[offset]=this.r;array[offset+1]=this.g;array[offset+2]=this.b;return array;},toJSON:function toJSON(){return this.getHex();}});/**
		 * Uniforms library for shared webgl shaders
		 */var UniformsLib={common:{diffuse:{value:new Color(0xeeeeee)},opacity:{value:1.0},map:{value:null},offsetRepeat:{value:new Vector4(0,0,1,1)},specularMap:{value:null},alphaMap:{value:null},envMap:{value:null},flipEnvMap:{value:-1},reflectivity:{value:1.0},refractionRatio:{value:0.98}},aomap:{aoMap:{value:null},aoMapIntensity:{value:1}},lightmap:{lightMap:{value:null},lightMapIntensity:{value:1}},emissivemap:{emissiveMap:{value:null}},bumpmap:{bumpMap:{value:null},bumpScale:{value:1}},normalmap:{normalMap:{value:null},normalScale:{value:new Vector2(1,1)}},displacementmap:{displacementMap:{value:null},displacementScale:{value:1},displacementBias:{value:0}},roughnessmap:{roughnessMap:{value:null}},metalnessmap:{metalnessMap:{value:null}},gradientmap:{gradientMap:{value:null}},fog:{fogDensity:{value:0.00025},fogNear:{value:1},fogFar:{value:2000},fogColor:{value:new Color(0xffffff)}},lights:{ambientLightColor:{value:[]},directionalLights:{value:[],properties:{direction:{},color:{},shadow:{},shadowBias:{},shadowRadius:{},shadowMapSize:{}}},directionalShadowMap:{value:[]},directionalShadowMatrix:{value:[]},spotLights:{value:[],properties:{color:{},position:{},direction:{},distance:{},coneCos:{},penumbraCos:{},decay:{},shadow:{},shadowBias:{},shadowRadius:{},shadowMapSize:{}}},spotShadowMap:{value:[]},spotShadowMatrix:{value:[]},pointLights:{value:[],properties:{color:{},position:{},decay:{},distance:{},shadow:{},shadowBias:{},shadowRadius:{},shadowMapSize:{}}},pointShadowMap:{value:[]},pointShadowMatrix:{value:[]},hemisphereLights:{value:[],properties:{direction:{},skyColor:{},groundColor:{}}},// TODO (abelnation): RectAreaLight BRDF data needs to be moved from example to main src
	rectAreaLights:{value:[],properties:{color:{},position:{},width:{},height:{}}}},points:{diffuse:{value:new Color(0xeeeeee)},opacity:{value:1.0},size:{value:1.0},scale:{value:1.0},map:{value:null},offsetRepeat:{value:new Vector4(0,0,1,1)}}};/**
		 * Uniform Utilities
		 */var UniformsUtils={merge:function merge(uniforms){var merged={};for(var u=0;u<uniforms.length;u++){var tmp=this.clone(uniforms[u]);for(var p in tmp){merged[p]=tmp[p];}}return merged;},clone:function clone(uniforms_src){var uniforms_dst={};for(var u in uniforms_src){uniforms_dst[u]={};for(var p in uniforms_src[u]){var parameter_src=uniforms_src[u][p];if(parameter_src&&(parameter_src.isColor||parameter_src.isMatrix3||parameter_src.isMatrix4||parameter_src.isVector2||parameter_src.isVector3||parameter_src.isVector4||parameter_src.isTexture)){uniforms_dst[u][p]=parameter_src.clone();}else if(Array.isArray(parameter_src)){uniforms_dst[u][p]=parameter_src.slice();}else{uniforms_dst[u][p]=parameter_src;}}}return uniforms_dst;}};var alphamap_fragment="#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif\n";var alphamap_pars_fragment="#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif\n";var alphatest_fragment="#ifdef ALPHATEST\n\tif ( diffuseColor.a < ALPHATEST ) discard;\n#endif\n";var aomap_fragment="#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( PHYSICAL )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\n\t#endif\n#endif\n";var aomap_pars_fragment="#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif";var begin_vertex="\nvec3 transformed = vec3( position );\n";var beginnormal_vertex="\nvec3 objectNormal = vec3( normal );\n";var bsdfs="float punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n\t\tif( decayExponent > 0.0 ) {\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\t\t\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\t\t\tfloat maxDistanceCutoffFactor = pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t\t\treturn distanceFalloff * maxDistanceCutoffFactor;\n#else\n\t\t\treturn pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\n#endif\n\t\t}\n\t\treturn 1.0;\n}\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\n\treturn ( 1.0 - specularColor ) * fresnel + specularColor;\n}\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\tfloat gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\treturn 1.0 / ( gl * gv );\n}\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNL = saturate( dot( geometry.normal, incidentLight.direction ) );\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( G * D );\n}\nvec2 ltcTextureCoords( const in GeometricContext geometry, const in float roughness ) {\n\tconst float LUT_SIZE  = 64.0;\n\tconst float LUT_SCALE = (LUT_SIZE - 1.0)/LUT_SIZE;\n\tconst float LUT_BIAS  = 0.5/LUT_SIZE;\n\tvec3 N = geometry.normal;\n\tvec3 V = geometry.viewDir;\n\tvec3 P = geometry.position;\n\tfloat theta = acos( dot( N, V ) );\n\tvec2 uv = vec2(\n\t\tsqrt( saturate( roughness ) ),\n\t\tsaturate( theta / ( 0.5 * PI ) ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nvoid clipQuadToHorizon( inout vec3 L[5], out int n ) {\n\tint config = 0;\n\tif ( L[0].z > 0.0 ) config += 1;\n\tif ( L[1].z > 0.0 ) config += 2;\n\tif ( L[2].z > 0.0 ) config += 4;\n\tif ( L[3].z > 0.0 ) config += 8;\n\tn = 0;\n\tif ( config == 0 ) {\n\t} else if ( config == 1 ) {\n\t\tn = 3;\n\t\tL[1] = -L[1].z * L[0] + L[0].z * L[1];\n\t\tL[2] = -L[3].z * L[0] + L[0].z * L[3];\n\t} else if ( config == 2 ) {\n\t\tn = 3;\n\t\tL[0] = -L[0].z * L[1] + L[1].z * L[0];\n\t\tL[2] = -L[2].z * L[1] + L[1].z * L[2];\n\t} else if ( config == 3 ) {\n\t\tn = 4;\n\t\tL[2] = -L[2].z * L[1] + L[1].z * L[2];\n\t\tL[3] = -L[3].z * L[0] + L[0].z * L[3];\n\t} else if ( config == 4 ) {\n\t\tn = 3;\n\t\tL[0] = -L[3].z * L[2] + L[2].z * L[3];\n\t\tL[1] = -L[1].z * L[2] + L[2].z * L[1];\n\t} else if ( config == 5 ) {\n\t\tn = 0;\n\t} else if ( config == 6 ) {\n\t\tn = 4;\n\t\tL[0] = -L[0].z * L[1] + L[1].z * L[0];\n\t\tL[3] = -L[3].z * L[2] + L[2].z * L[3];\n\t} else if ( config == 7 ) {\n\t\tn = 5;\n\t\tL[4] = -L[3].z * L[0] + L[0].z * L[3];\n\t\tL[3] = -L[3].z * L[2] + L[2].z * L[3];\n\t} else if ( config == 8 ) {\n\t\tn = 3;\n\t\tL[0] = -L[0].z * L[3] + L[3].z * L[0];\n\t\tL[1] = -L[2].z * L[3] + L[3].z * L[2];\n\t\tL[2] =  L[3];\n\t} else if ( config == 9 ) {\n\t\tn = 4;\n\t\tL[1] = -L[1].z * L[0] + L[0].z * L[1];\n\t\tL[2] = -L[2].z * L[3] + L[3].z * L[2];\n\t} else if ( config == 10 ) {\n\t\tn = 0;\n\t} else if ( config == 11 ) {\n\t\tn = 5;\n\t\tL[4] = L[3];\n\t\tL[3] = -L[2].z * L[3] + L[3].z * L[2];\n\t\tL[2] = -L[2].z * L[1] + L[1].z * L[2];\n\t} else if ( config == 12 ) {\n\t\tn = 4;\n\t\tL[1] = -L[1].z * L[2] + L[2].z * L[1];\n\t\tL[0] = -L[0].z * L[3] + L[3].z * L[0];\n\t} else if ( config == 13 ) {\n\t\tn = 5;\n\t\tL[4] = L[3];\n\t\tL[3] = L[2];\n\t\tL[2] = -L[1].z * L[2] + L[2].z * L[1];\n\t\tL[1] = -L[1].z * L[0] + L[0].z * L[1];\n\t} else if ( config == 14 ) {\n\t\tn = 5;\n\t\tL[4] = -L[0].z * L[3] + L[3].z * L[0];\n\t\tL[0] = -L[0].z * L[1] + L[1].z * L[0];\n\t} else if ( config == 15 ) {\n\t\tn = 4;\n\t}\n\tif ( n == 3 )\n\t\tL[3] = L[0];\n\tif ( n == 4 )\n\t\tL[4] = L[0];\n}\nfloat integrateLtcBrdfOverRectEdge( vec3 v1, vec3 v2 ) {\n\tfloat cosTheta = dot( v1, v2 );\n\tfloat theta = acos( cosTheta );\n\tfloat res = cross( v1, v2 ).z * ( ( theta > 0.001 ) ? theta / sin( theta ) : 1.0 );\n\treturn res;\n}\nvoid initRectPoints( const in vec3 pos, const in vec3 halfWidth, const in vec3 halfHeight, out vec3 rectPoints[4] ) {\n\trectPoints[0] = pos - halfWidth - halfHeight;\n\trectPoints[1] = pos + halfWidth - halfHeight;\n\trectPoints[2] = pos + halfWidth + halfHeight;\n\trectPoints[3] = pos - halfWidth + halfHeight;\n}\nvec3 integrateLtcBrdfOverRect( const in GeometricContext geometry, const in mat3 brdfMat, const in vec3 rectPoints[4] ) {\n\tvec3 N = geometry.normal;\n\tvec3 V = geometry.viewDir;\n\tvec3 P = geometry.position;\n\tvec3 T1, T2;\n\tT1 = normalize(V - N * dot( V, N ));\n\tT2 = - cross( N, T1 );\n\tmat3 brdfWrtSurface = brdfMat * transpose( mat3( T1, T2, N ) );\n\tvec3 clippedRect[5];\n\tclippedRect[0] = brdfWrtSurface * ( rectPoints[0] - P );\n\tclippedRect[1] = brdfWrtSurface * ( rectPoints[1] - P );\n\tclippedRect[2] = brdfWrtSurface * ( rectPoints[2] - P );\n\tclippedRect[3] = brdfWrtSurface * ( rectPoints[3] - P );\n\tint n;\n\tclipQuadToHorizon(clippedRect, n);\n\tif ( n == 0 )\n\t\treturn vec3( 0, 0, 0 );\n\tclippedRect[0] = normalize( clippedRect[0] );\n\tclippedRect[1] = normalize( clippedRect[1] );\n\tclippedRect[2] = normalize( clippedRect[2] );\n\tclippedRect[3] = normalize( clippedRect[3] );\n\tclippedRect[4] = normalize( clippedRect[4] );\n\tfloat sum = 0.0;\n\tsum += integrateLtcBrdfOverRectEdge( clippedRect[0], clippedRect[1] );\n\tsum += integrateLtcBrdfOverRectEdge( clippedRect[1], clippedRect[2] );\n\tsum += integrateLtcBrdfOverRectEdge( clippedRect[2], clippedRect[3] );\n\tif (n >= 4)\n\t\tsum += integrateLtcBrdfOverRectEdge( clippedRect[3], clippedRect[4] );\n\tif (n == 5)\n\t\tsum += integrateLtcBrdfOverRectEdge( clippedRect[4], clippedRect[0] );\n\tsum = max( 0.0, sum );\n\tvec3 Lo_i = vec3( sum, sum, sum );\n\treturn Lo_i;\n}\nvec3 Rect_Area_Light_Specular_Reflectance(\n\t\tconst in GeometricContext geometry,\n\t\tconst in vec3 lightPos, const in vec3 lightHalfWidth, const in vec3 lightHalfHeight,\n\t\tconst in float roughness,\n\t\tconst in sampler2D ltcMat, const in sampler2D ltcMag ) {\n\tvec3 rectPoints[4];\n\tinitRectPoints( lightPos, lightHalfWidth, lightHalfHeight, rectPoints );\n\tvec2 uv = ltcTextureCoords( geometry, roughness );\n\tvec4 brdfLtcApproxParams, t;\n\tbrdfLtcApproxParams = texture2D( ltcMat, uv );\n\tt = texture2D( ltcMat, uv );\n\tfloat brdfLtcScalar = texture2D( ltcMag, uv ).a;\n\tmat3 brdfLtcApproxMat = mat3(\n\t\tvec3(   1,   0, t.y ),\n\t\tvec3(   0, t.z,   0 ),\n\t\tvec3( t.w,   0, t.x )\n\t);\n\tvec3 specularReflectance = integrateLtcBrdfOverRect( geometry, brdfLtcApproxMat, rectPoints );\n\tspecularReflectance *= brdfLtcScalar;\n\treturn specularReflectance;\n}\nvec3 Rect_Area_Light_Diffuse_Reflectance(\n\t\tconst in GeometricContext geometry,\n\t\tconst in vec3 lightPos, const in vec3 lightHalfWidth, const in vec3 lightHalfHeight ) {\n\tvec3 rectPoints[4];\n\tinitRectPoints( lightPos, lightHalfWidth, lightHalfHeight, rectPoints );\n\tmat3 diffuseBrdfMat = mat3(1);\n\tvec3 diffuseReflectance = integrateLtcBrdfOverRect( geometry, diffuseBrdfMat, rectPoints );\n\treturn diffuseReflectance;\n}\nvec3 BRDF_Specular_GGX_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\tvec2 AB = vec2( -1.04, 1.04 ) * a004 + r.zw;\n\treturn specularColor * AB.x + AB.y;\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\n\treturn ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\n}\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\n\treturn sqrt( 2.0 / ( blinnExponent + 2.0 ) );\n}\n";var bumpmap_pars_fragment="#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\n\t\tvec3 vSigmaX = dFdx( surf_pos );\n\t\tvec3 vSigmaY = dFdy( surf_pos );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 );\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif\n";var clipping_planes_fragment="#if NUM_CLIPPING_PLANES > 0\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; ++ i ) {\n\t\tvec4 plane = clippingPlanes[ i ];\n\t\tif ( dot( vViewPosition, plane.xyz ) > plane.w ) discard;\n\t}\n\t\t\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\tbool clipped = true;\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; ++ i ) {\n\t\t\tvec4 plane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vViewPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t}\n\t\tif ( clipped ) discard;\n\t\n\t#endif\n#endif\n";var clipping_planes_pars_fragment="#if NUM_CLIPPING_PLANES > 0\n\t#if ! defined( PHYSICAL ) && ! defined( PHONG )\n\t\tvarying vec3 vViewPosition;\n\t#endif\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif\n";var clipping_planes_pars_vertex="#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG )\n\tvarying vec3 vViewPosition;\n#endif\n";var clipping_planes_vertex="#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n";var color_fragment="#ifdef USE_COLOR\n\tdiffuseColor.rgb *= vColor;\n#endif";var color_pars_fragment="#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif\n";var color_pars_vertex="#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif";var color_vertex="#ifdef USE_COLOR\n\tvColor.xyz = color.xyz;\n#endif";var common="#define PI 3.14159265359\n#define PI2 6.28318530718\n#define PI_HALF 1.5707963267949\n#define RECIPROCAL_PI 0.31830988618\n#define RECIPROCAL_PI2 0.15915494\n#define LOG2 1.442695\n#define EPSILON 1e-6\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#define whiteCompliment(a) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract(sin(sn) * c);\n}\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\tfloat distance = dot( planeNormal, point - pointOnPlane );\n\treturn - distance * planeNormal + point;\n}\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn sign( dot( point - pointOnPlane, planeNormal ) );\n}\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\n}\nmat3 transpose( const in mat3 v ) {\n\tmat3 tmp;\n\ttmp[0] = vec3(v[0].x, v[1].x, v[2].x);\n\ttmp[1] = vec3(v[0].y, v[1].y, v[2].y);\n\ttmp[2] = vec3(v[0].z, v[1].z, v[2].z);\n\treturn tmp;\n}\n";var cube_uv_reflection_fragment="#ifdef ENVMAP_TYPE_CUBE_UV\n#define cubeUV_textureSize (1024.0)\nint getFaceFromDirection(vec3 direction) {\n\tvec3 absDirection = abs(direction);\n\tint face = -1;\n\tif( absDirection.x > absDirection.z ) {\n\t\tif(absDirection.x > absDirection.y )\n\t\t\tface = direction.x > 0.0 ? 0 : 3;\n\t\telse\n\t\t\tface = direction.y > 0.0 ? 1 : 4;\n\t}\n\telse {\n\t\tif(absDirection.z > absDirection.y )\n\t\t\tface = direction.z > 0.0 ? 2 : 5;\n\t\telse\n\t\t\tface = direction.y > 0.0 ? 1 : 4;\n\t}\n\treturn face;\n}\n#define cubeUV_maxLods1  (log2(cubeUV_textureSize*0.25) - 1.0)\n#define cubeUV_rangeClamp (exp2((6.0 - 1.0) * 2.0))\nvec2 MipLevelInfo( vec3 vec, float roughnessLevel, float roughness ) {\n\tfloat scale = exp2(cubeUV_maxLods1 - roughnessLevel);\n\tfloat dxRoughness = dFdx(roughness);\n\tfloat dyRoughness = dFdy(roughness);\n\tvec3 dx = dFdx( vec * scale * dxRoughness );\n\tvec3 dy = dFdy( vec * scale * dyRoughness );\n\tfloat d = max( dot( dx, dx ), dot( dy, dy ) );\n\td = clamp(d, 1.0, cubeUV_rangeClamp);\n\tfloat mipLevel = 0.5 * log2(d);\n\treturn vec2(floor(mipLevel), fract(mipLevel));\n}\n#define cubeUV_maxLods2 (log2(cubeUV_textureSize*0.25) - 2.0)\n#define cubeUV_rcpTextureSize (1.0 / cubeUV_textureSize)\nvec2 getCubeUV(vec3 direction, float roughnessLevel, float mipLevel) {\n\tmipLevel = roughnessLevel > cubeUV_maxLods2 - 3.0 ? 0.0 : mipLevel;\n\tfloat a = 16.0 * cubeUV_rcpTextureSize;\n\tvec2 exp2_packed = exp2( vec2( roughnessLevel, mipLevel ) );\n\tvec2 rcp_exp2_packed = vec2( 1.0 ) / exp2_packed;\n\tfloat powScale = exp2_packed.x * exp2_packed.y;\n\tfloat scale = rcp_exp2_packed.x * rcp_exp2_packed.y * 0.25;\n\tfloat mipOffset = 0.75*(1.0 - rcp_exp2_packed.y) * rcp_exp2_packed.x;\n\tbool bRes = mipLevel == 0.0;\n\tscale =  bRes && (scale < a) ? a : scale;\n\tvec3 r;\n\tvec2 offset;\n\tint face = getFaceFromDirection(direction);\n\tfloat rcpPowScale = 1.0 / powScale;\n\tif( face == 0) {\n\t\tr = vec3(direction.x, -direction.z, direction.y);\n\t\toffset = vec2(0.0+mipOffset,0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 1) {\n\t\tr = vec3(direction.y, direction.x, direction.z);\n\t\toffset = vec2(scale+mipOffset, 0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 2) {\n\t\tr = vec3(direction.z, direction.x, direction.y);\n\t\toffset = vec2(2.0*scale+mipOffset, 0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 3) {\n\t\tr = vec3(direction.x, direction.z, direction.y);\n\t\toffset = vec2(0.0+mipOffset,0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\telse if( face == 4) {\n\t\tr = vec3(direction.y, direction.x, -direction.z);\n\t\toffset = vec2(scale+mipOffset, 0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\telse {\n\t\tr = vec3(direction.z, -direction.x, direction.y);\n\t\toffset = vec2(2.0*scale+mipOffset, 0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\tr = normalize(r);\n\tfloat texelOffset = 0.5 * cubeUV_rcpTextureSize;\n\tvec2 s = ( r.yz / abs( r.x ) + vec2( 1.0 ) ) * 0.5;\n\tvec2 base = offset + vec2( texelOffset );\n\treturn base + s * ( scale - 2.0 * texelOffset );\n}\n#define cubeUV_maxLods3 (log2(cubeUV_textureSize*0.25) - 3.0)\nvec4 textureCubeUV(vec3 reflectedDirection, float roughness ) {\n\tfloat roughnessVal = roughness* cubeUV_maxLods3;\n\tfloat r1 = floor(roughnessVal);\n\tfloat r2 = r1 + 1.0;\n\tfloat t = fract(roughnessVal);\n\tvec2 mipInfo = MipLevelInfo(reflectedDirection, r1, roughness);\n\tfloat s = mipInfo.y;\n\tfloat level0 = mipInfo.x;\n\tfloat level1 = level0 + 1.0;\n\tlevel1 = level1 > 5.0 ? 5.0 : level1;\n\tlevel0 += min( floor( s + 0.5 ), 5.0 );\n\tvec2 uv_10 = getCubeUV(reflectedDirection, r1, level0);\n\tvec4 color10 = envMapTexelToLinear(texture2D(envMap, uv_10));\n\tvec2 uv_20 = getCubeUV(reflectedDirection, r2, level0);\n\tvec4 color20 = envMapTexelToLinear(texture2D(envMap, uv_20));\n\tvec4 result = mix(color10, color20, t);\n\treturn vec4(result.rgb, 1.0);\n}\n#endif\n";var defaultnormal_vertex="#ifdef FLIP_SIDED\n\tobjectNormal = -objectNormal;\n#endif\nvec3 transformedNormal = normalMatrix * objectNormal;\n";var displacementmap_pars_vertex="#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif\n";var displacementmap_vertex="#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normal * ( texture2D( displacementMap, uv ).x * displacementScale + displacementBias );\n#endif\n";var emissivemap_fragment="#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\temissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif\n";var emissivemap_pars_fragment="#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif\n";var encodings_fragment="  gl_FragColor = linearToOutputTexel( gl_FragColor );\n";var encodings_pars_fragment="\nvec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.xyz, vec3( gammaFactor ) ), value.w );\n}\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.xyz, vec3( 1.0 / gammaFactor ) ), value.w );\n}\nvec4 sRGBToLinear( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.w );\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.w );\n}\nvec4 RGBEToLinear( in vec4 value ) {\n\treturn vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\nvec4 LinearToRGBE( in vec4 value ) {\n\tfloat maxComponent = max( max( value.r, value.g ), value.b );\n\tfloat fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n\treturn vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n}\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.xyz * value.w * maxRange, 1.0 );\n}\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.x, max( value.g, value.b ) );\n\tfloat M      = clamp( maxRGB / maxRange, 0.0, 1.0 );\n\tM            = ceil( M * 255.0 ) / 255.0;\n\treturn vec4( value.rgb / ( M * maxRange ), M );\n}\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.x, max( value.g, value.b ) );\n\tfloat D      = max( maxRange / maxRGB, 1.0 );\n\tD            = min( floor( D ) / 255.0, 1.0 );\n\treturn vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\nvec4 LinearToLogLuv( in vec4 value )  {\n\tvec3 Xp_Y_XYZp = value.rgb * cLogLuvM;\n\tXp_Y_XYZp = max(Xp_Y_XYZp, vec3(1e-6, 1e-6, 1e-6));\n\tvec4 vResult;\n\tvResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\n\tfloat Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\n\tvResult.w = fract(Le);\n\tvResult.z = (Le - (floor(vResult.w*255.0))/255.0)/255.0;\n\treturn vResult;\n}\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\nvec4 LogLuvToLinear( in vec4 value ) {\n\tfloat Le = value.z * 255.0 + value.w;\n\tvec3 Xp_Y_XYZp;\n\tXp_Y_XYZp.y = exp2((Le - 127.0) / 2.0);\n\tXp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\n\tXp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\n\tvec3 vRGB = Xp_Y_XYZp.rgb * cLogLuvInverseM;\n\treturn vec4( max(vRGB, 0.0), 1.0 );\n}\n";var envmap_fragment="#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, flipNormal * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\tvec2 sampleUV;\n\t\tsampleUV.y = saturate( flipNormal * reflectVec.y * 0.5 + 0.5 );\n\t\tsampleUV.x = atan( flipNormal * reflectVec.z, flipNormal * reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\t\tvec4 envColor = texture2D( envMap, sampleUV );\n\t#elif defined( ENVMAP_TYPE_SPHERE )\n\t\tvec3 reflectView = flipNormal * normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0, 0.0, 1.0 ) );\n\t\tvec4 envColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5 );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\tenvColor = envMapTexelToLinear( envColor );\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif\n";var envmap_pars_fragment="#if defined( USE_ENVMAP ) || defined( PHYSICAL )\n\tuniform float reflectivity;\n\tuniform float envMapIntensity;\n#endif\n#ifdef USE_ENVMAP\n\t#if ! defined( PHYSICAL ) && ( defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) )\n\t\tvarying vec3 vWorldPosition;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\tuniform float flipEnvMap;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( PHYSICAL )\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif\n";var envmap_pars_vertex="#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif\n";var envmap_vertex="#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif\n";var fog_vertex="\n#ifdef USE_FOG\nfogDepth = -mvPosition.z;\n#endif";var fog_pars_vertex="#ifdef USE_FOG\n  varying float fogDepth;\n#endif\n";var fog_fragment="#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = whiteCompliment( exp2( - fogDensity * fogDensity * fogDepth * fogDepth * LOG2 ) );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, fogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif\n";var fog_pars_fragment="#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float fogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif\n";var gradientmap_pars_fragment="#ifdef TOON\n\tuniform sampler2D gradientMap;\n\tvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\t\tfloat dotNL = dot( normal, lightDirection );\n\t\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t\t#ifdef USE_GRADIENTMAP\n\t\t\treturn texture2D( gradientMap, coord ).rgb;\n\t\t#else\n\t\t\treturn ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n\t\t#endif\n\t}\n#endif\n";var lightmap_fragment="#ifdef USE_LIGHTMAP\n\treflectedLight.indirectDiffuse += PI * texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n#endif\n";var lightmap_pars_fragment="#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif";var lights_lambert_vertex="vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n\tvLightBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\n#if NUM_POINT_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tgetPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tgetSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_DIR_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tgetDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\tvLightFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\n\t\t#endif\n\t}\n#endif\n";var lights_pars="uniform vec3 ambientLightColor;\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treturn irradiance;\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tdirectLight.color = directionalLight.color;\n\t\tdirectLight.direction = directionalLight.direction;\n\t\tdirectLight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tdirectLight.color = pointLight.color;\n\t\tdirectLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\n\t\tdirectLight.visible = ( directLight.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight  ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tfloat angleCos = dot( directLight.direction, spotLight.direction );\n\t\tif ( angleCos > spotLight.coneCos ) {\n\t\t\tfloat spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\t\tdirectLight.color = spotLight.color;\n\t\t\tdirectLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tdirectLight.visible = true;\n\t\t} else {\n\t\t\tdirectLight.color = vec3( 0.0 );\n\t\t\tdirectLight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltcMat;\tuniform sampler2D ltcMag;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\n\t\tfloat dotNL = dot( geometry.normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tirradiance *= PI;\n\t\t#endif\n\t\treturn irradiance;\n\t}\n#endif\n#if defined( USE_ENVMAP ) && defined( PHYSICAL )\n\tvec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\n\t\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\tvec4 envMapColor = textureCubeUV( queryVec, 1.0 );\n\t\t#else\n\t\t\tvec4 envMapColor = vec4( 0.0 );\n\t\t#endif\n\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t}\n\tfloat getSpecularMIPLevel( const in float blinnShininessExponent, const in int maxMIPLevel ) {\n\t\tfloat maxMIPLevelScalar = float( maxMIPLevel );\n\t\tfloat desiredMIPLevel = maxMIPLevelScalar - 0.79248 - 0.5 * log2( pow2( blinnShininessExponent ) + 1.0 );\n\t\treturn clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\n\t}\n\tvec3 getLightProbeIndirectRadiance( const in GeometricContext geometry, const in float blinnShininessExponent, const in int maxMIPLevel ) {\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( -geometry.viewDir, geometry.normal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( -geometry.viewDir, geometry.normal, refractionRatio );\n\t\t#endif\n\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\tfloat specularMIPLevel = getSpecularMIPLevel( blinnShininessExponent, maxMIPLevel );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\tvec4 envMapColor = textureCubeUV(queryReflectVec, BlinnExponentToGGXRoughness(blinnShininessExponent));\n\t\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\t\tvec2 sampleUV;\n\t\t\tsampleUV.y = saturate( reflectVec.y * 0.5 + 0.5 );\n\t\t\tsampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, sampleUV, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = texture2D( envMap, sampleUV, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_SPHERE )\n\t\t\tvec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0,0.0,1.0 ) );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#endif\n\t\treturn envMapColor.rgb * envMapIntensity;\n\t}\n#endif\n";var lights_phong_fragment="BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;\n";var lights_phong_pars_fragment="varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct BlinnPhongMaterial {\n\tvec3\tdiffuseColor;\n\tvec3\tspecularColor;\n\tfloat\tspecularShininess;\n\tfloat\tspecularStrength;\n};\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_BlinnPhong( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 matDiffColor = material.diffuseColor;\n\t\tvec3 matSpecColor = material.specularColor;\n\t\tvec3 lightColor   = rectAreaLight.color;\n\t\tfloat roughness = BlinnExponentToGGXRoughness( material.specularShininess );\n\t\tvec3 spec = Rect_Area_Light_Specular_Reflectance(\n\t\t\t\tgeometry,\n\t\t\t\trectAreaLight.position, rectAreaLight.halfWidth, rectAreaLight.halfHeight,\n\t\t\t\troughness,\n\t\t\t\tltcMat, ltcMag );\n\t\tvec3 diff = Rect_Area_Light_Diffuse_Reflectance(\n\t\t\t\tgeometry,\n\t\t\t\trectAreaLight.position, rectAreaLight.halfWidth, rectAreaLight.halfHeight );\n\t\treflectedLight.directSpecular += lightColor * matSpecColor * spec / PI2;\n\t\treflectedLight.directDiffuse  += lightColor * matDiffColor * diff / PI2;\n\t}\n#endif\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\t#ifdef TOON\n\t\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\t#else\n\t\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\t\tvec3 irradiance = dotNL * directLight.color;\n\t#endif\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )\t(0)\n";var lights_physical_fragment="PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nmaterial.specularRoughness = clamp( roughnessFactor, 0.04, 1.0 );\n#ifdef STANDARD\n\tmaterial.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );\n\tmaterial.clearCoat = saturate( clearCoat );\tmaterial.clearCoatRoughness = clamp( clearCoatRoughness, 0.04, 1.0 );\n#endif\n";var lights_physical_pars_fragment="struct PhysicalMaterial {\n\tvec3\tdiffuseColor;\n\tfloat\tspecularRoughness;\n\tvec3\tspecularColor;\n\t#ifndef STANDARD\n\t\tfloat clearCoat;\n\t\tfloat clearCoatRoughness;\n\t#endif\n};\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\nfloat clearCoatDHRApprox( const in float roughness, const in float dotNL ) {\n\treturn DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 matDiffColor = material.diffuseColor;\n\t\tvec3 matSpecColor = material.specularColor;\n\t\tvec3 lightColor   = rectAreaLight.color;\n\t\tfloat roughness = material.specularRoughness;\n\t\tvec3 spec = Rect_Area_Light_Specular_Reflectance(\n\t\t\t\tgeometry,\n\t\t\t\trectAreaLight.position, rectAreaLight.halfWidth, rectAreaLight.halfHeight,\n\t\t\t\troughness,\n\t\t\t\tltcMat, ltcMag );\n\t\tvec3 diff = Rect_Area_Light_Diffuse_Reflectance(\n\t\t\t\tgeometry,\n\t\t\t\trectAreaLight.position, rectAreaLight.halfWidth, rectAreaLight.halfHeight );\n\t\treflectedLight.directSpecular += lightColor * matSpecColor * spec;\n\t\treflectedLight.directDiffuse  += lightColor * matDiffColor * diff;\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\t#ifndef STANDARD\n\t\tfloat clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\n\t#else\n\t\tfloat clearCoatDHR = 0.0;\n\t#endif\n\treflectedLight.directSpecular += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry, material.specularColor, material.specularRoughness );\n\treflectedLight.directDiffuse += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\t#ifndef STANDARD\n\t\treflectedLight.directSpecular += irradiance * material.clearCoat * BRDF_Specular_GGX( directLight, geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\n\t#endif\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 clearCoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t#ifndef STANDARD\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\tfloat dotNL = dotNV;\n\t\tfloat clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\n\t#else\n\t\tfloat clearCoatDHR = 0.0;\n\t#endif\n\treflectedLight.indirectSpecular += ( 1.0 - clearCoatDHR ) * radiance * BRDF_Specular_GGX_Environment( geometry, material.specularColor, material.specularRoughness );\n\t#ifndef STANDARD\n\t\treflectedLight.indirectSpecular += clearCoatRadiance * material.clearCoat * BRDF_Specular_GGX_Environment( geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\n\t#endif\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\n#define Material_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.specularRoughness )\n#define Material_ClearCoat_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.clearCoatRoughness )\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}\n";var lights_template="\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = normalize( vViewPosition );\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointDirectLightIrradiance( pointLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( pointLight.shadow, directLight.visible ) ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotDirectLightIrradiance( spotLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( spotLight.shadow, directLight.visible ) ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( directionalLight.shadow, directLight.visible ) ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\t#ifdef USE_LIGHTMAP\n\t\tvec3 lightMapIrradiance = texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tlightMapIrradiance *= PI;\n\t\t#endif\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t}\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( PHYSICAL ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tirradiance += getLightProbeIndirectIrradiance( geometry, 8 );\n\t#endif\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\tvec3 radiance = getLightProbeIndirectRadiance( geometry, Material_BlinnShininessExponent( material ), 8 );\n\t#ifndef STANDARD\n\t\tvec3 clearCoatRadiance = getLightProbeIndirectRadiance( geometry, Material_ClearCoat_BlinnShininessExponent( material ), 8 );\n\t#else\n\t\tvec3 clearCoatRadiance = vec3( 0.0 );\n\t#endif\n\tRE_IndirectSpecular( radiance, clearCoatRadiance, geometry, material, reflectedLight );\n#endif\n";var logdepthbuf_fragment="#if defined(USE_LOGDEPTHBUF) && defined(USE_LOGDEPTHBUF_EXT)\n\tgl_FragDepthEXT = log2(vFragDepth) * logDepthBufFC * 0.5;\n#endif";var logdepthbuf_pars_fragment="#ifdef USE_LOGDEPTHBUF\n\tuniform float logDepthBufFC;\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t#endif\n#endif\n";var logdepthbuf_pars_vertex="#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t#endif\n\tuniform float logDepthBufFC;\n#endif";var logdepthbuf_vertex="#ifdef USE_LOGDEPTHBUF\n\tgl_Position.z = log2(max( EPSILON, gl_Position.w + 1.0 )) * logDepthBufFC;\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t#else\n\t\tgl_Position.z = (gl_Position.z - 1.0) * gl_Position.w;\n\t#endif\n#endif\n";var map_fragment="#ifdef USE_MAP\n\tvec4 texelColor = texture2D( map, vUv );\n\ttexelColor = mapTexelToLinear( texelColor );\n\tdiffuseColor *= texelColor;\n#endif\n";var map_pars_fragment="#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n";var map_particle_fragment="#ifdef USE_MAP\n\tvec4 mapTexel = texture2D( map, vec2( gl_PointCoord.x, 1.0 - gl_PointCoord.y ) * offsetRepeat.zw + offsetRepeat.xy );\n\tdiffuseColor *= mapTexelToLinear( mapTexel );\n#endif\n";var map_particle_pars_fragment="#ifdef USE_MAP\n\tuniform vec4 offsetRepeat;\n\tuniform sampler2D map;\n#endif\n";var metalnessmap_fragment="float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif\n";var metalnessmap_pars_fragment="#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif";var morphnormal_vertex="#ifdef USE_MORPHNORMALS\n\tobjectNormal += ( morphNormal0 - normal ) * morphTargetInfluences[ 0 ];\n\tobjectNormal += ( morphNormal1 - normal ) * morphTargetInfluences[ 1 ];\n\tobjectNormal += ( morphNormal2 - normal ) * morphTargetInfluences[ 2 ];\n\tobjectNormal += ( morphNormal3 - normal ) * morphTargetInfluences[ 3 ];\n#endif\n";var morphtarget_pars_vertex="#ifdef USE_MORPHTARGETS\n\t#ifndef USE_MORPHNORMALS\n\tuniform float morphTargetInfluences[ 8 ];\n\t#else\n\tuniform float morphTargetInfluences[ 4 ];\n\t#endif\n#endif";var morphtarget_vertex="#ifdef USE_MORPHTARGETS\n\ttransformed += ( morphTarget0 - position ) * morphTargetInfluences[ 0 ];\n\ttransformed += ( morphTarget1 - position ) * morphTargetInfluences[ 1 ];\n\ttransformed += ( morphTarget2 - position ) * morphTargetInfluences[ 2 ];\n\ttransformed += ( morphTarget3 - position ) * morphTargetInfluences[ 3 ];\n\t#ifndef USE_MORPHNORMALS\n\ttransformed += ( morphTarget4 - position ) * morphTargetInfluences[ 4 ];\n\ttransformed += ( morphTarget5 - position ) * morphTargetInfluences[ 5 ];\n\ttransformed += ( morphTarget6 - position ) * morphTargetInfluences[ 6 ];\n\ttransformed += ( morphTarget7 - position ) * morphTargetInfluences[ 7 ];\n\t#endif\n#endif\n";var normal_flip="#ifdef DOUBLE_SIDED\n\tfloat flipNormal = ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n#else\n\tfloat flipNormal = 1.0;\n#endif\n";var normal_fragment="#ifdef FLAT_SHADED\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal ) * flipNormal;\n#endif\n#ifdef USE_NORMALMAP\n\tnormal = perturbNormal2Arb( -vViewPosition, normal );\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\n#endif\n";var normalmap_pars_fragment="#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm ) {\n\t\tvec3 q0 = dFdx( eye_pos.xyz );\n\t\tvec3 q1 = dFdy( eye_pos.xyz );\n\t\tvec2 st0 = dFdx( vUv.st );\n\t\tvec2 st1 = dFdy( vUv.st );\n\t\tvec3 S = normalize( q0 * st1.t - q1 * st0.t );\n\t\tvec3 T = normalize( -q0 * st1.s + q1 * st0.s );\n\t\tvec3 N = normalize( surf_norm );\n\t\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t\tmapN.xy = normalScale * mapN.xy;\n\t\tmat3 tsn = mat3( S, T, N );\n\t\treturn normalize( tsn * mapN );\n\t}\n#endif\n";var packing="vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 1.0 - 2.0 * rgb.xyz;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}\n";var premultiplied_alpha_fragment="#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif\n";var project_vertex="#ifdef USE_SKINNING\n\tvec4 mvPosition = modelViewMatrix * skinned;\n#else\n\tvec4 mvPosition = modelViewMatrix * vec4( transformed, 1.0 );\n#endif\ngl_Position = projectionMatrix * mvPosition;\n";var dithering_fragment="#if defined( DITHERING )\n  gl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif\n";var dithering_pars_fragment="vec3 dithering( vec3 color ) {\n\tfloat grid_position = fract( dot( gl_FragCoord.xy - vec2( 0.5, 0.5 ) , vec2( 1.0 / 16.0, 10.0 / 36.0 ) + 0.25 ) );\n\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\treturn color + 0.5 / 255.0 + dither_shift_RGB;\n}";var roughnessmap_fragment="float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\troughnessFactor *= texelRoughness.g;\n#endif\n";var roughnessmap_pars_fragment="#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif";var shadowmap_pars_fragment="#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHTS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHTS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\n\t\tconst vec2 offset = vec2( 0.0, 1.0 );\n\t\tvec2 texelSize = vec2( 1.0 ) / size;\n\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\n\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\n\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\n\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\n\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\n\t\tvec2 f = fract( uv * size + 0.5 );\n\t\tfloat a = mix( lb, lt, f.y );\n\t\tfloat b = mix( rb, rt, f.y );\n\t\tfloat c = mix( a, b, f.x );\n\t\treturn c;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\t\tbool frustumTest = all( frustumTestVec );\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\treturn (\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn 1.0;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\tfloat dp = ( length( lightToPosition ) - shadowBias ) / 1000.0;\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif\n";var shadowmap_pars_vertex="#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHTS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHTS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\n\t#endif\n#endif\n";var shadowmap_vertex="#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n#endif\n";var shadowmask_pars_fragment="float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\tDirectionalLight directionalLight;\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tshadow *= bool( directionalLight.shadow ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\tSpotLight spotLight;\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tshadow *= bool( spotLight.shadow ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t}\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\tPointLight pointLight;\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tshadow *= bool( pointLight.shadow ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ] ) : 1.0;\n\t}\n\t#endif\n\t#endif\n\treturn shadow;\n}\n";var skinbase_vertex="#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif";var skinning_pars_vertex="#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\t#ifdef BONE_TEXTURE\n\t\tuniform sampler2D boneTexture;\n\t\tuniform int boneTextureSize;\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tfloat j = i * 4.0;\n\t\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\t\ty = dy * ( y + 0.5 );\n\t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\t\treturn bone;\n\t\t}\n\t#else\n\t\tuniform mat4 boneMatrices[ MAX_BONES ];\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tmat4 bone = boneMatrices[ int(i) ];\n\t\t\treturn bone;\n\t\t}\n\t#endif\n#endif\n";var skinning_vertex="#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\tskinned  = bindMatrixInverse * skinned;\n#endif\n";var skinnormal_vertex="#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix  = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n#endif\n";var specularmap_fragment="float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif";var specularmap_pars_fragment="#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif";var tonemapping_fragment="#if defined( TONE_MAPPING )\n  gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif\n";var tonemapping_pars_fragment="#define saturate(a) clamp( a, 0.0, 1.0 )\nuniform float toneMappingExposure;\nuniform float toneMappingWhitePoint;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\n#define Uncharted2Helper( x ) max( ( ( x * ( 0.15 * x + 0.10 * 0.50 ) + 0.20 * 0.02 ) / ( x * ( 0.15 * x + 0.50 ) + 0.20 * 0.30 ) ) - 0.02 / 0.30, vec3( 0.0 ) )\nvec3 Uncharted2ToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( Uncharted2Helper( color ) / Uncharted2Helper( vec3( toneMappingWhitePoint ) ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\n";var uv_pars_fragment="#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvarying vec2 vUv;\n#endif";var uv_pars_vertex="#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvarying vec2 vUv;\n\tuniform vec4 offsetRepeat;\n#endif\n";var uv_vertex="#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvUv = uv * offsetRepeat.zw + offsetRepeat.xy;\n#endif";var uv2_pars_fragment="#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif";var uv2_pars_vertex="#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n#endif";var uv2_vertex="#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = uv2;\n#endif";var worldpos_vertex="#if defined( USE_ENVMAP ) || defined( PHONG ) || defined( PHYSICAL ) || defined( LAMBERT ) || defined ( USE_SHADOWMAP )\n\t#ifdef USE_SKINNING\n\t\tvec4 worldPosition = modelMatrix * skinned;\n\t#else\n\t\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\n\t#endif\n#endif\n";var cube_frag="uniform samplerCube tCube;\nuniform float tFlip;\nuniform float opacity;\nvarying vec3 vWorldPosition;\n#include <common>\nvoid main() {\n\tgl_FragColor = textureCube( tCube, vec3( tFlip * vWorldPosition.x, vWorldPosition.yz ) );\n\tgl_FragColor.a *= opacity;\n}\n";var cube_vert="varying vec3 vWorldPosition;\n#include <common>\nvoid main() {\n\tvWorldPosition = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}\n";var depth_frag="#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <logdepthbuf_fragment>\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( gl_FragCoord.z ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( gl_FragCoord.z );\n\t#endif\n}\n";var depth_vert="#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#include <begin_vertex>\n\t#include <displacementmap_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n}\n";var distanceRGBA_frag="uniform vec3 lightPos;\nvarying vec4 vWorldPosition;\n#include <common>\n#include <packing>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tgl_FragColor = packDepthToRGBA( length( vWorldPosition.xyz - lightPos.xyz ) / 1000.0 );\n}\n";var distanceRGBA_vert="varying vec4 vWorldPosition;\n#include <common>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <skinbase_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition;\n}\n";var equirect_frag="uniform sampler2D tEquirect;\nuniform float tFlip;\nvarying vec3 vWorldPosition;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldPosition );\n\tvec2 sampleUV;\n\tsampleUV.y = saturate( tFlip * direction.y * -0.5 + 0.5 );\n\tsampleUV.x = atan( direction.z, direction.x ) * RECIPROCAL_PI2 + 0.5;\n\tgl_FragColor = texture2D( tEquirect, sampleUV );\n}\n";var equirect_vert="varying vec3 vWorldPosition;\n#include <common>\nvoid main() {\n\tvWorldPosition = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}\n";var linedashed_frag="uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n";var linedashed_vert="uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\tvLineDistance = scale * lineDistance;\n\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}\n";var meshbasic_frag="uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\treflectedLight.indirectDiffuse += texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <normal_flip>\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n";var meshbasic_vert="#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_ENVMAP\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}\n";var meshlambert_frag="uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n#endif\n#include <common>\n#include <packing>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <bsdfs>\n#include <lights_pars>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <emissivemap_fragment>\n\treflectedLight.indirectDiffuse = getAmbientLightIrradiance( ambientLightColor );\n\t#include <lightmap_fragment>\n\treflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n\t#else\n\t\treflectedLight.directDiffuse = vLightFront;\n\t#endif\n\treflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <normal_flip>\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <dithering_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n";var meshlambert_vert="#define LAMBERT\nvarying vec3 vLightFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <lights_lambert_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}\n";var meshphong_frag="#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_flip>\n\t#include <normal_fragment>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_template>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <dithering_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n";var meshphong_vert="#define PHONG\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <displacementmap_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}\n";var meshphysical_frag="#define PHYSICAL\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifndef STANDARD\n\tuniform float clearCoat;\n\tuniform float clearCoatRoughness;\n#endif\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <packing>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <lights_pars>\n#include <lights_physical_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_flip>\n\t#include <normal_fragment>\n\t#include <emissivemap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_template>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <dithering_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n";var meshphysical_vert="#define PHYSICAL\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <displacementmap_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}\n";var normal_frag="#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\nvoid main() {\n\t#include <logdepthbuf_fragment>\n\t#include <normal_flip>\n\t#include <normal_fragment>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n}\n";var normal_vert="#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <displacementmap_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}\n";var points_frag="uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n";var points_vert="uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#ifdef USE_SIZEATTENUATION\n\t\tgl_PointSize = size * ( scale / - mvPosition.z );\n\t#else\n\t\tgl_PointSize = size;\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}\n";var shadow_frag="uniform float opacity;\n#include <common>\n#include <packing>\n#include <bsdfs>\n#include <lights_pars>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\tgl_FragColor = vec4( 0.0, 0.0, 0.0, opacity * ( 1.0 - getShadowMask() ) );\n}\n";var shadow_vert="#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n}\n";var ShaderChunk={alphamap_fragment:alphamap_fragment,alphamap_pars_fragment:alphamap_pars_fragment,alphatest_fragment:alphatest_fragment,aomap_fragment:aomap_fragment,aomap_pars_fragment:aomap_pars_fragment,begin_vertex:begin_vertex,beginnormal_vertex:beginnormal_vertex,bsdfs:bsdfs,bumpmap_pars_fragment:bumpmap_pars_fragment,clipping_planes_fragment:clipping_planes_fragment,clipping_planes_pars_fragment:clipping_planes_pars_fragment,clipping_planes_pars_vertex:clipping_planes_pars_vertex,clipping_planes_vertex:clipping_planes_vertex,color_fragment:color_fragment,color_pars_fragment:color_pars_fragment,color_pars_vertex:color_pars_vertex,color_vertex:color_vertex,common:common,cube_uv_reflection_fragment:cube_uv_reflection_fragment,defaultnormal_vertex:defaultnormal_vertex,displacementmap_pars_vertex:displacementmap_pars_vertex,displacementmap_vertex:displacementmap_vertex,emissivemap_fragment:emissivemap_fragment,emissivemap_pars_fragment:emissivemap_pars_fragment,encodings_fragment:encodings_fragment,encodings_pars_fragment:encodings_pars_fragment,envmap_fragment:envmap_fragment,envmap_pars_fragment:envmap_pars_fragment,envmap_pars_vertex:envmap_pars_vertex,envmap_vertex:envmap_vertex,fog_vertex:fog_vertex,fog_pars_vertex:fog_pars_vertex,fog_fragment:fog_fragment,fog_pars_fragment:fog_pars_fragment,gradientmap_pars_fragment:gradientmap_pars_fragment,lightmap_fragment:lightmap_fragment,lightmap_pars_fragment:lightmap_pars_fragment,lights_lambert_vertex:lights_lambert_vertex,lights_pars:lights_pars,lights_phong_fragment:lights_phong_fragment,lights_phong_pars_fragment:lights_phong_pars_fragment,lights_physical_fragment:lights_physical_fragment,lights_physical_pars_fragment:lights_physical_pars_fragment,lights_template:lights_template,logdepthbuf_fragment:logdepthbuf_fragment,logdepthbuf_pars_fragment:logdepthbuf_pars_fragment,logdepthbuf_pars_vertex:logdepthbuf_pars_vertex,logdepthbuf_vertex:logdepthbuf_vertex,map_fragment:map_fragment,map_pars_fragment:map_pars_fragment,map_particle_fragment:map_particle_fragment,map_particle_pars_fragment:map_particle_pars_fragment,metalnessmap_fragment:metalnessmap_fragment,metalnessmap_pars_fragment:metalnessmap_pars_fragment,morphnormal_vertex:morphnormal_vertex,morphtarget_pars_vertex:morphtarget_pars_vertex,morphtarget_vertex:morphtarget_vertex,normal_flip:normal_flip,normal_fragment:normal_fragment,normalmap_pars_fragment:normalmap_pars_fragment,packing:packing,premultiplied_alpha_fragment:premultiplied_alpha_fragment,project_vertex:project_vertex,dithering_fragment:dithering_fragment,dithering_pars_fragment:dithering_pars_fragment,roughnessmap_fragment:roughnessmap_fragment,roughnessmap_pars_fragment:roughnessmap_pars_fragment,shadowmap_pars_fragment:shadowmap_pars_fragment,shadowmap_pars_vertex:shadowmap_pars_vertex,shadowmap_vertex:shadowmap_vertex,shadowmask_pars_fragment:shadowmask_pars_fragment,skinbase_vertex:skinbase_vertex,skinning_pars_vertex:skinning_pars_vertex,skinning_vertex:skinning_vertex,skinnormal_vertex:skinnormal_vertex,specularmap_fragment:specularmap_fragment,specularmap_pars_fragment:specularmap_pars_fragment,tonemapping_fragment:tonemapping_fragment,tonemapping_pars_fragment:tonemapping_pars_fragment,uv_pars_fragment:uv_pars_fragment,uv_pars_vertex:uv_pars_vertex,uv_vertex:uv_vertex,uv2_pars_fragment:uv2_pars_fragment,uv2_pars_vertex:uv2_pars_vertex,uv2_vertex:uv2_vertex,worldpos_vertex:worldpos_vertex,cube_frag:cube_frag,cube_vert:cube_vert,depth_frag:depth_frag,depth_vert:depth_vert,distanceRGBA_frag:distanceRGBA_frag,distanceRGBA_vert:distanceRGBA_vert,equirect_frag:equirect_frag,equirect_vert:equirect_vert,linedashed_frag:linedashed_frag,linedashed_vert:linedashed_vert,meshbasic_frag:meshbasic_frag,meshbasic_vert:meshbasic_vert,meshlambert_frag:meshlambert_frag,meshlambert_vert:meshlambert_vert,meshphong_frag:meshphong_frag,meshphong_vert:meshphong_vert,meshphysical_frag:meshphysical_frag,meshphysical_vert:meshphysical_vert,normal_frag:normal_frag,normal_vert:normal_vert,points_frag:points_frag,points_vert:points_vert,shadow_frag:shadow_frag,shadow_vert:shadow_vert};/**
		 * @author alteredq / http://alteredqualia.com/
		 * @author mrdoob / http://mrdoob.com/
		 * @author mikael emtinger / http://gomo.se/
		 */var ShaderLib={basic:{uniforms:UniformsUtils.merge([UniformsLib.common,UniformsLib.aomap,UniformsLib.lightmap,UniformsLib.fog]),vertexShader:ShaderChunk.meshbasic_vert,fragmentShader:ShaderChunk.meshbasic_frag},lambert:{uniforms:UniformsUtils.merge([UniformsLib.common,UniformsLib.aomap,UniformsLib.lightmap,UniformsLib.emissivemap,UniformsLib.fog,UniformsLib.lights,{emissive:{value:new Color(0x000000)}}]),vertexShader:ShaderChunk.meshlambert_vert,fragmentShader:ShaderChunk.meshlambert_frag},phong:{uniforms:UniformsUtils.merge([UniformsLib.common,UniformsLib.aomap,UniformsLib.lightmap,UniformsLib.emissivemap,UniformsLib.bumpmap,UniformsLib.normalmap,UniformsLib.displacementmap,UniformsLib.gradientmap,UniformsLib.fog,UniformsLib.lights,{emissive:{value:new Color(0x000000)},specular:{value:new Color(0x111111)},shininess:{value:30}}]),vertexShader:ShaderChunk.meshphong_vert,fragmentShader:ShaderChunk.meshphong_frag},standard:{uniforms:UniformsUtils.merge([UniformsLib.common,UniformsLib.aomap,UniformsLib.lightmap,UniformsLib.emissivemap,UniformsLib.bumpmap,UniformsLib.normalmap,UniformsLib.displacementmap,UniformsLib.roughnessmap,UniformsLib.metalnessmap,UniformsLib.fog,UniformsLib.lights,{emissive:{value:new Color(0x000000)},roughness:{value:0.5},metalness:{value:0.5},envMapIntensity:{value:1}// temporary
	}]),vertexShader:ShaderChunk.meshphysical_vert,fragmentShader:ShaderChunk.meshphysical_frag},points:{uniforms:UniformsUtils.merge([UniformsLib.points,UniformsLib.fog]),vertexShader:ShaderChunk.points_vert,fragmentShader:ShaderChunk.points_frag},dashed:{uniforms:UniformsUtils.merge([UniformsLib.common,UniformsLib.fog,{scale:{value:1},dashSize:{value:1},totalSize:{value:2}}]),vertexShader:ShaderChunk.linedashed_vert,fragmentShader:ShaderChunk.linedashed_frag},depth:{uniforms:UniformsUtils.merge([UniformsLib.common,UniformsLib.displacementmap]),vertexShader:ShaderChunk.depth_vert,fragmentShader:ShaderChunk.depth_frag},normal:{uniforms:UniformsUtils.merge([UniformsLib.common,UniformsLib.bumpmap,UniformsLib.normalmap,UniformsLib.displacementmap,{opacity:{value:1.0}}]),vertexShader:ShaderChunk.normal_vert,fragmentShader:ShaderChunk.normal_frag},/* -------------------------------------------------------------------------
			//	Cube map shader
			 ------------------------------------------------------------------------- */cube:{uniforms:{tCube:{value:null},tFlip:{value:-1},opacity:{value:1.0}},vertexShader:ShaderChunk.cube_vert,fragmentShader:ShaderChunk.cube_frag},/* -------------------------------------------------------------------------
			//	Cube map shader
			 ------------------------------------------------------------------------- */equirect:{uniforms:{tEquirect:{value:null},tFlip:{value:-1}},vertexShader:ShaderChunk.equirect_vert,fragmentShader:ShaderChunk.equirect_frag},distanceRGBA:{uniforms:{lightPos:{value:new Vector3()}},vertexShader:ShaderChunk.distanceRGBA_vert,fragmentShader:ShaderChunk.distanceRGBA_frag}};ShaderLib.physical={uniforms:UniformsUtils.merge([ShaderLib.standard.uniforms,{clearCoat:{value:0},clearCoatRoughness:{value:0}}]),vertexShader:ShaderChunk.meshphysical_vert,fragmentShader:ShaderChunk.meshphysical_frag};/**
		 * @author szimek / https://github.com/szimek/
		 * @author alteredq / http://alteredqualia.com/
		 * @author Marius Kintel / https://github.com/kintel
		 *//*
		 In options, we can specify:
		 * Texture parameters for an auto-generated target texture
		 * depthBuffer/stencilBuffer: Booleans to indicate if we should generate these buffers
		*/function WebGLRenderTarget(width,height,options){this.uuid=_Math.generateUUID();this.width=width;this.height=height;this.scissor=new Vector4(0,0,width,height);this.scissorTest=false;this.viewport=new Vector4(0,0,width,height);options=options||{};if(options.minFilter===undefined)options.minFilter=LinearFilter;this.texture=new Texture(undefined,undefined,options.wrapS,options.wrapT,options.magFilter,options.minFilter,options.format,options.type,options.anisotropy,options.encoding);this.depthBuffer=options.depthBuffer!==undefined?options.depthBuffer:true;this.stencilBuffer=options.stencilBuffer!==undefined?options.stencilBuffer:true;this.depthTexture=options.depthTexture!==undefined?options.depthTexture:null;}_assign(WebGLRenderTarget.prototype,EventDispatcher.prototype,{isWebGLRenderTarget:true,setSize:function setSize(width,height){if(this.width!==width||this.height!==height){this.width=width;this.height=height;this.dispose();}this.viewport.set(0,0,width,height);this.scissor.set(0,0,width,height);},clone:function clone(){return new this.constructor().copy(this);},copy:function copy(source){this.width=source.width;this.height=source.height;this.viewport.copy(source.viewport);this.texture=source.texture.clone();this.depthBuffer=source.depthBuffer;this.stencilBuffer=source.stencilBuffer;this.depthTexture=source.depthTexture;return this;},dispose:function dispose(){this.dispatchEvent({type:'dispose'});}});/**
		 * @author mrdoob / http://mrdoob.com/
		 * @author alteredq / http://alteredqualia.com/
		 */var materialId=0;function Material(){Object.defineProperty(this,'id',{value:materialId++});this.uuid=_Math.generateUUID();this.name='';this.type='Material';this.fog=true;this.lights=true;this.blending=NormalBlending;this.side=FrontSide;this.shading=SmoothShading;// THREE.FlatShading, THREE.SmoothShading
	this.vertexColors=NoColors;// THREE.NoColors, THREE.VertexColors, THREE.FaceColors
	this.opacity=1;this.transparent=false;this.blendSrc=SrcAlphaFactor;this.blendDst=OneMinusSrcAlphaFactor;this.blendEquation=AddEquation;this.blendSrcAlpha=null;this.blendDstAlpha=null;this.blendEquationAlpha=null;this.depthFunc=LessEqualDepth;this.depthTest=true;this.depthWrite=true;this.clippingPlanes=null;this.clipIntersection=false;this.clipShadows=false;this.colorWrite=true;this.precision=null;// override the renderer's default precision for this material
	this.polygonOffset=false;this.polygonOffsetFactor=0;this.polygonOffsetUnits=0;this.dithering=false;this.alphaTest=0;this.premultipliedAlpha=false;this.overdraw=0;// Overdrawn pixels (typically between 0 and 1) for fixing antialiasing gaps in CanvasRenderer
	this.visible=true;this.needsUpdate=true;}_assign(Material.prototype,EventDispatcher.prototype,{isMaterial:true,setValues:function setValues(values){if(values===undefined)return;for(var key in values){var newValue=values[key];if(newValue===undefined){console.warn("THREE.Material: '"+key+"' parameter is undefined.");continue;}var currentValue=this[key];if(currentValue===undefined){console.warn("THREE."+this.type+": '"+key+"' is not a property of this material.");continue;}if(currentValue&&currentValue.isColor){currentValue.set(newValue);}else if(currentValue&&currentValue.isVector3&&newValue&&newValue.isVector3){currentValue.copy(newValue);}else if(key==='overdraw'){// ensure overdraw is backwards-compatible with legacy boolean type
	this[key]=Number(newValue);}else{this[key]=newValue;}}},toJSON:function toJSON(meta){var isRoot=meta===undefined;if(isRoot){meta={textures:{},images:{}};}var data={metadata:{version:4.5,type:'Material',generator:'Material.toJSON'}};// standard Material serialization
	data.uuid=this.uuid;data.type=this.type;if(this.name!=='')data.name=this.name;if(this.color&&this.color.isColor)data.color=this.color.getHex();if(this.roughness!==undefined)data.roughness=this.roughness;if(this.metalness!==undefined)data.metalness=this.metalness;if(this.emissive&&this.emissive.isColor)data.emissive=this.emissive.getHex();if(this.specular&&this.specular.isColor)data.specular=this.specular.getHex();if(this.shininess!==undefined)data.shininess=this.shininess;if(this.clearCoat!==undefined)data.clearCoat=this.clearCoat;if(this.clearCoatRoughness!==undefined)data.clearCoatRoughness=this.clearCoatRoughness;if(this.map&&this.map.isTexture)data.map=this.map.toJSON(meta).uuid;if(this.alphaMap&&this.alphaMap.isTexture)data.alphaMap=this.alphaMap.toJSON(meta).uuid;if(this.lightMap&&this.lightMap.isTexture)data.lightMap=this.lightMap.toJSON(meta).uuid;if(this.bumpMap&&this.bumpMap.isTexture){data.bumpMap=this.bumpMap.toJSON(meta).uuid;data.bumpScale=this.bumpScale;}if(this.normalMap&&this.normalMap.isTexture){data.normalMap=this.normalMap.toJSON(meta).uuid;data.normalScale=this.normalScale.toArray();}if(this.displacementMap&&this.displacementMap.isTexture){data.displacementMap=this.displacementMap.toJSON(meta).uuid;data.displacementScale=this.displacementScale;data.displacementBias=this.displacementBias;}if(this.roughnessMap&&this.roughnessMap.isTexture)data.roughnessMap=this.roughnessMap.toJSON(meta).uuid;if(this.metalnessMap&&this.metalnessMap.isTexture)data.metalnessMap=this.metalnessMap.toJSON(meta).uuid;if(this.emissiveMap&&this.emissiveMap.isTexture)data.emissiveMap=this.emissiveMap.toJSON(meta).uuid;if(this.specularMap&&this.specularMap.isTexture)data.specularMap=this.specularMap.toJSON(meta).uuid;if(this.envMap&&this.envMap.isTexture){data.envMap=this.envMap.toJSON(meta).uuid;data.reflectivity=this.reflectivity;// Scale behind envMap
	}if(this.gradientMap&&this.gradientMap.isTexture){data.gradientMap=this.gradientMap.toJSON(meta).uuid;}if(this.size!==undefined)data.size=this.size;if(this.sizeAttenuation!==undefined)data.sizeAttenuation=this.sizeAttenuation;if(this.blending!==NormalBlending)data.blending=this.blending;if(this.shading!==SmoothShading)data.shading=this.shading;if(this.side!==FrontSide)data.side=this.side;if(this.vertexColors!==NoColors)data.vertexColors=this.vertexColors;if(this.opacity<1)data.opacity=this.opacity;if(this.transparent===true)data.transparent=this.transparent;data.depthFunc=this.depthFunc;data.depthTest=this.depthTest;data.depthWrite=this.depthWrite;if(this.alphaTest>0)data.alphaTest=this.alphaTest;if(this.premultipliedAlpha===true)data.premultipliedAlpha=this.premultipliedAlpha;if(this.wireframe===true)data.wireframe=this.wireframe;if(this.wireframeLinewidth>1)data.wireframeLinewidth=this.wireframeLinewidth;if(this.wireframeLinecap!=='round')data.wireframeLinecap=this.wireframeLinecap;if(this.wireframeLinejoin!=='round')data.wireframeLinejoin=this.wireframeLinejoin;data.skinning=this.skinning;data.morphTargets=this.morphTargets;data.dithering=this.dithering;// TODO: Copied from Object3D.toJSON
	function extractFromCache(cache){var values=[];for(var key in cache){var data=cache[key];delete data.metadata;values.push(data);}return values;}if(isRoot){var textures=extractFromCache(meta.textures);var images=extractFromCache(meta.images);if(textures.length>0)data.textures=textures;if(images.length>0)data.images=images;}return data;},clone:function clone(){return new this.constructor().copy(this);},copy:function copy(source){this.name=source.name;this.fog=source.fog;this.lights=source.lights;this.blending=source.blending;this.side=source.side;this.shading=source.shading;this.vertexColors=source.vertexColors;this.opacity=source.opacity;this.transparent=source.transparent;this.blendSrc=source.blendSrc;this.blendDst=source.blendDst;this.blendEquation=source.blendEquation;this.blendSrcAlpha=source.blendSrcAlpha;this.blendDstAlpha=source.blendDstAlpha;this.blendEquationAlpha=source.blendEquationAlpha;this.depthFunc=source.depthFunc;this.depthTest=source.depthTest;this.depthWrite=source.depthWrite;this.colorWrite=source.colorWrite;this.precision=source.precision;this.polygonOffset=source.polygonOffset;this.polygonOffsetFactor=source.polygonOffsetFactor;this.polygonOffsetUnits=source.polygonOffsetUnits;this.dithering=source.dithering;this.alphaTest=source.alphaTest;this.premultipliedAlpha=source.premultipliedAlpha;this.overdraw=source.overdraw;this.visible=source.visible;this.clipShadows=source.clipShadows;this.clipIntersection=source.clipIntersection;var srcPlanes=source.clippingPlanes,dstPlanes=null;if(srcPlanes!==null){var n=srcPlanes.length;dstPlanes=new Array(n);for(var i=0;i!==n;++i){dstPlanes[i]=srcPlanes[i].clone();}}this.clippingPlanes=dstPlanes;return this;},dispose:function dispose(){this.dispatchEvent({type:'dispose'});}});/**
		 * @author alteredq / http://alteredqualia.com/
		 *
		 * parameters = {
		 *  defines: { "label" : "value" },
		 *  uniforms: { "parameter1": { value: 1.0 }, "parameter2": { value2: 2 } },
		 *
		 *  fragmentShader: <string>,
		 *  vertexShader: <string>,
		 *
		 *  wireframe: <boolean>,
		 *  wireframeLinewidth: <float>,
		 *
		 *  lights: <bool>,
		 *
		 *  skinning: <bool>,
		 *  morphTargets: <bool>,
		 *  morphNormals: <bool>
		 * }
		 */function ShaderMaterial(parameters){Material.call(this);this.type='ShaderMaterial';this.defines={};this.uniforms={};this.vertexShader='void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}';this.fragmentShader='void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}';this.linewidth=1;this.wireframe=false;this.wireframeLinewidth=1;this.fog=false;// set to use scene fog
	this.lights=false;// set to use scene lights
	this.clipping=false;// set to use user-defined clipping planes
	this.skinning=false;// set to use skinning attribute streams
	this.morphTargets=false;// set to use morph targets
	this.morphNormals=false;// set to use morph normals
	this.extensions={derivatives:false,// set to use derivatives
	fragDepth:false,// set to use fragment depth values
	drawBuffers:false,// set to use draw buffers
	shaderTextureLOD:false// set to use shader texture LOD
	};// When rendered geometry doesn't include these attributes but the material does,
	// use these default values in WebGL. This avoids errors when buffer data is missing.
	this.defaultAttributeValues={'color':[1,1,1],'uv':[0,0],'uv2':[0,0]};this.index0AttributeName=undefined;if(parameters!==undefined){if(parameters.attributes!==undefined){console.error('THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead.');}this.setValues(parameters);}}ShaderMaterial.prototype=Object.create(Material.prototype);ShaderMaterial.prototype.constructor=ShaderMaterial;ShaderMaterial.prototype.isShaderMaterial=true;ShaderMaterial.prototype.copy=function(source){Material.prototype.copy.call(this,source);this.fragmentShader=source.fragmentShader;this.vertexShader=source.vertexShader;this.uniforms=UniformsUtils.clone(source.uniforms);this.defines=source.defines;this.wireframe=source.wireframe;this.wireframeLinewidth=source.wireframeLinewidth;this.lights=source.lights;this.clipping=source.clipping;this.skinning=source.skinning;this.morphTargets=source.morphTargets;this.morphNormals=source.morphNormals;this.extensions=source.extensions;return this;};ShaderMaterial.prototype.toJSON=function(meta){var data=Material.prototype.toJSON.call(this,meta);data.uniforms=this.uniforms;data.vertexShader=this.vertexShader;data.fragmentShader=this.fragmentShader;return data;};/**
		 * @author mrdoob / http://mrdoob.com/
		 * @author alteredq / http://alteredqualia.com/
		 * @author bhouston / https://clara.io
		 * @author WestLangley / http://github.com/WestLangley
		 *
		 * parameters = {
		 *
		 *  opacity: <float>,
		 *
		 *  map: new THREE.Texture( <Image> ),
		 *
		 *  alphaMap: new THREE.Texture( <Image> ),
		 *
		 *  displacementMap: new THREE.Texture( <Image> ),
		 *  displacementScale: <float>,
		 *  displacementBias: <float>,
		 *
		 *  wireframe: <boolean>,
		 *  wireframeLinewidth: <float>
		 * }
		 */function MeshDepthMaterial(parameters){Material.call(this);this.type='MeshDepthMaterial';this.depthPacking=BasicDepthPacking;this.skinning=false;this.morphTargets=false;this.map=null;this.alphaMap=null;this.displacementMap=null;this.displacementScale=1;this.displacementBias=0;this.wireframe=false;this.wireframeLinewidth=1;this.fog=false;this.lights=false;this.setValues(parameters);}MeshDepthMaterial.prototype=Object.create(Material.prototype);MeshDepthMaterial.prototype.constructor=MeshDepthMaterial;MeshDepthMaterial.prototype.isMeshDepthMaterial=true;MeshDepthMaterial.prototype.copy=function(source){Material.prototype.copy.call(this,source);this.depthPacking=source.depthPacking;this.skinning=source.skinning;this.morphTargets=source.morphTargets;this.map=source.map;this.alphaMap=source.alphaMap;this.displacementMap=source.displacementMap;this.displacementScale=source.displacementScale;this.displacementBias=source.displacementBias;this.wireframe=source.wireframe;this.wireframeLinewidth=source.wireframeLinewidth;return this;};/**
		 * @author bhouston / http://clara.io
		 * @author WestLangley / http://github.com/WestLangley
		 */function Box3(min,max){this.min=min!==undefined?min:new Vector3(+Infinity,+Infinity,+Infinity);this.max=max!==undefined?max:new Vector3(-Infinity,-Infinity,-Infinity);}_assign(Box3.prototype,{isBox3:true,set:function set(min,max){this.min.copy(min);this.max.copy(max);return this;},setFromArray:function setFromArray(array){var minX=+Infinity;var minY=+Infinity;var minZ=+Infinity;var maxX=-Infinity;var maxY=-Infinity;var maxZ=-Infinity;for(var i=0,l=array.length;i<l;i+=3){var x=array[i];var y=array[i+1];var z=array[i+2];if(x<minX)minX=x;if(y<minY)minY=y;if(z<minZ)minZ=z;if(x>maxX)maxX=x;if(y>maxY)maxY=y;if(z>maxZ)maxZ=z;}this.min.set(minX,minY,minZ);this.max.set(maxX,maxY,maxZ);return this;},setFromBufferAttribute:function setFromBufferAttribute(attribute){var minX=+Infinity;var minY=+Infinity;var minZ=+Infinity;var maxX=-Infinity;var maxY=-Infinity;var maxZ=-Infinity;for(var i=0,l=attribute.count;i<l;i++){var x=attribute.getX(i);var y=attribute.getY(i);var z=attribute.getZ(i);if(x<minX)minX=x;if(y<minY)minY=y;if(z<minZ)minZ=z;if(x>maxX)maxX=x;if(y>maxY)maxY=y;if(z>maxZ)maxZ=z;}this.min.set(minX,minY,minZ);this.max.set(maxX,maxY,maxZ);return this;},setFromPoints:function setFromPoints(points){this.makeEmpty();for(var i=0,il=points.length;i<il;i++){this.expandByPoint(points[i]);}return this;},setFromCenterAndSize:function(){var v1=new Vector3();return function setFromCenterAndSize(center,size){var halfSize=v1.copy(size).multiplyScalar(0.5);this.min.copy(center).sub(halfSize);this.max.copy(center).add(halfSize);return this;};}(),setFromObject:function setFromObject(object){this.makeEmpty();return this.expandByObject(object);},clone:function clone(){return new this.constructor().copy(this);},copy:function copy(box){this.min.copy(box.min);this.max.copy(box.max);return this;},makeEmpty:function makeEmpty(){this.min.x=this.min.y=this.min.z=+Infinity;this.max.x=this.max.y=this.max.z=-Infinity;return this;},isEmpty:function isEmpty(){// this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes
	return this.max.x<this.min.x||this.max.y<this.min.y||this.max.z<this.min.z;},getCenter:function getCenter(optionalTarget){var result=optionalTarget||new Vector3();return this.isEmpty()?result.set(0,0,0):result.addVectors(this.min,this.max).multiplyScalar(0.5);},getSize:function getSize(optionalTarget){var result=optionalTarget||new Vector3();return this.isEmpty()?result.set(0,0,0):result.subVectors(this.max,this.min);},expandByPoint:function expandByPoint(point){this.min.min(point);this.max.max(point);return this;},expandByVector:function expandByVector(vector){this.min.sub(vector);this.max.add(vector);return this;},expandByScalar:function expandByScalar(scalar){this.min.addScalar(-scalar);this.max.addScalar(scalar);return this;},expandByObject:function(){// Computes the world-axis-aligned bounding box of an object (including its children),
	// accounting for both the object's, and children's, world transforms
	var v1=new Vector3();return function expandByObject(object){var scope=this;object.updateMatrixWorld(true);object.traverse(function(node){var i,l;var geometry=node.geometry;if(geometry!==undefined){if(geometry.isGeometry){var vertices=geometry.vertices;for(i=0,l=vertices.length;i<l;i++){v1.copy(vertices[i]);v1.applyMatrix4(node.matrixWorld);scope.expandByPoint(v1);}}else if(geometry.isBufferGeometry){var attribute=geometry.attributes.position;if(attribute!==undefined){for(i=0,l=attribute.count;i<l;i++){v1.fromBufferAttribute(attribute,i).applyMatrix4(node.matrixWorld);scope.expandByPoint(v1);}}}}});return this;};}(),containsPoint:function containsPoint(point){return point.x<this.min.x||point.x>this.max.x||point.y<this.min.y||point.y>this.max.y||point.z<this.min.z||point.z>this.max.z?false:true;},containsBox:function containsBox(box){return this.min.x<=box.min.x&&box.max.x<=this.max.x&&this.min.y<=box.min.y&&box.max.y<=this.max.y&&this.min.z<=box.min.z&&box.max.z<=this.max.z;},getParameter:function getParameter(point,optionalTarget){// This can potentially have a divide by zero if the box
	// has a size dimension of 0.
	var result=optionalTarget||new Vector3();return result.set((point.x-this.min.x)/(this.max.x-this.min.x),(point.y-this.min.y)/(this.max.y-this.min.y),(point.z-this.min.z)/(this.max.z-this.min.z));},intersectsBox:function intersectsBox(box){// using 6 splitting planes to rule out intersections.
	return box.max.x<this.min.x||box.min.x>this.max.x||box.max.y<this.min.y||box.min.y>this.max.y||box.max.z<this.min.z||box.min.z>this.max.z?false:true;},intersectsSphere:function(){var closestPoint=new Vector3();return function intersectsSphere(sphere){// Find the point on the AABB closest to the sphere center.
	this.clampPoint(sphere.center,closestPoint);// If that point is inside the sphere, the AABB and sphere intersect.
	return closestPoint.distanceToSquared(sphere.center)<=sphere.radius*sphere.radius;};}(),intersectsPlane:function intersectsPlane(plane){// We compute the minimum and maximum dot product values. If those values
	// are on the same side (back or front) of the plane, then there is no intersection.
	var min,max;if(plane.normal.x>0){min=plane.normal.x*this.min.x;max=plane.normal.x*this.max.x;}else{min=plane.normal.x*this.max.x;max=plane.normal.x*this.min.x;}if(plane.normal.y>0){min+=plane.normal.y*this.min.y;max+=plane.normal.y*this.max.y;}else{min+=plane.normal.y*this.max.y;max+=plane.normal.y*this.min.y;}if(plane.normal.z>0){min+=plane.normal.z*this.min.z;max+=plane.normal.z*this.max.z;}else{min+=plane.normal.z*this.max.z;max+=plane.normal.z*this.min.z;}return min<=plane.constant&&max>=plane.constant;},clampPoint:function clampPoint(point,optionalTarget){var result=optionalTarget||new Vector3();return result.copy(point).clamp(this.min,this.max);},distanceToPoint:function(){var v1=new Vector3();return function distanceToPoint(point){var clampedPoint=v1.copy(point).clamp(this.min,this.max);return clampedPoint.sub(point).length();};}(),getBoundingSphere:function(){var v1=new Vector3();return function getBoundingSphere(optionalTarget){var result=optionalTarget||new Sphere();this.getCenter(result.center);result.radius=this.getSize(v1).length()*0.5;return result;};}(),intersect:function intersect(box){this.min.max(box.min);this.max.min(box.max);// ensure that if there is no overlap, the result is fully empty, not slightly empty with non-inf/+inf values that will cause subsequence intersects to erroneously return valid values.
	if(this.isEmpty())this.makeEmpty();return this;},union:function union(box){this.min.min(box.min);this.max.max(box.max);return this;},applyMatrix4:function(){var points=[new Vector3(),new Vector3(),new Vector3(),new Vector3(),new Vector3(),new Vector3(),new Vector3(),new Vector3()];return function applyMatrix4(matrix){// transform of empty box is an empty box.
	if(this.isEmpty())return this;// NOTE: I am using a binary pattern to specify all 2^3 combinations below
	points[0].set(this.min.x,this.min.y,this.min.z).applyMatrix4(matrix);// 000
	points[1].set(this.min.x,this.min.y,this.max.z).applyMatrix4(matrix);// 001
	points[2].set(this.min.x,this.max.y,this.min.z).applyMatrix4(matrix);// 010
	points[3].set(this.min.x,this.max.y,this.max.z).applyMatrix4(matrix);// 011
	points[4].set(this.max.x,this.min.y,this.min.z).applyMatrix4(matrix);// 100
	points[5].set(this.max.x,this.min.y,this.max.z).applyMatrix4(matrix);// 101
	points[6].set(this.max.x,this.max.y,this.min.z).applyMatrix4(matrix);// 110
	points[7].set(this.max.x,this.max.y,this.max.z).applyMatrix4(matrix);// 111
	this.setFromPoints(points);return this;};}(),translate:function translate(offset){this.min.add(offset);this.max.add(offset);return this;},equals:function equals(box){return box.min.equals(this.min)&&box.max.equals(this.max);}});/**
		 * @author bhouston / http://clara.io
		 * @author mrdoob / http://mrdoob.com/
		 */function Sphere(center,radius){this.center=center!==undefined?center:new Vector3();this.radius=radius!==undefined?radius:0;}_assign(Sphere.prototype,{set:function set(center,radius){this.center.copy(center);this.radius=radius;return this;},setFromPoints:function(){var box=new Box3();return function setFromPoints(points,optionalCenter){var center=this.center;if(optionalCenter!==undefined){center.copy(optionalCenter);}else{box.setFromPoints(points).getCenter(center);}var maxRadiusSq=0;for(var i=0,il=points.length;i<il;i++){maxRadiusSq=Math.max(maxRadiusSq,center.distanceToSquared(points[i]));}this.radius=Math.sqrt(maxRadiusSq);return this;};}(),clone:function clone(){return new this.constructor().copy(this);},copy:function copy(sphere){this.center.copy(sphere.center);this.radius=sphere.radius;return this;},empty:function empty(){return this.radius<=0;},containsPoint:function containsPoint(point){return point.distanceToSquared(this.center)<=this.radius*this.radius;},distanceToPoint:function distanceToPoint(point){return point.distanceTo(this.center)-this.radius;},intersectsSphere:function intersectsSphere(sphere){var radiusSum=this.radius+sphere.radius;return sphere.center.distanceToSquared(this.center)<=radiusSum*radiusSum;},intersectsBox:function intersectsBox(box){return box.intersectsSphere(this);},intersectsPlane:function intersectsPlane(plane){// We use the following equation to compute the signed distance from
	// the center of the sphere to the plane.
	//
	// distance = q * n - d
	//
	// If this distance is greater than the radius of the sphere,
	// then there is no intersection.
	return Math.abs(this.center.dot(plane.normal)-plane.constant)<=this.radius;},clampPoint:function clampPoint(point,optionalTarget){var deltaLengthSq=this.center.distanceToSquared(point);var result=optionalTarget||new Vector3();result.copy(point);if(deltaLengthSq>this.radius*this.radius){result.sub(this.center).normalize();result.multiplyScalar(this.radius).add(this.center);}return result;},getBoundingBox:function getBoundingBox(optionalTarget){var box=optionalTarget||new Box3();box.set(this.center,this.center);box.expandByScalar(this.radius);return box;},applyMatrix4:function applyMatrix4(matrix){this.center.applyMatrix4(matrix);this.radius=this.radius*matrix.getMaxScaleOnAxis();return this;},translate:function translate(offset){this.center.add(offset);return this;},equals:function equals(sphere){return sphere.center.equals(this.center)&&sphere.radius===this.radius;}});/**
		 * @author alteredq / http://alteredqualia.com/
		 * @author WestLangley / http://github.com/WestLangley
		 * @author bhouston / http://clara.io
		 * @author tschw
		 */function Matrix3(){this.elements=[1,0,0,0,1,0,0,0,1];if(arguments.length>0){console.error('THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.');}}_assign(Matrix3.prototype,{isMatrix3:true,set:function set(n11,n12,n13,n21,n22,n23,n31,n32,n33){var te=this.elements;te[0]=n11;te[1]=n21;te[2]=n31;te[3]=n12;te[4]=n22;te[5]=n32;te[6]=n13;te[7]=n23;te[8]=n33;return this;},identity:function identity(){this.set(1,0,0,0,1,0,0,0,1);return this;},clone:function clone(){return new this.constructor().fromArray(this.elements);},copy:function copy(m){var te=this.elements;var me=m.elements;te[0]=me[0];te[1]=me[1];te[2]=me[2];te[3]=me[3];te[4]=me[4];te[5]=me[5];te[6]=me[6];te[7]=me[7];te[8]=me[8];return this;},setFromMatrix4:function setFromMatrix4(m){var me=m.elements;this.set(me[0],me[4],me[8],me[1],me[5],me[9],me[2],me[6],me[10]);return this;},applyToBufferAttribute:function(){var v1=new Vector3();return function applyToBufferAttribute(attribute){for(var i=0,l=attribute.count;i<l;i++){v1.x=attribute.getX(i);v1.y=attribute.getY(i);v1.z=attribute.getZ(i);v1.applyMatrix3(this);attribute.setXYZ(i,v1.x,v1.y,v1.z);}return attribute;};}(),multiply:function multiply(m){return this.multiplyMatrices(this,m);},premultiply:function premultiply(m){return this.multiplyMatrices(m,this);},multiplyMatrices:function multiplyMatrices(a,b){var ae=a.elements;var be=b.elements;var te=this.elements;var a11=ae[0],a12=ae[3],a13=ae[6];var a21=ae[1],a22=ae[4],a23=ae[7];var a31=ae[2],a32=ae[5],a33=ae[8];var b11=be[0],b12=be[3],b13=be[6];var b21=be[1],b22=be[4],b23=be[7];var b31=be[2],b32=be[5],b33=be[8];te[0]=a11*b11+a12*b21+a13*b31;te[3]=a11*b12+a12*b22+a13*b32;te[6]=a11*b13+a12*b23+a13*b33;te[1]=a21*b11+a22*b21+a23*b31;te[4]=a21*b12+a22*b22+a23*b32;te[7]=a21*b13+a22*b23+a23*b33;te[2]=a31*b11+a32*b21+a33*b31;te[5]=a31*b12+a32*b22+a33*b32;te[8]=a31*b13+a32*b23+a33*b33;return this;},multiplyScalar:function multiplyScalar(s){var te=this.elements;te[0]*=s;te[3]*=s;te[6]*=s;te[1]*=s;te[4]*=s;te[7]*=s;te[2]*=s;te[5]*=s;te[8]*=s;return this;},determinant:function determinant(){var te=this.elements;var a=te[0],b=te[1],c=te[2],d=te[3],e=te[4],f=te[5],g=te[6],h=te[7],i=te[8];return a*e*i-a*f*h-b*d*i+b*f*g+c*d*h-c*e*g;},getInverse:function getInverse(matrix,throwOnDegenerate){if(matrix&&matrix.isMatrix4){console.error("THREE.Matrix3.getInverse no longer takes a Matrix4 argument.");}var me=matrix.elements,te=this.elements,n11=me[0],n21=me[1],n31=me[2],n12=me[3],n22=me[4],n32=me[5],n13=me[6],n23=me[7],n33=me[8],t11=n33*n22-n32*n23,t12=n32*n13-n33*n12,t13=n23*n12-n22*n13,det=n11*t11+n21*t12+n31*t13;if(det===0){var msg="THREE.Matrix3.getInverse(): can't invert matrix, determinant is 0";if(throwOnDegenerate===true){throw new Error(msg);}else{console.warn(msg);}return this.identity();}var detInv=1/det;te[0]=t11*detInv;te[1]=(n31*n23-n33*n21)*detInv;te[2]=(n32*n21-n31*n22)*detInv;te[3]=t12*detInv;te[4]=(n33*n11-n31*n13)*detInv;te[5]=(n31*n12-n32*n11)*detInv;te[6]=t13*detInv;te[7]=(n21*n13-n23*n11)*detInv;te[8]=(n22*n11-n21*n12)*detInv;return this;},transpose:function transpose(){var tmp,m=this.elements;tmp=m[1];m[1]=m[3];m[3]=tmp;tmp=m[2];m[2]=m[6];m[6]=tmp;tmp=m[5];m[5]=m[7];m[7]=tmp;return this;},getNormalMatrix:function getNormalMatrix(matrix4){return this.setFromMatrix4(matrix4).getInverse(this).transpose();},transposeIntoArray:function transposeIntoArray(r){var m=this.elements;r[0]=m[0];r[1]=m[3];r[2]=m[6];r[3]=m[1];r[4]=m[4];r[5]=m[7];r[6]=m[2];r[7]=m[5];r[8]=m[8];return this;},equals:function equals(matrix){var te=this.elements;var me=matrix.elements;for(var i=0;i<9;i++){if(te[i]!==me[i])return false;}return true;},fromArray:function fromArray(array,offset){if(offset===undefined)offset=0;for(var i=0;i<9;i++){this.elements[i]=array[i+offset];}return this;},toArray:function toArray(array,offset){if(array===undefined)array=[];if(offset===undefined)offset=0;var te=this.elements;array[offset]=te[0];array[offset+1]=te[1];array[offset+2]=te[2];array[offset+3]=te[3];array[offset+4]=te[4];array[offset+5]=te[5];array[offset+6]=te[6];array[offset+7]=te[7];array[offset+8]=te[8];return array;}});/**
		 * @author bhouston / http://clara.io
		 */function Plane(normal,constant){this.normal=normal!==undefined?normal:new Vector3(1,0,0);this.constant=constant!==undefined?constant:0;}_assign(Plane.prototype,{set:function set(normal,constant){this.normal.copy(normal);this.constant=constant;return this;},setComponents:function setComponents(x,y,z,w){this.normal.set(x,y,z);this.constant=w;return this;},setFromNormalAndCoplanarPoint:function setFromNormalAndCoplanarPoint(normal,point){this.normal.copy(normal);this.constant=-point.dot(this.normal);// must be this.normal, not normal, as this.normal is normalized
	return this;},setFromCoplanarPoints:function(){var v1=new Vector3();var v2=new Vector3();return function setFromCoplanarPoints(a,b,c){var normal=v1.subVectors(c,b).cross(v2.subVectors(a,b)).normalize();// Q: should an error be thrown if normal is zero (e.g. degenerate plane)?
	this.setFromNormalAndCoplanarPoint(normal,a);return this;};}(),clone:function clone(){return new this.constructor().copy(this);},copy:function copy(plane){this.normal.copy(plane.normal);this.constant=plane.constant;return this;},normalize:function normalize(){// Note: will lead to a divide by zero if the plane is invalid.
	var inverseNormalLength=1.0/this.normal.length();this.normal.multiplyScalar(inverseNormalLength);this.constant*=inverseNormalLength;return this;},negate:function negate(){this.constant*=-1;this.normal.negate();return this;},distanceToPoint:function distanceToPoint(point){return this.normal.dot(point)+this.constant;},distanceToSphere:function distanceToSphere(sphere){return this.distanceToPoint(sphere.center)-sphere.radius;},projectPoint:function projectPoint(point,optionalTarget){return this.orthoPoint(point,optionalTarget).sub(point).negate();},orthoPoint:function orthoPoint(point,optionalTarget){var perpendicularMagnitude=this.distanceToPoint(point);var result=optionalTarget||new Vector3();return result.copy(this.normal).multiplyScalar(perpendicularMagnitude);},intersectLine:function(){var v1=new Vector3();return function intersectLine(line,optionalTarget){var result=optionalTarget||new Vector3();var direction=line.delta(v1);var denominator=this.normal.dot(direction);if(denominator===0){// line is coplanar, return origin
	if(this.distanceToPoint(line.start)===0){return result.copy(line.start);}// Unsure if this is the correct method to handle this case.
	return undefined;}var t=-(line.start.dot(this.normal)+this.constant)/denominator;if(t<0||t>1){return undefined;}return result.copy(direction).multiplyScalar(t).add(line.start);};}(),intersectsLine:function intersectsLine(line){// Note: this tests if a line intersects the plane, not whether it (or its end-points) are coplanar with it.
	var startSign=this.distanceToPoint(line.start);var endSign=this.distanceToPoint(line.end);return startSign<0&&endSign>0||endSign<0&&startSign>0;},intersectsBox:function intersectsBox(box){return box.intersectsPlane(this);},intersectsSphere:function intersectsSphere(sphere){return sphere.intersectsPlane(this);},coplanarPoint:function coplanarPoint(optionalTarget){var result=optionalTarget||new Vector3();return result.copy(this.normal).multiplyScalar(-this.constant);},applyMatrix4:function(){var v1=new Vector3();var m1=new Matrix3();return function applyMatrix4(matrix,optionalNormalMatrix){var referencePoint=this.coplanarPoint(v1).applyMatrix4(matrix);// transform normal based on theory here:
	// http://www.songho.ca/opengl/gl_normaltransform.html
	var normalMatrix=optionalNormalMatrix||m1.getNormalMatrix(matrix);var normal=this.normal.applyMatrix3(normalMatrix).normalize();// recalculate constant (like in setFromNormalAndCoplanarPoint)
	this.constant=-referencePoint.dot(normal);return this;};}(),translate:function translate(offset){this.constant=this.constant-offset.dot(this.normal);return this;},equals:function equals(plane){return plane.normal.equals(this.normal)&&plane.constant===this.constant;}});/**
		 * @author mrdoob / http://mrdoob.com/
		 * @author alteredq / http://alteredqualia.com/
		 * @author bhouston / http://clara.io
		 */function Frustum(p0,p1,p2,p3,p4,p5){this.planes=[p0!==undefined?p0:new Plane(),p1!==undefined?p1:new Plane(),p2!==undefined?p2:new Plane(),p3!==undefined?p3:new Plane(),p4!==undefined?p4:new Plane(),p5!==undefined?p5:new Plane()];}_assign(Frustum.prototype,{set:function set(p0,p1,p2,p3,p4,p5){var planes=this.planes;planes[0].copy(p0);planes[1].copy(p1);planes[2].copy(p2);planes[3].copy(p3);planes[4].copy(p4);planes[5].copy(p5);return this;},clone:function clone(){return new this.constructor().copy(this);},copy:function copy(frustum){var planes=this.planes;for(var i=0;i<6;i++){planes[i].copy(frustum.planes[i]);}return this;},setFromMatrix:function setFromMatrix(m){var planes=this.planes;var me=m.elements;var me0=me[0],me1=me[1],me2=me[2],me3=me[3];var me4=me[4],me5=me[5],me6=me[6],me7=me[7];var me8=me[8],me9=me[9],me10=me[10],me11=me[11];var me12=me[12],me13=me[13],me14=me[14],me15=me[15];planes[0].setComponents(me3-me0,me7-me4,me11-me8,me15-me12).normalize();planes[1].setComponents(me3+me0,me7+me4,me11+me8,me15+me12).normalize();planes[2].setComponents(me3+me1,me7+me5,me11+me9,me15+me13).normalize();planes[3].setComponents(me3-me1,me7-me5,me11-me9,me15-me13).normalize();planes[4].setComponents(me3-me2,me7-me6,me11-me10,me15-me14).normalize();planes[5].setComponents(me3+me2,me7+me6,me11+me10,me15+me14).normalize();return this;},intersectsObject:function(){var sphere=new Sphere();return function intersectsObject(object){var geometry=object.geometry;if(geometry.boundingSphere===null)geometry.computeBoundingSphere();sphere.copy(geometry.boundingSphere).applyMatrix4(object.matrixWorld);return this.intersectsSphere(sphere);};}(),intersectsSprite:function(){var sphere=new Sphere();return function intersectsSprite(sprite){sphere.center.set(0,0,0);sphere.radius=0.7071067811865476;sphere.applyMatrix4(sprite.matrixWorld);return this.intersectsSphere(sphere);};}(),intersectsSphere:function intersectsSphere(sphere){var planes=this.planes;var center=sphere.center;var negRadius=-sphere.radius;for(var i=0;i<6;i++){var distance=planes[i].distanceToPoint(center);if(distance<negRadius){return false;}}return true;},intersectsBox:function(){var p1=new Vector3(),p2=new Vector3();return function intersectsBox(box){var planes=this.planes;for(var i=0;i<6;i++){var plane=planes[i];p1.x=plane.normal.x>0?box.min.x:box.max.x;p2.x=plane.normal.x>0?box.max.x:box.min.x;p1.y=plane.normal.y>0?box.min.y:box.max.y;p2.y=plane.normal.y>0?box.max.y:box.min.y;p1.z=plane.normal.z>0?box.min.z:box.max.z;p2.z=plane.normal.z>0?box.max.z:box.min.z;var d1=plane.distanceToPoint(p1);var d2=plane.distanceToPoint(p2);// if both outside plane, no intersection
	if(d1<0&&d2<0){return false;}}return true;};}(),containsPoint:function containsPoint(point){var planes=this.planes;for(var i=0;i<6;i++){if(planes[i].distanceToPoint(point)<0){return false;}}return true;}});/**
		 * @author alteredq / http://alteredqualia.com/
		 * @author mrdoob / http://mrdoob.com/
		 */function WebGLShadowMap(_renderer,_lights,_objects,capabilities){var _gl=_renderer.context,_state=_renderer.state,_frustum=new Frustum(),_projScreenMatrix=new Matrix4(),_lightShadows=_lights.shadows,_shadowMapSize=new Vector2(),_maxShadowMapSize=new Vector2(capabilities.maxTextureSize,capabilities.maxTextureSize),_lookTarget=new Vector3(),_lightPositionWorld=new Vector3(),_MorphingFlag=1,_SkinningFlag=2,_NumberOfMaterialVariants=(_MorphingFlag|_SkinningFlag)+1,_depthMaterials=new Array(_NumberOfMaterialVariants),_distanceMaterials=new Array(_NumberOfMaterialVariants),_materialCache={};var cubeDirections=[new Vector3(1,0,0),new Vector3(-1,0,0),new Vector3(0,0,1),new Vector3(0,0,-1),new Vector3(0,1,0),new Vector3(0,-1,0)];var cubeUps=[new Vector3(0,1,0),new Vector3(0,1,0),new Vector3(0,1,0),new Vector3(0,1,0),new Vector3(0,0,1),new Vector3(0,0,-1)];var cube2DViewPorts=[new Vector4(),new Vector4(),new Vector4(),new Vector4(),new Vector4(),new Vector4()];// init
	var depthMaterialTemplate=new MeshDepthMaterial();depthMaterialTemplate.depthPacking=RGBADepthPacking;depthMaterialTemplate.clipping=true;var distanceShader=ShaderLib["distanceRGBA"];var distanceUniforms=UniformsUtils.clone(distanceShader.uniforms);for(var i=0;i!==_NumberOfMaterialVariants;++i){var useMorphing=(i&_MorphingFlag)!==0;var useSkinning=(i&_SkinningFlag)!==0;var depthMaterial=depthMaterialTemplate.clone();depthMaterial.morphTargets=useMorphing;depthMaterial.skinning=useSkinning;_depthMaterials[i]=depthMaterial;var distanceMaterial=new ShaderMaterial({defines:{'USE_SHADOWMAP':''},uniforms:distanceUniforms,vertexShader:distanceShader.vertexShader,fragmentShader:distanceShader.fragmentShader,morphTargets:useMorphing,skinning:useSkinning,clipping:true});_distanceMaterials[i]=distanceMaterial;}//
	var scope=this;this.enabled=false;this.autoUpdate=true;this.needsUpdate=false;this.type=PCFShadowMap;this.renderReverseSided=true;this.renderSingleSided=true;this.render=function(scene,camera){if(scope.enabled===false)return;if(scope.autoUpdate===false&&scope.needsUpdate===false)return;if(_lightShadows.length===0)return;// Set GL state for depth map.
	_state.disable(_gl.BLEND);_state.buffers.color.setClear(1,1,1,1);_state.buffers.depth.setTest(true);_state.setScissorTest(false);// render depth map
	var faceCount,isPointLight;for(var i=0,il=_lightShadows.length;i<il;i++){var light=_lightShadows[i];var shadow=light.shadow;if(shadow===undefined){console.warn('THREE.WebGLShadowMap:',light,'has no shadow.');continue;}var shadowCamera=shadow.camera;_shadowMapSize.copy(shadow.mapSize);_shadowMapSize.min(_maxShadowMapSize);if(light&&light.isPointLight){faceCount=6;isPointLight=true;var vpWidth=_shadowMapSize.x;var vpHeight=_shadowMapSize.y;// These viewports map a cube-map onto a 2D texture with the
	// following orientation:
	//
	//  xzXZ
	//   y Y
	//
	// X - Positive x direction
	// x - Negative x direction
	// Y - Positive y direction
	// y - Negative y direction
	// Z - Positive z direction
	// z - Negative z direction
	// positive X
	cube2DViewPorts[0].set(vpWidth*2,vpHeight,vpWidth,vpHeight);// negative X
	cube2DViewPorts[1].set(0,vpHeight,vpWidth,vpHeight);// positive Z
	cube2DViewPorts[2].set(vpWidth*3,vpHeight,vpWidth,vpHeight);// negative Z
	cube2DViewPorts[3].set(vpWidth,vpHeight,vpWidth,vpHeight);// positive Y
	cube2DViewPorts[4].set(vpWidth*3,0,vpWidth,vpHeight);// negative Y
	cube2DViewPorts[5].set(vpWidth,0,vpWidth,vpHeight);_shadowMapSize.x*=4.0;_shadowMapSize.y*=2.0;}else{faceCount=1;isPointLight=false;}if(shadow.map===null){var pars={minFilter:NearestFilter,magFilter:NearestFilter,format:RGBAFormat};shadow.map=new WebGLRenderTarget(_shadowMapSize.x,_shadowMapSize.y,pars);shadow.map.texture.name=light.name+".shadowMap";shadowCamera.updateProjectionMatrix();}if(shadow.isSpotLightShadow){shadow.update(light);}var shadowMap=shadow.map;var shadowMatrix=shadow.matrix;_lightPositionWorld.setFromMatrixPosition(light.matrixWorld);shadowCamera.position.copy(_lightPositionWorld);_renderer.setRenderTarget(shadowMap);_renderer.clear();// render shadow map for each cube face (if omni-directional) or
	// run a single pass if not
	for(var face=0;face<faceCount;face++){if(isPointLight){_lookTarget.copy(shadowCamera.position);_lookTarget.add(cubeDirections[face]);shadowCamera.up.copy(cubeUps[face]);shadowCamera.lookAt(_lookTarget);var vpDimensions=cube2DViewPorts[face];_state.viewport(vpDimensions);}else{_lookTarget.setFromMatrixPosition(light.target.matrixWorld);shadowCamera.lookAt(_lookTarget);}shadowCamera.updateMatrixWorld();shadowCamera.matrixWorldInverse.getInverse(shadowCamera.matrixWorld);// compute shadow matrix
	shadowMatrix.set(0.5,0.0,0.0,0.5,0.0,0.5,0.0,0.5,0.0,0.0,0.5,0.5,0.0,0.0,0.0,1.0);shadowMatrix.multiply(shadowCamera.projectionMatrix);shadowMatrix.multiply(shadowCamera.matrixWorldInverse);// update camera matrices and frustum
	_projScreenMatrix.multiplyMatrices(shadowCamera.projectionMatrix,shadowCamera.matrixWorldInverse);_frustum.setFromMatrix(_projScreenMatrix);// set object matrices & frustum culling
	renderObject(scene,camera,shadowCamera,isPointLight);}}// Restore GL state.
	var clearColor=_renderer.getClearColor();var clearAlpha=_renderer.getClearAlpha();_renderer.setClearColor(clearColor,clearAlpha);scope.needsUpdate=false;};function getDepthMaterial(object,material,isPointLight,lightPositionWorld){var geometry=object.geometry;var result=null;var materialVariants=_depthMaterials;var customMaterial=object.customDepthMaterial;if(isPointLight){materialVariants=_distanceMaterials;customMaterial=object.customDistanceMaterial;}if(!customMaterial){var useMorphing=false;if(material.morphTargets){if(geometry&&geometry.isBufferGeometry){useMorphing=geometry.morphAttributes&&geometry.morphAttributes.position&&geometry.morphAttributes.position.length>0;}else if(geometry&&geometry.isGeometry){useMorphing=geometry.morphTargets&&geometry.morphTargets.length>0;}}if(object.isSkinnedMesh&&material.skinning===false){console.warn('THREE.WebGLShadowMap: THREE.SkinnedMesh with material.skinning set to false:',object);}var useSkinning=object.isSkinnedMesh&&material.skinning;var variantIndex=0;if(useMorphing)variantIndex|=_MorphingFlag;if(useSkinning)variantIndex|=_SkinningFlag;result=materialVariants[variantIndex];}else{result=customMaterial;}if(_renderer.localClippingEnabled&&material.clipShadows===true&&material.clippingPlanes.length!==0){// in this case we need a unique material instance reflecting the
	// appropriate state
	var keyA=result.uuid,keyB=material.uuid;var materialsForVariant=_materialCache[keyA];if(materialsForVariant===undefined){materialsForVariant={};_materialCache[keyA]=materialsForVariant;}var cachedMaterial=materialsForVariant[keyB];if(cachedMaterial===undefined){cachedMaterial=result.clone();materialsForVariant[keyB]=cachedMaterial;}result=cachedMaterial;}result.visible=material.visible;result.wireframe=material.wireframe;var side=material.side;if(scope.renderSingleSided&&side==DoubleSide){side=FrontSide;}if(scope.renderReverseSided){if(side===FrontSide)side=BackSide;else if(side===BackSide)side=FrontSide;}result.side=side;result.clipShadows=material.clipShadows;result.clippingPlanes=material.clippingPlanes;result.wireframeLinewidth=material.wireframeLinewidth;result.linewidth=material.linewidth;if(isPointLight&&result.uniforms.lightPos!==undefined){result.uniforms.lightPos.value.copy(lightPositionWorld);}return result;}function renderObject(object,camera,shadowCamera,isPointLight){if(object.visible===false)return;var visible=object.layers.test(camera.layers);if(visible&&(object.isMesh||object.isLine||object.isPoints)){if(object.castShadow&&(!object.frustumCulled||_frustum.intersectsObject(object))){object.modelViewMatrix.multiplyMatrices(shadowCamera.matrixWorldInverse,object.matrixWorld);var geometry=_objects.update(object);var material=object.material;if(Array.isArray(material)){var groups=geometry.groups;for(var k=0,kl=groups.length;k<kl;k++){var group=groups[k];var groupMaterial=material[group.materialIndex];if(groupMaterial&&groupMaterial.visible){var depthMaterial=getDepthMaterial(object,groupMaterial,isPointLight,_lightPositionWorld);_renderer.renderBufferDirect(shadowCamera,null,geometry,depthMaterial,object,group);}}}else if(material.visible){var depthMaterial=getDepthMaterial(object,material,isPointLight,_lightPositionWorld);_renderer.renderBufferDirect(shadowCamera,null,geometry,depthMaterial,object,null);}}}var children=object.children;for(var i=0,l=children.length;i<l;i++){renderObject(children[i],camera,shadowCamera,isPointLight);}}}/**
		 * @author bhouston / http://clara.io
		 */function Ray(origin,direction){this.origin=origin!==undefined?origin:new Vector3();this.direction=direction!==undefined?direction:new Vector3();}_assign(Ray.prototype,{set:function set(origin,direction){this.origin.copy(origin);this.direction.copy(direction);return this;},clone:function clone(){return new this.constructor().copy(this);},copy:function copy(ray){this.origin.copy(ray.origin);this.direction.copy(ray.direction);return this;},at:function at(t,optionalTarget){var result=optionalTarget||new Vector3();return result.copy(this.direction).multiplyScalar(t).add(this.origin);},lookAt:function lookAt(v){this.direction.copy(v).sub(this.origin).normalize();return this;},recast:function(){var v1=new Vector3();return function recast(t){this.origin.copy(this.at(t,v1));return this;};}(),closestPointToPoint:function closestPointToPoint(point,optionalTarget){var result=optionalTarget||new Vector3();result.subVectors(point,this.origin);var directionDistance=result.dot(this.direction);if(directionDistance<0){return result.copy(this.origin);}return result.copy(this.direction).multiplyScalar(directionDistance).add(this.origin);},distanceToPoint:function distanceToPoint(point){return Math.sqrt(this.distanceSqToPoint(point));},distanceSqToPoint:function(){var v1=new Vector3();return function distanceSqToPoint(point){var directionDistance=v1.subVectors(point,this.origin).dot(this.direction);// point behind the ray
	if(directionDistance<0){return this.origin.distanceToSquared(point);}v1.copy(this.direction).multiplyScalar(directionDistance).add(this.origin);return v1.distanceToSquared(point);};}(),distanceSqToSegment:function(){var segCenter=new Vector3();var segDir=new Vector3();var diff=new Vector3();return function distanceSqToSegment(v0,v1,optionalPointOnRay,optionalPointOnSegment){// from http://www.geometrictools.com/GTEngine/Include/Mathematics/GteDistRaySegment.h
	// It returns the min distance between the ray and the segment
	// defined by v0 and v1
	// It can also set two optional targets :
	// - The closest point on the ray
	// - The closest point on the segment
	segCenter.copy(v0).add(v1).multiplyScalar(0.5);segDir.copy(v1).sub(v0).normalize();diff.copy(this.origin).sub(segCenter);var segExtent=v0.distanceTo(v1)*0.5;var a01=-this.direction.dot(segDir);var b0=diff.dot(this.direction);var b1=-diff.dot(segDir);var c=diff.lengthSq();var det=Math.abs(1-a01*a01);var s0,s1,sqrDist,extDet;if(det>0){// The ray and segment are not parallel.
	s0=a01*b1-b0;s1=a01*b0-b1;extDet=segExtent*det;if(s0>=0){if(s1>=-extDet){if(s1<=extDet){// region 0
	// Minimum at interior points of ray and segment.
	var invDet=1/det;s0*=invDet;s1*=invDet;sqrDist=s0*(s0+a01*s1+2*b0)+s1*(a01*s0+s1+2*b1)+c;}else{// region 1
	s1=segExtent;s0=Math.max(0,-(a01*s1+b0));sqrDist=-s0*s0+s1*(s1+2*b1)+c;}}else{// region 5
	s1=-segExtent;s0=Math.max(0,-(a01*s1+b0));sqrDist=-s0*s0+s1*(s1+2*b1)+c;}}else{if(s1<=-extDet){// region 4
	s0=Math.max(0,-(-a01*segExtent+b0));s1=s0>0?-segExtent:Math.min(Math.max(-segExtent,-b1),segExtent);sqrDist=-s0*s0+s1*(s1+2*b1)+c;}else if(s1<=extDet){// region 3
	s0=0;s1=Math.min(Math.max(-segExtent,-b1),segExtent);sqrDist=s1*(s1+2*b1)+c;}else{// region 2
	s0=Math.max(0,-(a01*segExtent+b0));s1=s0>0?segExtent:Math.min(Math.max(-segExtent,-b1),segExtent);sqrDist=-s0*s0+s1*(s1+2*b1)+c;}}}else{// Ray and segment are parallel.
	s1=a01>0?-segExtent:segExtent;s0=Math.max(0,-(a01*s1+b0));sqrDist=-s0*s0+s1*(s1+2*b1)+c;}if(optionalPointOnRay){optionalPointOnRay.copy(this.direction).multiplyScalar(s0).add(this.origin);}if(optionalPointOnSegment){optionalPointOnSegment.copy(segDir).multiplyScalar(s1).add(segCenter);}return sqrDist;};}(),intersectSphere:function(){var v1=new Vector3();return function intersectSphere(sphere,optionalTarget){v1.subVectors(sphere.center,this.origin);var tca=v1.dot(this.direction);var d2=v1.dot(v1)-tca*tca;var radius2=sphere.radius*sphere.radius;if(d2>radius2)return null;var thc=Math.sqrt(radius2-d2);// t0 = first intersect point - entrance on front of sphere
	var t0=tca-thc;// t1 = second intersect point - exit point on back of sphere
	var t1=tca+thc;// test to see if both t0 and t1 are behind the ray - if so, return null
	if(t0<0&&t1<0)return null;// test to see if t0 is behind the ray:
	// if it is, the ray is inside the sphere, so return the second exit point scaled by t1,
	// in order to always return an intersect point that is in front of the ray.
	if(t0<0)return this.at(t1,optionalTarget);// else t0 is in front of the ray, so return the first collision point scaled by t0
	return this.at(t0,optionalTarget);};}(),intersectsSphere:function intersectsSphere(sphere){return this.distanceToPoint(sphere.center)<=sphere.radius;},distanceToPlane:function distanceToPlane(plane){var denominator=plane.normal.dot(this.direction);if(denominator===0){// line is coplanar, return origin
	if(plane.distanceToPoint(this.origin)===0){return 0;}// Null is preferable to undefined since undefined means.... it is undefined
	return null;}var t=-(this.origin.dot(plane.normal)+plane.constant)/denominator;// Return if the ray never intersects the plane
	return t>=0?t:null;},intersectPlane:function intersectPlane(plane,optionalTarget){var t=this.distanceToPlane(plane);if(t===null){return null;}return this.at(t,optionalTarget);},intersectsPlane:function intersectsPlane(plane){// check if the ray lies on the plane first
	var distToPoint=plane.distanceToPoint(this.origin);if(distToPoint===0){return true;}var denominator=plane.normal.dot(this.direction);if(denominator*distToPoint<0){return true;}// ray origin is behind the plane (and is pointing behind it)
	return false;},intersectBox:function intersectBox(box,optionalTarget){var tmin,tmax,tymin,tymax,tzmin,tzmax;var invdirx=1/this.direction.x,invdiry=1/this.direction.y,invdirz=1/this.direction.z;var origin=this.origin;if(invdirx>=0){tmin=(box.min.x-origin.x)*invdirx;tmax=(box.max.x-origin.x)*invdirx;}else{tmin=(box.max.x-origin.x)*invdirx;tmax=(box.min.x-origin.x)*invdirx;}if(invdiry>=0){tymin=(box.min.y-origin.y)*invdiry;tymax=(box.max.y-origin.y)*invdiry;}else{tymin=(box.max.y-origin.y)*invdiry;tymax=(box.min.y-origin.y)*invdiry;}if(tmin>tymax||tymin>tmax)return null;// These lines also handle the case where tmin or tmax is NaN
	// (result of 0 * Infinity). x !== x returns true if x is NaN
	if(tymin>tmin||tmin!==tmin)tmin=tymin;if(tymax<tmax||tmax!==tmax)tmax=tymax;if(invdirz>=0){tzmin=(box.min.z-origin.z)*invdirz;tzmax=(box.max.z-origin.z)*invdirz;}else{tzmin=(box.max.z-origin.z)*invdirz;tzmax=(box.min.z-origin.z)*invdirz;}if(tmin>tzmax||tzmin>tmax)return null;if(tzmin>tmin||tmin!==tmin)tmin=tzmin;if(tzmax<tmax||tmax!==tmax)tmax=tzmax;//return point closest to the ray (positive side)
	if(tmax<0)return null;return this.at(tmin>=0?tmin:tmax,optionalTarget);},intersectsBox:function(){var v=new Vector3();return function intersectsBox(box){return this.intersectBox(box,v)!==null;};}(),intersectTriangle:function(){// Compute the offset origin, edges, and normal.
	var diff=new Vector3();var edge1=new Vector3();var edge2=new Vector3();var normal=new Vector3();return function intersectTriangle(a,b,c,backfaceCulling,optionalTarget){// from http://www.geometrictools.com/GTEngine/Include/Mathematics/GteIntrRay3Triangle3.h
	edge1.subVectors(b,a);edge2.subVectors(c,a);normal.crossVectors(edge1,edge2);// Solve Q + t*D = b1*E1 + b2*E2 (Q = kDiff, D = ray direction,
	// E1 = kEdge1, E2 = kEdge2, N = Cross(E1,E2)) by
	//   |Dot(D,N)|*b1 = sign(Dot(D,N))*Dot(D,Cross(Q,E2))
	//   |Dot(D,N)|*b2 = sign(Dot(D,N))*Dot(D,Cross(E1,Q))
	//   |Dot(D,N)|*t = -sign(Dot(D,N))*Dot(Q,N)
	var DdN=this.direction.dot(normal);var sign;if(DdN>0){if(backfaceCulling)return null;sign=1;}else if(DdN<0){sign=-1;DdN=-DdN;}else{return null;}diff.subVectors(this.origin,a);var DdQxE2=sign*this.direction.dot(edge2.crossVectors(diff,edge2));// b1 < 0, no intersection
	if(DdQxE2<0){return null;}var DdE1xQ=sign*this.direction.dot(edge1.cross(diff));// b2 < 0, no intersection
	if(DdE1xQ<0){return null;}// b1+b2 > 1, no intersection
	if(DdQxE2+DdE1xQ>DdN){return null;}// Line intersects triangle, check if ray does.
	var QdN=-sign*diff.dot(normal);// t < 0, no intersection
	if(QdN<0){return null;}// Ray intersects triangle.
	return this.at(QdN/DdN,optionalTarget);};}(),applyMatrix4:function applyMatrix4(matrix4){this.direction.add(this.origin).applyMatrix4(matrix4);this.origin.applyMatrix4(matrix4);this.direction.sub(this.origin);this.direction.normalize();return this;},equals:function equals(ray){return ray.origin.equals(this.origin)&&ray.direction.equals(this.direction);}});/**
		 * @author mrdoob / http://mrdoob.com/
		 * @author WestLangley / http://github.com/WestLangley
		 * @author bhouston / http://clara.io
		 */function Euler(x,y,z,order){this._x=x||0;this._y=y||0;this._z=z||0;this._order=order||Euler.DefaultOrder;}Euler.RotationOrders=['XYZ','YZX','ZXY','XZY','YXZ','ZYX'];Euler.DefaultOrder='XYZ';Object.defineProperties(Euler.prototype,{x:{get:function get(){return this._x;},set:function set(value){this._x=value;this.onChangeCallback();}},y:{get:function get(){return this._y;},set:function set(value){this._y=value;this.onChangeCallback();}},z:{get:function get(){return this._z;},set:function set(value){this._z=value;this.onChangeCallback();}},order:{get:function get(){return this._order;},set:function set(value){this._order=value;this.onChangeCallback();}}});_assign(Euler.prototype,{isEuler:true,set:function set(x,y,z,order){this._x=x;this._y=y;this._z=z;this._order=order||this._order;this.onChangeCallback();return this;},clone:function clone(){return new this.constructor(this._x,this._y,this._z,this._order);},copy:function copy(euler){this._x=euler._x;this._y=euler._y;this._z=euler._z;this._order=euler._order;this.onChangeCallback();return this;},setFromRotationMatrix:function setFromRotationMatrix(m,order,update){var clamp=_Math.clamp;// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)
	var te=m.elements;var m11=te[0],m12=te[4],m13=te[8];var m21=te[1],m22=te[5],m23=te[9];var m31=te[2],m32=te[6],m33=te[10];order=order||this._order;if(order==='XYZ'){this._y=Math.asin(clamp(m13,-1,1));if(Math.abs(m13)<0.99999){this._x=Math.atan2(-m23,m33);this._z=Math.atan2(-m12,m11);}else{this._x=Math.atan2(m32,m22);this._z=0;}}else if(order==='YXZ'){this._x=Math.asin(-clamp(m23,-1,1));if(Math.abs(m23)<0.99999){this._y=Math.atan2(m13,m33);this._z=Math.atan2(m21,m22);}else{this._y=Math.atan2(-m31,m11);this._z=0;}}else if(order==='ZXY'){this._x=Math.asin(clamp(m32,-1,1));if(Math.abs(m32)<0.99999){this._y=Math.atan2(-m31,m33);this._z=Math.atan2(-m12,m22);}else{this._y=0;this._z=Math.atan2(m21,m11);}}else if(order==='ZYX'){this._y=Math.asin(-clamp(m31,-1,1));if(Math.abs(m31)<0.99999){this._x=Math.atan2(m32,m33);this._z=Math.atan2(m21,m11);}else{this._x=0;this._z=Math.atan2(-m12,m22);}}else if(order==='YZX'){this._z=Math.asin(clamp(m21,-1,1));if(Math.abs(m21)<0.99999){this._x=Math.atan2(-m23,m22);this._y=Math.atan2(-m31,m11);}else{this._x=0;this._y=Math.atan2(m13,m33);}}else if(order==='XZY'){this._z=Math.asin(-clamp(m12,-1,1));if(Math.abs(m12)<0.99999){this._x=Math.atan2(m32,m22);this._y=Math.atan2(m13,m11);}else{this._x=Math.atan2(-m23,m33);this._y=0;}}else{console.warn('THREE.Euler: .setFromRotationMatrix() given unsupported order: '+order);}this._order=order;if(update!==false)this.onChangeCallback();return this;},setFromQuaternion:function(){var matrix=new Matrix4();return function setFromQuaternion(q,order,update){matrix.makeRotationFromQuaternion(q);return this.setFromRotationMatrix(matrix,order,update);};}(),setFromVector3:function setFromVector3(v,order){return this.set(v.x,v.y,v.z,order||this._order);},reorder:function(){// WARNING: this discards revolution information -bhouston
	var q=new Quaternion();return function reorder(newOrder){q.setFromEuler(this);return this.setFromQuaternion(q,newOrder);};}(),equals:function equals(euler){return euler._x===this._x&&euler._y===this._y&&euler._z===this._z&&euler._order===this._order;},fromArray:function fromArray(array){this._x=array[0];this._y=array[1];this._z=array[2];if(array[3]!==undefined)this._order=array[3];this.onChangeCallback();return this;},toArray:function toArray(array,offset){if(array===undefined)array=[];if(offset===undefined)offset=0;array[offset]=this._x;array[offset+1]=this._y;array[offset+2]=this._z;array[offset+3]=this._order;return array;},toVector3:function toVector3(optionalResult){if(optionalResult){return optionalResult.set(this._x,this._y,this._z);}else{return new Vector3(this._x,this._y,this._z);}},onChange:function onChange(callback){this.onChangeCallback=callback;return this;},onChangeCallback:function onChangeCallback(){}});/**
		 * @author mrdoob / http://mrdoob.com/
		 */function Layers(){this.mask=1|0;}_assign(Layers.prototype,{set:function set(channel){this.mask=1<<channel|0;},enable:function enable(channel){this.mask|=1<<channel|0;},toggle:function toggle(channel){this.mask^=1<<channel|0;},disable:function disable(channel){this.mask&=~(1<<channel|0);},test:function test(layers){return(this.mask&layers.mask)!==0;}});/**
		 * @author mrdoob / http://mrdoob.com/
		 * @author mikael emtinger / http://gomo.se/
		 * @author alteredq / http://alteredqualia.com/
		 * @author WestLangley / http://github.com/WestLangley
		 * @author elephantatwork / www.elephantatwork.ch
		 */var object3DId=0;function Object3D(){Object.defineProperty(this,'id',{value:object3DId++});this.uuid=_Math.generateUUID();this.name='';this.type='Object3D';this.parent=null;this.children=[];this.up=Object3D.DefaultUp.clone();var position=new Vector3();var rotation=new Euler();var quaternion=new Quaternion();var scale=new Vector3(1,1,1);function onRotationChange(){quaternion.setFromEuler(rotation,false);}function onQuaternionChange(){rotation.setFromQuaternion(quaternion,undefined,false);}rotation.onChange(onRotationChange);quaternion.onChange(onQuaternionChange);Object.defineProperties(this,{position:{enumerable:true,value:position},rotation:{enumerable:true,value:rotation},quaternion:{enumerable:true,value:quaternion},scale:{enumerable:true,value:scale},modelViewMatrix:{value:new Matrix4()},normalMatrix:{value:new Matrix3()}});this.matrix=new Matrix4();this.matrixWorld=new Matrix4();this.matrixAutoUpdate=Object3D.DefaultMatrixAutoUpdate;this.matrixWorldNeedsUpdate=false;this.layers=new Layers();this.visible=true;this.castShadow=false;this.receiveShadow=false;this.frustumCulled=true;this.renderOrder=0;this.userData={};this.onBeforeRender=function(){};this.onAfterRender=function(){};}Object3D.DefaultUp=new Vector3(0,1,0);Object3D.DefaultMatrixAutoUpdate=true;_assign(Object3D.prototype,EventDispatcher.prototype,{isObject3D:true,applyMatrix:function applyMatrix(matrix){this.matrix.multiplyMatrices(matrix,this.matrix);this.matrix.decompose(this.position,this.quaternion,this.scale);},setRotationFromAxisAngle:function setRotationFromAxisAngle(axis,angle){// assumes axis is normalized
	this.quaternion.setFromAxisAngle(axis,angle);},setRotationFromEuler:function setRotationFromEuler(euler){this.quaternion.setFromEuler(euler,true);},setRotationFromMatrix:function setRotationFromMatrix(m){// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)
	this.quaternion.setFromRotationMatrix(m);},setRotationFromQuaternion:function setRotationFromQuaternion(q){// assumes q is normalized
	this.quaternion.copy(q);},rotateOnAxis:function(){// rotate object on axis in object space
	// axis is assumed to be normalized
	var q1=new Quaternion();return function rotateOnAxis(axis,angle){q1.setFromAxisAngle(axis,angle);this.quaternion.multiply(q1);return this;};}(),rotateX:function(){var v1=new Vector3(1,0,0);return function rotateX(angle){return this.rotateOnAxis(v1,angle);};}(),rotateY:function(){var v1=new Vector3(0,1,0);return function rotateY(angle){return this.rotateOnAxis(v1,angle);};}(),rotateZ:function(){var v1=new Vector3(0,0,1);return function rotateZ(angle){return this.rotateOnAxis(v1,angle);};}(),translateOnAxis:function(){// translate object by distance along axis in object space
	// axis is assumed to be normalized
	var v1=new Vector3();return function translateOnAxis(axis,distance){v1.copy(axis).applyQuaternion(this.quaternion);this.position.add(v1.multiplyScalar(distance));return this;};}(),translateX:function(){var v1=new Vector3(1,0,0);return function translateX(distance){return this.translateOnAxis(v1,distance);};}(),translateY:function(){var v1=new Vector3(0,1,0);return function translateY(distance){return this.translateOnAxis(v1,distance);};}(),translateZ:function(){var v1=new Vector3(0,0,1);return function translateZ(distance){return this.translateOnAxis(v1,distance);};}(),localToWorld:function localToWorld(vector){return vector.applyMatrix4(this.matrixWorld);},worldToLocal:function(){var m1=new Matrix4();return function worldToLocal(vector){return vector.applyMatrix4(m1.getInverse(this.matrixWorld));};}(),lookAt:function(){// This routine does not support objects with rotated and/or translated parent(s)
	var m1=new Matrix4();return function lookAt(vector){if(this.isCamera){m1.lookAt(this.position,vector,this.up);}else{m1.lookAt(vector,this.position,this.up);}this.quaternion.setFromRotationMatrix(m1);};}(),add:function add(object){if(arguments.length>1){for(var i=0;i<arguments.length;i++){this.add(arguments[i]);}return this;}if(object===this){console.error("THREE.Object3D.add: object can't be added as a child of itself.",object);return this;}if(object&&object.isObject3D){if(object.parent!==null){object.parent.remove(object);}object.parent=this;object.dispatchEvent({type:'added'});this.children.push(object);}else{console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.",object);}return this;},remove:function remove(object){if(arguments.length>1){for(var i=0;i<arguments.length;i++){this.remove(arguments[i]);}}var index=this.children.indexOf(object);if(index!==-1){object.parent=null;object.dispatchEvent({type:'removed'});this.children.splice(index,1);}},getObjectById:function getObjectById(id){return this.getObjectByProperty('id',id);},getObjectByName:function getObjectByName(name){return this.getObjectByProperty('name',name);},getObjectByProperty:function getObjectByProperty(name,value){if(this[name]===value)return this;for(var i=0,l=this.children.length;i<l;i++){var child=this.children[i];var object=child.getObjectByProperty(name,value);if(object!==undefined){return object;}}return undefined;},getWorldPosition:function getWorldPosition(optionalTarget){var result=optionalTarget||new Vector3();this.updateMatrixWorld(true);return result.setFromMatrixPosition(this.matrixWorld);},getWorldQuaternion:function(){var position=new Vector3();var scale=new Vector3();return function getWorldQuaternion(optionalTarget){var result=optionalTarget||new Quaternion();this.updateMatrixWorld(true);this.matrixWorld.decompose(position,result,scale);return result;};}(),getWorldRotation:function(){var quaternion=new Quaternion();return function getWorldRotation(optionalTarget){var result=optionalTarget||new Euler();this.getWorldQuaternion(quaternion);return result.setFromQuaternion(quaternion,this.rotation.order,false);};}(),getWorldScale:function(){var position=new Vector3();var quaternion=new Quaternion();return function getWorldScale(optionalTarget){var result=optionalTarget||new Vector3();this.updateMatrixWorld(true);this.matrixWorld.decompose(position,quaternion,result);return result;};}(),getWorldDirection:function(){var quaternion=new Quaternion();return function getWorldDirection(optionalTarget){var result=optionalTarget||new Vector3();this.getWorldQuaternion(quaternion);return result.set(0,0,1).applyQuaternion(quaternion);};}(),raycast:function raycast(){},traverse:function traverse(callback){callback(this);var children=this.children;for(var i=0,l=children.length;i<l;i++){children[i].traverse(callback);}},traverseVisible:function traverseVisible(callback){if(this.visible===false)return;callback(this);var children=this.children;for(var i=0,l=children.length;i<l;i++){children[i].traverseVisible(callback);}},traverseAncestors:function traverseAncestors(callback){var parent=this.parent;if(parent!==null){callback(parent);parent.traverseAncestors(callback);}},updateMatrix:function updateMatrix(){this.matrix.compose(this.position,this.quaternion,this.scale);this.matrixWorldNeedsUpdate=true;},updateMatrixWorld:function updateMatrixWorld(force){if(this.matrixAutoUpdate)this.updateMatrix();if(this.matrixWorldNeedsUpdate||force){if(this.parent===null){this.matrixWorld.copy(this.matrix);}else{this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix);}this.matrixWorldNeedsUpdate=false;force=true;}// update children
	var children=this.children;for(var i=0,l=children.length;i<l;i++){children[i].updateMatrixWorld(force);}},toJSON:function toJSON(meta){// meta is '' when called from JSON.stringify
	var isRootObject=meta===undefined||meta==='';var output={};// meta is a hash used to collect geometries, materials.
	// not providing it implies that this is the root object
	// being serialized.
	if(isRootObject){// initialize meta obj
	meta={geometries:{},materials:{},textures:{},images:{}};output.metadata={version:4.5,type:'Object',generator:'Object3D.toJSON'};}// standard Object3D serialization
	var object={};object.uuid=this.uuid;object.type=this.type;if(this.name!=='')object.name=this.name;if(JSON.stringify(this.userData)!=='{}')object.userData=this.userData;if(this.castShadow===true)object.castShadow=true;if(this.receiveShadow===true)object.receiveShadow=true;if(this.visible===false)object.visible=false;object.matrix=this.matrix.toArray();//
	function serialize(library,element){if(library[element.uuid]===undefined){library[element.uuid]=element.toJSON(meta);}return element.uuid;}if(this.geometry!==undefined){object.geometry=serialize(meta.geometries,this.geometry);}if(this.material!==undefined){if(Array.isArray(this.material)){var uuids=[];for(var i=0,l=this.material.length;i<l;i++){uuids.push(serialize(meta.materials,this.material[i]));}object.material=uuids;}else{object.material=serialize(meta.materials,this.material);}}//
	if(this.children.length>0){object.children=[];for(var i=0;i<this.children.length;i++){object.children.push(this.children[i].toJSON(meta).object);}}if(isRootObject){var geometries=extractFromCache(meta.geometries);var materials=extractFromCache(meta.materials);var textures=extractFromCache(meta.textures);var images=extractFromCache(meta.images);if(geometries.length>0)output.geometries=geometries;if(materials.length>0)output.materials=materials;if(textures.length>0)output.textures=textures;if(images.length>0)output.images=images;}output.object=object;return output;// extract data from the cache hash
	// remove metadata on each item
	// and return as array
	function extractFromCache(cache){var values=[];for(var key in cache){var data=cache[key];delete data.metadata;values.push(data);}return values;}},clone:function clone(recursive){return new this.constructor().copy(this,recursive);},copy:function copy(source,recursive){if(recursive===undefined)recursive=true;this.name=source.name;this.up.copy(source.up);this.position.copy(source.position);this.quaternion.copy(source.quaternion);this.scale.copy(source.scale);this.matrix.copy(source.matrix);this.matrixWorld.copy(source.matrixWorld);this.matrixAutoUpdate=source.matrixAutoUpdate;this.matrixWorldNeedsUpdate=source.matrixWorldNeedsUpdate;this.layers.mask=source.layers.mask;this.visible=source.visible;this.castShadow=source.castShadow;this.receiveShadow=source.receiveShadow;this.frustumCulled=source.frustumCulled;this.renderOrder=source.renderOrder;this.userData=JSON.parse(JSON.stringify(source.userData));if(recursive===true){for(var i=0;i<source.children.length;i++){var child=source.children[i];this.add(child.clone());}}return this;}});/**
		 * @author bhouston / http://clara.io
		 */function Line3(start,end){this.start=start!==undefined?start:new Vector3();this.end=end!==undefined?end:new Vector3();}_assign(Line3.prototype,{set:function set(start,end){this.start.copy(start);this.end.copy(end);return this;},clone:function clone(){return new this.constructor().copy(this);},copy:function copy(line){this.start.copy(line.start);this.end.copy(line.end);return this;},getCenter:function getCenter(optionalTarget){var result=optionalTarget||new Vector3();return result.addVectors(this.start,this.end).multiplyScalar(0.5);},delta:function delta(optionalTarget){var result=optionalTarget||new Vector3();return result.subVectors(this.end,this.start);},distanceSq:function distanceSq(){return this.start.distanceToSquared(this.end);},distance:function distance(){return this.start.distanceTo(this.end);},at:function at(t,optionalTarget){var result=optionalTarget||new Vector3();return this.delta(result).multiplyScalar(t).add(this.start);},closestPointToPointParameter:function(){var startP=new Vector3();var startEnd=new Vector3();return function closestPointToPointParameter(point,clampToLine){startP.subVectors(point,this.start);startEnd.subVectors(this.end,this.start);var startEnd2=startEnd.dot(startEnd);var startEnd_startP=startEnd.dot(startP);var t=startEnd_startP/startEnd2;if(clampToLine){t=_Math.clamp(t,0,1);}return t;};}(),closestPointToPoint:function closestPointToPoint(point,clampToLine,optionalTarget){var t=this.closestPointToPointParameter(point,clampToLine);var result=optionalTarget||new Vector3();return this.delta(result).multiplyScalar(t).add(this.start);},applyMatrix4:function applyMatrix4(matrix){this.start.applyMatrix4(matrix);this.end.applyMatrix4(matrix);return this;},equals:function equals(line){return line.start.equals(this.start)&&line.end.equals(this.end);}});/**
		 * @author bhouston / http://clara.io
		 * @author mrdoob / http://mrdoob.com/
		 */function Triangle(a,b,c){this.a=a!==undefined?a:new Vector3();this.b=b!==undefined?b:new Vector3();this.c=c!==undefined?c:new Vector3();}_assign(Triangle,{normal:function(){var v0=new Vector3();return function normal(a,b,c,optionalTarget){var result=optionalTarget||new Vector3();result.subVectors(c,b);v0.subVectors(a,b);result.cross(v0);var resultLengthSq=result.lengthSq();if(resultLengthSq>0){return result.multiplyScalar(1/Math.sqrt(resultLengthSq));}return result.set(0,0,0);};}(),// static/instance method to calculate barycentric coordinates
	// based on: http://www.blackpawn.com/texts/pointinpoly/default.html
	barycoordFromPoint:function(){var v0=new Vector3();var v1=new Vector3();var v2=new Vector3();return function barycoordFromPoint(point,a,b,c,optionalTarget){v0.subVectors(c,a);v1.subVectors(b,a);v2.subVectors(point,a);var dot00=v0.dot(v0);var dot01=v0.dot(v1);var dot02=v0.dot(v2);var dot11=v1.dot(v1);var dot12=v1.dot(v2);var denom=dot00*dot11-dot01*dot01;var result=optionalTarget||new Vector3();// collinear or singular triangle
	if(denom===0){// arbitrary location outside of triangle?
	// not sure if this is the best idea, maybe should be returning undefined
	return result.set(-2,-1,-1);}var invDenom=1/denom;var u=(dot11*dot02-dot01*dot12)*invDenom;var v=(dot00*dot12-dot01*dot02)*invDenom;// barycentric coordinates must always sum to 1
	return result.set(1-u-v,v,u);};}(),containsPoint:function(){var v1=new Vector3();return function containsPoint(point,a,b,c){var result=Triangle.barycoordFromPoint(point,a,b,c,v1);return result.x>=0&&result.y>=0&&result.x+result.y<=1;};}()});_assign(Triangle.prototype,{set:function set(a,b,c){this.a.copy(a);this.b.copy(b);this.c.copy(c);return this;},setFromPointsAndIndices:function setFromPointsAndIndices(points,i0,i1,i2){this.a.copy(points[i0]);this.b.copy(points[i1]);this.c.copy(points[i2]);return this;},clone:function clone(){return new this.constructor().copy(this);},copy:function copy(triangle){this.a.copy(triangle.a);this.b.copy(triangle.b);this.c.copy(triangle.c);return this;},area:function(){var v0=new Vector3();var v1=new Vector3();return function area(){v0.subVectors(this.c,this.b);v1.subVectors(this.a,this.b);return v0.cross(v1).length()*0.5;};}(),midpoint:function midpoint(optionalTarget){var result=optionalTarget||new Vector3();return result.addVectors(this.a,this.b).add(this.c).multiplyScalar(1/3);},normal:function normal(optionalTarget){return Triangle.normal(this.a,this.b,this.c,optionalTarget);},plane:function plane(optionalTarget){var result=optionalTarget||new Plane();return result.setFromCoplanarPoints(this.a,this.b,this.c);},barycoordFromPoint:function barycoordFromPoint(point,optionalTarget){return Triangle.barycoordFromPoint(point,this.a,this.b,this.c,optionalTarget);},containsPoint:function containsPoint(point){return Triangle.containsPoint(point,this.a,this.b,this.c);},closestPointToPoint:function(){var plane=new Plane();var edgeList=[new Line3(),new Line3(),new Line3()];var projectedPoint=new Vector3();var closestPoint=new Vector3();return function closestPointToPoint(point,optionalTarget){var result=optionalTarget||new Vector3();var minDistance=Infinity;// project the point onto the plane of the triangle
	plane.setFromCoplanarPoints(this.a,this.b,this.c);plane.projectPoint(point,projectedPoint);// check if the projection lies within the triangle
	if(this.containsPoint(projectedPoint)===true){// if so, this is the closest point
	result.copy(projectedPoint);}else{// if not, the point falls outside the triangle. the result is the closest point to the triangle's edges or vertices
	edgeList[0].set(this.a,this.b);edgeList[1].set(this.b,this.c);edgeList[2].set(this.c,this.a);for(var i=0;i<edgeList.length;i++){edgeList[i].closestPointToPoint(projectedPoint,true,closestPoint);var distance=projectedPoint.distanceToSquared(closestPoint);if(distance<minDistance){minDistance=distance;result.copy(closestPoint);}}}return result;};}(),equals:function equals(triangle){return triangle.a.equals(this.a)&&triangle.b.equals(this.b)&&triangle.c.equals(this.c);}});/**
		 * @author mrdoob / http://mrdoob.com/
		 * @author alteredq / http://alteredqualia.com/
		 */function Face3(a,b,c,normal,color,materialIndex){this.a=a;this.b=b;this.c=c;this.normal=normal&&normal.isVector3?normal:new Vector3();this.vertexNormals=Array.isArray(normal)?normal:[];this.color=color&&color.isColor?color:new Color();this.vertexColors=Array.isArray(color)?color:[];this.materialIndex=materialIndex!==undefined?materialIndex:0;}_assign(Face3.prototype,{clone:function clone(){return new this.constructor().copy(this);},copy:function copy(source){this.a=source.a;this.b=source.b;this.c=source.c;this.normal.copy(source.normal);this.color.copy(source.color);this.materialIndex=source.materialIndex;for(var i=0,il=source.vertexNormals.length;i<il;i++){this.vertexNormals[i]=source.vertexNormals[i].clone();}for(var i=0,il=source.vertexColors.length;i<il;i++){this.vertexColors[i]=source.vertexColors[i].clone();}return this;}});/**
		 * @author mrdoob / http://mrdoob.com/
		 * @author alteredq / http://alteredqualia.com/
		 *
		 * parameters = {
		 *  color: <hex>,
		 *  opacity: <float>,
		 *  map: new THREE.Texture( <Image> ),
		 *
		 *  lightMap: new THREE.Texture( <Image> ),
		 *  lightMapIntensity: <float>
		 *
		 *  aoMap: new THREE.Texture( <Image> ),
		 *  aoMapIntensity: <float>
		 *
		 *  specularMap: new THREE.Texture( <Image> ),
		 *
		 *  alphaMap: new THREE.Texture( <Image> ),
		 *
		 *  envMap: new THREE.TextureCube( [posx, negx, posy, negy, posz, negz] ),
		 *  combine: THREE.Multiply,
		 *  reflectivity: <float>,
		 *  refractionRatio: <float>,
		 *
		 *  shading: THREE.SmoothShading,
		 *  depthTest: <bool>,
		 *  depthWrite: <bool>,
		 *
		 *  wireframe: <boolean>,
		 *  wireframeLinewidth: <float>,
		 *
		 *  skinning: <bool>,
		 *  morphTargets: <bool>
		 * }
		 */function MeshBasicMaterial(parameters){Material.call(this);this.type='MeshBasicMaterial';this.color=new Color(0xffffff);// emissive
	this.map=null;this.lightMap=null;this.lightMapIntensity=1.0;this.aoMap=null;this.aoMapIntensity=1.0;this.specularMap=null;this.alphaMap=null;this.envMap=null;this.combine=MultiplyOperation;this.reflectivity=1;this.refractionRatio=0.98;this.wireframe=false;this.wireframeLinewidth=1;this.wireframeLinecap='round';this.wireframeLinejoin='round';this.skinning=false;this.morphTargets=false;this.lights=false;this.setValues(parameters);}MeshBasicMaterial.prototype=Object.create(Material.prototype);MeshBasicMaterial.prototype.constructor=MeshBasicMaterial;MeshBasicMaterial.prototype.isMeshBasicMaterial=true;MeshBasicMaterial.prototype.copy=function(source){Material.prototype.copy.call(this,source);this.color.copy(source.color);this.map=source.map;this.lightMap=source.lightMap;this.lightMapIntensity=source.lightMapIntensity;this.aoMap=source.aoMap;this.aoMapIntensity=source.aoMapIntensity;this.specularMap=source.specularMap;this.alphaMap=source.alphaMap;this.envMap=source.envMap;this.combine=source.combine;this.reflectivity=source.reflectivity;this.refractionRatio=source.refractionRatio;this.wireframe=source.wireframe;this.wireframeLinewidth=source.wireframeLinewidth;this.wireframeLinecap=source.wireframeLinecap;this.wireframeLinejoin=source.wireframeLinejoin;this.skinning=source.skinning;this.morphTargets=source.morphTargets;return this;};/**
		 * @author mrdoob / http://mrdoob.com/
		 */function BufferAttribute(array,itemSize,normalized){if(Array.isArray(array)){throw new TypeError('THREE.BufferAttribute: array should be a Typed Array.');}this.uuid=_Math.generateUUID();this.array=array;this.itemSize=itemSize;this.count=array!==undefined?array.length/itemSize:0;this.normalized=normalized===true;this.dynamic=false;this.updateRange={offset:0,count:-1};this.onUploadCallback=function(){};this.version=0;}Object.defineProperty(BufferAttribute.prototype,'needsUpdate',{set:function set(value){if(value===true)this.version++;}});_assign(BufferAttribute.prototype,{isBufferAttribute:true,setArray:function setArray(array){if(Array.isArray(array)){throw new TypeError('THREE.BufferAttribute: array should be a Typed Array.');}this.count=array!==undefined?array.length/this.itemSize:0;this.array=array;},setDynamic:function setDynamic(value){this.dynamic=value;return this;},copy:function copy(source){this.array=new source.array.constructor(source.array);this.itemSize=source.itemSize;this.count=source.count;this.normalized=source.normalized;this.dynamic=source.dynamic;return this;},copyAt:function copyAt(index1,attribute,index2){index1*=this.itemSize;index2*=attribute.itemSize;for(var i=0,l=this.itemSize;i<l;i++){this.array[index1+i]=attribute.array[index2+i];}return this;},copyArray:function copyArray(array){this.array.set(array);return this;},copyColorsArray:function copyColorsArray(colors){var array=this.array,offset=0;for(var i=0,l=colors.length;i<l;i++){var color=colors[i];if(color===undefined){console.warn('THREE.BufferAttribute.copyColorsArray(): color is undefined',i);color=new Color();}array[offset++]=color.r;array[offset++]=color.g;array[offset++]=color.b;}return this;},copyIndicesArray:function copyIndicesArray(indices){var array=this.array,offset=0;for(var i=0,l=indices.length;i<l;i++){var index=indices[i];array[offset++]=index.a;array[offset++]=index.b;array[offset++]=index.c;}return this;},copyVector2sArray:function copyVector2sArray(vectors){var array=this.array,offset=0;for(var i=0,l=vectors.length;i<l;i++){var vector=vectors[i];if(vector===undefined){console.warn('THREE.BufferAttribute.copyVector2sArray(): vector is undefined',i);vector=new Vector2();}array[offset++]=vector.x;array[offset++]=vector.y;}return this;},copyVector3sArray:function copyVector3sArray(vectors){var array=this.array,offset=0;for(var i=0,l=vectors.length;i<l;i++){var vector=vectors[i];if(vector===undefined){console.warn('THREE.BufferAttribute.copyVector3sArray(): vector is undefined',i);vector=new Vector3();}array[offset++]=vector.x;array[offset++]=vector.y;array[offset++]=vector.z;}return this;},copyVector4sArray:function copyVector4sArray(vectors){var array=this.array,offset=0;for(var i=0,l=vectors.length;i<l;i++){var vector=vectors[i];if(vector===undefined){console.warn('THREE.BufferAttribute.copyVector4sArray(): vector is undefined',i);vector=new Vector4();}array[offset++]=vector.x;array[offset++]=vector.y;array[offset++]=vector.z;array[offset++]=vector.w;}return this;},set:function set(value,offset){if(offset===undefined)offset=0;this.array.set(value,offset);return this;},getX:function getX(index){return this.array[index*this.itemSize];},setX:function setX(index,x){this.array[index*this.itemSize]=x;return this;},getY:function getY(index){return this.array[index*this.itemSize+1];},setY:function setY(index,y){this.array[index*this.itemSize+1]=y;return this;},getZ:function getZ(index){return this.array[index*this.itemSize+2];},setZ:function setZ(index,z){this.array[index*this.itemSize+2]=z;return this;},getW:function getW(index){return this.array[index*this.itemSize+3];},setW:function setW(index,w){this.array[index*this.itemSize+3]=w;return this;},setXY:function setXY(index,x,y){index*=this.itemSize;this.array[index+0]=x;this.array[index+1]=y;return this;},setXYZ:function setXYZ(index,x,y,z){index*=this.itemSize;this.array[index+0]=x;this.array[index+1]=y;this.array[index+2]=z;return this;},setXYZW:function setXYZW(index,x,y,z,w){index*=this.itemSize;this.array[index+0]=x;this.array[index+1]=y;this.array[index+2]=z;this.array[index+3]=w;return this;},onUpload:function onUpload(callback){this.onUploadCallback=callback;return this;},clone:function clone(){return new this.constructor(this.array,this.itemSize).copy(this);}});//
	function Int8BufferAttribute(array,itemSize){BufferAttribute.call(this,new Int8Array(array),itemSize);}Int8BufferAttribute.prototype=Object.create(BufferAttribute.prototype);Int8BufferAttribute.prototype.constructor=Int8BufferAttribute;function Uint8BufferAttribute(array,itemSize){BufferAttribute.call(this,new Uint8Array(array),itemSize);}Uint8BufferAttribute.prototype=Object.create(BufferAttribute.prototype);Uint8BufferAttribute.prototype.constructor=Uint8BufferAttribute;function Uint8ClampedBufferAttribute(array,itemSize){BufferAttribute.call(this,new Uint8ClampedArray(array),itemSize);}Uint8ClampedBufferAttribute.prototype=Object.create(BufferAttribute.prototype);Uint8ClampedBufferAttribute.prototype.constructor=Uint8ClampedBufferAttribute;function Int16BufferAttribute(array,itemSize){BufferAttribute.call(this,new Int16Array(array),itemSize);}Int16BufferAttribute.prototype=Object.create(BufferAttribute.prototype);Int16BufferAttribute.prototype.constructor=Int16BufferAttribute;function Uint16BufferAttribute(array,itemSize){BufferAttribute.call(this,new Uint16Array(array),itemSize);}Uint16BufferAttribute.prototype=Object.create(BufferAttribute.prototype);Uint16BufferAttribute.prototype.constructor=Uint16BufferAttribute;function Int32BufferAttribute(array,itemSize){BufferAttribute.call(this,new Int32Array(array),itemSize);}Int32BufferAttribute.prototype=Object.create(BufferAttribute.prototype);Int32BufferAttribute.prototype.constructor=Int32BufferAttribute;function Uint32BufferAttribute(array,itemSize){BufferAttribute.call(this,new Uint32Array(array),itemSize);}Uint32BufferAttribute.prototype=Object.create(BufferAttribute.prototype);Uint32BufferAttribute.prototype.constructor=Uint32BufferAttribute;function Float32BufferAttribute(array,itemSize){BufferAttribute.call(this,new Float32Array(array),itemSize);}Float32BufferAttribute.prototype=Object.create(BufferAttribute.prototype);Float32BufferAttribute.prototype.constructor=Float32BufferAttribute;function Float64BufferAttribute(array,itemSize){BufferAttribute.call(this,new Float64Array(array),itemSize);}Float64BufferAttribute.prototype=Object.create(BufferAttribute.prototype);Float64BufferAttribute.prototype.constructor=Float64BufferAttribute;/**
		 * @author mrdoob / http://mrdoob.com/
		 */function DirectGeometry(){this.indices=[];this.vertices=[];this.normals=[];this.colors=[];this.uvs=[];this.uvs2=[];this.groups=[];this.morphTargets={};this.skinWeights=[];this.skinIndices=[];// this.lineDistances = [];
	this.boundingBox=null;this.boundingSphere=null;// update flags
	this.verticesNeedUpdate=false;this.normalsNeedUpdate=false;this.colorsNeedUpdate=false;this.uvsNeedUpdate=false;this.groupsNeedUpdate=false;}_assign(DirectGeometry.prototype,{computeGroups:function computeGroups(geometry){var group;var groups=[];var materialIndex=undefined;var faces=geometry.faces;for(var i=0;i<faces.length;i++){var face=faces[i];// materials
	if(face.materialIndex!==materialIndex){materialIndex=face.materialIndex;if(group!==undefined){group.count=i*3-group.start;groups.push(group);}group={start:i*3,materialIndex:materialIndex};}}if(group!==undefined){group.count=i*3-group.start;groups.push(group);}this.groups=groups;},fromGeometry:function fromGeometry(geometry){var faces=geometry.faces;var vertices=geometry.vertices;var faceVertexUvs=geometry.faceVertexUvs;var hasFaceVertexUv=faceVertexUvs[0]&&faceVertexUvs[0].length>0;var hasFaceVertexUv2=faceVertexUvs[1]&&faceVertexUvs[1].length>0;// morphs
	var morphTargets=geometry.morphTargets;var morphTargetsLength=morphTargets.length;var morphTargetsPosition;if(morphTargetsLength>0){morphTargetsPosition=[];for(var i=0;i<morphTargetsLength;i++){morphTargetsPosition[i]=[];}this.morphTargets.position=morphTargetsPosition;}var morphNormals=geometry.morphNormals;var morphNormalsLength=morphNormals.length;var morphTargetsNormal;if(morphNormalsLength>0){morphTargetsNormal=[];for(var i=0;i<morphNormalsLength;i++){morphTargetsNormal[i]=[];}this.morphTargets.normal=morphTargetsNormal;}// skins
	var skinIndices=geometry.skinIndices;var skinWeights=geometry.skinWeights;var hasSkinIndices=skinIndices.length===vertices.length;var hasSkinWeights=skinWeights.length===vertices.length;//
	for(var i=0;i<faces.length;i++){var face=faces[i];this.vertices.push(vertices[face.a],vertices[face.b],vertices[face.c]);var vertexNormals=face.vertexNormals;if(vertexNormals.length===3){this.normals.push(vertexNormals[0],vertexNormals[1],vertexNormals[2]);}else{var normal=face.normal;this.normals.push(normal,normal,normal);}var vertexColors=face.vertexColors;if(vertexColors.length===3){this.colors.push(vertexColors[0],vertexColors[1],vertexColors[2]);}else{var color=face.color;this.colors.push(color,color,color);}if(hasFaceVertexUv===true){var vertexUvs=faceVertexUvs[0][i];if(vertexUvs!==undefined){this.uvs.push(vertexUvs[0],vertexUvs[1],vertexUvs[2]);}else{console.warn('THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ',i);this.uvs.push(new Vector2(),new Vector2(),new Vector2());}}if(hasFaceVertexUv2===true){var vertexUvs=faceVertexUvs[1][i];if(vertexUvs!==undefined){this.uvs2.push(vertexUvs[0],vertexUvs[1],vertexUvs[2]);}else{console.warn('THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ',i);this.uvs2.push(new Vector2(),new Vector2(),new Vector2());}}// morphs
	for(var j=0;j<morphTargetsLength;j++){var morphTarget=morphTargets[j].vertices;morphTargetsPosition[j].push(morphTarget[face.a],morphTarget[face.b],morphTarget[face.c]);}for(var j=0;j<morphNormalsLength;j++){var morphNormal=morphNormals[j].vertexNormals[i];morphTargetsNormal[j].push(morphNormal.a,morphNormal.b,morphNormal.c);}// skins
	if(hasSkinIndices){this.skinIndices.push(skinIndices[face.a],skinIndices[face.b],skinIndices[face.c]);}if(hasSkinWeights){this.skinWeights.push(skinWeights[face.a],skinWeights[face.b],skinWeights[face.c]);}}this.computeGroups(geometry);this.verticesNeedUpdate=geometry.verticesNeedUpdate;this.normalsNeedUpdate=geometry.normalsNeedUpdate;this.colorsNeedUpdate=geometry.colorsNeedUpdate;this.uvsNeedUpdate=geometry.uvsNeedUpdate;this.groupsNeedUpdate=geometry.groupsNeedUpdate;return this;}});function arrayMax(array){if(array.length===0)return-Infinity;var max=array[0];for(var i=1,l=array.length;i<l;++i){if(array[i]>max)max=array[i];}return max;}/**
		 * @author mrdoob / http://mrdoob.com/
		 * @author kile / http://kile.stravaganza.org/
		 * @author alteredq / http://alteredqualia.com/
		 * @author mikael emtinger / http://gomo.se/
		 * @author zz85 / http://www.lab4games.net/zz85/blog
		 * @author bhouston / http://clara.io
		 */var count=0;function GeometryIdCount(){return count++;}function Geometry(){Object.defineProperty(this,'id',{value:GeometryIdCount()});this.uuid=_Math.generateUUID();this.name='';this.type='Geometry';this.vertices=[];this.colors=[];this.faces=[];this.faceVertexUvs=[[]];this.morphTargets=[];this.morphNormals=[];this.skinWeights=[];this.skinIndices=[];this.lineDistances=[];this.boundingBox=null;this.boundingSphere=null;// update flags
	this.elementsNeedUpdate=false;this.verticesNeedUpdate=false;this.uvsNeedUpdate=false;this.normalsNeedUpdate=false;this.colorsNeedUpdate=false;this.lineDistancesNeedUpdate=false;this.groupsNeedUpdate=false;}_assign(Geometry.prototype,EventDispatcher.prototype,{isGeometry:true,applyMatrix:function applyMatrix(matrix){var normalMatrix=new Matrix3().getNormalMatrix(matrix);for(var i=0,il=this.vertices.length;i<il;i++){var vertex=this.vertices[i];vertex.applyMatrix4(matrix);}for(var i=0,il=this.faces.length;i<il;i++){var face=this.faces[i];face.normal.applyMatrix3(normalMatrix).normalize();for(var j=0,jl=face.vertexNormals.length;j<jl;j++){face.vertexNormals[j].applyMatrix3(normalMatrix).normalize();}}if(this.boundingBox!==null){this.computeBoundingBox();}if(this.boundingSphere!==null){this.computeBoundingSphere();}this.verticesNeedUpdate=true;this.normalsNeedUpdate=true;return this;},rotateX:function(){// rotate geometry around world x-axis
	var m1=new Matrix4();return function rotateX(angle){m1.makeRotationX(angle);this.applyMatrix(m1);return this;};}(),rotateY:function(){// rotate geometry around world y-axis
	var m1=new Matrix4();return function rotateY(angle){m1.makeRotationY(angle);this.applyMatrix(m1);return this;};}(),rotateZ:function(){// rotate geometry around world z-axis
	var m1=new Matrix4();return function rotateZ(angle){m1.makeRotationZ(angle);this.applyMatrix(m1);return this;};}(),translate:function(){// translate geometry
	var m1=new Matrix4();return function translate(x,y,z){m1.makeTranslation(x,y,z);this.applyMatrix(m1);return this;};}(),scale:function(){// scale geometry
	var m1=new Matrix4();return function scale(x,y,z){m1.makeScale(x,y,z);this.applyMatrix(m1);return this;};}(),lookAt:function(){var obj=new Object3D();return function lookAt(vector){obj.lookAt(vector);obj.updateMatrix();this.applyMatrix(obj.matrix);};}(),fromBufferGeometry:function fromBufferGeometry(geometry){var scope=this;var indices=geometry.index!==null?geometry.index.array:undefined;var attributes=geometry.attributes;var positions=attributes.position.array;var normals=attributes.normal!==undefined?attributes.normal.array:undefined;var colors=attributes.color!==undefined?attributes.color.array:undefined;var uvs=attributes.uv!==undefined?attributes.uv.array:undefined;var uvs2=attributes.uv2!==undefined?attributes.uv2.array:undefined;if(uvs2!==undefined)this.faceVertexUvs[1]=[];var tempNormals=[];var tempUVs=[];var tempUVs2=[];for(var i=0,j=0;i<positions.length;i+=3,j+=2){scope.vertices.push(new Vector3(positions[i],positions[i+1],positions[i+2]));if(normals!==undefined){tempNormals.push(new Vector3(normals[i],normals[i+1],normals[i+2]));}if(colors!==undefined){scope.colors.push(new Color(colors[i],colors[i+1],colors[i+2]));}if(uvs!==undefined){tempUVs.push(new Vector2(uvs[j],uvs[j+1]));}if(uvs2!==undefined){tempUVs2.push(new Vector2(uvs2[j],uvs2[j+1]));}}function addFace(a,b,c,materialIndex){var vertexNormals=normals!==undefined?[tempNormals[a].clone(),tempNormals[b].clone(),tempNormals[c].clone()]:[];var vertexColors=colors!==undefined?[scope.colors[a].clone(),scope.colors[b].clone(),scope.colors[c].clone()]:[];var face=new Face3(a,b,c,vertexNormals,vertexColors,materialIndex);scope.faces.push(face);if(uvs!==undefined){scope.faceVertexUvs[0].push([tempUVs[a].clone(),tempUVs[b].clone(),tempUVs[c].clone()]);}if(uvs2!==undefined){scope.faceVertexUvs[1].push([tempUVs2[a].clone(),tempUVs2[b].clone(),tempUVs2[c].clone()]);}}var groups=geometry.groups;if(groups.length>0){for(var i=0;i<groups.length;i++){var group=groups[i];var start=group.start;var count=group.count;for(var j=start,jl=start+count;j<jl;j+=3){if(indices!==undefined){addFace(indices[j],indices[j+1],indices[j+2],group.materialIndex);}else{addFace(j,j+1,j+2,group.materialIndex);}}}}else{if(indices!==undefined){for(var i=0;i<indices.length;i+=3){addFace(indices[i],indices[i+1],indices[i+2]);}}else{for(var i=0;i<positions.length/3;i+=3){addFace(i,i+1,i+2);}}}this.computeFaceNormals();if(geometry.boundingBox!==null){this.boundingBox=geometry.boundingBox.clone();}if(geometry.boundingSphere!==null){this.boundingSphere=geometry.boundingSphere.clone();}return this;},center:function center(){this.computeBoundingBox();var offset=this.boundingBox.getCenter().negate();this.translate(offset.x,offset.y,offset.z);return offset;},normalize:function normalize(){this.computeBoundingSphere();var center=this.boundingSphere.center;var radius=this.boundingSphere.radius;var s=radius===0?1:1.0/radius;var matrix=new Matrix4();matrix.set(s,0,0,-s*center.x,0,s,0,-s*center.y,0,0,s,-s*center.z,0,0,0,1);this.applyMatrix(matrix);return this;},computeFaceNormals:function computeFaceNormals(){var cb=new Vector3(),ab=new Vector3();for(var f=0,fl=this.faces.length;f<fl;f++){var face=this.faces[f];var vA=this.vertices[face.a];var vB=this.vertices[face.b];var vC=this.vertices[face.c];cb.subVectors(vC,vB);ab.subVectors(vA,vB);cb.cross(ab);cb.normalize();face.normal.copy(cb);}},computeVertexNormals:function computeVertexNormals(areaWeighted){if(areaWeighted===undefined)areaWeighted=true;var v,vl,f,fl,face,vertices;vertices=new Array(this.vertices.length);for(v=0,vl=this.vertices.length;v<vl;v++){vertices[v]=new Vector3();}if(areaWeighted){// vertex normals weighted by triangle areas
	// http://www.iquilezles.org/www/articles/normals/normals.htm
	var vA,vB,vC;var cb=new Vector3(),ab=new Vector3();for(f=0,fl=this.faces.length;f<fl;f++){face=this.faces[f];vA=this.vertices[face.a];vB=this.vertices[face.b];vC=this.vertices[face.c];cb.subVectors(vC,vB);ab.subVectors(vA,vB);cb.cross(ab);vertices[face.a].add(cb);vertices[face.b].add(cb);vertices[face.c].add(cb);}}else{this.computeFaceNormals();for(f=0,fl=this.faces.length;f<fl;f++){face=this.faces[f];vertices[face.a].add(face.normal);vertices[face.b].add(face.normal);vertices[face.c].add(face.normal);}}for(v=0,vl=this.vertices.length;v<vl;v++){vertices[v].normalize();}for(f=0,fl=this.faces.length;f<fl;f++){face=this.faces[f];var vertexNormals=face.vertexNormals;if(vertexNormals.length===3){vertexNormals[0].copy(vertices[face.a]);vertexNormals[1].copy(vertices[face.b]);vertexNormals[2].copy(vertices[face.c]);}else{vertexNormals[0]=vertices[face.a].clone();vertexNormals[1]=vertices[face.b].clone();vertexNormals[2]=vertices[face.c].clone();}}if(this.faces.length>0){this.normalsNeedUpdate=true;}},computeFlatVertexNormals:function computeFlatVertexNormals(){var f,fl,face;this.computeFaceNormals();for(f=0,fl=this.faces.length;f<fl;f++){face=this.faces[f];var vertexNormals=face.vertexNormals;if(vertexNormals.length===3){vertexNormals[0].copy(face.normal);vertexNormals[1].copy(face.normal);vertexNormals[2].copy(face.normal);}else{vertexNormals[0]=face.normal.clone();vertexNormals[1]=face.normal.clone();vertexNormals[2]=face.normal.clone();}}if(this.faces.length>0){this.normalsNeedUpdate=true;}},computeMorphNormals:function computeMorphNormals(){var i,il,f,fl,face;// save original normals
	// - create temp variables on first access
	//   otherwise just copy (for faster repeated calls)
	for(f=0,fl=this.faces.length;f<fl;f++){face=this.faces[f];if(!face.__originalFaceNormal){face.__originalFaceNormal=face.normal.clone();}else{face.__originalFaceNormal.copy(face.normal);}if(!face.__originalVertexNormals)face.__originalVertexNormals=[];for(i=0,il=face.vertexNormals.length;i<il;i++){if(!face.__originalVertexNormals[i]){face.__originalVertexNormals[i]=face.vertexNormals[i].clone();}else{face.__originalVertexNormals[i].copy(face.vertexNormals[i]);}}}// use temp geometry to compute face and vertex normals for each morph
	var tmpGeo=new Geometry();tmpGeo.faces=this.faces;for(i=0,il=this.morphTargets.length;i<il;i++){// create on first access
	if(!this.morphNormals[i]){this.morphNormals[i]={};this.morphNormals[i].faceNormals=[];this.morphNormals[i].vertexNormals=[];var dstNormalsFace=this.morphNormals[i].faceNormals;var dstNormalsVertex=this.morphNormals[i].vertexNormals;var faceNormal,vertexNormals;for(f=0,fl=this.faces.length;f<fl;f++){faceNormal=new Vector3();vertexNormals={a:new Vector3(),b:new Vector3(),c:new Vector3()};dstNormalsFace.push(faceNormal);dstNormalsVertex.push(vertexNormals);}}var morphNormals=this.morphNormals[i];// set vertices to morph target
	tmpGeo.vertices=this.morphTargets[i].vertices;// compute morph normals
	tmpGeo.computeFaceNormals();tmpGeo.computeVertexNormals();// store morph normals
	var faceNormal,vertexNormals;for(f=0,fl=this.faces.length;f<fl;f++){face=this.faces[f];faceNormal=morphNormals.faceNormals[f];vertexNormals=morphNormals.vertexNormals[f];faceNormal.copy(face.normal);vertexNormals.a.copy(face.vertexNormals[0]);vertexNormals.b.copy(face.vertexNormals[1]);vertexNormals.c.copy(face.vertexNormals[2]);}}// restore original normals
	for(f=0,fl=this.faces.length;f<fl;f++){face=this.faces[f];face.normal=face.__originalFaceNormal;face.vertexNormals=face.__originalVertexNormals;}},computeLineDistances:function computeLineDistances(){var d=0;var vertices=this.vertices;for(var i=0,il=vertices.length;i<il;i++){if(i>0){d+=vertices[i].distanceTo(vertices[i-1]);}this.lineDistances[i]=d;}},computeBoundingBox:function computeBoundingBox(){if(this.boundingBox===null){this.boundingBox=new Box3();}this.boundingBox.setFromPoints(this.vertices);},computeBoundingSphere:function computeBoundingSphere(){if(this.boundingSphere===null){this.boundingSphere=new Sphere();}this.boundingSphere.setFromPoints(this.vertices);},merge:function merge(geometry,matrix,materialIndexOffset){if((geometry&&geometry.isGeometry)===false){console.error('THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.',geometry);return;}var normalMatrix,vertexOffset=this.vertices.length,vertices1=this.vertices,vertices2=geometry.vertices,faces1=this.faces,faces2=geometry.faces,uvs1=this.faceVertexUvs[0],uvs2=geometry.faceVertexUvs[0],colors1=this.colors,colors2=geometry.colors;if(materialIndexOffset===undefined)materialIndexOffset=0;if(matrix!==undefined){normalMatrix=new Matrix3().getNormalMatrix(matrix);}// vertices
	for(var i=0,il=vertices2.length;i<il;i++){var vertex=vertices2[i];var vertexCopy=vertex.clone();if(matrix!==undefined)vertexCopy.applyMatrix4(matrix);vertices1.push(vertexCopy);}// colors
	for(var i=0,il=colors2.length;i<il;i++){colors1.push(colors2[i].clone());}// faces
	for(i=0,il=faces2.length;i<il;i++){var face=faces2[i],faceCopy,normal,color,faceVertexNormals=face.vertexNormals,faceVertexColors=face.vertexColors;faceCopy=new Face3(face.a+vertexOffset,face.b+vertexOffset,face.c+vertexOffset);faceCopy.normal.copy(face.normal);if(normalMatrix!==undefined){faceCopy.normal.applyMatrix3(normalMatrix).normalize();}for(var j=0,jl=faceVertexNormals.length;j<jl;j++){normal=faceVertexNormals[j].clone();if(normalMatrix!==undefined){normal.applyMatrix3(normalMatrix).normalize();}faceCopy.vertexNormals.push(normal);}faceCopy.color.copy(face.color);for(var j=0,jl=faceVertexColors.length;j<jl;j++){color=faceVertexColors[j];faceCopy.vertexColors.push(color.clone());}faceCopy.materialIndex=face.materialIndex+materialIndexOffset;faces1.push(faceCopy);}// uvs
	for(i=0,il=uvs2.length;i<il;i++){var uv=uvs2[i],uvCopy=[];if(uv===undefined){continue;}for(var j=0,jl=uv.length;j<jl;j++){uvCopy.push(uv[j].clone());}uvs1.push(uvCopy);}},mergeMesh:function mergeMesh(mesh){if((mesh&&mesh.isMesh)===false){console.error('THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.',mesh);return;}mesh.matrixAutoUpdate&&mesh.updateMatrix();this.merge(mesh.geometry,mesh.matrix);},/*
			 * Checks for duplicate vertices with hashmap.
			 * Duplicated vertices are removed
			 * and faces' vertices are updated.
			 */mergeVertices:function mergeVertices(){var verticesMap={};// Hashmap for looking up vertices by position coordinates (and making sure they are unique)
	var unique=[],changes=[];var v,key;var precisionPoints=4;// number of decimal points, e.g. 4 for epsilon of 0.0001
	var precision=Math.pow(10,precisionPoints);var i,il,face;var indices,j,jl;for(i=0,il=this.vertices.length;i<il;i++){v=this.vertices[i];key=Math.round(v.x*precision)+'_'+Math.round(v.y*precision)+'_'+Math.round(v.z*precision);if(verticesMap[key]===undefined){verticesMap[key]=i;unique.push(this.vertices[i]);changes[i]=unique.length-1;}else{//console.log('Duplicate vertex found. ', i, ' could be using ', verticesMap[key]);
	changes[i]=changes[verticesMap[key]];}}// if faces are completely degenerate after merging vertices, we
	// have to remove them from the geometry.
	var faceIndicesToRemove=[];for(i=0,il=this.faces.length;i<il;i++){face=this.faces[i];face.a=changes[face.a];face.b=changes[face.b];face.c=changes[face.c];indices=[face.a,face.b,face.c];// if any duplicate vertices are found in a Face3
	// we have to remove the face as nothing can be saved
	for(var n=0;n<3;n++){if(indices[n]===indices[(n+1)%3]){faceIndicesToRemove.push(i);break;}}}for(i=faceIndicesToRemove.length-1;i>=0;i--){var idx=faceIndicesToRemove[i];this.faces.splice(idx,1);for(j=0,jl=this.faceVertexUvs.length;j<jl;j++){this.faceVertexUvs[j].splice(idx,1);}}// Use unique set of vertices
	var diff=this.vertices.length-unique.length;this.vertices=unique;return diff;},sortFacesByMaterialIndex:function sortFacesByMaterialIndex(){var faces=this.faces;var length=faces.length;// tag faces
	for(var i=0;i<length;i++){faces[i]._id=i;}// sort faces
	function materialIndexSort(a,b){return a.materialIndex-b.materialIndex;}faces.sort(materialIndexSort);// sort uvs
	var uvs1=this.faceVertexUvs[0];var uvs2=this.faceVertexUvs[1];var newUvs1,newUvs2;if(uvs1&&uvs1.length===length)newUvs1=[];if(uvs2&&uvs2.length===length)newUvs2=[];for(var i=0;i<length;i++){var id=faces[i]._id;if(newUvs1)newUvs1.push(uvs1[id]);if(newUvs2)newUvs2.push(uvs2[id]);}if(newUvs1)this.faceVertexUvs[0]=newUvs1;if(newUvs2)this.faceVertexUvs[1]=newUvs2;},toJSON:function toJSON(){var data={metadata:{version:4.5,type:'Geometry',generator:'Geometry.toJSON'}};// standard Geometry serialization
	data.uuid=this.uuid;data.type=this.type;if(this.name!=='')data.name=this.name;if(this.parameters!==undefined){var parameters=this.parameters;for(var key in parameters){if(parameters[key]!==undefined)data[key]=parameters[key];}return data;}var vertices=[];for(var i=0;i<this.vertices.length;i++){var vertex=this.vertices[i];vertices.push(vertex.x,vertex.y,vertex.z);}var faces=[];var normals=[];var normalsHash={};var colors=[];var colorsHash={};var uvs=[];var uvsHash={};for(var i=0;i<this.faces.length;i++){var face=this.faces[i];var hasMaterial=true;var hasFaceUv=false;// deprecated
	var hasFaceVertexUv=this.faceVertexUvs[0][i]!==undefined;var hasFaceNormal=face.normal.length()>0;var hasFaceVertexNormal=face.vertexNormals.length>0;var hasFaceColor=face.color.r!==1||face.color.g!==1||face.color.b!==1;var hasFaceVertexColor=face.vertexColors.length>0;var faceType=0;faceType=setBit(faceType,0,0);// isQuad
	faceType=setBit(faceType,1,hasMaterial);faceType=setBit(faceType,2,hasFaceUv);faceType=setBit(faceType,3,hasFaceVertexUv);faceType=setBit(faceType,4,hasFaceNormal);faceType=setBit(faceType,5,hasFaceVertexNormal);faceType=setBit(faceType,6,hasFaceColor);faceType=setBit(faceType,7,hasFaceVertexColor);faces.push(faceType);faces.push(face.a,face.b,face.c);faces.push(face.materialIndex);if(hasFaceVertexUv){var faceVertexUvs=this.faceVertexUvs[0][i];faces.push(getUvIndex(faceVertexUvs[0]),getUvIndex(faceVertexUvs[1]),getUvIndex(faceVertexUvs[2]));}if(hasFaceNormal){faces.push(getNormalIndex(face.normal));}if(hasFaceVertexNormal){var vertexNormals=face.vertexNormals;faces.push(getNormalIndex(vertexNormals[0]),getNormalIndex(vertexNormals[1]),getNormalIndex(vertexNormals[2]));}if(hasFaceColor){faces.push(getColorIndex(face.color));}if(hasFaceVertexColor){var vertexColors=face.vertexColors;faces.push(getColorIndex(vertexColors[0]),getColorIndex(vertexColors[1]),getColorIndex(vertexColors[2]));}}function setBit(value,position,enabled){return enabled?value|1<<position:value&~(1<<position);}function getNormalIndex(normal){var hash=normal.x.toString()+normal.y.toString()+normal.z.toString();if(normalsHash[hash]!==undefined){return normalsHash[hash];}normalsHash[hash]=normals.length/3;normals.push(normal.x,normal.y,normal.z);return normalsHash[hash];}function getColorIndex(color){var hash=color.r.toString()+color.g.toString()+color.b.toString();if(colorsHash[hash]!==undefined){return colorsHash[hash];}colorsHash[hash]=colors.length;colors.push(color.getHex());return colorsHash[hash];}function getUvIndex(uv){var hash=uv.x.toString()+uv.y.toString();if(uvsHash[hash]!==undefined){return uvsHash[hash];}uvsHash[hash]=uvs.length/2;uvs.push(uv.x,uv.y);return uvsHash[hash];}data.data={};data.data.vertices=vertices;data.data.normals=normals;if(colors.length>0)data.data.colors=colors;if(uvs.length>0)data.data.uvs=[uvs];// temporal backward compatibility
	data.data.faces=faces;return data;},clone:function clone(){/*
				 // Handle primitives
	
				 var parameters = this.parameters;
	
				 if ( parameters !== undefined ) {
	
				 var values = [];
	
				 for ( var key in parameters ) {
	
				 values.push( parameters[ key ] );
	
				 }
	
				 var geometry = Object.create( this.constructor.prototype );
				 this.constructor.apply( geometry, values );
				 return geometry;
	
				 }
	
				 return new this.constructor().copy( this );
				 */return new Geometry().copy(this);},copy:function copy(source){var i,il,j,jl,k,kl;// reset
	this.vertices=[];this.colors=[];this.faces=[];this.faceVertexUvs=[[]];this.morphTargets=[];this.morphNormals=[];this.skinWeights=[];this.skinIndices=[];this.lineDistances=[];this.boundingBox=null;this.boundingSphere=null;// name
	this.name=source.name;// vertices
	var vertices=source.vertices;for(i=0,il=vertices.length;i<il;i++){this.vertices.push(vertices[i].clone());}// colors
	var colors=source.colors;for(i=0,il=colors.length;i<il;i++){this.colors.push(colors[i].clone());}// faces
	var faces=source.faces;for(i=0,il=faces.length;i<il;i++){this.faces.push(faces[i].clone());}// face vertex uvs
	for(i=0,il=source.faceVertexUvs.length;i<il;i++){var faceVertexUvs=source.faceVertexUvs[i];if(this.faceVertexUvs[i]===undefined){this.faceVertexUvs[i]=[];}for(j=0,jl=faceVertexUvs.length;j<jl;j++){var uvs=faceVertexUvs[j],uvsCopy=[];for(k=0,kl=uvs.length;k<kl;k++){var uv=uvs[k];uvsCopy.push(uv.clone());}this.faceVertexUvs[i].push(uvsCopy);}}// morph targets
	var morphTargets=source.morphTargets;for(i=0,il=morphTargets.length;i<il;i++){var morphTarget={};morphTarget.name=morphTargets[i].name;// vertices
	if(morphTargets[i].vertices!==undefined){morphTarget.vertices=[];for(j=0,jl=morphTargets[i].vertices.length;j<jl;j++){morphTarget.vertices.push(morphTargets[i].vertices[j].clone());}}// normals
	if(morphTargets[i].normals!==undefined){morphTarget.normals=[];for(j=0,jl=morphTargets[i].normals.length;j<jl;j++){morphTarget.normals.push(morphTargets[i].normals[j].clone());}}this.morphTargets.push(morphTarget);}// morph normals
	var morphNormals=source.morphNormals;for(i=0,il=morphNormals.length;i<il;i++){var morphNormal={};// vertex normals
	if(morphNormals[i].vertexNormals!==undefined){morphNormal.vertexNormals=[];for(j=0,jl=morphNormals[i].vertexNormals.length;j<jl;j++){var srcVertexNormal=morphNormals[i].vertexNormals[j];var destVertexNormal={};destVertexNormal.a=srcVertexNormal.a.clone();destVertexNormal.b=srcVertexNormal.b.clone();destVertexNormal.c=srcVertexNormal.c.clone();morphNormal.vertexNormals.push(destVertexNormal);}}// face normals
	if(morphNormals[i].faceNormals!==undefined){morphNormal.faceNormals=[];for(j=0,jl=morphNormals[i].faceNormals.length;j<jl;j++){morphNormal.faceNormals.push(morphNormals[i].faceNormals[j].clone());}}this.morphNormals.push(morphNormal);}// skin weights
	var skinWeights=source.skinWeights;for(i=0,il=skinWeights.length;i<il;i++){this.skinWeights.push(skinWeights[i].clone());}// skin indices
	var skinIndices=source.skinIndices;for(i=0,il=skinIndices.length;i<il;i++){this.skinIndices.push(skinIndices[i].clone());}// line distances
	var lineDistances=source.lineDistances;for(i=0,il=lineDistances.length;i<il;i++){this.lineDistances.push(lineDistances[i]);}// bounding box
	var boundingBox=source.boundingBox;if(boundingBox!==null){this.boundingBox=boundingBox.clone();}// bounding sphere
	var boundingSphere=source.boundingSphere;if(boundingSphere!==null){this.boundingSphere=boundingSphere.clone();}// update flags
	this.elementsNeedUpdate=source.elementsNeedUpdate;this.verticesNeedUpdate=source.verticesNeedUpdate;this.uvsNeedUpdate=source.uvsNeedUpdate;this.normalsNeedUpdate=source.normalsNeedUpdate;this.colorsNeedUpdate=source.colorsNeedUpdate;this.lineDistancesNeedUpdate=source.lineDistancesNeedUpdate;this.groupsNeedUpdate=source.groupsNeedUpdate;return this;},dispose:function dispose(){this.dispatchEvent({type:'dispose'});}});/**
		 * @author alteredq / http://alteredqualia.com/
		 * @author mrdoob / http://mrdoob.com/
		 */function BufferGeometry(){Object.defineProperty(this,'id',{value:GeometryIdCount()});this.uuid=_Math.generateUUID();this.name='';this.type='BufferGeometry';this.index=null;this.attributes={};this.morphAttributes={};this.groups=[];this.boundingBox=null;this.boundingSphere=null;this.drawRange={start:0,count:Infinity};}BufferGeometry.MaxIndex=65535;_assign(BufferGeometry.prototype,EventDispatcher.prototype,{isBufferGeometry:true,getIndex:function getIndex(){return this.index;},setIndex:function setIndex(index){if(Array.isArray(index)){this.index=new(arrayMax(index)>65535?Uint32BufferAttribute:Uint16BufferAttribute)(index,1);}else{this.index=index;}},addAttribute:function addAttribute(name,attribute){if((attribute&&attribute.isBufferAttribute)===false&&(attribute&&attribute.isInterleavedBufferAttribute)===false){console.warn('THREE.BufferGeometry: .addAttribute() now expects ( name, attribute ).');this.addAttribute(name,new BufferAttribute(arguments[1],arguments[2]));return;}if(name==='index'){console.warn('THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute.');this.setIndex(attribute);return;}this.attributes[name]=attribute;return this;},getAttribute:function getAttribute(name){return this.attributes[name];},removeAttribute:function removeAttribute(name){delete this.attributes[name];return this;},addGroup:function addGroup(start,count,materialIndex){this.groups.push({start:start,count:count,materialIndex:materialIndex!==undefined?materialIndex:0});},clearGroups:function clearGroups(){this.groups=[];},setDrawRange:function setDrawRange(start,count){this.drawRange.start=start;this.drawRange.count=count;},applyMatrix:function applyMatrix(matrix){var position=this.attributes.position;if(position!==undefined){matrix.applyToBufferAttribute(position);position.needsUpdate=true;}var normal=this.attributes.normal;if(normal!==undefined){var normalMatrix=new Matrix3().getNormalMatrix(matrix);normalMatrix.applyToBufferAttribute(normal);normal.needsUpdate=true;}if(this.boundingBox!==null){this.computeBoundingBox();}if(this.boundingSphere!==null){this.computeBoundingSphere();}return this;},rotateX:function(){// rotate geometry around world x-axis
	var m1=new Matrix4();return function rotateX(angle){m1.makeRotationX(angle);this.applyMatrix(m1);return this;};}(),rotateY:function(){// rotate geometry around world y-axis
	var m1=new Matrix4();return function rotateY(angle){m1.makeRotationY(angle);this.applyMatrix(m1);return this;};}(),rotateZ:function(){// rotate geometry around world z-axis
	var m1=new Matrix4();return function rotateZ(angle){m1.makeRotationZ(angle);this.applyMatrix(m1);return this;};}(),translate:function(){// translate geometry
	var m1=new Matrix4();return function translate(x,y,z){m1.makeTranslation(x,y,z);this.applyMatrix(m1);return this;};}(),scale:function(){// scale geometry
	var m1=new Matrix4();return function scale(x,y,z){m1.makeScale(x,y,z);this.applyMatrix(m1);return this;};}(),lookAt:function(){var obj=new Object3D();return function lookAt(vector){obj.lookAt(vector);obj.updateMatrix();this.applyMatrix(obj.matrix);};}(),center:function center(){this.computeBoundingBox();var offset=this.boundingBox.getCenter().negate();this.translate(offset.x,offset.y,offset.z);return offset;},setFromObject:function setFromObject(object){// console.log( 'THREE.BufferGeometry.setFromObject(). Converting', object, this );
	var geometry=object.geometry;if(object.isPoints||object.isLine){var positions=new Float32BufferAttribute(geometry.vertices.length*3,3);var colors=new Float32BufferAttribute(geometry.colors.length*3,3);this.addAttribute('position',positions.copyVector3sArray(geometry.vertices));this.addAttribute('color',colors.copyColorsArray(geometry.colors));if(geometry.lineDistances&&geometry.lineDistances.length===geometry.vertices.length){var lineDistances=new Float32BufferAttribute(geometry.lineDistances.length,1);this.addAttribute('lineDistance',lineDistances.copyArray(geometry.lineDistances));}if(geometry.boundingSphere!==null){this.boundingSphere=geometry.boundingSphere.clone();}if(geometry.boundingBox!==null){this.boundingBox=geometry.boundingBox.clone();}}else if(object.isMesh){if(geometry&&geometry.isGeometry){this.fromGeometry(geometry);}}return this;},updateFromObject:function updateFromObject(object){var geometry=object.geometry;if(object.isMesh){var direct=geometry.__directGeometry;if(geometry.elementsNeedUpdate===true){direct=undefined;geometry.elementsNeedUpdate=false;}if(direct===undefined){return this.fromGeometry(geometry);}direct.verticesNeedUpdate=geometry.verticesNeedUpdate;direct.normalsNeedUpdate=geometry.normalsNeedUpdate;direct.colorsNeedUpdate=geometry.colorsNeedUpdate;direct.uvsNeedUpdate=geometry.uvsNeedUpdate;direct.groupsNeedUpdate=geometry.groupsNeedUpdate;geometry.verticesNeedUpdate=false;geometry.normalsNeedUpdate=false;geometry.colorsNeedUpdate=false;geometry.uvsNeedUpdate=false;geometry.groupsNeedUpdate=false;geometry=direct;}var attribute;if(geometry.verticesNeedUpdate===true){attribute=this.attributes.position;if(attribute!==undefined){attribute.copyVector3sArray(geometry.vertices);attribute.needsUpdate=true;}geometry.verticesNeedUpdate=false;}if(geometry.normalsNeedUpdate===true){attribute=this.attributes.normal;if(attribute!==undefined){attribute.copyVector3sArray(geometry.normals);attribute.needsUpdate=true;}geometry.normalsNeedUpdate=false;}if(geometry.colorsNeedUpdate===true){attribute=this.attributes.color;if(attribute!==undefined){attribute.copyColorsArray(geometry.colors);attribute.needsUpdate=true;}geometry.colorsNeedUpdate=false;}if(geometry.uvsNeedUpdate){attribute=this.attributes.uv;if(attribute!==undefined){attribute.copyVector2sArray(geometry.uvs);attribute.needsUpdate=true;}geometry.uvsNeedUpdate=false;}if(geometry.lineDistancesNeedUpdate){attribute=this.attributes.lineDistance;if(attribute!==undefined){attribute.copyArray(geometry.lineDistances);attribute.needsUpdate=true;}geometry.lineDistancesNeedUpdate=false;}if(geometry.groupsNeedUpdate){geometry.computeGroups(object.geometry);this.groups=geometry.groups;geometry.groupsNeedUpdate=false;}return this;},fromGeometry:function fromGeometry(geometry){geometry.__directGeometry=new DirectGeometry().fromGeometry(geometry);return this.fromDirectGeometry(geometry.__directGeometry);},fromDirectGeometry:function fromDirectGeometry(geometry){var positions=new Float32Array(geometry.vertices.length*3);this.addAttribute('position',new BufferAttribute(positions,3).copyVector3sArray(geometry.vertices));if(geometry.normals.length>0){var normals=new Float32Array(geometry.normals.length*3);this.addAttribute('normal',new BufferAttribute(normals,3).copyVector3sArray(geometry.normals));}if(geometry.colors.length>0){var colors=new Float32Array(geometry.colors.length*3);this.addAttribute('color',new BufferAttribute(colors,3).copyColorsArray(geometry.colors));}if(geometry.uvs.length>0){var uvs=new Float32Array(geometry.uvs.length*2);this.addAttribute('uv',new BufferAttribute(uvs,2).copyVector2sArray(geometry.uvs));}if(geometry.uvs2.length>0){var uvs2=new Float32Array(geometry.uvs2.length*2);this.addAttribute('uv2',new BufferAttribute(uvs2,2).copyVector2sArray(geometry.uvs2));}if(geometry.indices.length>0){var TypeArray=arrayMax(geometry.indices)>65535?Uint32Array:Uint16Array;var indices=new TypeArray(geometry.indices.length*3);this.setIndex(new BufferAttribute(indices,1).copyIndicesArray(geometry.indices));}// groups
	this.groups=geometry.groups;// morphs
	for(var name in geometry.morphTargets){var array=[];var morphTargets=geometry.morphTargets[name];for(var i=0,l=morphTargets.length;i<l;i++){var morphTarget=morphTargets[i];var attribute=new Float32BufferAttribute(morphTarget.length*3,3);array.push(attribute.copyVector3sArray(morphTarget));}this.morphAttributes[name]=array;}// skinning
	if(geometry.skinIndices.length>0){var skinIndices=new Float32BufferAttribute(geometry.skinIndices.length*4,4);this.addAttribute('skinIndex',skinIndices.copyVector4sArray(geometry.skinIndices));}if(geometry.skinWeights.length>0){var skinWeights=new Float32BufferAttribute(geometry.skinWeights.length*4,4);this.addAttribute('skinWeight',skinWeights.copyVector4sArray(geometry.skinWeights));}//
	if(geometry.boundingSphere!==null){this.boundingSphere=geometry.boundingSphere.clone();}if(geometry.boundingBox!==null){this.boundingBox=geometry.boundingBox.clone();}return this;},computeBoundingBox:function computeBoundingBox(){if(this.boundingBox===null){this.boundingBox=new Box3();}var position=this.attributes.position;if(position!==undefined){this.boundingBox.setFromBufferAttribute(position);}else{this.boundingBox.makeEmpty();}if(isNaN(this.boundingBox.min.x)||isNaN(this.boundingBox.min.y)||isNaN(this.boundingBox.min.z)){console.error('THREE.BufferGeometry.computeBoundingBox: Computed min/max have NaN values. The "position" attribute is likely to have NaN values.',this);}},computeBoundingSphere:function(){var box=new Box3();var vector=new Vector3();return function computeBoundingSphere(){if(this.boundingSphere===null){this.boundingSphere=new Sphere();}var position=this.attributes.position;if(position){var center=this.boundingSphere.center;box.setFromBufferAttribute(position);box.getCenter(center);// hoping to find a boundingSphere with a radius smaller than the
	// boundingSphere of the boundingBox: sqrt(3) smaller in the best case
	var maxRadiusSq=0;for(var i=0,il=position.count;i<il;i++){vector.x=position.getX(i);vector.y=position.getY(i);vector.z=position.getZ(i);maxRadiusSq=Math.max(maxRadiusSq,center.distanceToSquared(vector));}this.boundingSphere.radius=Math.sqrt(maxRadiusSq);if(isNaN(this.boundingSphere.radius)){console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.',this);}}};}(),computeFaceNormals:function computeFaceNormals(){// backwards compatibility
	},computeVertexNormals:function computeVertexNormals(){var index=this.index;var attributes=this.attributes;var groups=this.groups;if(attributes.position){var positions=attributes.position.array;if(attributes.normal===undefined){this.addAttribute('normal',new BufferAttribute(new Float32Array(positions.length),3));}else{// reset existing normals to zero
	var array=attributes.normal.array;for(var i=0,il=array.length;i<il;i++){array[i]=0;}}var normals=attributes.normal.array;var vA,vB,vC;var pA=new Vector3(),pB=new Vector3(),pC=new Vector3();var cb=new Vector3(),ab=new Vector3();// indexed elements
	if(index){var indices=index.array;if(groups.length===0){this.addGroup(0,indices.length);}for(var j=0,jl=groups.length;j<jl;++j){var group=groups[j];var start=group.start;var count=group.count;for(var i=start,il=start+count;i<il;i+=3){vA=indices[i+0]*3;vB=indices[i+1]*3;vC=indices[i+2]*3;pA.fromArray(positions,vA);pB.fromArray(positions,vB);pC.fromArray(positions,vC);cb.subVectors(pC,pB);ab.subVectors(pA,pB);cb.cross(ab);normals[vA]+=cb.x;normals[vA+1]+=cb.y;normals[vA+2]+=cb.z;normals[vB]+=cb.x;normals[vB+1]+=cb.y;normals[vB+2]+=cb.z;normals[vC]+=cb.x;normals[vC+1]+=cb.y;normals[vC+2]+=cb.z;}}}else{// non-indexed elements (unconnected triangle soup)
	for(var i=0,il=positions.length;i<il;i+=9){pA.fromArray(positions,i);pB.fromArray(positions,i+3);pC.fromArray(positions,i+6);cb.subVectors(pC,pB);ab.subVectors(pA,pB);cb.cross(ab);normals[i]=cb.x;normals[i+1]=cb.y;normals[i+2]=cb.z;normals[i+3]=cb.x;normals[i+4]=cb.y;normals[i+5]=cb.z;normals[i+6]=cb.x;normals[i+7]=cb.y;normals[i+8]=cb.z;}}this.normalizeNormals();attributes.normal.needsUpdate=true;}},merge:function merge(geometry,offset){if((geometry&&geometry.isBufferGeometry)===false){console.error('THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.',geometry);return;}if(offset===undefined)offset=0;var attributes=this.attributes;for(var key in attributes){if(geometry.attributes[key]===undefined)continue;var attribute1=attributes[key];var attributeArray1=attribute1.array;var attribute2=geometry.attributes[key];var attributeArray2=attribute2.array;var attributeSize=attribute2.itemSize;for(var i=0,j=attributeSize*offset;i<attributeArray2.length;i++,j++){attributeArray1[j]=attributeArray2[i];}}return this;},normalizeNormals:function normalizeNormals(){var normals=this.attributes.normal;var x,y,z,n;for(var i=0,il=normals.count;i<il;i++){x=normals.getX(i);y=normals.getY(i);z=normals.getZ(i);n=1.0/Math.sqrt(x*x+y*y+z*z);normals.setXYZ(i,x*n,y*n,z*n);}},toNonIndexed:function toNonIndexed(){if(this.index===null){console.warn('THREE.BufferGeometry.toNonIndexed(): Geometry is already non-indexed.');return this;}var geometry2=new BufferGeometry();var indices=this.index.array;var attributes=this.attributes;for(var name in attributes){var attribute=attributes[name];var array=attribute.array;var itemSize=attribute.itemSize;var array2=new array.constructor(indices.length*itemSize);var index=0,index2=0;for(var i=0,l=indices.length;i<l;i++){index=indices[i]*itemSize;for(var j=0;j<itemSize;j++){array2[index2++]=array[index++];}}geometry2.addAttribute(name,new BufferAttribute(array2,itemSize));}return geometry2;},toJSON:function toJSON(){var data={metadata:{version:4.5,type:'BufferGeometry',generator:'BufferGeometry.toJSON'}};// standard BufferGeometry serialization
	data.uuid=this.uuid;data.type=this.type;if(this.name!=='')data.name=this.name;if(this.parameters!==undefined){var parameters=this.parameters;for(var key in parameters){if(parameters[key]!==undefined)data[key]=parameters[key];}return data;}data.data={attributes:{}};var index=this.index;if(index!==null){var array=Array.prototype.slice.call(index.array);data.data.index={type:index.array.constructor.name,array:array};}var attributes=this.attributes;for(var key in attributes){var attribute=attributes[key];var array=Array.prototype.slice.call(attribute.array);data.data.attributes[key]={itemSize:attribute.itemSize,type:attribute.array.constructor.name,array:array,normalized:attribute.normalized};}var groups=this.groups;if(groups.length>0){data.data.groups=JSON.parse(JSON.stringify(groups));}var boundingSphere=this.boundingSphere;if(boundingSphere!==null){data.data.boundingSphere={center:boundingSphere.center.toArray(),radius:boundingSphere.radius};}return data;},clone:function clone(){/*
				 // Handle primitives
	
				 var parameters = this.parameters;
	
				 if ( parameters !== undefined ) {
	
				 var values = [];
	
				 for ( var key in parameters ) {
	
				 values.push( parameters[ key ] );
	
				 }
	
				 var geometry = Object.create( this.constructor.prototype );
				 this.constructor.apply( geometry, values );
				 return geometry;
	
				 }
	
				 return new this.constructor().copy( this );
				 */return new BufferGeometry().copy(this);},copy:function copy(source){var name,i,l;// reset
	this.index=null;this.attributes={};this.morphAttributes={};this.groups=[];this.boundingBox=null;this.boundingSphere=null;// name
	this.name=source.name;// index
	var index=source.index;if(index!==null){this.setIndex(index.clone());}// attributes
	var attributes=source.attributes;for(name in attributes){var attribute=attributes[name];this.addAttribute(name,attribute.clone());}// morph attributes
	var morphAttributes=source.morphAttributes;for(name in morphAttributes){var array=[];var morphAttribute=morphAttributes[name];// morphAttribute: array of Float32BufferAttributes
	for(i=0,l=morphAttribute.length;i<l;i++){array.push(morphAttribute[i].clone());}this.morphAttributes[name]=array;}// groups
	var groups=source.groups;for(i=0,l=groups.length;i<l;i++){var group=groups[i];this.addGroup(group.start,group.count,group.materialIndex);}// bounding box
	var boundingBox=source.boundingBox;if(boundingBox!==null){this.boundingBox=boundingBox.clone();}// bounding sphere
	var boundingSphere=source.boundingSphere;if(boundingSphere!==null){this.boundingSphere=boundingSphere.clone();}// draw range
	this.drawRange.start=source.drawRange.start;this.drawRange.count=source.drawRange.count;return this;},dispose:function dispose(){this.dispatchEvent({type:'dispose'});}});/**
		 * @author mrdoob / http://mrdoob.com/
		 * @author alteredq / http://alteredqualia.com/
		 * @author mikael emtinger / http://gomo.se/
		 * @author jonobr1 / http://jonobr1.com/
		 */function Mesh(geometry,material){Object3D.call(this);this.type='Mesh';this.geometry=geometry!==undefined?geometry:new BufferGeometry();this.material=material!==undefined?material:new MeshBasicMaterial({color:Math.random()*0xffffff});this.drawMode=TrianglesDrawMode;this.updateMorphTargets();}Mesh.prototype=_assign(Object.create(Object3D.prototype),{constructor:Mesh,isMesh:true,setDrawMode:function setDrawMode(value){this.drawMode=value;},copy:function copy(source){Object3D.prototype.copy.call(this,source);this.drawMode=source.drawMode;return this;},updateMorphTargets:function updateMorphTargets(){var morphTargets=this.geometry.morphTargets;if(morphTargets!==undefined&&morphTargets.length>0){this.morphTargetInfluences=[];this.morphTargetDictionary={};for(var m=0,ml=morphTargets.length;m<ml;m++){this.morphTargetInfluences.push(0);this.morphTargetDictionary[morphTargets[m].name]=m;}}},raycast:function(){var inverseMatrix=new Matrix4();var ray=new Ray();var sphere=new Sphere();var vA=new Vector3();var vB=new Vector3();var vC=new Vector3();var tempA=new Vector3();var tempB=new Vector3();var tempC=new Vector3();var uvA=new Vector2();var uvB=new Vector2();var uvC=new Vector2();var barycoord=new Vector3();var intersectionPoint=new Vector3();var intersectionPointWorld=new Vector3();function uvIntersection(point,p1,p2,p3,uv1,uv2,uv3){Triangle.barycoordFromPoint(point,p1,p2,p3,barycoord);uv1.multiplyScalar(barycoord.x);uv2.multiplyScalar(barycoord.y);uv3.multiplyScalar(barycoord.z);uv1.add(uv2).add(uv3);return uv1.clone();}function checkIntersection(object,raycaster,ray,pA,pB,pC,point){var intersect;var material=object.material;if(material.side===BackSide){intersect=ray.intersectTriangle(pC,pB,pA,true,point);}else{intersect=ray.intersectTriangle(pA,pB,pC,material.side!==DoubleSide,point);}if(intersect===null)return null;intersectionPointWorld.copy(point);intersectionPointWorld.applyMatrix4(object.matrixWorld);var distance=raycaster.ray.origin.distanceTo(intersectionPointWorld);if(distance<raycaster.near||distance>raycaster.far)return null;return{distance:distance,point:intersectionPointWorld.clone(),object:object};}function checkBufferGeometryIntersection(object,raycaster,ray,position,uv,a,b,c){vA.fromBufferAttribute(position,a);vB.fromBufferAttribute(position,b);vC.fromBufferAttribute(position,c);var intersection=checkIntersection(object,raycaster,ray,vA,vB,vC,intersectionPoint);if(intersection){if(uv){uvA.fromBufferAttribute(uv,a);uvB.fromBufferAttribute(uv,b);uvC.fromBufferAttribute(uv,c);intersection.uv=uvIntersection(intersectionPoint,vA,vB,vC,uvA,uvB,uvC);}intersection.face=new Face3(a,b,c,Triangle.normal(vA,vB,vC));intersection.faceIndex=a;}return intersection;}return function raycast(raycaster,intersects){var geometry=this.geometry;var material=this.material;var matrixWorld=this.matrixWorld;if(material===undefined)return;// Checking boundingSphere distance to ray
	if(geometry.boundingSphere===null)geometry.computeBoundingSphere();sphere.copy(geometry.boundingSphere);sphere.applyMatrix4(matrixWorld);if(raycaster.ray.intersectsSphere(sphere)===false)return;//
	inverseMatrix.getInverse(matrixWorld);ray.copy(raycaster.ray).applyMatrix4(inverseMatrix);// Check boundingBox before continuing
	if(geometry.boundingBox!==null){if(ray.intersectsBox(geometry.boundingBox)===false)return;}var intersection;if(geometry.isBufferGeometry){var a,b,c;var index=geometry.index;var position=geometry.attributes.position;var uv=geometry.attributes.uv;var i,l;if(index!==null){// indexed buffer geometry
	for(i=0,l=index.count;i<l;i+=3){a=index.getX(i);b=index.getX(i+1);c=index.getX(i+2);intersection=checkBufferGeometryIntersection(this,raycaster,ray,position,uv,a,b,c);if(intersection){intersection.faceIndex=Math.floor(i/3);// triangle number in indices buffer semantics
	intersects.push(intersection);}}}else{// non-indexed buffer geometry
	for(i=0,l=position.count;i<l;i+=3){a=i;b=i+1;c=i+2;intersection=checkBufferGeometryIntersection(this,raycaster,ray,position,uv,a,b,c);if(intersection){intersection.index=a;// triangle number in positions buffer semantics
	intersects.push(intersection);}}}}else if(geometry.isGeometry){var fvA,fvB,fvC;var isMultiMaterial=Array.isArray(material);var vertices=geometry.vertices;var faces=geometry.faces;var uvs;var faceVertexUvs=geometry.faceVertexUvs[0];if(faceVertexUvs.length>0)uvs=faceVertexUvs;for(var f=0,fl=faces.length;f<fl;f++){var face=faces[f];var faceMaterial=isMultiMaterial?material[face.materialIndex]:material;if(faceMaterial===undefined)continue;fvA=vertices[face.a];fvB=vertices[face.b];fvC=vertices[face.c];if(faceMaterial.morphTargets===true){var morphTargets=geometry.morphTargets;var morphInfluences=this.morphTargetInfluences;vA.set(0,0,0);vB.set(0,0,0);vC.set(0,0,0);for(var t=0,tl=morphTargets.length;t<tl;t++){var influence=morphInfluences[t];if(influence===0)continue;var targets=morphTargets[t].vertices;vA.addScaledVector(tempA.subVectors(targets[face.a],fvA),influence);vB.addScaledVector(tempB.subVectors(targets[face.b],fvB),influence);vC.addScaledVector(tempC.subVectors(targets[face.c],fvC),influence);}vA.add(fvA);vB.add(fvB);vC.add(fvC);fvA=vA;fvB=vB;fvC=vC;}intersection=checkIntersection(this,raycaster,ray,fvA,fvB,fvC,intersectionPoint);if(intersection){if(uvs&&uvs[f]){var uvs_f=uvs[f];uvA.copy(uvs_f[0]);uvB.copy(uvs_f[1]);uvC.copy(uvs_f[2]);intersection.uv=uvIntersection(intersectionPoint,fvA,fvB,fvC,uvA,uvB,uvC);}intersection.face=face;intersection.faceIndex=f;intersects.push(intersection);}}}};}(),clone:function clone(){return new this.constructor(this.geometry,this.material).copy(this);}});/**
		 * @author mrdoob / http://mrdoob.com/
		 * @author Mugen87 / https://github.com/Mugen87
		 *
		 * based on http://papervision3d.googlecode.com/svn/trunk/as3/trunk/src/org/papervision3d/objects/primitives/Cube.as
		 */// BoxBufferGeometry
	function BoxBufferGeometry(width,height,depth,widthSegments,heightSegments,depthSegments){BufferGeometry.call(this);this.type='BoxBufferGeometry';this.parameters={width:width,height:height,depth:depth,widthSegments:widthSegments,heightSegments:heightSegments,depthSegments:depthSegments};var scope=this;// segments
	widthSegments=Math.floor(widthSegments)||1;heightSegments=Math.floor(heightSegments)||1;depthSegments=Math.floor(depthSegments)||1;// buffers
	var indices=[];var vertices=[];var normals=[];var uvs=[];// helper variables
	var numberOfVertices=0;var groupStart=0;// build each side of the box geometry
	buildPlane('z','y','x',-1,-1,depth,height,width,depthSegments,heightSegments,0);// px
	buildPlane('z','y','x',1,-1,depth,height,-width,depthSegments,heightSegments,1);// nx
	buildPlane('x','z','y',1,1,width,depth,height,widthSegments,depthSegments,2);// py
	buildPlane('x','z','y',1,-1,width,depth,-height,widthSegments,depthSegments,3);// ny
	buildPlane('x','y','z',1,-1,width,height,depth,widthSegments,heightSegments,4);// pz
	buildPlane('x','y','z',-1,-1,width,height,-depth,widthSegments,heightSegments,5);// nz
	// build geometry
	this.setIndex(indices);this.addAttribute('position',new Float32BufferAttribute(vertices,3));this.addAttribute('normal',new Float32BufferAttribute(normals,3));this.addAttribute('uv',new Float32BufferAttribute(uvs,2));function buildPlane(u,v,w,udir,vdir,width,height,depth,gridX,gridY,materialIndex){var segmentWidth=width/gridX;var segmentHeight=height/gridY;var widthHalf=width/2;var heightHalf=height/2;var depthHalf=depth/2;var gridX1=gridX+1;var gridY1=gridY+1;var vertexCounter=0;var groupCount=0;var ix,iy;var vector=new Vector3();// generate vertices, normals and uvs
	for(iy=0;iy<gridY1;iy++){var y=iy*segmentHeight-heightHalf;for(ix=0;ix<gridX1;ix++){var x=ix*segmentWidth-widthHalf;// set values to correct vector component
	vector[u]=x*udir;vector[v]=y*vdir;vector[w]=depthHalf;// now apply vector to vertex buffer
	vertices.push(vector.x,vector.y,vector.z);// set values to correct vector component
	vector[u]=0;vector[v]=0;vector[w]=depth>0?1:-1;// now apply vector to normal buffer
	normals.push(vector.x,vector.y,vector.z);// uvs
	uvs.push(ix/gridX);uvs.push(1-iy/gridY);// counters
	vertexCounter+=1;}}// indices
	// 1. you need three indices to draw a single face
	// 2. a single segment consists of two faces
	// 3. so we need to generate six (2*3) indices per segment
	for(iy=0;iy<gridY;iy++){for(ix=0;ix<gridX;ix++){var a=numberOfVertices+ix+gridX1*iy;var b=numberOfVertices+ix+gridX1*(iy+1);var c=numberOfVertices+(ix+1)+gridX1*(iy+1);var d=numberOfVertices+(ix+1)+gridX1*iy;// faces
	indices.push(a,b,d);indices.push(b,c,d);// increase counter
	groupCount+=6;}}// add a group to the geometry. this will ensure multi material support
	scope.addGroup(groupStart,groupCount,materialIndex);// calculate new start value for groups
	groupStart+=groupCount;// update total number of vertices
	numberOfVertices+=vertexCounter;}}BoxBufferGeometry.prototype=Object.create(BufferGeometry.prototype);BoxBufferGeometry.prototype.constructor=BoxBufferGeometry;/**
		 * @author mrdoob / http://mrdoob.com/
		 * @author Mugen87 / https://github.com/Mugen87
		 *
		 * based on http://papervision3d.googlecode.com/svn/trunk/as3/trunk/src/org/papervision3d/objects/primitives/Plane.as
		 */// PlaneBufferGeometry
	function PlaneBufferGeometry(width,height,widthSegments,heightSegments){BufferGeometry.call(this);this.type='PlaneBufferGeometry';this.parameters={width:width,height:height,widthSegments:widthSegments,heightSegments:heightSegments};var width_half=width/2;var height_half=height/2;var gridX=Math.floor(widthSegments)||1;var gridY=Math.floor(heightSegments)||1;var gridX1=gridX+1;var gridY1=gridY+1;var segment_width=width/gridX;var segment_height=height/gridY;var ix,iy;// buffers
	var indices=[];var vertices=[];var normals=[];var uvs=[];// generate vertices, normals and uvs
	for(iy=0;iy<gridY1;iy++){var y=iy*segment_height-height_half;for(ix=0;ix<gridX1;ix++){var x=ix*segment_width-width_half;vertices.push(x,-y,0);normals.push(0,0,1);uvs.push(ix/gridX);uvs.push(1-iy/gridY);}}// indices
	for(iy=0;iy<gridY;iy++){for(ix=0;ix<gridX;ix++){var a=ix+gridX1*iy;var b=ix+gridX1*(iy+1);var c=ix+1+gridX1*(iy+1);var d=ix+1+gridX1*iy;// faces
	indices.push(a,b,d);indices.push(b,c,d);}}// build geometry
	this.setIndex(indices);this.addAttribute('position',new Float32BufferAttribute(vertices,3));this.addAttribute('normal',new Float32BufferAttribute(normals,3));this.addAttribute('uv',new Float32BufferAttribute(uvs,2));}PlaneBufferGeometry.prototype=Object.create(BufferGeometry.prototype);PlaneBufferGeometry.prototype.constructor=PlaneBufferGeometry;/**
		 * @author mrdoob / http://mrdoob.com/
		 * @author mikael emtinger / http://gomo.se/
		 * @author WestLangley / http://github.com/WestLangley
		*/function Camera(){Object3D.call(this);this.type='Camera';this.matrixWorldInverse=new Matrix4();this.projectionMatrix=new Matrix4();}Camera.prototype=_assign(Object.create(Object3D.prototype),{constructor:Camera,isCamera:true,copy:function copy(source){Object3D.prototype.copy.call(this,source);this.matrixWorldInverse.copy(source.matrixWorldInverse);this.projectionMatrix.copy(source.projectionMatrix);return this;},getWorldDirection:function(){var quaternion=new Quaternion();return function getWorldDirection(optionalTarget){var result=optionalTarget||new Vector3();this.getWorldQuaternion(quaternion);return result.set(0,0,-1).applyQuaternion(quaternion);};}(),clone:function clone(){return new this.constructor().copy(this);}});/**
		 * @author mrdoob / http://mrdoob.com/
		 * @author greggman / http://games.greggman.com/
		 * @author zz85 / http://www.lab4games.net/zz85/blog
		 * @author tschw
		 */function PerspectiveCamera(fov,aspect,near,far){Camera.call(this);this.type='PerspectiveCamera';this.fov=fov!==undefined?fov:50;this.zoom=1;this.near=near!==undefined?near:0.1;this.far=far!==undefined?far:2000;this.focus=10;this.aspect=aspect!==undefined?aspect:1;this.view=null;this.filmGauge=35;// width of the film (default in millimeters)
	this.filmOffset=0;// horizontal film offset (same unit as gauge)
	this.updateProjectionMatrix();}PerspectiveCamera.prototype=_assign(Object.create(Camera.prototype),{constructor:PerspectiveCamera,isPerspectiveCamera:true,copy:function copy(source){Camera.prototype.copy.call(this,source);this.fov=source.fov;this.zoom=source.zoom;this.near=source.near;this.far=source.far;this.focus=source.focus;this.aspect=source.aspect;this.view=source.view===null?null:_assign({},source.view);this.filmGauge=source.filmGauge;this.filmOffset=source.filmOffset;return this;},/**
			 * Sets the FOV by focal length in respect to the current .filmGauge.
			 *
			 * The default film gauge is 35, so that the focal length can be specified for
			 * a 35mm (full frame) camera.
			 *
			 * Values for focal length and film gauge must have the same unit.
			 */setFocalLength:function setFocalLength(focalLength){// see http://www.bobatkins.com/photography/technical/field_of_view.html
	var vExtentSlope=0.5*this.getFilmHeight()/focalLength;this.fov=_Math.RAD2DEG*2*Math.atan(vExtentSlope);this.updateProjectionMatrix();},/**
			 * Calculates the focal length from the current .fov and .filmGauge.
			 */getFocalLength:function getFocalLength(){var vExtentSlope=Math.tan(_Math.DEG2RAD*0.5*this.fov);return 0.5*this.getFilmHeight()/vExtentSlope;},getEffectiveFOV:function getEffectiveFOV(){return _Math.RAD2DEG*2*Math.atan(Math.tan(_Math.DEG2RAD*0.5*this.fov)/this.zoom);},getFilmWidth:function getFilmWidth(){// film not completely covered in portrait format (aspect < 1)
	return this.filmGauge*Math.min(this.aspect,1);},getFilmHeight:function getFilmHeight(){// film not completely covered in landscape format (aspect > 1)
	return this.filmGauge/Math.max(this.aspect,1);},/**
			 * Sets an offset in a larger frustum. This is useful for multi-window or
			 * multi-monitor/multi-machine setups.
			 *
			 * For example, if you have 3x2 monitors and each monitor is 1920x1080 and
			 * the monitors are in grid like this
			 *
			 *   +---+---+---+
			 *   | A | B | C |
			 *   +---+---+---+
			 *   | D | E | F |
			 *   +---+---+---+
			 *
			 * then for each monitor you would call it like this
			 *
			 *   var w = 1920;
			 *   var h = 1080;
			 *   var fullWidth = w * 3;
			 *   var fullHeight = h * 2;
			 *
			 *   --A--
			 *   camera.setOffset( fullWidth, fullHeight, w * 0, h * 0, w, h );
			 *   --B--
			 *   camera.setOffset( fullWidth, fullHeight, w * 1, h * 0, w, h );
			 *   --C--
			 *   camera.setOffset( fullWidth, fullHeight, w * 2, h * 0, w, h );
			 *   --D--
			 *   camera.setOffset( fullWidth, fullHeight, w * 0, h * 1, w, h );
			 *   --E--
			 *   camera.setOffset( fullWidth, fullHeight, w * 1, h * 1, w, h );
			 *   --F--
			 *   camera.setOffset( fullWidth, fullHeight, w * 2, h * 1, w, h );
			 *
			 *   Note there is no reason monitors have to be the same size or in a grid.
			 */setViewOffset:function setViewOffset(fullWidth,fullHeight,x,y,width,height){this.aspect=fullWidth/fullHeight;this.view={fullWidth:fullWidth,fullHeight:fullHeight,offsetX:x,offsetY:y,width:width,height:height};this.updateProjectionMatrix();},clearViewOffset:function clearViewOffset(){this.view=null;this.updateProjectionMatrix();},updateProjectionMatrix:function updateProjectionMatrix(){var near=this.near,top=near*Math.tan(_Math.DEG2RAD*0.5*this.fov)/this.zoom,height=2*top,width=this.aspect*height,left=-0.5*width,view=this.view;if(view!==null){var fullWidth=view.fullWidth,fullHeight=view.fullHeight;left+=view.offsetX*width/fullWidth;top-=view.offsetY*height/fullHeight;width*=view.width/fullWidth;height*=view.height/fullHeight;}var skew=this.filmOffset;if(skew!==0)left+=near*skew/this.getFilmWidth();this.projectionMatrix.makePerspective(left,left+width,top,top-height,near,this.far);},toJSON:function toJSON(meta){var data=Object3D.prototype.toJSON.call(this,meta);data.object.fov=this.fov;data.object.zoom=this.zoom;data.object.near=this.near;data.object.far=this.far;data.object.focus=this.focus;data.object.aspect=this.aspect;if(this.view!==null)data.object.view=_assign({},this.view);data.object.filmGauge=this.filmGauge;data.object.filmOffset=this.filmOffset;return data;}});/**
		 * @author alteredq / http://alteredqualia.com/
		 * @author arose / http://github.com/arose
		 */function OrthographicCamera(left,right,top,bottom,near,far){Camera.call(this);this.type='OrthographicCamera';this.zoom=1;this.view=null;this.left=left;this.right=right;this.top=top;this.bottom=bottom;this.near=near!==undefined?near:0.1;this.far=far!==undefined?far:2000;this.updateProjectionMatrix();}OrthographicCamera.prototype=_assign(Object.create(Camera.prototype),{constructor:OrthographicCamera,isOrthographicCamera:true,copy:function copy(source){Camera.prototype.copy.call(this,source);this.left=source.left;this.right=source.right;this.top=source.top;this.bottom=source.bottom;this.near=source.near;this.far=source.far;this.zoom=source.zoom;this.view=source.view===null?null:_assign({},source.view);return this;},setViewOffset:function setViewOffset(fullWidth,fullHeight,x,y,width,height){this.view={fullWidth:fullWidth,fullHeight:fullHeight,offsetX:x,offsetY:y,width:width,height:height};this.updateProjectionMatrix();},clearViewOffset:function clearViewOffset(){this.view=null;this.updateProjectionMatrix();},updateProjectionMatrix:function updateProjectionMatrix(){var dx=(this.right-this.left)/(2*this.zoom);var dy=(this.top-this.bottom)/(2*this.zoom);var cx=(this.right+this.left)/2;var cy=(this.top+this.bottom)/2;var left=cx-dx;var right=cx+dx;var top=cy+dy;var bottom=cy-dy;if(this.view!==null){var zoomW=this.zoom/(this.view.width/this.view.fullWidth);var zoomH=this.zoom/(this.view.height/this.view.fullHeight);var scaleW=(this.right-this.left)/this.view.width;var scaleH=(this.top-this.bottom)/this.view.height;left+=scaleW*(this.view.offsetX/zoomW);right=left+scaleW*(this.view.width/zoomW);top-=scaleH*(this.view.offsetY/zoomH);bottom=top-scaleH*(this.view.height/zoomH);}this.projectionMatrix.makeOrthographic(left,right,top,bottom,this.near,this.far);},toJSON:function toJSON(meta){var data=Object3D.prototype.toJSON.call(this,meta);data.object.zoom=this.zoom;data.object.left=this.left;data.object.right=this.right;data.object.top=this.top;data.object.bottom=this.bottom;data.object.near=this.near;data.object.far=this.far;if(this.view!==null)data.object.view=_assign({},this.view);return data;}});/**
		 * @author mrdoob / http://mrdoob.com/
		 */function WebGLAttributes(gl){var buffers={};function createBuffer(attribute,bufferType){var array=attribute.array;var usage=attribute.dynamic?gl.DYNAMIC_DRAW:gl.STATIC_DRAW;var buffer=gl.createBuffer();gl.bindBuffer(bufferType,buffer);gl.bufferData(bufferType,array,usage);attribute.onUploadCallback();var type=gl.FLOAT;if(array instanceof Float32Array){type=gl.FLOAT;}else if(array instanceof Float64Array){console.warn("Unsupported data buffer format: Float64Array");}else if(array instanceof Uint16Array){type=gl.UNSIGNED_SHORT;}else if(array instanceof Int16Array){type=gl.SHORT;}else if(array instanceof Uint32Array){type=gl.UNSIGNED_INT;}else if(array instanceof Int32Array){type=gl.INT;}else if(array instanceof Int8Array){type=gl.BYTE;}else if(array instanceof Uint8Array){type=gl.UNSIGNED_BYTE;}return{buffer:buffer,type:type,bytesPerElement:array.BYTES_PER_ELEMENT,version:attribute.version};}function updateBuffer(buffer,attribute,bufferType){var array=attribute.array;var updateRange=attribute.updateRange;gl.bindBuffer(bufferType,buffer);if(attribute.dynamic===false){gl.bufferData(bufferType,array,gl.STATIC_DRAW);}else if(updateRange.count===-1){// Not using update ranges
	gl.bufferSubData(bufferType,0,array);}else if(updateRange.count===0){console.error('THREE.WebGLObjects.updateBuffer: dynamic THREE.BufferAttribute marked as needsUpdate but updateRange.count is 0, ensure you are using set methods or updating manually.');}else{gl.bufferSubData(bufferType,updateRange.offset*array.BYTES_PER_ELEMENT,array.subarray(updateRange.offset,updateRange.offset+updateRange.count));updateRange.count=0;// reset range
	}}//
	function get(attribute){if(attribute.isInterleavedBufferAttribute)attribute=attribute.data;return buffers[attribute.uuid];}function remove(attribute){var data=buffers[attribute.uuid];if(data){gl.deleteBuffer(data.buffer);delete buffers[attribute.uuid];}}function update(attribute,bufferType){if(attribute.isInterleavedBufferAttribute)attribute=attribute.data;var data=buffers[attribute.uuid];if(data===undefined){buffers[attribute.uuid]=createBuffer(attribute,bufferType);}else if(data.version<attribute.version){updateBuffer(data.buffer,attribute,bufferType);data.version=attribute.version;}}return{get:get,remove:remove,update:update};}/**
		 * @author mrdoob / http://mrdoob.com/
		 */function painterSortStable(a,b){if(a.renderOrder!==b.renderOrder){return a.renderOrder-b.renderOrder;}else if(a.program&&b.program&&a.program!==b.program){return a.program.id-b.program.id;}else if(a.material.id!==b.material.id){return a.material.id-b.material.id;}else if(a.z!==b.z){return a.z-b.z;}else{return a.id-b.id;}}function reversePainterSortStable(a,b){if(a.renderOrder!==b.renderOrder){return a.renderOrder-b.renderOrder;}if(a.z!==b.z){return b.z-a.z;}else{return a.id-b.id;}}function WebGLRenderList(){var opaque=[];var opaqueLastIndex=-1;var transparent=[];var transparentLastIndex=-1;function init(){opaqueLastIndex=-1;transparentLastIndex=-1;}function push(object,geometry,material,z,group){var array,index;// allocate the next position in the appropriate array
	if(material.transparent){array=transparent;index=++transparentLastIndex;}else{array=opaque;index=++opaqueLastIndex;}// recycle existing render item or grow the array
	var renderItem=array[index];if(renderItem){renderItem.id=object.id;renderItem.object=object;renderItem.geometry=geometry;renderItem.material=material;renderItem.program=material.program;renderItem.renderOrder=object.renderOrder;renderItem.z=z;renderItem.group=group;}else{renderItem={id:object.id,object:object,geometry:geometry,material:material,program:material.program,renderOrder:object.renderOrder,z:z,group:group};// assert( index === array.length );
	array.push(renderItem);}}function finish(){opaque.length=opaqueLastIndex+1;transparent.length=transparentLastIndex+1;}function sort(){opaque.sort(painterSortStable);transparent.sort(reversePainterSortStable);}return{opaque:opaque,transparent:transparent,init:init,push:push,finish:finish,sort:sort};}function WebGLRenderLists(){var lists={};function get(scene,camera){var hash=scene.id+','+camera.id;var list=lists[hash];if(list===undefined){console.log('THREE.WebGLRenderLists:',hash);list=new WebGLRenderList();lists[hash]=list;}return list;}function dispose(){lists={};}return{get:get,dispose:dispose};}/**
		 * @author mrdoob / http://mrdoob.com/
		 */function WebGLIndexedBufferRenderer(gl,extensions,infoRender){var mode;function setMode(value){mode=value;}var type,size;function setIndex(index){if(index.array instanceof Uint32Array&&extensions.get('OES_element_index_uint')){type=gl.UNSIGNED_INT;size=4;}else if(index.array instanceof Uint16Array){type=gl.UNSIGNED_SHORT;size=2;}else{type=gl.UNSIGNED_BYTE;size=1;}}function render(start,count){gl.drawElements(mode,count,type,start*size);infoRender.calls++;infoRender.vertices+=count;if(mode===gl.TRIANGLES)infoRender.faces+=count/3;}function renderInstances(geometry,start,count){var extension=extensions.get('ANGLE_instanced_arrays');if(extension===null){console.error('THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.');return;}extension.drawElementsInstancedANGLE(mode,count,type,start*size,geometry.maxInstancedCount);infoRender.calls++;infoRender.vertices+=count*geometry.maxInstancedCount;if(mode===gl.TRIANGLES)infoRender.faces+=geometry.maxInstancedCount*count/3;}//
	this.setMode=setMode;this.setIndex=setIndex;this.render=render;this.renderInstances=renderInstances;}/**
		 * @author mrdoob / http://mrdoob.com/
		 */function WebGLBufferRenderer(gl,extensions,infoRender){var mode;function setMode(value){mode=value;}function render(start,count){gl.drawArrays(mode,start,count);infoRender.calls++;infoRender.vertices+=count;if(mode===gl.TRIANGLES)infoRender.faces+=count/3;}function renderInstances(geometry,start,count){var extension=extensions.get('ANGLE_instanced_arrays');if(extension===null){console.error('THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.');return;}var position=geometry.attributes.position;if(position.isInterleavedBufferAttribute){count=position.data.count;extension.drawArraysInstancedANGLE(mode,0,count,geometry.maxInstancedCount);}else{extension.drawArraysInstancedANGLE(mode,start,count,geometry.maxInstancedCount);}infoRender.calls++;infoRender.vertices+=count*geometry.maxInstancedCount;if(mode===gl.TRIANGLES)infoRender.faces+=geometry.maxInstancedCount*count/3;}//
	this.setMode=setMode;this.render=render;this.renderInstances=renderInstances;}/**
		 * @author mrdoob / http://mrdoob.com/
		 */function WebGLGeometries(gl,attributes,infoMemory){var geometries={};var wireframeAttributes={};function onGeometryDispose(event){var geometry=event.target;var buffergeometry=geometries[geometry.id];if(buffergeometry.index!==null){attributes.remove(buffergeometry.index);}for(var name in buffergeometry.attributes){attributes.remove(buffergeometry.attributes[name]);}geometry.removeEventListener('dispose',onGeometryDispose);delete geometries[geometry.id];// TODO Remove duplicate code
	var attribute=wireframeAttributes[geometry.id];if(attribute){attributes.remove(attribute);delete wireframeAttributes[geometry.id];}attribute=wireframeAttributes[buffergeometry.id];if(attribute){attributes.remove(attribute);delete wireframeAttributes[buffergeometry.id];}//
	infoMemory.geometries--;}function get(object,geometry){var buffergeometry=geometries[geometry.id];if(buffergeometry)return buffergeometry;geometry.addEventListener('dispose',onGeometryDispose);if(geometry.isBufferGeometry){buffergeometry=geometry;}else if(geometry.isGeometry){if(geometry._bufferGeometry===undefined){geometry._bufferGeometry=new BufferGeometry().setFromObject(object);}buffergeometry=geometry._bufferGeometry;}geometries[geometry.id]=buffergeometry;infoMemory.geometries++;return buffergeometry;}function update(geometry){var index=geometry.index;var geometryAttributes=geometry.attributes;if(index!==null){attributes.update(index,gl.ELEMENT_ARRAY_BUFFER);}for(var name in geometryAttributes){attributes.update(geometryAttributes[name],gl.ARRAY_BUFFER);}// morph targets
	var morphAttributes=geometry.morphAttributes;for(var name in morphAttributes){var array=morphAttributes[name];for(var i=0,l=array.length;i<l;i++){attributes.update(array[i],gl.ARRAY_BUFFER);}}}function getWireframeAttribute(geometry){var attribute=wireframeAttributes[geometry.id];if(attribute)return attribute;var indices=[];var geometryIndex=geometry.index;var geometryAttributes=geometry.attributes;// console.time( 'wireframe' );
	if(geometryIndex!==null){var array=geometryIndex.array;for(var i=0,l=array.length;i<l;i+=3){var a=array[i+0];var b=array[i+1];var c=array[i+2];indices.push(a,b,b,c,c,a);}}else{var array=geometryAttributes.position.array;for(var i=0,l=array.length/3-1;i<l;i+=3){var a=i+0;var b=i+1;var c=i+2;indices.push(a,b,b,c,c,a);}}// console.timeEnd( 'wireframe' );
	attribute=new(arrayMax(indices)>65535?Uint32BufferAttribute:Uint16BufferAttribute)(indices,1);attributes.update(attribute,gl.ELEMENT_ARRAY_BUFFER);wireframeAttributes[geometry.id]=attribute;return attribute;}return{get:get,update:update,getWireframeAttribute:getWireframeAttribute};}/**
		 * @author mrdoob / http://mrdoob.com/
		 */function WebGLLights(){var lights={};return{get:function get(light){if(lights[light.id]!==undefined){return lights[light.id];}var uniforms;switch(light.type){case'DirectionalLight':uniforms={direction:new Vector3(),color:new Color(),shadow:false,shadowBias:0,shadowRadius:1,shadowMapSize:new Vector2()};break;case'SpotLight':uniforms={position:new Vector3(),direction:new Vector3(),color:new Color(),distance:0,coneCos:0,penumbraCos:0,decay:0,shadow:false,shadowBias:0,shadowRadius:1,shadowMapSize:new Vector2()};break;case'PointLight':uniforms={position:new Vector3(),color:new Color(),distance:0,decay:0,shadow:false,shadowBias:0,shadowRadius:1,shadowMapSize:new Vector2()};break;case'HemisphereLight':uniforms={direction:new Vector3(),skyColor:new Color(),groundColor:new Color()};break;case'RectAreaLight':uniforms={color:new Color(),position:new Vector3(),halfWidth:new Vector3(),halfHeight:new Vector3()// TODO (abelnation): set RectAreaLight shadow uniforms
	};break;}lights[light.id]=uniforms;return uniforms;}};}/**
		 * @author mrdoob / http://mrdoob.com/
		 */function WebGLObjects(gl,geometries,infoRender){var updateList={};function update(object){var frame=infoRender.frame;var geometry=object.geometry;var buffergeometry=geometries.get(object,geometry);// Update once per frame
	if(updateList[buffergeometry.id]!==frame){if(geometry.isGeometry){buffergeometry.updateFromObject(object);}geometries.update(buffergeometry);updateList[buffergeometry.id]=frame;}return buffergeometry;}function clear(){updateList={};}return{update:update,clear:clear};}/**
		 * @author mrdoob / http://mrdoob.com/
		 */function addLineNumbers(string){var lines=string.split('\n');for(var i=0;i<lines.length;i++){lines[i]=i+1+': '+lines[i];}return lines.join('\n');}function WebGLShader(gl,type,string){var shader=gl.createShader(type);gl.shaderSource(shader,string);gl.compileShader(shader);if(gl.getShaderParameter(shader,gl.COMPILE_STATUS)===false){console.error('THREE.WebGLShader: Shader couldn\'t compile.');}if(gl.getShaderInfoLog(shader)!==''){console.warn('THREE.WebGLShader: gl.getShaderInfoLog()',type===gl.VERTEX_SHADER?'vertex':'fragment',gl.getShaderInfoLog(shader),addLineNumbers(string));}// --enable-privileged-webgl-extension
	// console.log( type, gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( shader ) );
	return shader;}/**
		 * @author mrdoob / http://mrdoob.com/
		 */var programIdCount=0;function getEncodingComponents(encoding){switch(encoding){case LinearEncoding:return['Linear','( value )'];case sRGBEncoding:return['sRGB','( value )'];case RGBEEncoding:return['RGBE','( value )'];case RGBM7Encoding:return['RGBM','( value, 7.0 )'];case RGBM16Encoding:return['RGBM','( value, 16.0 )'];case RGBDEncoding:return['RGBD','( value, 256.0 )'];case GammaEncoding:return['Gamma','( value, float( GAMMA_FACTOR ) )'];default:throw new Error('unsupported encoding: '+encoding);}}function getTexelDecodingFunction(functionName,encoding){var components=getEncodingComponents(encoding);return"vec4 "+functionName+"( vec4 value ) { return "+components[0]+"ToLinear"+components[1]+"; }";}function getTexelEncodingFunction(functionName,encoding){var components=getEncodingComponents(encoding);return"vec4 "+functionName+"( vec4 value ) { return LinearTo"+components[0]+components[1]+"; }";}function getToneMappingFunction(functionName,toneMapping){var toneMappingName;switch(toneMapping){case LinearToneMapping:toneMappingName="Linear";break;case ReinhardToneMapping:toneMappingName="Reinhard";break;case Uncharted2ToneMapping:toneMappingName="Uncharted2";break;case CineonToneMapping:toneMappingName="OptimizedCineon";break;default:throw new Error('unsupported toneMapping: '+toneMapping);}return"vec3 "+functionName+"( vec3 color ) { return "+toneMappingName+"ToneMapping( color ); }";}function generateExtensions(extensions,parameters,rendererExtensions){extensions=extensions||{};var chunks=[extensions.derivatives||parameters.envMapCubeUV||parameters.bumpMap||parameters.normalMap||parameters.flatShading?'#extension GL_OES_standard_derivatives : enable':'',(extensions.fragDepth||parameters.logarithmicDepthBuffer)&&rendererExtensions.get('EXT_frag_depth')?'#extension GL_EXT_frag_depth : enable':'',extensions.drawBuffers&&rendererExtensions.get('WEBGL_draw_buffers')?'#extension GL_EXT_draw_buffers : require':'',(extensions.shaderTextureLOD||parameters.envMap)&&rendererExtensions.get('EXT_shader_texture_lod')?'#extension GL_EXT_shader_texture_lod : enable':''];return chunks.filter(filterEmptyLine).join('\n');}function generateDefines(defines){var chunks=[];for(var name in defines){var value=defines[name];if(value===false)continue;chunks.push('#define '+name+' '+value);}return chunks.join('\n');}function fetchAttributeLocations(gl,program,identifiers){var attributes={};var n=gl.getProgramParameter(program,gl.ACTIVE_ATTRIBUTES);for(var i=0;i<n;i++){var info=gl.getActiveAttrib(program,i);var name=info.name;// console.log("THREE.WebGLProgram: ACTIVE VERTEX ATTRIBUTE:", name, i );
	attributes[name]=gl.getAttribLocation(program,name);}return attributes;}function filterEmptyLine(string){return string!=='';}function replaceLightNums(string,parameters){return string.replace(/NUM_DIR_LIGHTS/g,parameters.numDirLights).replace(/NUM_SPOT_LIGHTS/g,parameters.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g,parameters.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g,parameters.numPointLights).replace(/NUM_HEMI_LIGHTS/g,parameters.numHemiLights);}function parseIncludes(string){var pattern=/^\s*#include +<([\w\d.]+)>/gm;function replace(match,include){var replace=ShaderChunk[include];if(replace===undefined){throw new Error('Can not resolve #include <'+include+'>');}return parseIncludes(replace);}return string.replace(pattern,replace);}function unrollLoops(string){var pattern=/for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g;function replace(match,start,end,snippet){var unroll='';for(var i=parseInt(start);i<parseInt(end);i++){unroll+=snippet.replace(/\[ i \]/g,'[ '+i+' ]');}return unroll;}return string.replace(pattern,replace);}function WebGLProgram(renderer,code,material,parameters){var gl=renderer.context;var extensions=material.extensions;var defines=material.defines;var vertexShader=material.__webglShader.vertexShader;var fragmentShader=material.__webglShader.fragmentShader;var shadowMapTypeDefine='SHADOWMAP_TYPE_BASIC';if(parameters.shadowMapType===PCFShadowMap){shadowMapTypeDefine='SHADOWMAP_TYPE_PCF';}else if(parameters.shadowMapType===PCFSoftShadowMap){shadowMapTypeDefine='SHADOWMAP_TYPE_PCF_SOFT';}var envMapTypeDefine='ENVMAP_TYPE_CUBE';var envMapModeDefine='ENVMAP_MODE_REFLECTION';var envMapBlendingDefine='ENVMAP_BLENDING_MULTIPLY';if(parameters.envMap){switch(material.envMap.mapping){case CubeReflectionMapping:case CubeRefractionMapping:envMapTypeDefine='ENVMAP_TYPE_CUBE';break;case CubeUVReflectionMapping:case CubeUVRefractionMapping:envMapTypeDefine='ENVMAP_TYPE_CUBE_UV';break;case EquirectangularReflectionMapping:case EquirectangularRefractionMapping:envMapTypeDefine='ENVMAP_TYPE_EQUIREC';break;case SphericalReflectionMapping:envMapTypeDefine='ENVMAP_TYPE_SPHERE';break;}switch(material.envMap.mapping){case CubeRefractionMapping:case EquirectangularRefractionMapping:envMapModeDefine='ENVMAP_MODE_REFRACTION';break;}switch(material.combine){case MultiplyOperation:envMapBlendingDefine='ENVMAP_BLENDING_MULTIPLY';break;case MixOperation:envMapBlendingDefine='ENVMAP_BLENDING_MIX';break;case AddOperation:envMapBlendingDefine='ENVMAP_BLENDING_ADD';break;}}var gammaFactorDefine=renderer.gammaFactor>0?renderer.gammaFactor:1.0;// console.log( 'building new program ' );
	//
	var customExtensions=generateExtensions(extensions,parameters,renderer.extensions);var customDefines=generateDefines(defines);//
	var program=gl.createProgram();var prefixVertex,prefixFragment;if(material.isRawShaderMaterial){prefixVertex=[customDefines,'\n'].filter(filterEmptyLine).join('\n');prefixFragment=[customExtensions,customDefines,'\n'].filter(filterEmptyLine).join('\n');}else{prefixVertex=['precision '+parameters.precision+' float;','precision '+parameters.precision+' int;','#define SHADER_NAME '+material.__webglShader.name,customDefines,parameters.supportsVertexTextures?'#define VERTEX_TEXTURES':'','#define GAMMA_FACTOR '+gammaFactorDefine,'#define MAX_BONES '+parameters.maxBones,parameters.useFog&&parameters.fog?'#define USE_FOG':'',parameters.useFog&&parameters.fogExp?'#define FOG_EXP2':'',parameters.map?'#define USE_MAP':'',parameters.envMap?'#define USE_ENVMAP':'',parameters.envMap?'#define '+envMapModeDefine:'',parameters.lightMap?'#define USE_LIGHTMAP':'',parameters.aoMap?'#define USE_AOMAP':'',parameters.emissiveMap?'#define USE_EMISSIVEMAP':'',parameters.bumpMap?'#define USE_BUMPMAP':'',parameters.normalMap?'#define USE_NORMALMAP':'',parameters.displacementMap&&parameters.supportsVertexTextures?'#define USE_DISPLACEMENTMAP':'',parameters.specularMap?'#define USE_SPECULARMAP':'',parameters.roughnessMap?'#define USE_ROUGHNESSMAP':'',parameters.metalnessMap?'#define USE_METALNESSMAP':'',parameters.alphaMap?'#define USE_ALPHAMAP':'',parameters.vertexColors?'#define USE_COLOR':'',parameters.flatShading?'#define FLAT_SHADED':'',parameters.skinning?'#define USE_SKINNING':'',parameters.useVertexTexture?'#define BONE_TEXTURE':'',parameters.morphTargets?'#define USE_MORPHTARGETS':'',parameters.morphNormals&&parameters.flatShading===false?'#define USE_MORPHNORMALS':'',parameters.doubleSided?'#define DOUBLE_SIDED':'',parameters.flipSided?'#define FLIP_SIDED':'','#define NUM_CLIPPING_PLANES '+parameters.numClippingPlanes,parameters.shadowMapEnabled?'#define USE_SHADOWMAP':'',parameters.shadowMapEnabled?'#define '+shadowMapTypeDefine:'',parameters.sizeAttenuation?'#define USE_SIZEATTENUATION':'',parameters.logarithmicDepthBuffer?'#define USE_LOGDEPTHBUF':'',parameters.logarithmicDepthBuffer&&renderer.extensions.get('EXT_frag_depth')?'#define USE_LOGDEPTHBUF_EXT':'','uniform mat4 modelMatrix;','uniform mat4 modelViewMatrix;','uniform mat4 projectionMatrix;','uniform mat4 viewMatrix;','uniform mat3 normalMatrix;','uniform vec3 cameraPosition;','attribute vec3 position;','attribute vec3 normal;','attribute vec2 uv;','#ifdef USE_COLOR','	attribute vec3 color;','#endif','#ifdef USE_MORPHTARGETS','	attribute vec3 morphTarget0;','	attribute vec3 morphTarget1;','	attribute vec3 morphTarget2;','	attribute vec3 morphTarget3;','	#ifdef USE_MORPHNORMALS','		attribute vec3 morphNormal0;','		attribute vec3 morphNormal1;','		attribute vec3 morphNormal2;','		attribute vec3 morphNormal3;','	#else','		attribute vec3 morphTarget4;','		attribute vec3 morphTarget5;','		attribute vec3 morphTarget6;','		attribute vec3 morphTarget7;','	#endif','#endif','#ifdef USE_SKINNING','	attribute vec4 skinIndex;','	attribute vec4 skinWeight;','#endif','\n'].filter(filterEmptyLine).join('\n');prefixFragment=[customExtensions,'precision '+parameters.precision+' float;','precision '+parameters.precision+' int;','#define SHADER_NAME '+material.__webglShader.name,customDefines,parameters.alphaTest?'#define ALPHATEST '+parameters.alphaTest:'','#define GAMMA_FACTOR '+gammaFactorDefine,parameters.useFog&&parameters.fog?'#define USE_FOG':'',parameters.useFog&&parameters.fogExp?'#define FOG_EXP2':'',parameters.map?'#define USE_MAP':'',parameters.envMap?'#define USE_ENVMAP':'',parameters.envMap?'#define '+envMapTypeDefine:'',parameters.envMap?'#define '+envMapModeDefine:'',parameters.envMap?'#define '+envMapBlendingDefine:'',parameters.lightMap?'#define USE_LIGHTMAP':'',parameters.aoMap?'#define USE_AOMAP':'',parameters.emissiveMap?'#define USE_EMISSIVEMAP':'',parameters.bumpMap?'#define USE_BUMPMAP':'',parameters.normalMap?'#define USE_NORMALMAP':'',parameters.specularMap?'#define USE_SPECULARMAP':'',parameters.roughnessMap?'#define USE_ROUGHNESSMAP':'',parameters.metalnessMap?'#define USE_METALNESSMAP':'',parameters.alphaMap?'#define USE_ALPHAMAP':'',parameters.vertexColors?'#define USE_COLOR':'',parameters.gradientMap?'#define USE_GRADIENTMAP':'',parameters.flatShading?'#define FLAT_SHADED':'',parameters.doubleSided?'#define DOUBLE_SIDED':'',parameters.flipSided?'#define FLIP_SIDED':'','#define NUM_CLIPPING_PLANES '+parameters.numClippingPlanes,'#define UNION_CLIPPING_PLANES '+(parameters.numClippingPlanes-parameters.numClipIntersection),parameters.shadowMapEnabled?'#define USE_SHADOWMAP':'',parameters.shadowMapEnabled?'#define '+shadowMapTypeDefine:'',parameters.premultipliedAlpha?"#define PREMULTIPLIED_ALPHA":'',parameters.physicallyCorrectLights?"#define PHYSICALLY_CORRECT_LIGHTS":'',parameters.logarithmicDepthBuffer?'#define USE_LOGDEPTHBUF':'',parameters.logarithmicDepthBuffer&&renderer.extensions.get('EXT_frag_depth')?'#define USE_LOGDEPTHBUF_EXT':'',parameters.envMap&&renderer.extensions.get('EXT_shader_texture_lod')?'#define TEXTURE_LOD_EXT':'','uniform mat4 viewMatrix;','uniform vec3 cameraPosition;',parameters.toneMapping!==NoToneMapping?"#define TONE_MAPPING":'',parameters.toneMapping!==NoToneMapping?ShaderChunk['tonemapping_pars_fragment']:'',// this code is required here because it is used by the toneMapping() function defined below
	parameters.toneMapping!==NoToneMapping?getToneMappingFunction("toneMapping",parameters.toneMapping):'',parameters.dithering?'#define DITHERING':'',parameters.dithering?ShaderChunk['dithering_pars_fragment']:'',parameters.outputEncoding||parameters.mapEncoding||parameters.envMapEncoding||parameters.emissiveMapEncoding?ShaderChunk['encodings_pars_fragment']:'',// this code is required here because it is used by the various encoding/decoding function defined below
	parameters.mapEncoding?getTexelDecodingFunction('mapTexelToLinear',parameters.mapEncoding):'',parameters.envMapEncoding?getTexelDecodingFunction('envMapTexelToLinear',parameters.envMapEncoding):'',parameters.emissiveMapEncoding?getTexelDecodingFunction('emissiveMapTexelToLinear',parameters.emissiveMapEncoding):'',parameters.outputEncoding?getTexelEncodingFunction("linearToOutputTexel",parameters.outputEncoding):'',parameters.depthPacking?"#define DEPTH_PACKING "+material.depthPacking:'','\n'].filter(filterEmptyLine).join('\n');}vertexShader=parseIncludes(vertexShader,parameters);vertexShader=replaceLightNums(vertexShader,parameters);fragmentShader=parseIncludes(fragmentShader,parameters);fragmentShader=replaceLightNums(fragmentShader,parameters);if(!material.isShaderMaterial){vertexShader=unrollLoops(vertexShader);fragmentShader=unrollLoops(fragmentShader);}var vertexGlsl=prefixVertex+vertexShader;var fragmentGlsl=prefixFragment+fragmentShader;// console.log( '*VERTEX*', vertexGlsl );
	// console.log( '*FRAGMENT*', fragmentGlsl );
	var glVertexShader=WebGLShader(gl,gl.VERTEX_SHADER,vertexGlsl);var glFragmentShader=WebGLShader(gl,gl.FRAGMENT_SHADER,fragmentGlsl);gl.attachShader(program,glVertexShader);gl.attachShader(program,glFragmentShader);// Force a particular attribute to index 0.
	if(material.index0AttributeName!==undefined){gl.bindAttribLocation(program,0,material.index0AttributeName);}else if(parameters.morphTargets===true){// programs with morphTargets displace position out of attribute 0
	gl.bindAttribLocation(program,0,'position');}gl.linkProgram(program);var programLog=gl.getProgramInfoLog(program);var vertexLog=gl.getShaderInfoLog(glVertexShader);var fragmentLog=gl.getShaderInfoLog(glFragmentShader);var runnable=true;var haveDiagnostics=true;// console.log( '**VERTEX**', gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( glVertexShader ) );
	// console.log( '**FRAGMENT**', gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( glFragmentShader ) );
	if(gl.getProgramParameter(program,gl.LINK_STATUS)===false){runnable=false;console.error('THREE.WebGLProgram: shader error: ',gl.getError(),'gl.VALIDATE_STATUS',gl.getProgramParameter(program,gl.VALIDATE_STATUS),'gl.getProgramInfoLog',programLog,vertexLog,fragmentLog);}else if(programLog!==''){console.warn('THREE.WebGLProgram: gl.getProgramInfoLog()',programLog);}else if(vertexLog===''||fragmentLog===''){haveDiagnostics=false;}if(haveDiagnostics){this.diagnostics={runnable:runnable,material:material,programLog:programLog,vertexShader:{log:vertexLog,prefix:prefixVertex},fragmentShader:{log:fragmentLog,prefix:prefixFragment}};}// clean up
	gl.deleteShader(glVertexShader);gl.deleteShader(glFragmentShader);// set up caching for uniform locations
	var cachedUniforms;this.getUniforms=function(){if(cachedUniforms===undefined){cachedUniforms=new WebGLUniforms(gl,program,renderer);}return cachedUniforms;};// set up caching for attribute locations
	var cachedAttributes;this.getAttributes=function(){if(cachedAttributes===undefined){cachedAttributes=fetchAttributeLocations(gl,program);}return cachedAttributes;};// free resource
	this.destroy=function(){gl.deleteProgram(program);this.program=undefined;};// DEPRECATED
	Object.defineProperties(this,{uniforms:{get:function get(){console.warn('THREE.WebGLProgram: .uniforms is now .getUniforms().');return this.getUniforms();}},attributes:{get:function get(){console.warn('THREE.WebGLProgram: .attributes is now .getAttributes().');return this.getAttributes();}}});//
	this.id=programIdCount++;this.code=code;this.usedTimes=1;this.program=program;this.vertexShader=glVertexShader;this.fragmentShader=glFragmentShader;return this;}/**
		 * @author mrdoob / http://mrdoob.com/
		 */function WebGLPrograms(renderer,capabilities){var programs=[];var shaderIDs={MeshDepthMaterial:'depth',MeshNormalMaterial:'normal',MeshBasicMaterial:'basic',MeshLambertMaterial:'lambert',MeshPhongMaterial:'phong',MeshToonMaterial:'phong',MeshStandardMaterial:'physical',MeshPhysicalMaterial:'physical',LineBasicMaterial:'basic',LineDashedMaterial:'dashed',PointsMaterial:'points'};var parameterNames=["precision","supportsVertexTextures","map","mapEncoding","envMap","envMapMode","envMapEncoding","lightMap","aoMap","emissiveMap","emissiveMapEncoding","bumpMap","normalMap","displacementMap","specularMap","roughnessMap","metalnessMap","gradientMap","alphaMap","combine","vertexColors","fog","useFog","fogExp","flatShading","sizeAttenuation","logarithmicDepthBuffer","skinning","maxBones","useVertexTexture","morphTargets","morphNormals","maxMorphTargets","maxMorphNormals","premultipliedAlpha","numDirLights","numPointLights","numSpotLights","numHemiLights","numRectAreaLights","shadowMapEnabled","shadowMapType","toneMapping",'physicallyCorrectLights',"alphaTest","doubleSided","flipSided","numClippingPlanes","numClipIntersection","depthPacking","dithering"];function allocateBones(object){var skeleton=object.skeleton;var bones=skeleton.bones;if(capabilities.floatVertexTextures){return 1024;}else{// default for when object is not specified
	// ( for example when prebuilding shader to be used with multiple objects )
	//
	//  - leave some extra space for other uniforms
	//  - limit here is ANGLE's 254 max uniform vectors
	//    (up to 54 should be safe)
	var nVertexUniforms=capabilities.maxVertexUniforms;var nVertexMatrices=Math.floor((nVertexUniforms-20)/4);var maxBones=Math.min(nVertexMatrices,bones.length);if(maxBones<bones.length){console.warn('THREE.WebGLRenderer: Skeleton has '+bones.length+' bones. This GPU supports '+maxBones+'.');return 0;}return maxBones;}}function getTextureEncodingFromMap(map,gammaOverrideLinear){var encoding;if(!map){encoding=LinearEncoding;}else if(map.isTexture){encoding=map.encoding;}else if(map.isWebGLRenderTarget){console.warn("THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead.");encoding=map.texture.encoding;}// add backwards compatibility for WebGLRenderer.gammaInput/gammaOutput parameter, should probably be removed at some point.
	if(encoding===LinearEncoding&&gammaOverrideLinear){encoding=GammaEncoding;}return encoding;}this.getParameters=function(material,lights,fog,nClipPlanes,nClipIntersection,object){var shaderID=shaderIDs[material.type];// heuristics to create shader parameters according to lights in the scene
	// (not to blow over maxLights budget)
	var maxBones=object.isSkinnedMesh?allocateBones(object):0;var precision=renderer.getPrecision();if(material.precision!==null){precision=capabilities.getMaxPrecision(material.precision);if(precision!==material.precision){console.warn('THREE.WebGLProgram.getParameters:',material.precision,'not supported, using',precision,'instead.');}}var currentRenderTarget=renderer.getRenderTarget();var parameters={shaderID:shaderID,precision:precision,supportsVertexTextures:capabilities.vertexTextures,outputEncoding:getTextureEncodingFromMap(!currentRenderTarget?null:currentRenderTarget.texture,renderer.gammaOutput),map:!!material.map,mapEncoding:getTextureEncodingFromMap(material.map,renderer.gammaInput),envMap:!!material.envMap,envMapMode:material.envMap&&material.envMap.mapping,envMapEncoding:getTextureEncodingFromMap(material.envMap,renderer.gammaInput),envMapCubeUV:!!material.envMap&&(material.envMap.mapping===CubeUVReflectionMapping||material.envMap.mapping===CubeUVRefractionMapping),lightMap:!!material.lightMap,aoMap:!!material.aoMap,emissiveMap:!!material.emissiveMap,emissiveMapEncoding:getTextureEncodingFromMap(material.emissiveMap,renderer.gammaInput),bumpMap:!!material.bumpMap,normalMap:!!material.normalMap,displacementMap:!!material.displacementMap,roughnessMap:!!material.roughnessMap,metalnessMap:!!material.metalnessMap,specularMap:!!material.specularMap,alphaMap:!!material.alphaMap,gradientMap:!!material.gradientMap,combine:material.combine,vertexColors:material.vertexColors,fog:!!fog,useFog:material.fog,fogExp:fog&&fog.isFogExp2,flatShading:material.shading===FlatShading,sizeAttenuation:material.sizeAttenuation,logarithmicDepthBuffer:capabilities.logarithmicDepthBuffer,skinning:material.skinning&&maxBones>0,maxBones:maxBones,useVertexTexture:capabilities.floatVertexTextures,morphTargets:material.morphTargets,morphNormals:material.morphNormals,maxMorphTargets:renderer.maxMorphTargets,maxMorphNormals:renderer.maxMorphNormals,numDirLights:lights.directional.length,numPointLights:lights.point.length,numSpotLights:lights.spot.length,numRectAreaLights:lights.rectArea.length,numHemiLights:lights.hemi.length,numClippingPlanes:nClipPlanes,numClipIntersection:nClipIntersection,dithering:material.dithering,shadowMapEnabled:renderer.shadowMap.enabled&&object.receiveShadow&&lights.shadows.length>0,shadowMapType:renderer.shadowMap.type,toneMapping:renderer.toneMapping,physicallyCorrectLights:renderer.physicallyCorrectLights,premultipliedAlpha:material.premultipliedAlpha,alphaTest:material.alphaTest,doubleSided:material.side===DoubleSide,flipSided:material.side===BackSide,depthPacking:material.depthPacking!==undefined?material.depthPacking:false};return parameters;};this.getProgramCode=function(material,parameters){var array=[];if(parameters.shaderID){array.push(parameters.shaderID);}else{array.push(material.fragmentShader);array.push(material.vertexShader);}if(material.defines!==undefined){for(var name in material.defines){array.push(name);array.push(material.defines[name]);}}for(var i=0;i<parameterNames.length;i++){array.push(parameters[parameterNames[i]]);}return array.join();};this.acquireProgram=function(material,parameters,code){var program;// Check if code has been already compiled
	for(var p=0,pl=programs.length;p<pl;p++){var programInfo=programs[p];if(programInfo.code===code){program=programInfo;++program.usedTimes;break;}}if(program===undefined){program=new WebGLProgram(renderer,code,material,parameters);programs.push(program);}return program;};this.releaseProgram=function(program){if(--program.usedTimes===0){// Remove from unordered set
	var i=programs.indexOf(program);programs[i]=programs[programs.length-1];programs.pop();// Free WebGL resources
	program.destroy();}};// Exposed for resource monitoring & error feedback via renderer.info:
	this.programs=programs;}/**
		 * @author mrdoob / http://mrdoob.com/
		 */function WebGLTextures(_gl,extensions,state,properties,capabilities,paramThreeToGL,infoMemory){var _isWebGL2=typeof WebGL2RenderingContext!=='undefined'&&_gl instanceof WebGL2RenderingContext;//
	function clampToMaxSize(image,maxSize){if(image.width>maxSize||image.height>maxSize){// Warning: Scaling through the canvas will only work with images that use
	// premultiplied alpha.
	var scale=maxSize/Math.max(image.width,image.height);var canvas=document.createElementNS('http://www.w3.org/1999/xhtml','canvas');canvas.width=Math.floor(image.width*scale);canvas.height=Math.floor(image.height*scale);var context=canvas.getContext('2d');context.drawImage(image,0,0,image.width,image.height,0,0,canvas.width,canvas.height);console.warn('THREE.WebGLRenderer: image is too big ('+image.width+'x'+image.height+'). Resized to '+canvas.width+'x'+canvas.height,image);return canvas;}return image;}function isPowerOfTwo(image){return _Math.isPowerOfTwo(image.width)&&_Math.isPowerOfTwo(image.height);}function makePowerOfTwo(image){if(image instanceof HTMLImageElement||image instanceof HTMLCanvasElement){var canvas=document.createElementNS('http://www.w3.org/1999/xhtml','canvas');canvas.width=_Math.nearestPowerOfTwo(image.width);canvas.height=_Math.nearestPowerOfTwo(image.height);var context=canvas.getContext('2d');context.drawImage(image,0,0,canvas.width,canvas.height);console.warn('THREE.WebGLRenderer: image is not power of two ('+image.width+'x'+image.height+'). Resized to '+canvas.width+'x'+canvas.height,image);return canvas;}return image;}function textureNeedsPowerOfTwo(texture){return texture.wrapS!==ClampToEdgeWrapping||texture.wrapT!==ClampToEdgeWrapping||texture.minFilter!==NearestFilter&&texture.minFilter!==LinearFilter;}// Fallback filters for non-power-of-2 textures
	function filterFallback(f){if(f===NearestFilter||f===NearestMipMapNearestFilter||f===NearestMipMapLinearFilter){return _gl.NEAREST;}return _gl.LINEAR;}//
	function onTextureDispose(event){var texture=event.target;texture.removeEventListener('dispose',onTextureDispose);deallocateTexture(texture);infoMemory.textures--;}function onRenderTargetDispose(event){var renderTarget=event.target;renderTarget.removeEventListener('dispose',onRenderTargetDispose);deallocateRenderTarget(renderTarget);infoMemory.textures--;}//
	function deallocateTexture(texture){var textureProperties=properties.get(texture);if(texture.image&&textureProperties.__image__webglTextureCube){// cube texture
	_gl.deleteTexture(textureProperties.__image__webglTextureCube);}else{// 2D texture
	if(textureProperties.__webglInit===undefined)return;_gl.deleteTexture(textureProperties.__webglTexture);}// remove all webgl properties
	properties.remove(texture);}function deallocateRenderTarget(renderTarget){var renderTargetProperties=properties.get(renderTarget);var textureProperties=properties.get(renderTarget.texture);if(!renderTarget)return;if(textureProperties.__webglTexture!==undefined){_gl.deleteTexture(textureProperties.__webglTexture);}if(renderTarget.depthTexture){renderTarget.depthTexture.dispose();}if(renderTarget.isWebGLRenderTargetCube){for(var i=0;i<6;i++){_gl.deleteFramebuffer(renderTargetProperties.__webglFramebuffer[i]);if(renderTargetProperties.__webglDepthbuffer)_gl.deleteRenderbuffer(renderTargetProperties.__webglDepthbuffer[i]);}}else{_gl.deleteFramebuffer(renderTargetProperties.__webglFramebuffer);if(renderTargetProperties.__webglDepthbuffer)_gl.deleteRenderbuffer(renderTargetProperties.__webglDepthbuffer);}properties.remove(renderTarget.texture);properties.remove(renderTarget);}//
	function setTexture2D(texture,slot){var textureProperties=properties.get(texture);if(texture.version>0&&textureProperties.__version!==texture.version){var image=texture.image;if(image===undefined){console.warn('THREE.WebGLRenderer: Texture marked for update but image is undefined',texture);}else if(image.complete===false){console.warn('THREE.WebGLRenderer: Texture marked for update but image is incomplete',texture);}else{uploadTexture(textureProperties,texture,slot);return;}}state.activeTexture(_gl.TEXTURE0+slot);state.bindTexture(_gl.TEXTURE_2D,textureProperties.__webglTexture);}function setTextureCube(texture,slot){var textureProperties=properties.get(texture);if(texture.image.length===6){if(texture.version>0&&textureProperties.__version!==texture.version){if(!textureProperties.__image__webglTextureCube){texture.addEventListener('dispose',onTextureDispose);textureProperties.__image__webglTextureCube=_gl.createTexture();infoMemory.textures++;}state.activeTexture(_gl.TEXTURE0+slot);state.bindTexture(_gl.TEXTURE_CUBE_MAP,textureProperties.__image__webglTextureCube);_gl.pixelStorei(_gl.UNPACK_FLIP_Y_WEBGL,texture.flipY);var isCompressed=texture&&texture.isCompressedTexture;var isDataTexture=texture.image[0]&&texture.image[0].isDataTexture;var cubeImage=[];for(var i=0;i<6;i++){if(!isCompressed&&!isDataTexture){cubeImage[i]=clampToMaxSize(texture.image[i],capabilities.maxCubemapSize);}else{cubeImage[i]=isDataTexture?texture.image[i].image:texture.image[i];}}var image=cubeImage[0],isPowerOfTwoImage=isPowerOfTwo(image),glFormat=paramThreeToGL(texture.format),glType=paramThreeToGL(texture.type);setTextureParameters(_gl.TEXTURE_CUBE_MAP,texture,isPowerOfTwoImage);for(var i=0;i<6;i++){if(!isCompressed){if(isDataTexture){state.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X+i,0,glFormat,cubeImage[i].width,cubeImage[i].height,0,glFormat,glType,cubeImage[i].data);}else{state.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X+i,0,glFormat,glFormat,glType,cubeImage[i]);}}else{var mipmap,mipmaps=cubeImage[i].mipmaps;for(var j=0,jl=mipmaps.length;j<jl;j++){mipmap=mipmaps[j];if(texture.format!==RGBAFormat&&texture.format!==RGBFormat){if(state.getCompressedTextureFormats().indexOf(glFormat)>-1){state.compressedTexImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X+i,j,glFormat,mipmap.width,mipmap.height,0,mipmap.data);}else{console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()");}}else{state.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X+i,j,glFormat,mipmap.width,mipmap.height,0,glFormat,glType,mipmap.data);}}}}if(texture.generateMipmaps&&isPowerOfTwoImage){_gl.generateMipmap(_gl.TEXTURE_CUBE_MAP);}textureProperties.__version=texture.version;if(texture.onUpdate)texture.onUpdate(texture);}else{state.activeTexture(_gl.TEXTURE0+slot);state.bindTexture(_gl.TEXTURE_CUBE_MAP,textureProperties.__image__webglTextureCube);}}}function setTextureCubeDynamic(texture,slot){state.activeTexture(_gl.TEXTURE0+slot);state.bindTexture(_gl.TEXTURE_CUBE_MAP,properties.get(texture).__webglTexture);}function setTextureParameters(textureType,texture,isPowerOfTwoImage){var extension;if(isPowerOfTwoImage){_gl.texParameteri(textureType,_gl.TEXTURE_WRAP_S,paramThreeToGL(texture.wrapS));_gl.texParameteri(textureType,_gl.TEXTURE_WRAP_T,paramThreeToGL(texture.wrapT));_gl.texParameteri(textureType,_gl.TEXTURE_MAG_FILTER,paramThreeToGL(texture.magFilter));_gl.texParameteri(textureType,_gl.TEXTURE_MIN_FILTER,paramThreeToGL(texture.minFilter));}else{_gl.texParameteri(textureType,_gl.TEXTURE_WRAP_S,_gl.CLAMP_TO_EDGE);_gl.texParameteri(textureType,_gl.TEXTURE_WRAP_T,_gl.CLAMP_TO_EDGE);if(texture.wrapS!==ClampToEdgeWrapping||texture.wrapT!==ClampToEdgeWrapping){console.warn('THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping.',texture);}_gl.texParameteri(textureType,_gl.TEXTURE_MAG_FILTER,filterFallback(texture.magFilter));_gl.texParameteri(textureType,_gl.TEXTURE_MIN_FILTER,filterFallback(texture.minFilter));if(texture.minFilter!==NearestFilter&&texture.minFilter!==LinearFilter){console.warn('THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.',texture);}}extension=extensions.get('EXT_texture_filter_anisotropic');if(extension){if(texture.type===FloatType&&extensions.get('OES_texture_float_linear')===null)return;if(texture.type===HalfFloatType&&extensions.get('OES_texture_half_float_linear')===null)return;if(texture.anisotropy>1||properties.get(texture).__currentAnisotropy){_gl.texParameterf(textureType,extension.TEXTURE_MAX_ANISOTROPY_EXT,Math.min(texture.anisotropy,capabilities.getMaxAnisotropy()));properties.get(texture).__currentAnisotropy=texture.anisotropy;}}}function uploadTexture(textureProperties,texture,slot){if(textureProperties.__webglInit===undefined){textureProperties.__webglInit=true;texture.addEventListener('dispose',onTextureDispose);textureProperties.__webglTexture=_gl.createTexture();infoMemory.textures++;}state.activeTexture(_gl.TEXTURE0+slot);state.bindTexture(_gl.TEXTURE_2D,textureProperties.__webglTexture);_gl.pixelStorei(_gl.UNPACK_FLIP_Y_WEBGL,texture.flipY);_gl.pixelStorei(_gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL,texture.premultiplyAlpha);_gl.pixelStorei(_gl.UNPACK_ALIGNMENT,texture.unpackAlignment);var image=clampToMaxSize(texture.image,capabilities.maxTextureSize);if(textureNeedsPowerOfTwo(texture)&&isPowerOfTwo(image)===false){image=makePowerOfTwo(image);}var isPowerOfTwoImage=isPowerOfTwo(image),glFormat=paramThreeToGL(texture.format),glType=paramThreeToGL(texture.type);setTextureParameters(_gl.TEXTURE_2D,texture,isPowerOfTwoImage);var mipmap,mipmaps=texture.mipmaps;if(texture.isDepthTexture){// populate depth texture with dummy data
	var internalFormat=_gl.DEPTH_COMPONENT;if(texture.type===FloatType){if(!_isWebGL2)throw new Error('Float Depth Texture only supported in WebGL2.0');internalFormat=_gl.DEPTH_COMPONENT32F;}else if(_isWebGL2){// WebGL 2.0 requires signed internalformat for glTexImage2D
	internalFormat=_gl.DEPTH_COMPONENT16;}if(texture.format===DepthFormat&&internalFormat===_gl.DEPTH_COMPONENT){// The error INVALID_OPERATION is generated by texImage2D if format and internalformat are
	// DEPTH_COMPONENT and type is not UNSIGNED_SHORT or UNSIGNED_INT
	// (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)
	if(texture.type!==UnsignedShortType&&texture.type!==UnsignedIntType){console.warn('THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture.');texture.type=UnsignedShortType;glType=paramThreeToGL(texture.type);}}// Depth stencil textures need the DEPTH_STENCIL internal format
	// (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)
	if(texture.format===DepthStencilFormat){internalFormat=_gl.DEPTH_STENCIL;// The error INVALID_OPERATION is generated by texImage2D if format and internalformat are
	// DEPTH_STENCIL and type is not UNSIGNED_INT_24_8_WEBGL.
	// (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)
	if(texture.type!==UnsignedInt248Type){console.warn('THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture.');texture.type=UnsignedInt248Type;glType=paramThreeToGL(texture.type);}}state.texImage2D(_gl.TEXTURE_2D,0,internalFormat,image.width,image.height,0,glFormat,glType,null);}else if(texture.isDataTexture){// use manually created mipmaps if available
	// if there are no manual mipmaps
	// set 0 level mipmap and then use GL to generate other mipmap levels
	if(mipmaps.length>0&&isPowerOfTwoImage){for(var i=0,il=mipmaps.length;i<il;i++){mipmap=mipmaps[i];state.texImage2D(_gl.TEXTURE_2D,i,glFormat,mipmap.width,mipmap.height,0,glFormat,glType,mipmap.data);}texture.generateMipmaps=false;}else{state.texImage2D(_gl.TEXTURE_2D,0,glFormat,image.width,image.height,0,glFormat,glType,image.data);}}else if(texture.isCompressedTexture){for(var i=0,il=mipmaps.length;i<il;i++){mipmap=mipmaps[i];if(texture.format!==RGBAFormat&&texture.format!==RGBFormat){if(state.getCompressedTextureFormats().indexOf(glFormat)>-1){state.compressedTexImage2D(_gl.TEXTURE_2D,i,glFormat,mipmap.width,mipmap.height,0,mipmap.data);}else{console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()");}}else{state.texImage2D(_gl.TEXTURE_2D,i,glFormat,mipmap.width,mipmap.height,0,glFormat,glType,mipmap.data);}}}else{// regular Texture (image, video, canvas)
	// use manually created mipmaps if available
	// if there are no manual mipmaps
	// set 0 level mipmap and then use GL to generate other mipmap levels
	if(mipmaps.length>0&&isPowerOfTwoImage){for(var i=0,il=mipmaps.length;i<il;i++){mipmap=mipmaps[i];state.texImage2D(_gl.TEXTURE_2D,i,glFormat,glFormat,glType,mipmap);}texture.generateMipmaps=false;}else{state.texImage2D(_gl.TEXTURE_2D,0,glFormat,glFormat,glType,image);}}if(texture.generateMipmaps&&isPowerOfTwoImage)_gl.generateMipmap(_gl.TEXTURE_2D);textureProperties.__version=texture.version;if(texture.onUpdate)texture.onUpdate(texture);}// Render targets
	// Setup storage for target texture and bind it to correct framebuffer
	function setupFrameBufferTexture(framebuffer,renderTarget,attachment,textureTarget){var glFormat=paramThreeToGL(renderTarget.texture.format);var glType=paramThreeToGL(renderTarget.texture.type);state.texImage2D(textureTarget,0,glFormat,renderTarget.width,renderTarget.height,0,glFormat,glType,null);_gl.bindFramebuffer(_gl.FRAMEBUFFER,framebuffer);_gl.framebufferTexture2D(_gl.FRAMEBUFFER,attachment,textureTarget,properties.get(renderTarget.texture).__webglTexture,0);_gl.bindFramebuffer(_gl.FRAMEBUFFER,null);}// Setup storage for internal depth/stencil buffers and bind to correct framebuffer
	function setupRenderBufferStorage(renderbuffer,renderTarget){_gl.bindRenderbuffer(_gl.RENDERBUFFER,renderbuffer);if(renderTarget.depthBuffer&&!renderTarget.stencilBuffer){_gl.renderbufferStorage(_gl.RENDERBUFFER,_gl.DEPTH_COMPONENT16,renderTarget.width,renderTarget.height);_gl.framebufferRenderbuffer(_gl.FRAMEBUFFER,_gl.DEPTH_ATTACHMENT,_gl.RENDERBUFFER,renderbuffer);}else if(renderTarget.depthBuffer&&renderTarget.stencilBuffer){_gl.renderbufferStorage(_gl.RENDERBUFFER,_gl.DEPTH_STENCIL,renderTarget.width,renderTarget.height);_gl.framebufferRenderbuffer(_gl.FRAMEBUFFER,_gl.DEPTH_STENCIL_ATTACHMENT,_gl.RENDERBUFFER,renderbuffer);}else{// FIXME: We don't support !depth !stencil
	_gl.renderbufferStorage(_gl.RENDERBUFFER,_gl.RGBA4,renderTarget.width,renderTarget.height);}_gl.bindRenderbuffer(_gl.RENDERBUFFER,null);}// Setup resources for a Depth Texture for a FBO (needs an extension)
	function setupDepthTexture(framebuffer,renderTarget){var isCube=renderTarget&&renderTarget.isWebGLRenderTargetCube;if(isCube)throw new Error('Depth Texture with cube render targets is not supported!');_gl.bindFramebuffer(_gl.FRAMEBUFFER,framebuffer);if(!(renderTarget.depthTexture&&renderTarget.depthTexture.isDepthTexture)){throw new Error('renderTarget.depthTexture must be an instance of THREE.DepthTexture');}// upload an empty depth texture with framebuffer size
	if(!properties.get(renderTarget.depthTexture).__webglTexture||renderTarget.depthTexture.image.width!==renderTarget.width||renderTarget.depthTexture.image.height!==renderTarget.height){renderTarget.depthTexture.image.width=renderTarget.width;renderTarget.depthTexture.image.height=renderTarget.height;renderTarget.depthTexture.needsUpdate=true;}setTexture2D(renderTarget.depthTexture,0);var webglDepthTexture=properties.get(renderTarget.depthTexture).__webglTexture;if(renderTarget.depthTexture.format===DepthFormat){_gl.framebufferTexture2D(_gl.FRAMEBUFFER,_gl.DEPTH_ATTACHMENT,_gl.TEXTURE_2D,webglDepthTexture,0);}else if(renderTarget.depthTexture.format===DepthStencilFormat){_gl.framebufferTexture2D(_gl.FRAMEBUFFER,_gl.DEPTH_STENCIL_ATTACHMENT,_gl.TEXTURE_2D,webglDepthTexture,0);}else{throw new Error('Unknown depthTexture format');}}// Setup GL resources for a non-texture depth buffer
	function setupDepthRenderbuffer(renderTarget){var renderTargetProperties=properties.get(renderTarget);var isCube=renderTarget.isWebGLRenderTargetCube===true;if(renderTarget.depthTexture){if(isCube)throw new Error('target.depthTexture not supported in Cube render targets');setupDepthTexture(renderTargetProperties.__webglFramebuffer,renderTarget);}else{if(isCube){renderTargetProperties.__webglDepthbuffer=[];for(var i=0;i<6;i++){_gl.bindFramebuffer(_gl.FRAMEBUFFER,renderTargetProperties.__webglFramebuffer[i]);renderTargetProperties.__webglDepthbuffer[i]=_gl.createRenderbuffer();setupRenderBufferStorage(renderTargetProperties.__webglDepthbuffer[i],renderTarget);}}else{_gl.bindFramebuffer(_gl.FRAMEBUFFER,renderTargetProperties.__webglFramebuffer);renderTargetProperties.__webglDepthbuffer=_gl.createRenderbuffer();setupRenderBufferStorage(renderTargetProperties.__webglDepthbuffer,renderTarget);}}_gl.bindFramebuffer(_gl.FRAMEBUFFER,null);}// Set up GL resources for the render target
	function setupRenderTarget(renderTarget){var renderTargetProperties=properties.get(renderTarget);var textureProperties=properties.get(renderTarget.texture);renderTarget.addEventListener('dispose',onRenderTargetDispose);textureProperties.__webglTexture=_gl.createTexture();infoMemory.textures++;var isCube=renderTarget.isWebGLRenderTargetCube===true;var isTargetPowerOfTwo=isPowerOfTwo(renderTarget);// Setup framebuffer
	if(isCube){renderTargetProperties.__webglFramebuffer=[];for(var i=0;i<6;i++){renderTargetProperties.__webglFramebuffer[i]=_gl.createFramebuffer();}}else{renderTargetProperties.__webglFramebuffer=_gl.createFramebuffer();}// Setup color buffer
	if(isCube){state.bindTexture(_gl.TEXTURE_CUBE_MAP,textureProperties.__webglTexture);setTextureParameters(_gl.TEXTURE_CUBE_MAP,renderTarget.texture,isTargetPowerOfTwo);for(var i=0;i<6;i++){setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer[i],renderTarget,_gl.COLOR_ATTACHMENT0,_gl.TEXTURE_CUBE_MAP_POSITIVE_X+i);}if(renderTarget.texture.generateMipmaps&&isTargetPowerOfTwo)_gl.generateMipmap(_gl.TEXTURE_CUBE_MAP);state.bindTexture(_gl.TEXTURE_CUBE_MAP,null);}else{state.bindTexture(_gl.TEXTURE_2D,textureProperties.__webglTexture);setTextureParameters(_gl.TEXTURE_2D,renderTarget.texture,isTargetPowerOfTwo);setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer,renderTarget,_gl.COLOR_ATTACHMENT0,_gl.TEXTURE_2D);if(renderTarget.texture.generateMipmaps&&isTargetPowerOfTwo)_gl.generateMipmap(_gl.TEXTURE_2D);state.bindTexture(_gl.TEXTURE_2D,null);}// Setup depth and stencil buffers
	if(renderTarget.depthBuffer){setupDepthRenderbuffer(renderTarget);}}function updateRenderTargetMipmap(renderTarget){var texture=renderTarget.texture;if(texture.generateMipmaps&&isPowerOfTwo(renderTarget)&&texture.minFilter!==NearestFilter&&texture.minFilter!==LinearFilter){var target=renderTarget&&renderTarget.isWebGLRenderTargetCube?_gl.TEXTURE_CUBE_MAP:_gl.TEXTURE_2D;var webglTexture=properties.get(texture).__webglTexture;state.bindTexture(target,webglTexture);_gl.generateMipmap(target);state.bindTexture(target,null);}}this.setTexture2D=setTexture2D;this.setTextureCube=setTextureCube;this.setTextureCubeDynamic=setTextureCubeDynamic;this.setupRenderTarget=setupRenderTarget;this.updateRenderTargetMipmap=updateRenderTargetMipmap;}/**
		 * @author fordacious / fordacious.github.io
		 */function WebGLProperties(){var properties={};function get(object){var uuid=object.uuid;var map=properties[uuid];if(map===undefined){map={};properties[uuid]=map;}return map;}function remove(object){delete properties[object.uuid];}function clear(){properties={};}return{get:get,remove:remove,clear:clear};}/**
		 * @author mrdoob / http://mrdoob.com/
		 */function WebGLState(gl,extensions,paramThreeToGL){function ColorBuffer(){var locked=false;var color=new Vector4();var currentColorMask=null;var currentColorClear=new Vector4();return{setMask:function setMask(colorMask){if(currentColorMask!==colorMask&&!locked){gl.colorMask(colorMask,colorMask,colorMask,colorMask);currentColorMask=colorMask;}},setLocked:function setLocked(lock){locked=lock;},setClear:function setClear(r,g,b,a,premultipliedAlpha){if(premultipliedAlpha===true){r*=a;g*=a;b*=a;}color.set(r,g,b,a);if(currentColorClear.equals(color)===false){gl.clearColor(r,g,b,a);currentColorClear.copy(color);}},reset:function reset(){locked=false;currentColorMask=null;currentColorClear.set(0,0,0,1);}};}function DepthBuffer(){var locked=false;var currentDepthMask=null;var currentDepthFunc=null;var currentDepthClear=null;return{setTest:function setTest(depthTest){if(depthTest){enable(gl.DEPTH_TEST);}else{disable(gl.DEPTH_TEST);}},setMask:function setMask(depthMask){if(currentDepthMask!==depthMask&&!locked){gl.depthMask(depthMask);currentDepthMask=depthMask;}},setFunc:function setFunc(depthFunc){if(currentDepthFunc!==depthFunc){if(depthFunc){switch(depthFunc){case NeverDepth:gl.depthFunc(gl.NEVER);break;case AlwaysDepth:gl.depthFunc(gl.ALWAYS);break;case LessDepth:gl.depthFunc(gl.LESS);break;case LessEqualDepth:gl.depthFunc(gl.LEQUAL);break;case EqualDepth:gl.depthFunc(gl.EQUAL);break;case GreaterEqualDepth:gl.depthFunc(gl.GEQUAL);break;case GreaterDepth:gl.depthFunc(gl.GREATER);break;case NotEqualDepth:gl.depthFunc(gl.NOTEQUAL);break;default:gl.depthFunc(gl.LEQUAL);}}else{gl.depthFunc(gl.LEQUAL);}currentDepthFunc=depthFunc;}},setLocked:function setLocked(lock){locked=lock;},setClear:function setClear(depth){if(currentDepthClear!==depth){gl.clearDepth(depth);currentDepthClear=depth;}},reset:function reset(){locked=false;currentDepthMask=null;currentDepthFunc=null;currentDepthClear=null;}};}function StencilBuffer(){var locked=false;var currentStencilMask=null;var currentStencilFunc=null;var currentStencilRef=null;var currentStencilFuncMask=null;var currentStencilFail=null;var currentStencilZFail=null;var currentStencilZPass=null;var currentStencilClear=null;return{setTest:function setTest(stencilTest){if(stencilTest){enable(gl.STENCIL_TEST);}else{disable(gl.STENCIL_TEST);}},setMask:function setMask(stencilMask){if(currentStencilMask!==stencilMask&&!locked){gl.stencilMask(stencilMask);currentStencilMask=stencilMask;}},setFunc:function setFunc(stencilFunc,stencilRef,stencilMask){if(currentStencilFunc!==stencilFunc||currentStencilRef!==stencilRef||currentStencilFuncMask!==stencilMask){gl.stencilFunc(stencilFunc,stencilRef,stencilMask);currentStencilFunc=stencilFunc;currentStencilRef=stencilRef;currentStencilFuncMask=stencilMask;}},setOp:function setOp(stencilFail,stencilZFail,stencilZPass){if(currentStencilFail!==stencilFail||currentStencilZFail!==stencilZFail||currentStencilZPass!==stencilZPass){gl.stencilOp(stencilFail,stencilZFail,stencilZPass);currentStencilFail=stencilFail;currentStencilZFail=stencilZFail;currentStencilZPass=stencilZPass;}},setLocked:function setLocked(lock){locked=lock;},setClear:function setClear(stencil){if(currentStencilClear!==stencil){gl.clearStencil(stencil);currentStencilClear=stencil;}},reset:function reset(){locked=false;currentStencilMask=null;currentStencilFunc=null;currentStencilRef=null;currentStencilFuncMask=null;currentStencilFail=null;currentStencilZFail=null;currentStencilZPass=null;currentStencilClear=null;}};}//
	var colorBuffer=new ColorBuffer();var depthBuffer=new DepthBuffer();var stencilBuffer=new StencilBuffer();var maxVertexAttributes=gl.getParameter(gl.MAX_VERTEX_ATTRIBS);var newAttributes=new Uint8Array(maxVertexAttributes);var enabledAttributes=new Uint8Array(maxVertexAttributes);var attributeDivisors=new Uint8Array(maxVertexAttributes);var capabilities={};var compressedTextureFormats=null;var currentBlending=null;var currentBlendEquation=null;var currentBlendSrc=null;var currentBlendDst=null;var currentBlendEquationAlpha=null;var currentBlendSrcAlpha=null;var currentBlendDstAlpha=null;var currentPremultipledAlpha=false;var currentFlipSided=null;var currentCullFace=null;var currentLineWidth=null;var currentPolygonOffsetFactor=null;var currentPolygonOffsetUnits=null;var currentScissorTest=null;var maxTextures=gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);var version=parseFloat(/^WebGL\ ([0-9])/.exec(gl.getParameter(gl.VERSION))[1]);var lineWidthAvailable=parseFloat(version)>=1.0;var currentTextureSlot=null;var currentBoundTextures={};var currentScissor=new Vector4();var currentViewport=new Vector4();function createTexture(type,target,count){var data=new Uint8Array(4);// 4 is required to match default unpack alignment of 4.
	var texture=gl.createTexture();gl.bindTexture(type,texture);gl.texParameteri(type,gl.TEXTURE_MIN_FILTER,gl.NEAREST);gl.texParameteri(type,gl.TEXTURE_MAG_FILTER,gl.NEAREST);for(var i=0;i<count;i++){gl.texImage2D(target+i,0,gl.RGBA,1,1,0,gl.RGBA,gl.UNSIGNED_BYTE,data);}return texture;}var emptyTextures={};emptyTextures[gl.TEXTURE_2D]=createTexture(gl.TEXTURE_2D,gl.TEXTURE_2D,1);emptyTextures[gl.TEXTURE_CUBE_MAP]=createTexture(gl.TEXTURE_CUBE_MAP,gl.TEXTURE_CUBE_MAP_POSITIVE_X,6);//
	function init(){colorBuffer.setClear(0,0,0,1);depthBuffer.setClear(1);stencilBuffer.setClear(0);enable(gl.DEPTH_TEST);depthBuffer.setFunc(LessEqualDepth);setFlipSided(false);setCullFace(CullFaceBack);enable(gl.CULL_FACE);enable(gl.BLEND);setBlending(NormalBlending);}function initAttributes(){for(var i=0,l=newAttributes.length;i<l;i++){newAttributes[i]=0;}}function enableAttribute(attribute){newAttributes[attribute]=1;if(enabledAttributes[attribute]===0){gl.enableVertexAttribArray(attribute);enabledAttributes[attribute]=1;}if(attributeDivisors[attribute]!==0){var extension=extensions.get('ANGLE_instanced_arrays');extension.vertexAttribDivisorANGLE(attribute,0);attributeDivisors[attribute]=0;}}function enableAttributeAndDivisor(attribute,meshPerAttribute){newAttributes[attribute]=1;if(enabledAttributes[attribute]===0){gl.enableVertexAttribArray(attribute);enabledAttributes[attribute]=1;}if(attributeDivisors[attribute]!==meshPerAttribute){var extension=extensions.get('ANGLE_instanced_arrays');extension.vertexAttribDivisorANGLE(attribute,meshPerAttribute);attributeDivisors[attribute]=meshPerAttribute;}}function disableUnusedAttributes(){for(var i=0,l=enabledAttributes.length;i!==l;++i){if(enabledAttributes[i]!==newAttributes[i]){gl.disableVertexAttribArray(i);enabledAttributes[i]=0;}}}function enable(id){if(capabilities[id]!==true){gl.enable(id);capabilities[id]=true;}}function disable(id){if(capabilities[id]!==false){gl.disable(id);capabilities[id]=false;}}function getCompressedTextureFormats(){if(compressedTextureFormats===null){compressedTextureFormats=[];if(extensions.get('WEBGL_compressed_texture_pvrtc')||extensions.get('WEBGL_compressed_texture_s3tc')||extensions.get('WEBGL_compressed_texture_etc1')){var formats=gl.getParameter(gl.COMPRESSED_TEXTURE_FORMATS);for(var i=0;i<formats.length;i++){compressedTextureFormats.push(formats[i]);}}}return compressedTextureFormats;}function setBlending(blending,blendEquation,blendSrc,blendDst,blendEquationAlpha,blendSrcAlpha,blendDstAlpha,premultipliedAlpha){if(blending!==NoBlending){enable(gl.BLEND);}else{disable(gl.BLEND);}if(blending!==currentBlending||premultipliedAlpha!==currentPremultipledAlpha){if(blending===AdditiveBlending){if(premultipliedAlpha){gl.blendEquationSeparate(gl.FUNC_ADD,gl.FUNC_ADD);gl.blendFuncSeparate(gl.ONE,gl.ONE,gl.ONE,gl.ONE);}else{gl.blendEquation(gl.FUNC_ADD);gl.blendFunc(gl.SRC_ALPHA,gl.ONE);}}else if(blending===SubtractiveBlending){if(premultipliedAlpha){gl.blendEquationSeparate(gl.FUNC_ADD,gl.FUNC_ADD);gl.blendFuncSeparate(gl.ZERO,gl.ZERO,gl.ONE_MINUS_SRC_COLOR,gl.ONE_MINUS_SRC_ALPHA);}else{gl.blendEquation(gl.FUNC_ADD);gl.blendFunc(gl.ZERO,gl.ONE_MINUS_SRC_COLOR);}}else if(blending===MultiplyBlending){if(premultipliedAlpha){gl.blendEquationSeparate(gl.FUNC_ADD,gl.FUNC_ADD);gl.blendFuncSeparate(gl.ZERO,gl.SRC_COLOR,gl.ZERO,gl.SRC_ALPHA);}else{gl.blendEquation(gl.FUNC_ADD);gl.blendFunc(gl.ZERO,gl.SRC_COLOR);}}else{if(premultipliedAlpha){gl.blendEquationSeparate(gl.FUNC_ADD,gl.FUNC_ADD);gl.blendFuncSeparate(gl.ONE,gl.ONE_MINUS_SRC_ALPHA,gl.ONE,gl.ONE_MINUS_SRC_ALPHA);}else{gl.blendEquationSeparate(gl.FUNC_ADD,gl.FUNC_ADD);gl.blendFuncSeparate(gl.SRC_ALPHA,gl.ONE_MINUS_SRC_ALPHA,gl.ONE,gl.ONE_MINUS_SRC_ALPHA);}}currentBlending=blending;currentPremultipledAlpha=premultipliedAlpha;}if(blending===CustomBlending){blendEquationAlpha=blendEquationAlpha||blendEquation;blendSrcAlpha=blendSrcAlpha||blendSrc;blendDstAlpha=blendDstAlpha||blendDst;if(blendEquation!==currentBlendEquation||blendEquationAlpha!==currentBlendEquationAlpha){gl.blendEquationSeparate(paramThreeToGL(blendEquation),paramThreeToGL(blendEquationAlpha));currentBlendEquation=blendEquation;currentBlendEquationAlpha=blendEquationAlpha;}if(blendSrc!==currentBlendSrc||blendDst!==currentBlendDst||blendSrcAlpha!==currentBlendSrcAlpha||blendDstAlpha!==currentBlendDstAlpha){gl.blendFuncSeparate(paramThreeToGL(blendSrc),paramThreeToGL(blendDst),paramThreeToGL(blendSrcAlpha),paramThreeToGL(blendDstAlpha));currentBlendSrc=blendSrc;currentBlendDst=blendDst;currentBlendSrcAlpha=blendSrcAlpha;currentBlendDstAlpha=blendDstAlpha;}}else{currentBlendEquation=null;currentBlendSrc=null;currentBlendDst=null;currentBlendEquationAlpha=null;currentBlendSrcAlpha=null;currentBlendDstAlpha=null;}}function setMaterial(material){material.side===DoubleSide?disable(gl.CULL_FACE):enable(gl.CULL_FACE);setFlipSided(material.side===BackSide);material.transparent===true?setBlending(material.blending,material.blendEquation,material.blendSrc,material.blendDst,material.blendEquationAlpha,material.blendSrcAlpha,material.blendDstAlpha,material.premultipliedAlpha):setBlending(NoBlending);depthBuffer.setFunc(material.depthFunc);depthBuffer.setTest(material.depthTest);depthBuffer.setMask(material.depthWrite);colorBuffer.setMask(material.colorWrite);setPolygonOffset(material.polygonOffset,material.polygonOffsetFactor,material.polygonOffsetUnits);}//
	function setFlipSided(flipSided){if(currentFlipSided!==flipSided){if(flipSided){gl.frontFace(gl.CW);}else{gl.frontFace(gl.CCW);}currentFlipSided=flipSided;}}function setCullFace(cullFace){if(cullFace!==CullFaceNone){enable(gl.CULL_FACE);if(cullFace!==currentCullFace){if(cullFace===CullFaceBack){gl.cullFace(gl.BACK);}else if(cullFace===CullFaceFront){gl.cullFace(gl.FRONT);}else{gl.cullFace(gl.FRONT_AND_BACK);}}}else{disable(gl.CULL_FACE);}currentCullFace=cullFace;}function setLineWidth(width){if(width!==currentLineWidth){if(lineWidthAvailable)gl.lineWidth(width);currentLineWidth=width;}}function setPolygonOffset(polygonOffset,factor,units){if(polygonOffset){enable(gl.POLYGON_OFFSET_FILL);if(currentPolygonOffsetFactor!==factor||currentPolygonOffsetUnits!==units){gl.polygonOffset(factor,units);currentPolygonOffsetFactor=factor;currentPolygonOffsetUnits=units;}}else{disable(gl.POLYGON_OFFSET_FILL);}}function getScissorTest(){return currentScissorTest;}function setScissorTest(scissorTest){currentScissorTest=scissorTest;if(scissorTest){enable(gl.SCISSOR_TEST);}else{disable(gl.SCISSOR_TEST);}}// texture
	function activeTexture(webglSlot){if(webglSlot===undefined)webglSlot=gl.TEXTURE0+maxTextures-1;if(currentTextureSlot!==webglSlot){gl.activeTexture(webglSlot);currentTextureSlot=webglSlot;}}function bindTexture(webglType,webglTexture){if(currentTextureSlot===null){activeTexture();}var boundTexture=currentBoundTextures[currentTextureSlot];if(boundTexture===undefined){boundTexture={type:undefined,texture:undefined};currentBoundTextures[currentTextureSlot]=boundTexture;}if(boundTexture.type!==webglType||boundTexture.texture!==webglTexture){gl.bindTexture(webglType,webglTexture||emptyTextures[webglType]);boundTexture.type=webglType;boundTexture.texture=webglTexture;}}function compressedTexImage2D(){try{gl.compressedTexImage2D.apply(gl,arguments);}catch(error){console.error(error);}}function texImage2D(){try{gl.texImage2D.apply(gl,arguments);}catch(error){console.error(error);}}//
	function scissor(scissor){if(currentScissor.equals(scissor)===false){gl.scissor(scissor.x,scissor.y,scissor.z,scissor.w);currentScissor.copy(scissor);}}function viewport(viewport){if(currentViewport.equals(viewport)===false){gl.viewport(viewport.x,viewport.y,viewport.z,viewport.w);currentViewport.copy(viewport);}}//
	function reset(){for(var i=0;i<enabledAttributes.length;i++){if(enabledAttributes[i]===1){gl.disableVertexAttribArray(i);enabledAttributes[i]=0;}}capabilities={};compressedTextureFormats=null;currentTextureSlot=null;currentBoundTextures={};currentBlending=null;currentFlipSided=null;currentCullFace=null;colorBuffer.reset();depthBuffer.reset();stencilBuffer.reset();}return{buffers:{color:colorBuffer,depth:depthBuffer,stencil:stencilBuffer},init:init,initAttributes:initAttributes,enableAttribute:enableAttribute,enableAttributeAndDivisor:enableAttributeAndDivisor,disableUnusedAttributes:disableUnusedAttributes,enable:enable,disable:disable,getCompressedTextureFormats:getCompressedTextureFormats,setBlending:setBlending,setMaterial:setMaterial,setFlipSided:setFlipSided,setCullFace:setCullFace,setLineWidth:setLineWidth,setPolygonOffset:setPolygonOffset,getScissorTest:getScissorTest,setScissorTest:setScissorTest,activeTexture:activeTexture,bindTexture:bindTexture,compressedTexImage2D:compressedTexImage2D,texImage2D:texImage2D,scissor:scissor,viewport:viewport,reset:reset};}/**
		 * @author mrdoob / http://mrdoob.com/
		 */function WebGLCapabilities(gl,extensions,parameters){var maxAnisotropy;function getMaxAnisotropy(){if(maxAnisotropy!==undefined)return maxAnisotropy;var extension=extensions.get('EXT_texture_filter_anisotropic');if(extension!==null){maxAnisotropy=gl.getParameter(extension.MAX_TEXTURE_MAX_ANISOTROPY_EXT);}else{maxAnisotropy=0;}return maxAnisotropy;}function getMaxPrecision(precision){if(precision==='highp'){if(gl.getShaderPrecisionFormat(gl.VERTEX_SHADER,gl.HIGH_FLOAT).precision>0&&gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER,gl.HIGH_FLOAT).precision>0){return'highp';}precision='mediump';}if(precision==='mediump'){if(gl.getShaderPrecisionFormat(gl.VERTEX_SHADER,gl.MEDIUM_FLOAT).precision>0&&gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER,gl.MEDIUM_FLOAT).precision>0){return'mediump';}}return'lowp';}var precision=parameters.precision!==undefined?parameters.precision:'highp';var maxPrecision=getMaxPrecision(precision);if(maxPrecision!==precision){console.warn('THREE.WebGLRenderer:',precision,'not supported, using',maxPrecision,'instead.');precision=maxPrecision;}var logarithmicDepthBuffer=parameters.logarithmicDepthBuffer===true&&!!extensions.get('EXT_frag_depth');var maxTextures=gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);var maxVertexTextures=gl.getParameter(gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS);var maxTextureSize=gl.getParameter(gl.MAX_TEXTURE_SIZE);var maxCubemapSize=gl.getParameter(gl.MAX_CUBE_MAP_TEXTURE_SIZE);var maxAttributes=gl.getParameter(gl.MAX_VERTEX_ATTRIBS);var maxVertexUniforms=gl.getParameter(gl.MAX_VERTEX_UNIFORM_VECTORS);var maxVaryings=gl.getParameter(gl.MAX_VARYING_VECTORS);var maxFragmentUniforms=gl.getParameter(gl.MAX_FRAGMENT_UNIFORM_VECTORS);var vertexTextures=maxVertexTextures>0;var floatFragmentTextures=!!extensions.get('OES_texture_float');var floatVertexTextures=vertexTextures&&floatFragmentTextures;return{getMaxAnisotropy:getMaxAnisotropy,getMaxPrecision:getMaxPrecision,precision:precision,logarithmicDepthBuffer:logarithmicDepthBuffer,maxTextures:maxTextures,maxVertexTextures:maxVertexTextures,maxTextureSize:maxTextureSize,maxCubemapSize:maxCubemapSize,maxAttributes:maxAttributes,maxVertexUniforms:maxVertexUniforms,maxVaryings:maxVaryings,maxFragmentUniforms:maxFragmentUniforms,vertexTextures:vertexTextures,floatFragmentTextures:floatFragmentTextures,floatVertexTextures:floatVertexTextures};}/**
		 * @author mrdoob / http://mrdoob.com/
		 */function WebGLExtensions(gl){var extensions={};return{get:function get(name){if(extensions[name]!==undefined){return extensions[name];}var extension;switch(name){case'WEBGL_depth_texture':extension=gl.getExtension('WEBGL_depth_texture')||gl.getExtension('MOZ_WEBGL_depth_texture')||gl.getExtension('WEBKIT_WEBGL_depth_texture');break;case'EXT_texture_filter_anisotropic':extension=gl.getExtension('EXT_texture_filter_anisotropic')||gl.getExtension('MOZ_EXT_texture_filter_anisotropic')||gl.getExtension('WEBKIT_EXT_texture_filter_anisotropic');break;case'WEBGL_compressed_texture_s3tc':extension=gl.getExtension('WEBGL_compressed_texture_s3tc')||gl.getExtension('MOZ_WEBGL_compressed_texture_s3tc')||gl.getExtension('WEBKIT_WEBGL_compressed_texture_s3tc');break;case'WEBGL_compressed_texture_pvrtc':extension=gl.getExtension('WEBGL_compressed_texture_pvrtc')||gl.getExtension('WEBKIT_WEBGL_compressed_texture_pvrtc');break;case'WEBGL_compressed_texture_etc1':extension=gl.getExtension('WEBGL_compressed_texture_etc1');break;default:extension=gl.getExtension(name);}if(extension===null){console.warn('THREE.WebGLRenderer: '+name+' extension not supported.');}extensions[name]=extension;return extension;}};}/**
		 * @author tschw
		 */function WebGLClipping(){var scope=this,globalState=null,numGlobalPlanes=0,localClippingEnabled=false,renderingShadows=false,plane=new Plane(),viewNormalMatrix=new Matrix3(),uniform={value:null,needsUpdate:false};this.uniform=uniform;this.numPlanes=0;this.numIntersection=0;this.init=function(planes,enableLocalClipping,camera){var enabled=planes.length!==0||enableLocalClipping||// enable state of previous frame - the clipping code has to
	// run another frame in order to reset the state:
	numGlobalPlanes!==0||localClippingEnabled;localClippingEnabled=enableLocalClipping;globalState=projectPlanes(planes,camera,0);numGlobalPlanes=planes.length;return enabled;};this.beginShadows=function(){renderingShadows=true;projectPlanes(null);};this.endShadows=function(){renderingShadows=false;resetGlobalState();};this.setState=function(planes,clipIntersection,clipShadows,camera,cache,fromCache){if(!localClippingEnabled||planes===null||planes.length===0||renderingShadows&&!clipShadows){// there's no local clipping
	if(renderingShadows){// there's no global clipping
	projectPlanes(null);}else{resetGlobalState();}}else{var nGlobal=renderingShadows?0:numGlobalPlanes,lGlobal=nGlobal*4,dstArray=cache.clippingState||null;uniform.value=dstArray;// ensure unique state
	dstArray=projectPlanes(planes,camera,lGlobal,fromCache);for(var i=0;i!==lGlobal;++i){dstArray[i]=globalState[i];}cache.clippingState=dstArray;this.numIntersection=clipIntersection?this.numPlanes:0;this.numPlanes+=nGlobal;}};function resetGlobalState(){if(uniform.value!==globalState){uniform.value=globalState;uniform.needsUpdate=numGlobalPlanes>0;}scope.numPlanes=numGlobalPlanes;scope.numIntersection=0;}function projectPlanes(planes,camera,dstOffset,skipTransform){var nPlanes=planes!==null?planes.length:0,dstArray=null;if(nPlanes!==0){dstArray=uniform.value;if(skipTransform!==true||dstArray===null){var flatSize=dstOffset+nPlanes*4,viewMatrix=camera.matrixWorldInverse;viewNormalMatrix.getNormalMatrix(viewMatrix);if(dstArray===null||dstArray.length<flatSize){dstArray=new Float32Array(flatSize);}for(var i=0,i4=dstOffset;i!==nPlanes;++i,i4+=4){plane.copy(planes[i]).applyMatrix4(viewMatrix,viewNormalMatrix);plane.normal.toArray(dstArray,i4);dstArray[i4+3]=plane.constant;}}uniform.value=dstArray;uniform.needsUpdate=true;}scope.numPlanes=nPlanes;return dstArray;}}// import { LensFlarePlugin } from './webgl/plugins/LensFlarePlugin';
	// import { Sphere } from '../math/Sphere';
	/**
		 * @author supereggbert / http://www.paulbrunt.co.uk/
		 * @author mrdoob / http://mrdoob.com/
		 * @author alteredq / http://alteredqualia.com/
		 * @author szimek / https://github.com/szimek/
		 * @author tschw
		 */function WebGLRenderer(parameters){console.log('THREE.WebGLRenderer',REVISION);parameters=parameters||{};var _canvas=parameters.canvas!==undefined?parameters.canvas:document.createElementNS('http://www.w3.org/1999/xhtml','canvas'),_context=parameters.context!==undefined?parameters.context:null,_alpha=parameters.alpha!==undefined?parameters.alpha:false,_depth=parameters.depth!==undefined?parameters.depth:true,_stencil=parameters.stencil!==undefined?parameters.stencil:true,_antialias=parameters.antialias!==undefined?parameters.antialias:false,_premultipliedAlpha=parameters.premultipliedAlpha!==undefined?parameters.premultipliedAlpha:true,_preserveDrawingBuffer=parameters.preserveDrawingBuffer!==undefined?parameters.preserveDrawingBuffer:false;var lights=[];var currentRenderList=null;var morphInfluences=new Float32Array(8);var sprites=[];var lensFlares=[];// public properties
	this.domElement=_canvas;this.context=null;// clearing
	this.autoClear=true;this.autoClearColor=true;this.autoClearDepth=true;this.autoClearStencil=true;// scene graph
	this.sortObjects=true;// user-defined clipping
	this.clippingPlanes=[];this.localClippingEnabled=false;// physically based shading
	this.gammaFactor=2.0;// for backwards compatibility
	this.gammaInput=false;this.gammaOutput=false;// physical lights
	this.physicallyCorrectLights=false;// tone mapping
	this.toneMapping=LinearToneMapping;this.toneMappingExposure=1.0;this.toneMappingWhitePoint=1.0;// morphs
	this.maxMorphTargets=8;this.maxMorphNormals=4;// internal properties
	var _this=this,// internal state cache
	_currentProgram=null,_currentRenderTarget=null,_currentFramebuffer=null,_currentMaterialId=-1,_currentGeometryProgram='',_currentCamera=null,_currentScissor=new Vector4(),_currentScissorTest=null,_currentViewport=new Vector4(),//
	_usedTextureUnits=0,//
	_clearColor=new Color(0x000000),_clearAlpha=0,_width=_canvas.width,_height=_canvas.height,_pixelRatio=1,_scissor=new Vector4(0,0,_width,_height),_scissorTest=false,_viewport=new Vector4(0,0,_width,_height),// frustum
	_frustum=new Frustum(),// clipping
	_clipping=new WebGLClipping(),_clippingEnabled=false,_localClippingEnabled=false,// camera matrices cache
	_projScreenMatrix=new Matrix4(),_vector3=new Vector3(),_matrix4=new Matrix4(),_matrix42=new Matrix4(),// light arrays cache
	_lights={hash:'',ambient:[0,0,0],directional:[],directionalShadowMap:[],directionalShadowMatrix:[],spot:[],spotShadowMap:[],spotShadowMatrix:[],rectArea:[],point:[],pointShadowMap:[],pointShadowMatrix:[],hemi:[],shadows:[]},// info
	_infoMemory={geometries:0,textures:0},_infoRender={frame:0,calls:0,vertices:0,faces:0,points:0};this.info={render:_infoRender,memory:_infoMemory,programs:null};// initialize
	var _gl;try{var contextAttributes={alpha:_alpha,depth:_depth,stencil:_stencil,antialias:_antialias,premultipliedAlpha:_premultipliedAlpha,preserveDrawingBuffer:_preserveDrawingBuffer};_gl=_context||_canvas.getContext('webgl',contextAttributes)||_canvas.getContext('experimental-webgl',contextAttributes);if(_gl===null){if(_canvas.getContext('webgl')!==null){throw'Error creating WebGL context with your selected attributes.';}else{throw'Error creating WebGL context.';}}// Some experimental-webgl implementations do not have getShaderPrecisionFormat
	if(_gl.getShaderPrecisionFormat===undefined){_gl.getShaderPrecisionFormat=function(){return{'rangeMin':1,'rangeMax':1,'precision':1};};}_canvas.addEventListener('webglcontextlost',onContextLost,false);}catch(error){console.error('THREE.WebGLRenderer: '+error);}var extensions=new WebGLExtensions(_gl);extensions.get('WEBGL_depth_texture');extensions.get('OES_texture_float');extensions.get('OES_texture_float_linear');extensions.get('OES_texture_half_float');extensions.get('OES_texture_half_float_linear');extensions.get('OES_standard_derivatives');extensions.get('ANGLE_instanced_arrays');if(extensions.get('OES_element_index_uint')){BufferGeometry.MaxIndex=4294967296;}var capabilities=new WebGLCapabilities(_gl,extensions,parameters);var state=new WebGLState(_gl,extensions,paramThreeToGL);var properties=new WebGLProperties();var textures=new WebGLTextures(_gl,extensions,state,properties,capabilities,paramThreeToGL,_infoMemory);var attributes=new WebGLAttributes(_gl);var geometries=new WebGLGeometries(_gl,attributes,_infoMemory);var objects=new WebGLObjects(_gl,geometries,_infoRender);var programCache=new WebGLPrograms(this,capabilities);var lightCache=new WebGLLights();var renderLists=new WebGLRenderLists();this.info.programs=programCache.programs;var bufferRenderer=new WebGLBufferRenderer(_gl,extensions,_infoRender);var indexedBufferRenderer=new WebGLIndexedBufferRenderer(_gl,extensions,_infoRender);//
	var backgroundPlaneCamera,backgroundPlaneMesh;var backgroundBoxCamera,backgroundBoxMesh;//
	function getTargetPixelRatio(){return _currentRenderTarget===null?_pixelRatio:1;}function setDefaultGLState(){state.init();state.scissor(_currentScissor.copy(_scissor).multiplyScalar(_pixelRatio));state.viewport(_currentViewport.copy(_viewport).multiplyScalar(_pixelRatio));state.buffers.color.setClear(_clearColor.r,_clearColor.g,_clearColor.b,_clearAlpha,_premultipliedAlpha);}function resetGLState(){_currentProgram=null;_currentCamera=null;_currentGeometryProgram='';_currentMaterialId=-1;state.reset();}setDefaultGLState();this.context=_gl;this.capabilities=capabilities;this.extensions=extensions;this.properties=properties;this.state=state;// shadow map
	var shadowMap=new WebGLShadowMap(this,_lights,objects,capabilities);this.shadowMap=shadowMap;// Plugins
	var spritePlugin=new parameters.SpritePlugin(this,sprites);// var spritePlugin = new SpritePlugin( this, sprites );
	// var lensFlarePlugin = new LensFlarePlugin( this, lensFlares );
	// API
	this.getContext=function(){return _gl;};this.getContextAttributes=function(){return _gl.getContextAttributes();};this.forceContextLoss=function(){var extension=extensions.get('WEBGL_lose_context');if(extension)extension.loseContext();};this.getMaxAnisotropy=function(){return capabilities.getMaxAnisotropy();};this.getPrecision=function(){return capabilities.precision;};this.getPixelRatio=function(){return _pixelRatio;};this.setPixelRatio=function(value){if(value===undefined)return;_pixelRatio=value;this.setSize(_viewport.z,_viewport.w,false);};this.getSize=function(){return{width:_width,height:_height};};this.setSize=function(width,height,updateStyle){_width=width;_height=height;_canvas.width=width*_pixelRatio;_canvas.height=height*_pixelRatio;if(updateStyle!==false){_canvas.style.width=width+'px';_canvas.style.height=height+'px';}this.setViewport(0,0,width,height);};this.setViewport=function(x,y,width,height){state.viewport(_viewport.set(x,y,width,height));};this.setScissor=function(x,y,width,height){state.scissor(_scissor.set(x,y,width,height));};this.setScissorTest=function(boolean){state.setScissorTest(_scissorTest=boolean);};// Clearing
	this.getClearColor=function(){return _clearColor;};this.setClearColor=function(color,alpha){_clearColor.set(color);_clearAlpha=alpha!==undefined?alpha:1;state.buffers.color.setClear(_clearColor.r,_clearColor.g,_clearColor.b,_clearAlpha,_premultipliedAlpha);};this.getClearAlpha=function(){return _clearAlpha;};this.setClearAlpha=function(alpha){_clearAlpha=alpha;state.buffers.color.setClear(_clearColor.r,_clearColor.g,_clearColor.b,_clearAlpha,_premultipliedAlpha);};this.clear=function(color,depth,stencil){var bits=0;if(color===undefined||color)bits|=_gl.COLOR_BUFFER_BIT;if(depth===undefined||depth)bits|=_gl.DEPTH_BUFFER_BIT;if(stencil===undefined||stencil)bits|=_gl.STENCIL_BUFFER_BIT;_gl.clear(bits);};this.clearColor=function(){this.clear(true,false,false);};this.clearDepth=function(){this.clear(false,true,false);};this.clearStencil=function(){this.clear(false,false,true);};this.clearTarget=function(renderTarget,color,depth,stencil){this.setRenderTarget(renderTarget);this.clear(color,depth,stencil);};// Reset
	this.resetGLState=resetGLState;this.dispose=function(){_canvas.removeEventListener('webglcontextlost',onContextLost,false);renderLists.dispose();};// Events
	function onContextLost(event){event.preventDefault();resetGLState();setDefaultGLState();properties.clear();objects.clear();}function onMaterialDispose(event){var material=event.target;material.removeEventListener('dispose',onMaterialDispose);deallocateMaterial(material);}// Buffer deallocation
	function deallocateMaterial(material){releaseMaterialProgramReference(material);properties.remove(material);}function releaseMaterialProgramReference(material){var programInfo=properties.get(material).program;material.program=undefined;if(programInfo!==undefined){programCache.releaseProgram(programInfo);}}// Buffer rendering
	function renderObjectImmediate(object,program,material){object.render(function(object){_this.renderBufferImmediate(object,program,material);});}this.renderBufferImmediate=function(object,program,material){state.initAttributes();var buffers=properties.get(object);if(object.hasPositions&&!buffers.position)buffers.position=_gl.createBuffer();if(object.hasNormals&&!buffers.normal)buffers.normal=_gl.createBuffer();if(object.hasUvs&&!buffers.uv)buffers.uv=_gl.createBuffer();if(object.hasColors&&!buffers.color)buffers.color=_gl.createBuffer();var programAttributes=program.getAttributes();if(object.hasPositions){_gl.bindBuffer(_gl.ARRAY_BUFFER,buffers.position);_gl.bufferData(_gl.ARRAY_BUFFER,object.positionArray,_gl.DYNAMIC_DRAW);state.enableAttribute(programAttributes.position);_gl.vertexAttribPointer(programAttributes.position,3,_gl.FLOAT,false,0,0);}if(object.hasNormals){_gl.bindBuffer(_gl.ARRAY_BUFFER,buffers.normal);if(!material.isMeshPhongMaterial&&!material.isMeshStandardMaterial&&!material.isMeshNormalMaterial&&material.shading===FlatShading){for(var i=0,l=object.count*3;i<l;i+=9){var array=object.normalArray;var nx=(array[i+0]+array[i+3]+array[i+6])/3;var ny=(array[i+1]+array[i+4]+array[i+7])/3;var nz=(array[i+2]+array[i+5]+array[i+8])/3;array[i+0]=nx;array[i+1]=ny;array[i+2]=nz;array[i+3]=nx;array[i+4]=ny;array[i+5]=nz;array[i+6]=nx;array[i+7]=ny;array[i+8]=nz;}}_gl.bufferData(_gl.ARRAY_BUFFER,object.normalArray,_gl.DYNAMIC_DRAW);state.enableAttribute(programAttributes.normal);_gl.vertexAttribPointer(programAttributes.normal,3,_gl.FLOAT,false,0,0);}if(object.hasUvs&&material.map){_gl.bindBuffer(_gl.ARRAY_BUFFER,buffers.uv);_gl.bufferData(_gl.ARRAY_BUFFER,object.uvArray,_gl.DYNAMIC_DRAW);state.enableAttribute(programAttributes.uv);_gl.vertexAttribPointer(attributes.uv,2,_gl.FLOAT,false,0,0);}if(object.hasColors&&material.vertexColors!==NoColors){_gl.bindBuffer(_gl.ARRAY_BUFFER,buffers.color);_gl.bufferData(_gl.ARRAY_BUFFER,object.colorArray,_gl.DYNAMIC_DRAW);state.enableAttribute(programAttributes.color);_gl.vertexAttribPointer(programAttributes.color,3,_gl.FLOAT,false,0,0);}state.disableUnusedAttributes();_gl.drawArrays(_gl.TRIANGLES,0,object.count);object.count=0;};this.renderBufferDirect=function(camera,fog,geometry,material,object,group){state.setMaterial(material);var program=setProgram(camera,fog,material,object);var geometryProgram=geometry.id+'_'+program.id+'_'+(material.wireframe===true);var updateBuffers=false;if(geometryProgram!==_currentGeometryProgram){_currentGeometryProgram=geometryProgram;updateBuffers=true;}// morph targets
	var morphTargetInfluences=object.morphTargetInfluences;if(morphTargetInfluences!==undefined){// TODO Remove allocations
	var activeInfluences=[];for(var i=0,l=morphTargetInfluences.length;i<l;i++){var influence=morphTargetInfluences[i];activeInfluences.push([influence,i]);}activeInfluences.sort(absNumericalSort);if(activeInfluences.length>8){activeInfluences.length=8;}var morphAttributes=geometry.morphAttributes;for(var i=0,l=activeInfluences.length;i<l;i++){var influence=activeInfluences[i];morphInfluences[i]=influence[0];if(influence[0]!==0){var index=influence[1];if(material.morphTargets===true&&morphAttributes.position)geometry.addAttribute('morphTarget'+i,morphAttributes.position[index]);if(material.morphNormals===true&&morphAttributes.normal)geometry.addAttribute('morphNormal'+i,morphAttributes.normal[index]);}else{if(material.morphTargets===true)geometry.removeAttribute('morphTarget'+i);if(material.morphNormals===true)geometry.removeAttribute('morphNormal'+i);}}for(var i=activeInfluences.length,il=morphInfluences.length;i<il;i++){morphInfluences[i]=0.0;}program.getUniforms().setValue(_gl,'morphTargetInfluences',morphInfluences);updateBuffers=true;}//
	var index=geometry.index;var position=geometry.attributes.position;var rangeFactor=1;if(material.wireframe===true){index=geometries.getWireframeAttribute(geometry);rangeFactor=2;}var renderer=bufferRenderer;if(index!==null){renderer=indexedBufferRenderer;renderer.setIndex(index);}if(updateBuffers){setupVertexAttributes(material,program,geometry);if(index!==null){_gl.bindBuffer(_gl.ELEMENT_ARRAY_BUFFER,attributes.get(index).buffer);}}//
	var dataCount=0;if(index!==null){dataCount=index.count;}else if(position!==undefined){dataCount=position.count;}var rangeStart=geometry.drawRange.start*rangeFactor;var rangeCount=geometry.drawRange.count*rangeFactor;var groupStart=group!==null?group.start*rangeFactor:0;var groupCount=group!==null?group.count*rangeFactor:Infinity;var drawStart=Math.max(rangeStart,groupStart);var drawEnd=Math.min(dataCount,rangeStart+rangeCount,groupStart+groupCount)-1;var drawCount=Math.max(0,drawEnd-drawStart+1);if(drawCount===0)return;//
	if(object.isMesh){if(material.wireframe===true){state.setLineWidth(material.wireframeLinewidth*getTargetPixelRatio());renderer.setMode(_gl.LINES);}else{switch(object.drawMode){case TrianglesDrawMode:renderer.setMode(_gl.TRIANGLES);break;case TriangleStripDrawMode:renderer.setMode(_gl.TRIANGLE_STRIP);break;case TriangleFanDrawMode:renderer.setMode(_gl.TRIANGLE_FAN);break;}}}else if(object.isLine){var lineWidth=material.linewidth;if(lineWidth===undefined)lineWidth=1;// Not using Line*Material
	state.setLineWidth(lineWidth*getTargetPixelRatio());if(object.isLineSegments){renderer.setMode(_gl.LINES);}else if(object.isLineLoop){renderer.setMode(_gl.LINE_LOOP);}else{renderer.setMode(_gl.LINE_STRIP);}}else if(object.isPoints){renderer.setMode(_gl.POINTS);}if(geometry&&geometry.isInstancedBufferGeometry){if(geometry.maxInstancedCount>0){renderer.renderInstances(geometry,drawStart,drawCount);}}else{renderer.render(drawStart,drawCount);}};function setupVertexAttributes(material,program,geometry,startIndex){if(geometry&&geometry.isInstancedBufferGeometry){if(extensions.get('ANGLE_instanced_arrays')===null){console.error('THREE.WebGLRenderer.setupVertexAttributes: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.');return;}}if(startIndex===undefined)startIndex=0;state.initAttributes();var geometryAttributes=geometry.attributes;var programAttributes=program.getAttributes();var materialDefaultAttributeValues=material.defaultAttributeValues;for(var name in programAttributes){var programAttribute=programAttributes[name];if(programAttribute>=0){var geometryAttribute=geometryAttributes[name];if(geometryAttribute!==undefined){var normalized=geometryAttribute.normalized;var size=geometryAttribute.itemSize;var attributeProperties=attributes.get(geometryAttribute);var buffer=attributeProperties.buffer;var type=attributeProperties.type;var bytesPerElement=attributeProperties.bytesPerElement;if(geometryAttribute.isInterleavedBufferAttribute){var data=geometryAttribute.data;var stride=data.stride;var offset=geometryAttribute.offset;if(data&&data.isInstancedInterleavedBuffer){state.enableAttributeAndDivisor(programAttribute,data.meshPerAttribute);if(geometry.maxInstancedCount===undefined){geometry.maxInstancedCount=data.meshPerAttribute*data.count;}}else{state.enableAttribute(programAttribute);}_gl.bindBuffer(_gl.ARRAY_BUFFER,buffer);_gl.vertexAttribPointer(programAttribute,size,type,normalized,stride*bytesPerElement,(startIndex*stride+offset)*bytesPerElement);}else{if(geometryAttribute.isInstancedBufferAttribute){state.enableAttributeAndDivisor(programAttribute,geometryAttribute.meshPerAttribute);if(geometry.maxInstancedCount===undefined){geometry.maxInstancedCount=geometryAttribute.meshPerAttribute*geometryAttribute.count;}}else{state.enableAttribute(programAttribute);}_gl.bindBuffer(_gl.ARRAY_BUFFER,buffer);_gl.vertexAttribPointer(programAttribute,size,type,normalized,0,startIndex*size*bytesPerElement);}}else if(materialDefaultAttributeValues!==undefined){var value=materialDefaultAttributeValues[name];if(value!==undefined){switch(value.length){case 2:_gl.vertexAttrib2fv(programAttribute,value);break;case 3:_gl.vertexAttrib3fv(programAttribute,value);break;case 4:_gl.vertexAttrib4fv(programAttribute,value);break;default:_gl.vertexAttrib1fv(programAttribute,value);}}}}}state.disableUnusedAttributes();}// Sorting
	function absNumericalSort(a,b){return Math.abs(b[0])-Math.abs(a[0]);}// Rendering
	this.render=function(scene,camera,renderTarget,forceClear){if(camera!==undefined&&camera.isCamera!==true){console.error('THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.');return;}// reset caching for this frame
	_currentGeometryProgram='';_currentMaterialId=-1;_currentCamera=null;// update scene graph
	if(scene.autoUpdate===true)scene.updateMatrixWorld();// update camera matrices and frustum
	camera.onBeforeRender(_this);if(camera.parent===null)camera.updateMatrixWorld();camera.matrixWorldInverse.getInverse(camera.matrixWorld);_projScreenMatrix.multiplyMatrices(camera.projectionMatrix,camera.matrixWorldInverse);_frustum.setFromMatrix(_projScreenMatrix);lights.length=0;sprites.length=0;lensFlares.length=0;_localClippingEnabled=this.localClippingEnabled;_clippingEnabled=_clipping.init(this.clippingPlanes,_localClippingEnabled,camera);currentRenderList=renderLists.get(scene,camera);currentRenderList.init();projectObject(scene,camera,_this.sortObjects);currentRenderList.finish();if(_this.sortObjects===true){currentRenderList.sort();}//
	if(_clippingEnabled)_clipping.beginShadows();setupShadows(lights);shadowMap.render(scene,camera);setupLights(lights,camera);if(_clippingEnabled)_clipping.endShadows();//
	_infoRender.frame++;_infoRender.calls=0;_infoRender.vertices=0;_infoRender.faces=0;_infoRender.points=0;if(renderTarget===undefined){renderTarget=null;}this.setRenderTarget(renderTarget);//
	var background=scene.background;if(background===null){state.buffers.color.setClear(_clearColor.r,_clearColor.g,_clearColor.b,_clearAlpha,_premultipliedAlpha);}else if(background&&background.isColor){state.buffers.color.setClear(background.r,background.g,background.b,1,_premultipliedAlpha);forceClear=true;}if(this.autoClear||forceClear){this.clear(this.autoClearColor,this.autoClearDepth,this.autoClearStencil);}if(background&&background.isCubeTexture){if(backgroundBoxCamera===undefined){backgroundBoxCamera=new PerspectiveCamera();backgroundBoxMesh=new Mesh(new BoxBufferGeometry(5,5,5),new ShaderMaterial({uniforms:ShaderLib.cube.uniforms,vertexShader:ShaderLib.cube.vertexShader,fragmentShader:ShaderLib.cube.fragmentShader,side:BackSide,depthTest:false,depthWrite:false,fog:false}));}backgroundBoxCamera.projectionMatrix.copy(camera.projectionMatrix);backgroundBoxCamera.matrixWorld.extractRotation(camera.matrixWorld);backgroundBoxCamera.matrixWorldInverse.getInverse(backgroundBoxCamera.matrixWorld);backgroundBoxMesh.material.uniforms["tCube"].value=background;backgroundBoxMesh.modelViewMatrix.multiplyMatrices(backgroundBoxCamera.matrixWorldInverse,backgroundBoxMesh.matrixWorld);objects.update(backgroundBoxMesh);_this.renderBufferDirect(backgroundBoxCamera,null,backgroundBoxMesh.geometry,backgroundBoxMesh.material,backgroundBoxMesh,null);}else if(background&&background.isTexture){if(backgroundPlaneCamera===undefined){backgroundPlaneCamera=new OrthographicCamera(-1,1,1,-1,0,1);backgroundPlaneMesh=new Mesh(new PlaneBufferGeometry(2,2),new MeshBasicMaterial({depthTest:false,depthWrite:false,fog:false}));}backgroundPlaneMesh.material.map=background;objects.update(backgroundPlaneMesh);_this.renderBufferDirect(backgroundPlaneCamera,null,backgroundPlaneMesh.geometry,backgroundPlaneMesh.material,backgroundPlaneMesh,null);}//
	var opaqueObjects=currentRenderList.opaque;var transparentObjects=currentRenderList.transparent;if(scene.overrideMaterial){var overrideMaterial=scene.overrideMaterial;if(opaqueObjects.length)renderObjects(opaqueObjects,scene,camera,overrideMaterial);if(transparentObjects.length)renderObjects(transparentObjects,scene,camera,overrideMaterial);}else{// opaque pass (front-to-back order)
	if(opaqueObjects.length)renderObjects(opaqueObjects,scene,camera);// transparent pass (back-to-front order)
	if(transparentObjects.length)renderObjects(transparentObjects,scene,camera);}// custom render plugins (post pass)
	spritePlugin.render(scene,camera);// lensFlarePlugin.render( scene, camera, _currentViewport );
	// Generate mipmap if we're using any kind of mipmap filtering
	if(renderTarget){textures.updateRenderTargetMipmap(renderTarget);}// Ensure depth buffer writing is enabled so it can be cleared on next render
	state.buffers.depth.setTest(true);state.buffers.depth.setMask(true);state.buffers.color.setMask(true);if(camera.isArrayCamera&&camera.enabled){_this.setScissorTest(false);}camera.onAfterRender(_this);// _gl.finish();
	};/*
			// TODO Duplicated code (Frustum)
	
			var _sphere = new Sphere();
	
			function isObjectViewable( object ) {
	
				var geometry = object.geometry;
	
				if ( geometry.boundingSphere === null )
					geometry.computeBoundingSphere();
	
				_sphere.copy( geometry.boundingSphere ).
				applyMatrix4( object.matrixWorld );
	
				return isSphereViewable( _sphere );
	
			}
	
			function isSpriteViewable( sprite ) {
	
				_sphere.center.set( 0, 0, 0 );
				_sphere.radius = 0.7071067811865476;
				_sphere.applyMatrix4( sprite.matrixWorld );
	
				return isSphereViewable( _sphere );
	
			}
	
			function isSphereViewable( sphere ) {
	
				if ( ! _frustum.intersectsSphere( sphere ) ) return false;
	
				var numPlanes = _clipping.numPlanes;
	
				if ( numPlanes === 0 ) return true;
	
				var planes = _this.clippingPlanes,
	
					center = sphere.center,
					negRad = - sphere.radius,
					i = 0;
	
				do {
	
					// out when deeper than radius in the negative halfspace
					if ( planes[ i ].distanceToPoint( center ) < negRad ) return false;
	
				} while ( ++ i !== numPlanes );
	
				return true;
	
			}
			*/function projectObject(object,camera,sortObjects){if(!object.visible)return;if(object.isLight){lights.push(object);}else if(object.isSprite){if(!object.frustumCulled||_frustum.intersectsSprite(object)){sprites.push(object);}}else if(object.isLensFlare){lensFlares.push(object);}else if(object.isImmediateRenderObject){if(sortObjects){_vector3.setFromMatrixPosition(object.matrixWorld).applyMatrix4(_projScreenMatrix);}currentRenderList.push(object,null,object.material,_vector3.z,null);}else if(object.isMesh||object.isLine||object.isPoints){if(object.isSkinnedMesh){object.skeleton.update();}if(!object.frustumCulled||_frustum.intersectsObject(object)){if(sortObjects){_vector3.setFromMatrixPosition(object.matrixWorld).applyMatrix4(_projScreenMatrix);}var geometry=objects.update(object);var material=object.material;if(Array.isArray(material)){var groups=geometry.groups;for(var i=0,l=groups.length;i<l;i++){var group=groups[i];var groupMaterial=material[group.materialIndex];if(groupMaterial&&groupMaterial.visible){currentRenderList.push(object,geometry,groupMaterial,_vector3.z,group);}}}else if(material.visible){currentRenderList.push(object,geometry,material,_vector3.z,null);}}}var children=object.children;for(var i=0,l=children.length;i<l;i++){projectObject(children[i],camera,sortObjects);}}function renderObjects(renderList,scene,camera,overrideMaterial){for(var i=0,l=renderList.length;i<l;i++){var renderItem=renderList[i];var object=renderItem.object;var geometry=renderItem.geometry;var material=overrideMaterial===undefined?renderItem.material:overrideMaterial;var group=renderItem.group;object.onBeforeRender(_this,scene,camera,geometry,material,group);if(camera.isArrayCamera&&camera.enabled){var cameras=camera.cameras;for(var j=0,jl=cameras.length;j<jl;j++){var camera2=cameras[j];var bounds=camera2.bounds;_this.setViewport(bounds.x*_width*_pixelRatio,bounds.y*_height*_pixelRatio,bounds.z*_width*_pixelRatio,bounds.w*_height*_pixelRatio);_this.setScissor(bounds.x*_width*_pixelRatio,bounds.y*_height*_pixelRatio,bounds.z*_width*_pixelRatio,bounds.w*_height*_pixelRatio);_this.setScissorTest(true);renderObject(object,scene,camera2,geometry,material,group);}}else{renderObject(object,scene,camera,geometry,material,group);}object.onAfterRender(_this,scene,camera,geometry,material,group);}}function renderObject(object,scene,camera,geometry,material,group){if(object.layers.test(camera.layers)===false)return;object.modelViewMatrix.multiplyMatrices(camera.matrixWorldInverse,object.matrixWorld);object.normalMatrix.getNormalMatrix(object.modelViewMatrix);if(object.isImmediateRenderObject){state.setMaterial(material);var program=setProgram(camera,scene.fog,material,object);_currentGeometryProgram='';renderObjectImmediate(object,program,material);}else{_this.renderBufferDirect(camera,scene.fog,geometry,material,object,group);}}function initMaterial(material,fog,object){var materialProperties=properties.get(material);var parameters=programCache.getParameters(material,_lights,fog,_clipping.numPlanes,_clipping.numIntersection,object);var code=programCache.getProgramCode(material,parameters);var program=materialProperties.program;var programChange=true;if(program===undefined){// new material
	material.addEventListener('dispose',onMaterialDispose);}else if(program.code!==code){// changed glsl or parameters
	releaseMaterialProgramReference(material);}else if(parameters.shaderID!==undefined){// same glsl and uniform list
	return;}else{// only rebuild uniform list
	programChange=false;}if(programChange){if(parameters.shaderID){var shader=ShaderLib[parameters.shaderID];materialProperties.__webglShader={name:material.type,uniforms:UniformsUtils.clone(shader.uniforms),vertexShader:shader.vertexShader,fragmentShader:shader.fragmentShader};}else{materialProperties.__webglShader={name:material.type,uniforms:material.uniforms,vertexShader:material.vertexShader,fragmentShader:material.fragmentShader};}material.__webglShader=materialProperties.__webglShader;program=programCache.acquireProgram(material,parameters,code);materialProperties.program=program;material.program=program;}var programAttributes=program.getAttributes();if(material.morphTargets){material.numSupportedMorphTargets=0;for(var i=0;i<_this.maxMorphTargets;i++){if(programAttributes['morphTarget'+i]>=0){material.numSupportedMorphTargets++;}}}if(material.morphNormals){material.numSupportedMorphNormals=0;for(var i=0;i<_this.maxMorphNormals;i++){if(programAttributes['morphNormal'+i]>=0){material.numSupportedMorphNormals++;}}}var uniforms=materialProperties.__webglShader.uniforms;if(!material.isShaderMaterial&&!material.isRawShaderMaterial||material.clipping===true){materialProperties.numClippingPlanes=_clipping.numPlanes;materialProperties.numIntersection=_clipping.numIntersection;uniforms.clippingPlanes=_clipping.uniform;}materialProperties.fog=fog;// store the light setup it was created for
	materialProperties.lightsHash=_lights.hash;if(material.lights){// wire up the material to this renderer's lighting state
	uniforms.ambientLightColor.value=_lights.ambient;uniforms.directionalLights.value=_lights.directional;uniforms.spotLights.value=_lights.spot;uniforms.rectAreaLights.value=_lights.rectArea;uniforms.pointLights.value=_lights.point;uniforms.hemisphereLights.value=_lights.hemi;uniforms.directionalShadowMap.value=_lights.directionalShadowMap;uniforms.directionalShadowMatrix.value=_lights.directionalShadowMatrix;uniforms.spotShadowMap.value=_lights.spotShadowMap;uniforms.spotShadowMatrix.value=_lights.spotShadowMatrix;uniforms.pointShadowMap.value=_lights.pointShadowMap;uniforms.pointShadowMatrix.value=_lights.pointShadowMatrix;// TODO (abelnation): add area lights shadow info to uniforms
	}var progUniforms=materialProperties.program.getUniforms(),uniformsList=WebGLUniforms.seqWithValue(progUniforms.seq,uniforms);materialProperties.uniformsList=uniformsList;}function setProgram(camera,fog,material,object){_usedTextureUnits=0;var materialProperties=properties.get(material);if(_clippingEnabled){if(_localClippingEnabled||camera!==_currentCamera){var useCache=camera===_currentCamera&&material.id===_currentMaterialId;// we might want to call this function with some ClippingGroup
	// object instead of the material, once it becomes feasible
	// (#8465, #8379)
	_clipping.setState(material.clippingPlanes,material.clipIntersection,material.clipShadows,camera,materialProperties,useCache);}}if(material.needsUpdate===false){if(materialProperties.program===undefined){material.needsUpdate=true;}else if(material.fog&&materialProperties.fog!==fog){material.needsUpdate=true;}else if(material.lights&&materialProperties.lightsHash!==_lights.hash){material.needsUpdate=true;}else if(materialProperties.numClippingPlanes!==undefined&&(materialProperties.numClippingPlanes!==_clipping.numPlanes||materialProperties.numIntersection!==_clipping.numIntersection)){material.needsUpdate=true;}}if(material.needsUpdate){initMaterial(material,fog,object);material.needsUpdate=false;}var refreshProgram=false;var refreshMaterial=false;var refreshLights=false;var program=materialProperties.program,p_uniforms=program.getUniforms(),m_uniforms=materialProperties.__webglShader.uniforms;if(program.id!==_currentProgram){_gl.useProgram(program.program);_currentProgram=program.id;refreshProgram=true;refreshMaterial=true;refreshLights=true;}if(material.id!==_currentMaterialId){_currentMaterialId=material.id;refreshMaterial=true;}if(refreshProgram||camera!==_currentCamera){p_uniforms.setValue(_gl,'projectionMatrix',camera.projectionMatrix);if(capabilities.logarithmicDepthBuffer){p_uniforms.setValue(_gl,'logDepthBufFC',2.0/(Math.log(camera.far+1.0)/Math.LN2));}if(camera!==_currentCamera){_currentCamera=camera;// lighting uniforms depend on the camera so enforce an update
	// now, in case this material supports lights - or later, when
	// the next material that does gets activated:
	refreshMaterial=true;// set to true on material change
	refreshLights=true;// remains set until update done
	}// load material specific uniforms
	// (shader material also gets them for the sake of genericity)
	if(material.isShaderMaterial||material.isMeshPhongMaterial||material.isMeshStandardMaterial||material.envMap){var uCamPos=p_uniforms.map.cameraPosition;if(uCamPos!==undefined){uCamPos.setValue(_gl,_vector3.setFromMatrixPosition(camera.matrixWorld));}}if(material.isMeshPhongMaterial||material.isMeshLambertMaterial||material.isMeshBasicMaterial||material.isMeshStandardMaterial||material.isShaderMaterial||material.skinning){p_uniforms.setValue(_gl,'viewMatrix',camera.matrixWorldInverse);}p_uniforms.setValue(_gl,'toneMappingExposure',_this.toneMappingExposure);p_uniforms.setValue(_gl,'toneMappingWhitePoint',_this.toneMappingWhitePoint);}// skinning uniforms must be set even if material didn't change
	// auto-setting of texture unit for bone texture must go before other textures
	// not sure why, but otherwise weird things happen
	if(material.skinning){p_uniforms.setOptional(_gl,object,'bindMatrix');p_uniforms.setOptional(_gl,object,'bindMatrixInverse');var skeleton=object.skeleton;if(skeleton){var bones=skeleton.bones;if(capabilities.floatVertexTextures){if(skeleton.boneTexture===undefined){// layout (1 matrix = 4 pixels)
	//      RGBA RGBA RGBA RGBA (=> column1, column2, column3, column4)
	//  with  8x8  pixel texture max   16 bones * 4 pixels =  (8 * 8)
	//       16x16 pixel texture max   64 bones * 4 pixels = (16 * 16)
	//       32x32 pixel texture max  256 bones * 4 pixels = (32 * 32)
	//       64x64 pixel texture max 1024 bones * 4 pixels = (64 * 64)
	var size=Math.sqrt(bones.length*4);// 4 pixels needed for 1 matrix
	size=_Math.nextPowerOfTwo(Math.ceil(size));size=Math.max(size,4);var boneMatrices=new Float32Array(size*size*4);// 4 floats per RGBA pixel
	boneMatrices.set(skeleton.boneMatrices);// copy current values
	var boneTexture=new DataTexture(boneMatrices,size,size,RGBAFormat,FloatType);skeleton.boneMatrices=boneMatrices;skeleton.boneTexture=boneTexture;skeleton.boneTextureSize=size;}p_uniforms.setValue(_gl,'boneTexture',skeleton.boneTexture);p_uniforms.setValue(_gl,'boneTextureSize',skeleton.boneTextureSize);}else{p_uniforms.setOptional(_gl,skeleton,'boneMatrices');}}}if(refreshMaterial){if(material.lights){// the current material requires lighting info
	// note: all lighting uniforms are always set correctly
	// they simply reference the renderer's state for their
	// values
	//
	// use the current material's .needsUpdate flags to set
	// the GL state when required
	markUniformsLightsNeedsUpdate(m_uniforms,refreshLights);}// refresh uniforms common to several materials
	if(fog&&material.fog){refreshUniformsFog(m_uniforms,fog);}if(material.isMeshBasicMaterial||material.isMeshLambertMaterial||material.isMeshPhongMaterial||material.isMeshStandardMaterial||material.isMeshNormalMaterial||material.isMeshDepthMaterial){refreshUniformsCommon(m_uniforms,material);}// refresh single material specific uniforms
	if(material.isLineBasicMaterial){refreshUniformsLine(m_uniforms,material);}else if(material.isLineDashedMaterial){refreshUniformsLine(m_uniforms,material);refreshUniformsDash(m_uniforms,material);}else if(material.isPointsMaterial){refreshUniformsPoints(m_uniforms,material);}else if(material.isMeshLambertMaterial){refreshUniformsLambert(m_uniforms,material);}else if(material.isMeshToonMaterial){refreshUniformsToon(m_uniforms,material);}else if(material.isMeshPhongMaterial){refreshUniformsPhong(m_uniforms,material);}else if(material.isMeshPhysicalMaterial){refreshUniformsPhysical(m_uniforms,material);}else if(material.isMeshStandardMaterial){refreshUniformsStandard(m_uniforms,material);}else if(material.isMeshDepthMaterial){if(material.displacementMap){m_uniforms.displacementMap.value=material.displacementMap;m_uniforms.displacementScale.value=material.displacementScale;m_uniforms.displacementBias.value=material.displacementBias;}}else if(material.isMeshNormalMaterial){refreshUniformsNormal(m_uniforms,material);}// RectAreaLight Texture
	// TODO (mrdoob): Find a nicer implementation
	if(m_uniforms.ltcMat!==undefined)m_uniforms.ltcMat.value=UniformsLib.LTC_MAT_TEXTURE;if(m_uniforms.ltcMag!==undefined)m_uniforms.ltcMag.value=UniformsLib.LTC_MAG_TEXTURE;WebGLUniforms.upload(_gl,materialProperties.uniformsList,m_uniforms,_this);}// common matrices
	p_uniforms.setValue(_gl,'modelViewMatrix',object.modelViewMatrix);p_uniforms.setValue(_gl,'normalMatrix',object.normalMatrix);p_uniforms.setValue(_gl,'modelMatrix',object.matrixWorld);return program;}// Uniforms (refresh uniforms objects)
	function refreshUniformsCommon(uniforms,material){uniforms.opacity.value=material.opacity;uniforms.diffuse.value=material.color;if(material.emissive){uniforms.emissive.value.copy(material.emissive).multiplyScalar(material.emissiveIntensity);}uniforms.map.value=material.map;uniforms.specularMap.value=material.specularMap;uniforms.alphaMap.value=material.alphaMap;if(material.lightMap){uniforms.lightMap.value=material.lightMap;uniforms.lightMapIntensity.value=material.lightMapIntensity;}if(material.aoMap){uniforms.aoMap.value=material.aoMap;uniforms.aoMapIntensity.value=material.aoMapIntensity;}// uv repeat and offset setting priorities
	// 1. color map
	// 2. specular map
	// 3. normal map
	// 4. bump map
	// 5. alpha map
	// 6. emissive map
	var uvScaleMap;if(material.map){uvScaleMap=material.map;}else if(material.specularMap){uvScaleMap=material.specularMap;}else if(material.displacementMap){uvScaleMap=material.displacementMap;}else if(material.normalMap){uvScaleMap=material.normalMap;}else if(material.bumpMap){uvScaleMap=material.bumpMap;}else if(material.roughnessMap){uvScaleMap=material.roughnessMap;}else if(material.metalnessMap){uvScaleMap=material.metalnessMap;}else if(material.alphaMap){uvScaleMap=material.alphaMap;}else if(material.emissiveMap){uvScaleMap=material.emissiveMap;}if(uvScaleMap!==undefined){// backwards compatibility
	if(uvScaleMap.isWebGLRenderTarget){uvScaleMap=uvScaleMap.texture;}var offset=uvScaleMap.offset;var repeat=uvScaleMap.repeat;uniforms.offsetRepeat.value.set(offset.x,offset.y,repeat.x,repeat.y);}uniforms.envMap.value=material.envMap;// don't flip CubeTexture envMaps, flip everything else:
	//  WebGLRenderTargetCube will be flipped for backwards compatibility
	//  WebGLRenderTargetCube.texture will be flipped because it's a Texture and NOT a CubeTexture
	// this check must be handled differently, or removed entirely, if WebGLRenderTargetCube uses a CubeTexture in the future
	uniforms.flipEnvMap.value=!(material.envMap&&material.envMap.isCubeTexture)?1:-1;uniforms.reflectivity.value=material.reflectivity;uniforms.refractionRatio.value=material.refractionRatio;}function refreshUniformsLine(uniforms,material){uniforms.diffuse.value=material.color;uniforms.opacity.value=material.opacity;}function refreshUniformsDash(uniforms,material){uniforms.dashSize.value=material.dashSize;uniforms.totalSize.value=material.dashSize+material.gapSize;uniforms.scale.value=material.scale;}function refreshUniformsPoints(uniforms,material){uniforms.diffuse.value=material.color;uniforms.opacity.value=material.opacity;uniforms.size.value=material.size*_pixelRatio;uniforms.scale.value=_height*0.5;uniforms.map.value=material.map;if(material.map!==null){var offset=material.map.offset;var repeat=material.map.repeat;uniforms.offsetRepeat.value.set(offset.x,offset.y,repeat.x,repeat.y);}}function refreshUniformsFog(uniforms,fog){uniforms.fogColor.value=fog.color;if(fog.isFog){uniforms.fogNear.value=fog.near;uniforms.fogFar.value=fog.far;}else if(fog.isFogExp2){uniforms.fogDensity.value=fog.density;}}function refreshUniformsLambert(uniforms,material){if(material.emissiveMap){uniforms.emissiveMap.value=material.emissiveMap;}}function refreshUniformsPhong(uniforms,material){uniforms.specular.value=material.specular;uniforms.shininess.value=Math.max(material.shininess,1e-4);// to prevent pow( 0.0, 0.0 )
	if(material.emissiveMap){uniforms.emissiveMap.value=material.emissiveMap;}if(material.bumpMap){uniforms.bumpMap.value=material.bumpMap;uniforms.bumpScale.value=material.bumpScale;}if(material.normalMap){uniforms.normalMap.value=material.normalMap;uniforms.normalScale.value.copy(material.normalScale);}if(material.displacementMap){uniforms.displacementMap.value=material.displacementMap;uniforms.displacementScale.value=material.displacementScale;uniforms.displacementBias.value=material.displacementBias;}}function refreshUniformsToon(uniforms,material){refreshUniformsPhong(uniforms,material);if(material.gradientMap){uniforms.gradientMap.value=material.gradientMap;}}function refreshUniformsStandard(uniforms,material){uniforms.roughness.value=material.roughness;uniforms.metalness.value=material.metalness;if(material.roughnessMap){uniforms.roughnessMap.value=material.roughnessMap;}if(material.metalnessMap){uniforms.metalnessMap.value=material.metalnessMap;}if(material.emissiveMap){uniforms.emissiveMap.value=material.emissiveMap;}if(material.bumpMap){uniforms.bumpMap.value=material.bumpMap;uniforms.bumpScale.value=material.bumpScale;}if(material.normalMap){uniforms.normalMap.value=material.normalMap;uniforms.normalScale.value.copy(material.normalScale);}if(material.displacementMap){uniforms.displacementMap.value=material.displacementMap;uniforms.displacementScale.value=material.displacementScale;uniforms.displacementBias.value=material.displacementBias;}if(material.envMap){//uniforms.envMap.value = material.envMap; // part of uniforms common
	uniforms.envMapIntensity.value=material.envMapIntensity;}}function refreshUniformsPhysical(uniforms,material){uniforms.clearCoat.value=material.clearCoat;uniforms.clearCoatRoughness.value=material.clearCoatRoughness;refreshUniformsStandard(uniforms,material);}function refreshUniformsNormal(uniforms,material){if(material.bumpMap){uniforms.bumpMap.value=material.bumpMap;uniforms.bumpScale.value=material.bumpScale;}if(material.normalMap){uniforms.normalMap.value=material.normalMap;uniforms.normalScale.value.copy(material.normalScale);}if(material.displacementMap){uniforms.displacementMap.value=material.displacementMap;uniforms.displacementScale.value=material.displacementScale;uniforms.displacementBias.value=material.displacementBias;}}// If uniforms are marked as clean, they don't need to be loaded to the GPU.
	function markUniformsLightsNeedsUpdate(uniforms,value){uniforms.ambientLightColor.needsUpdate=value;uniforms.directionalLights.needsUpdate=value;uniforms.pointLights.needsUpdate=value;uniforms.spotLights.needsUpdate=value;uniforms.rectAreaLights.needsUpdate=value;uniforms.hemisphereLights.needsUpdate=value;}// Lighting
	function setupShadows(lights){var lightShadowsLength=0;for(var i=0,l=lights.length;i<l;i++){var light=lights[i];if(light.castShadow){_lights.shadows[lightShadowsLength]=light;lightShadowsLength++;}}_lights.shadows.length=lightShadowsLength;}function setupLights(lights,camera){var l,ll,light,shadow,r=0,g=0,b=0,color,intensity,distance,shadowMap,viewMatrix=camera.matrixWorldInverse,directionalLength=0,pointLength=0,spotLength=0,rectAreaLength=0,hemiLength=0;for(l=0,ll=lights.length;l<ll;l++){light=lights[l];color=light.color;intensity=light.intensity;distance=light.distance;shadowMap=light.shadow&&light.shadow.map?light.shadow.map.texture:null;if(light.isAmbientLight){r+=color.r*intensity;g+=color.g*intensity;b+=color.b*intensity;}else if(light.isDirectionalLight){var uniforms=lightCache.get(light);uniforms.color.copy(light.color).multiplyScalar(light.intensity);uniforms.direction.setFromMatrixPosition(light.matrixWorld);_vector3.setFromMatrixPosition(light.target.matrixWorld);uniforms.direction.sub(_vector3);uniforms.direction.transformDirection(viewMatrix);uniforms.shadow=light.castShadow;if(light.castShadow){shadow=light.shadow;uniforms.shadowBias=shadow.bias;uniforms.shadowRadius=shadow.radius;uniforms.shadowMapSize=shadow.mapSize;}_lights.directionalShadowMap[directionalLength]=shadowMap;_lights.directionalShadowMatrix[directionalLength]=light.shadow.matrix;_lights.directional[directionalLength]=uniforms;directionalLength++;}else if(light.isSpotLight){var uniforms=lightCache.get(light);uniforms.position.setFromMatrixPosition(light.matrixWorld);uniforms.position.applyMatrix4(viewMatrix);uniforms.color.copy(color).multiplyScalar(intensity);uniforms.distance=distance;uniforms.direction.setFromMatrixPosition(light.matrixWorld);_vector3.setFromMatrixPosition(light.target.matrixWorld);uniforms.direction.sub(_vector3);uniforms.direction.transformDirection(viewMatrix);uniforms.coneCos=Math.cos(light.angle);uniforms.penumbraCos=Math.cos(light.angle*(1-light.penumbra));uniforms.decay=light.distance===0?0.0:light.decay;uniforms.shadow=light.castShadow;if(light.castShadow){shadow=light.shadow;uniforms.shadowBias=shadow.bias;uniforms.shadowRadius=shadow.radius;uniforms.shadowMapSize=shadow.mapSize;}_lights.spotShadowMap[spotLength]=shadowMap;_lights.spotShadowMatrix[spotLength]=light.shadow.matrix;_lights.spot[spotLength]=uniforms;spotLength++;}else if(light.isRectAreaLight){var uniforms=lightCache.get(light);// (a) intensity controls irradiance of entire light
	uniforms.color.copy(color).multiplyScalar(intensity/(light.width*light.height));// (b) intensity controls the radiance per light area
	// uniforms.color.copy( color ).multiplyScalar( intensity );
	uniforms.position.setFromMatrixPosition(light.matrixWorld);uniforms.position.applyMatrix4(viewMatrix);// extract local rotation of light to derive width/height half vectors
	_matrix42.identity();_matrix4.copy(light.matrixWorld);_matrix4.premultiply(viewMatrix);_matrix42.extractRotation(_matrix4);uniforms.halfWidth.set(light.width*0.5,0.0,0.0);uniforms.halfHeight.set(0.0,light.height*0.5,0.0);uniforms.halfWidth.applyMatrix4(_matrix42);uniforms.halfHeight.applyMatrix4(_matrix42);// TODO (abelnation): RectAreaLight distance?
	// uniforms.distance = distance;
	_lights.rectArea[rectAreaLength]=uniforms;rectAreaLength++;}else if(light.isPointLight){var uniforms=lightCache.get(light);uniforms.position.setFromMatrixPosition(light.matrixWorld);uniforms.position.applyMatrix4(viewMatrix);uniforms.color.copy(light.color).multiplyScalar(light.intensity);uniforms.distance=light.distance;uniforms.decay=light.distance===0?0.0:light.decay;uniforms.shadow=light.castShadow;if(light.castShadow){shadow=light.shadow;uniforms.shadowBias=shadow.bias;uniforms.shadowRadius=shadow.radius;uniforms.shadowMapSize=shadow.mapSize;}_lights.pointShadowMap[pointLength]=shadowMap;if(_lights.pointShadowMatrix[pointLength]===undefined){_lights.pointShadowMatrix[pointLength]=new Matrix4();}// for point lights we set the shadow matrix to be a translation-only matrix
	// equal to inverse of the light's position
	_vector3.setFromMatrixPosition(light.matrixWorld).negate();_lights.pointShadowMatrix[pointLength].identity().setPosition(_vector3);_lights.point[pointLength]=uniforms;pointLength++;}else if(light.isHemisphereLight){var uniforms=lightCache.get(light);uniforms.direction.setFromMatrixPosition(light.matrixWorld);uniforms.direction.transformDirection(viewMatrix);uniforms.direction.normalize();uniforms.skyColor.copy(light.color).multiplyScalar(intensity);uniforms.groundColor.copy(light.groundColor).multiplyScalar(intensity);_lights.hemi[hemiLength]=uniforms;hemiLength++;}}_lights.ambient[0]=r;_lights.ambient[1]=g;_lights.ambient[2]=b;_lights.directional.length=directionalLength;_lights.spot.length=spotLength;_lights.rectArea.length=rectAreaLength;_lights.point.length=pointLength;_lights.hemi.length=hemiLength;// TODO (sam-g-steel) why aren't we using join
	_lights.hash=directionalLength+','+pointLength+','+spotLength+','+rectAreaLength+','+hemiLength+','+_lights.shadows.length;}// GL state setting
	this.setFaceCulling=function(cullFace,frontFaceDirection){state.setCullFace(cullFace);state.setFlipSided(frontFaceDirection===FrontFaceDirectionCW);};// Textures
	function allocTextureUnit(){var textureUnit=_usedTextureUnits;if(textureUnit>=capabilities.maxTextures){console.warn('WebGLRenderer: trying to use '+textureUnit+' texture units while this GPU supports only '+capabilities.maxTextures);}_usedTextureUnits+=1;return textureUnit;}this.allocTextureUnit=allocTextureUnit;// this.setTexture2D = setTexture2D;
	this.setTexture2D=function(){var warned=false;// backwards compatibility: peel texture.texture
	return function setTexture2D(texture,slot){if(texture&&texture.isWebGLRenderTarget){if(!warned){console.warn("THREE.WebGLRenderer.setTexture2D: don't use render targets as textures. Use their .texture property instead.");warned=true;}texture=texture.texture;}textures.setTexture2D(texture,slot);};}();this.setTexture=function(){var warned=false;return function setTexture(texture,slot){if(!warned){console.warn("THREE.WebGLRenderer: .setTexture is deprecated, use setTexture2D instead.");warned=true;}textures.setTexture2D(texture,slot);};}();this.setTextureCube=function(){var warned=false;return function setTextureCube(texture,slot){// backwards compatibility: peel texture.texture
	if(texture&&texture.isWebGLRenderTargetCube){if(!warned){console.warn("THREE.WebGLRenderer.setTextureCube: don't use cube render targets as textures. Use their .texture property instead.");warned=true;}texture=texture.texture;}// currently relying on the fact that WebGLRenderTargetCube.texture is a Texture and NOT a CubeTexture
	// TODO: unify these code paths
	if(texture&&texture.isCubeTexture||Array.isArray(texture.image)&&texture.image.length===6){// CompressedTexture can have Array in image :/
	// this function alone should take care of cube textures
	textures.setTextureCube(texture,slot);}else{// assumed: texture property of THREE.WebGLRenderTargetCube
	textures.setTextureCubeDynamic(texture,slot);}};}();this.getRenderTarget=function(){return _currentRenderTarget;};this.setRenderTarget=function(renderTarget){_currentRenderTarget=renderTarget;if(renderTarget&&properties.get(renderTarget).__webglFramebuffer===undefined){textures.setupRenderTarget(renderTarget);}var isCube=renderTarget&&renderTarget.isWebGLRenderTargetCube;var framebuffer;if(renderTarget){var renderTargetProperties=properties.get(renderTarget);if(isCube){framebuffer=renderTargetProperties.__webglFramebuffer[renderTarget.activeCubeFace];}else{framebuffer=renderTargetProperties.__webglFramebuffer;}_currentScissor.copy(renderTarget.scissor);_currentScissorTest=renderTarget.scissorTest;_currentViewport.copy(renderTarget.viewport);}else{framebuffer=null;_currentScissor.copy(_scissor).multiplyScalar(_pixelRatio);_currentScissorTest=_scissorTest;_currentViewport.copy(_viewport).multiplyScalar(_pixelRatio);}if(_currentFramebuffer!==framebuffer){_gl.bindFramebuffer(_gl.FRAMEBUFFER,framebuffer);_currentFramebuffer=framebuffer;}state.scissor(_currentScissor);state.setScissorTest(_currentScissorTest);state.viewport(_currentViewport);if(isCube){var textureProperties=properties.get(renderTarget.texture);_gl.framebufferTexture2D(_gl.FRAMEBUFFER,_gl.COLOR_ATTACHMENT0,_gl.TEXTURE_CUBE_MAP_POSITIVE_X+renderTarget.activeCubeFace,textureProperties.__webglTexture,renderTarget.activeMipMapLevel);}};this.readRenderTargetPixels=function(renderTarget,x,y,width,height,buffer){if((renderTarget&&renderTarget.isWebGLRenderTarget)===false){console.error('THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.');return;}var framebuffer=properties.get(renderTarget).__webglFramebuffer;if(framebuffer){var restore=false;if(framebuffer!==_currentFramebuffer){_gl.bindFramebuffer(_gl.FRAMEBUFFER,framebuffer);restore=true;}try{var texture=renderTarget.texture;var textureFormat=texture.format;var textureType=texture.type;if(textureFormat!==RGBAFormat&&paramThreeToGL(textureFormat)!==_gl.getParameter(_gl.IMPLEMENTATION_COLOR_READ_FORMAT)){console.error('THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.');return;}if(textureType!==UnsignedByteType&&paramThreeToGL(textureType)!==_gl.getParameter(_gl.IMPLEMENTATION_COLOR_READ_TYPE)&&// IE11, Edge and Chrome Mac < 52 (#9513)
	!(textureType===FloatType&&(extensions.get('OES_texture_float')||extensions.get('WEBGL_color_buffer_float')))&&// Chrome Mac >= 52 and Firefox
	!(textureType===HalfFloatType&&extensions.get('EXT_color_buffer_half_float'))){console.error('THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.');return;}if(_gl.checkFramebufferStatus(_gl.FRAMEBUFFER)===_gl.FRAMEBUFFER_COMPLETE){// the following if statement ensures valid read requests (no out-of-bounds pixels, see #8604)
	if(x>=0&&x<=renderTarget.width-width&&y>=0&&y<=renderTarget.height-height){_gl.readPixels(x,y,width,height,paramThreeToGL(textureFormat),paramThreeToGL(textureType),buffer);}}else{console.error('THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.');}}finally{if(restore){_gl.bindFramebuffer(_gl.FRAMEBUFFER,_currentFramebuffer);}}}};// Map three.js constants to WebGL constants
	function paramThreeToGL(p){var extension;if(p===RepeatWrapping)return _gl.REPEAT;if(p===ClampToEdgeWrapping)return _gl.CLAMP_TO_EDGE;if(p===MirroredRepeatWrapping)return _gl.MIRRORED_REPEAT;if(p===NearestFilter)return _gl.NEAREST;if(p===NearestMipMapNearestFilter)return _gl.NEAREST_MIPMAP_NEAREST;if(p===NearestMipMapLinearFilter)return _gl.NEAREST_MIPMAP_LINEAR;if(p===LinearFilter)return _gl.LINEAR;if(p===LinearMipMapNearestFilter)return _gl.LINEAR_MIPMAP_NEAREST;if(p===LinearMipMapLinearFilter)return _gl.LINEAR_MIPMAP_LINEAR;if(p===UnsignedByteType)return _gl.UNSIGNED_BYTE;if(p===UnsignedShort4444Type)return _gl.UNSIGNED_SHORT_4_4_4_4;if(p===UnsignedShort5551Type)return _gl.UNSIGNED_SHORT_5_5_5_1;if(p===UnsignedShort565Type)return _gl.UNSIGNED_SHORT_5_6_5;if(p===ByteType)return _gl.BYTE;if(p===ShortType)return _gl.SHORT;if(p===UnsignedShortType)return _gl.UNSIGNED_SHORT;if(p===IntType)return _gl.INT;if(p===UnsignedIntType)return _gl.UNSIGNED_INT;if(p===FloatType)return _gl.FLOAT;if(p===HalfFloatType){extension=extensions.get('OES_texture_half_float');if(extension!==null)return extension.HALF_FLOAT_OES;}if(p===AlphaFormat)return _gl.ALPHA;if(p===RGBFormat)return _gl.RGB;if(p===RGBAFormat)return _gl.RGBA;if(p===LuminanceFormat)return _gl.LUMINANCE;if(p===LuminanceAlphaFormat)return _gl.LUMINANCE_ALPHA;if(p===DepthFormat)return _gl.DEPTH_COMPONENT;if(p===DepthStencilFormat)return _gl.DEPTH_STENCIL;if(p===AddEquation)return _gl.FUNC_ADD;if(p===SubtractEquation)return _gl.FUNC_SUBTRACT;if(p===ReverseSubtractEquation)return _gl.FUNC_REVERSE_SUBTRACT;if(p===ZeroFactor)return _gl.ZERO;if(p===OneFactor)return _gl.ONE;if(p===SrcColorFactor)return _gl.SRC_COLOR;if(p===OneMinusSrcColorFactor)return _gl.ONE_MINUS_SRC_COLOR;if(p===SrcAlphaFactor)return _gl.SRC_ALPHA;if(p===OneMinusSrcAlphaFactor)return _gl.ONE_MINUS_SRC_ALPHA;if(p===DstAlphaFactor)return _gl.DST_ALPHA;if(p===OneMinusDstAlphaFactor)return _gl.ONE_MINUS_DST_ALPHA;if(p===DstColorFactor)return _gl.DST_COLOR;if(p===OneMinusDstColorFactor)return _gl.ONE_MINUS_DST_COLOR;if(p===SrcAlphaSaturateFactor)return _gl.SRC_ALPHA_SATURATE;if(p===RGB_S3TC_DXT1_Format||p===RGBA_S3TC_DXT1_Format||p===RGBA_S3TC_DXT3_Format||p===RGBA_S3TC_DXT5_Format){extension=extensions.get('WEBGL_compressed_texture_s3tc');if(extension!==null){if(p===RGB_S3TC_DXT1_Format)return extension.COMPRESSED_RGB_S3TC_DXT1_EXT;if(p===RGBA_S3TC_DXT1_Format)return extension.COMPRESSED_RGBA_S3TC_DXT1_EXT;if(p===RGBA_S3TC_DXT3_Format)return extension.COMPRESSED_RGBA_S3TC_DXT3_EXT;if(p===RGBA_S3TC_DXT5_Format)return extension.COMPRESSED_RGBA_S3TC_DXT5_EXT;}}if(p===RGB_PVRTC_4BPPV1_Format||p===RGB_PVRTC_2BPPV1_Format||p===RGBA_PVRTC_4BPPV1_Format||p===RGBA_PVRTC_2BPPV1_Format){extension=extensions.get('WEBGL_compressed_texture_pvrtc');if(extension!==null){if(p===RGB_PVRTC_4BPPV1_Format)return extension.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;if(p===RGB_PVRTC_2BPPV1_Format)return extension.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;if(p===RGBA_PVRTC_4BPPV1_Format)return extension.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;if(p===RGBA_PVRTC_2BPPV1_Format)return extension.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;}}if(p===RGB_ETC1_Format){extension=extensions.get('WEBGL_compressed_texture_etc1');if(extension!==null)return extension.COMPRESSED_RGB_ETC1_WEBGL;}if(p===MinEquation||p===MaxEquation){extension=extensions.get('EXT_blend_minmax');if(extension!==null){if(p===MinEquation)return extension.MIN_EXT;if(p===MaxEquation)return extension.MAX_EXT;}}if(p===UnsignedInt248Type){extension=extensions.get('WEBGL_depth_texture');if(extension!==null)return extension.UNSIGNED_INT_24_8_WEBGL;}return 0;}}/**
		 * @author mrdoob / http://mrdoob.com/
		 */function Scene(){Object3D.call(this);this.type='Scene';this.background=null;this.fog=null;this.overrideMaterial=null;this.autoUpdate=true;// checked by the renderer
	}Scene.prototype=_assign(Object.create(Object3D.prototype),{constructor:Scene,copy:function copy(source,recursive){Object3D.prototype.copy.call(this,source,recursive);if(source.background!==null)this.background=source.background.clone();if(source.fog!==null)this.fog=source.fog.clone();if(source.overrideMaterial!==null)this.overrideMaterial=source.overrideMaterial.clone();this.autoUpdate=source.autoUpdate;this.matrixAutoUpdate=source.matrixAutoUpdate;return this;},toJSON:function toJSON(meta){var data=Object3D.prototype.toJSON.call(this,meta);if(this.background!==null)data.object.background=this.background.toJSON(meta);if(this.fog!==null)data.object.fog=this.fog.toJSON();return data;}});/**
		 * @author alteredq / http://alteredqualia.com/
		 *
		 * parameters = {
		 *  color: <hex>,
		 *  opacity: <float>,
		 *  map: new THREE.Texture( <Image> ),
		 *
		 *	uvOffset: new THREE.Vector2(),
		 *	uvScale: new THREE.Vector2()
		 * }
		 */function SpriteMaterial(parameters){Material.call(this);this.type='SpriteMaterial';this.color=new Color(0xffffff);this.map=null;this.rotation=0;this.fog=false;this.lights=false;this.setValues(parameters);}SpriteMaterial.prototype=Object.create(Material.prototype);SpriteMaterial.prototype.constructor=SpriteMaterial;SpriteMaterial.prototype.isSpriteMaterial=true;SpriteMaterial.prototype.copy=function(source){Material.prototype.copy.call(this,source);this.color.copy(source.color);this.map=source.map;this.rotation=source.rotation;return this;};/**
		 * @author mikael emtinger / http://gomo.se/
		 * @author alteredq / http://alteredqualia.com/
		 */function Sprite(material){Object3D.call(this);this.type='Sprite';this.material=material!==undefined?material:new SpriteMaterial();}Sprite.prototype=_assign(Object.create(Object3D.prototype),{constructor:Sprite,isSprite:true,raycast:function(){var intersectPoint=new Vector3();var worldPosition=new Vector3();var worldScale=new Vector3();return function raycast(raycaster,intersects){worldPosition.setFromMatrixPosition(this.matrixWorld);raycaster.ray.closestPointToPoint(worldPosition,intersectPoint);worldScale.setFromMatrixScale(this.matrixWorld);var guessSizeSq=worldScale.x*worldScale.y/4;if(worldPosition.distanceToSquared(intersectPoint)>guessSizeSq)return;var distance=raycaster.ray.origin.distanceTo(intersectPoint);if(distance<raycaster.near||distance>raycaster.far)return;intersects.push({distance:distance,point:intersectPoint.clone(),face:null,object:this});};}(),clone:function clone(){return new this.constructor(this.material).copy(this);}});/**
		 * @author mrdoob / http://mrdoob.com/
		 * @author alteredq / http://alteredqualia.com/
		 *
		 * parameters = {
		 *  color: <hex>,
		 *  opacity: <float>,
		 *
		 *  linewidth: <float>,
		 *  linecap: "round",
		 *  linejoin: "round"
		 * }
		 */function LineBasicMaterial(parameters){Material.call(this);this.type='LineBasicMaterial';this.color=new Color(0xffffff);this.linewidth=1;this.linecap='round';this.linejoin='round';this.lights=false;this.setValues(parameters);}LineBasicMaterial.prototype=Object.create(Material.prototype);LineBasicMaterial.prototype.constructor=LineBasicMaterial;LineBasicMaterial.prototype.isLineBasicMaterial=true;LineBasicMaterial.prototype.copy=function(source){Material.prototype.copy.call(this,source);this.color.copy(source.color);this.linewidth=source.linewidth;this.linecap=source.linecap;this.linejoin=source.linejoin;return this;};/**
		 * @author mrdoob / http://mrdoob.com/
		 */function Line(geometry,material,mode){if(mode===1){console.warn('THREE.Line: parameter THREE.LinePieces no longer supported. Created THREE.LineSegments instead.');return new LineSegments(geometry,material);}Object3D.call(this);this.type='Line';this.geometry=geometry!==undefined?geometry:new BufferGeometry();this.material=material!==undefined?material:new LineBasicMaterial({color:Math.random()*0xffffff});}Line.prototype=_assign(Object.create(Object3D.prototype),{constructor:Line,isLine:true,raycast:function(){var inverseMatrix=new Matrix4();var ray=new Ray();var sphere=new Sphere();return function raycast(raycaster,intersects){var precision=raycaster.linePrecision;var precisionSq=precision*precision;var geometry=this.geometry;var matrixWorld=this.matrixWorld;// Checking boundingSphere distance to ray
	if(geometry.boundingSphere===null)geometry.computeBoundingSphere();sphere.copy(geometry.boundingSphere);sphere.applyMatrix4(matrixWorld);if(raycaster.ray.intersectsSphere(sphere)===false)return;//
	inverseMatrix.getInverse(matrixWorld);ray.copy(raycaster.ray).applyMatrix4(inverseMatrix);var vStart=new Vector3();var vEnd=new Vector3();var interSegment=new Vector3();var interRay=new Vector3();var step=this&&this.isLineSegments?2:1;if(geometry.isBufferGeometry){var index=geometry.index;var attributes=geometry.attributes;var positions=attributes.position.array;if(index!==null){var indices=index.array;for(var i=0,l=indices.length-1;i<l;i+=step){var a=indices[i];var b=indices[i+1];vStart.fromArray(positions,a*3);vEnd.fromArray(positions,b*3);var distSq=ray.distanceSqToSegment(vStart,vEnd,interRay,interSegment);if(distSq>precisionSq)continue;interRay.applyMatrix4(this.matrixWorld);//Move back to world space for distance calculation
	var distance=raycaster.ray.origin.distanceTo(interRay);if(distance<raycaster.near||distance>raycaster.far)continue;intersects.push({distance:distance,// What do we want? intersection point on the ray or on the segment??
	// point: raycaster.ray.at( distance ),
	point:interSegment.clone().applyMatrix4(this.matrixWorld),index:i,face:null,faceIndex:null,object:this});}}else{for(var i=0,l=positions.length/3-1;i<l;i+=step){vStart.fromArray(positions,3*i);vEnd.fromArray(positions,3*i+3);var distSq=ray.distanceSqToSegment(vStart,vEnd,interRay,interSegment);if(distSq>precisionSq)continue;interRay.applyMatrix4(this.matrixWorld);//Move back to world space for distance calculation
	var distance=raycaster.ray.origin.distanceTo(interRay);if(distance<raycaster.near||distance>raycaster.far)continue;intersects.push({distance:distance,// What do we want? intersection point on the ray or on the segment??
	// point: raycaster.ray.at( distance ),
	point:interSegment.clone().applyMatrix4(this.matrixWorld),index:i,face:null,faceIndex:null,object:this});}}}else if(geometry.isGeometry){var vertices=geometry.vertices;var nbVertices=vertices.length;for(var i=0;i<nbVertices-1;i+=step){var distSq=ray.distanceSqToSegment(vertices[i],vertices[i+1],interRay,interSegment);if(distSq>precisionSq)continue;interRay.applyMatrix4(this.matrixWorld);//Move back to world space for distance calculation
	var distance=raycaster.ray.origin.distanceTo(interRay);if(distance<raycaster.near||distance>raycaster.far)continue;intersects.push({distance:distance,// What do we want? intersection point on the ray or on the segment??
	// point: raycaster.ray.at( distance ),
	point:interSegment.clone().applyMatrix4(this.matrixWorld),index:i,face:null,faceIndex:null,object:this});}}};}(),clone:function clone(){return new this.constructor(this.geometry,this.material).copy(this);}});/**
		 * @author mrdoob / http://mrdoob.com/
		 */function LineSegments(geometry,material){Line.call(this,geometry,material);this.type='LineSegments';}LineSegments.prototype=_assign(Object.create(Line.prototype),{constructor:LineSegments,isLineSegments:true});/**
		 * @author mrdoob / http://mrdoob.com/
		 * @author alteredq / http://alteredqualia.com/
		 *
		 * parameters = {
		 *  color: <hex>,
		 *  opacity: <float>,
		 *  map: new THREE.Texture( <Image> ),
		 *
		 *  size: <float>,
		 *  sizeAttenuation: <bool>
		 * }
		 */function PointsMaterial(parameters){Material.call(this);this.type='PointsMaterial';this.color=new Color(0xffffff);this.map=null;this.size=1;this.sizeAttenuation=true;this.lights=false;this.setValues(parameters);}PointsMaterial.prototype=Object.create(Material.prototype);PointsMaterial.prototype.constructor=PointsMaterial;PointsMaterial.prototype.isPointsMaterial=true;PointsMaterial.prototype.copy=function(source){Material.prototype.copy.call(this,source);this.color.copy(source.color);this.map=source.map;this.size=source.size;this.sizeAttenuation=source.sizeAttenuation;return this;};/**
		 * @author alteredq / http://alteredqualia.com/
		 */function Points(geometry,material){Object3D.call(this);this.type='Points';this.geometry=geometry!==undefined?geometry:new BufferGeometry();this.material=material!==undefined?material:new PointsMaterial({color:Math.random()*0xffffff});}Points.prototype=_assign(Object.create(Object3D.prototype),{constructor:Points,isPoints:true,raycast:function(){var inverseMatrix=new Matrix4();var ray=new Ray();var sphere=new Sphere();return function raycast(raycaster,intersects){var object=this;var geometry=this.geometry;var matrixWorld=this.matrixWorld;var threshold=raycaster.params.Points.threshold;// Checking boundingSphere distance to ray
	if(geometry.boundingSphere===null)geometry.computeBoundingSphere();sphere.copy(geometry.boundingSphere);sphere.applyMatrix4(matrixWorld);sphere.radius+=threshold;if(raycaster.ray.intersectsSphere(sphere)===false)return;//
	inverseMatrix.getInverse(matrixWorld);ray.copy(raycaster.ray).applyMatrix4(inverseMatrix);var localThreshold=threshold/((this.scale.x+this.scale.y+this.scale.z)/3);var localThresholdSq=localThreshold*localThreshold;var position=new Vector3();function testPoint(point,index){var rayPointDistanceSq=ray.distanceSqToPoint(point);if(rayPointDistanceSq<localThresholdSq){var intersectPoint=ray.closestPointToPoint(point);intersectPoint.applyMatrix4(matrixWorld);var distance=raycaster.ray.origin.distanceTo(intersectPoint);if(distance<raycaster.near||distance>raycaster.far)return;intersects.push({distance:distance,distanceToRay:Math.sqrt(rayPointDistanceSq),point:intersectPoint.clone(),index:index,face:null,object:object});}}if(geometry.isBufferGeometry){var index=geometry.index;var attributes=geometry.attributes;var positions=attributes.position.array;if(index!==null){var indices=index.array;for(var i=0,il=indices.length;i<il;i++){var a=indices[i];position.fromArray(positions,a*3);testPoint(position,a);}}else{for(var i=0,l=positions.length/3;i<l;i++){position.fromArray(positions,i*3);testPoint(position,i);}}}else{var vertices=geometry.vertices;for(var i=0,l=vertices.length;i<l;i++){testPoint(vertices[i],i);}}};}(),clone:function clone(){return new this.constructor(this.geometry,this.material).copy(this);}});/**
		 * @author mrdoob / http://mrdoob.com/
		 */function Group(){Object3D.call(this);this.type='Group';}Group.prototype=_assign(Object.create(Object3D.prototype),{constructor:Group});/**
		 * @author oosmoxiecode / https://github.com/oosmoxiecode
		 * @author WestLangley / https://github.com/WestLangley
		 * @author zz85 / https://github.com/zz85
		 * @author miningold / https://github.com/miningold
		 * @author jonobr1 / https://github.com/jonobr1
		 * @author Mugen87 / https://github.com/Mugen87
		 *
		 */// TubeGeometry
	function TubeGeometry(path,tubularSegments,radius,radialSegments,closed,taper){Geometry.call(this);this.type='TubeGeometry';this.parameters={path:path,tubularSegments:tubularSegments,radius:radius,radialSegments:radialSegments,closed:closed};if(taper!==undefined)console.warn('THREE.TubeGeometry: taper has been removed.');var bufferGeometry=new TubeBufferGeometry(path,tubularSegments,radius,radialSegments,closed);// expose internals
	this.tangents=bufferGeometry.tangents;this.normals=bufferGeometry.normals;this.binormals=bufferGeometry.binormals;// create geometry
	this.fromBufferGeometry(bufferGeometry);this.mergeVertices();}TubeGeometry.prototype=Object.create(Geometry.prototype);TubeGeometry.prototype.constructor=TubeGeometry;// TubeBufferGeometry
	function TubeBufferGeometry(path,tubularSegments,radius,radialSegments,closed){BufferGeometry.call(this);this.type='TubeBufferGeometry';this.parameters={path:path,tubularSegments:tubularSegments,radius:radius,radialSegments:radialSegments,closed:closed};tubularSegments=tubularSegments||64;radius=radius||1;radialSegments=radialSegments||8;closed=closed||false;var frames=path.computeFrenetFrames(tubularSegments,closed);// expose internals
	this.tangents=frames.tangents;this.normals=frames.normals;this.binormals=frames.binormals;// helper variables
	var vertex=new Vector3();var normal=new Vector3();var uv=new Vector2();var i,j;// buffer
	var vertices=[];var normals=[];var uvs=[];var indices=[];// create buffer data
	generateBufferData();// build geometry
	this.setIndex(indices);this.addAttribute('position',new Float32BufferAttribute(vertices,3));this.addAttribute('normal',new Float32BufferAttribute(normals,3));this.addAttribute('uv',new Float32BufferAttribute(uvs,2));// functions
	function generateBufferData(){for(i=0;i<tubularSegments;i++){generateSegment(i);}// if the geometry is not closed, generate the last row of vertices and normals
	// at the regular position on the given path
	//
	// if the geometry is closed, duplicate the first row of vertices and normals (uvs will differ)
	generateSegment(closed===false?tubularSegments:0);// uvs are generated in a separate function.
	// this makes it easy compute correct values for closed geometries
	generateUVs();// finally create faces
	generateIndices();}function generateSegment(i){// we use getPointAt to sample evenly distributed points from the given path
	var P=path.getPointAt(i/tubularSegments);// retrieve corresponding normal and binormal
	var N=frames.normals[i];var B=frames.binormals[i];// generate normals and vertices for the current segment
	for(j=0;j<=radialSegments;j++){var v=j/radialSegments*Math.PI*2;var sin=Math.sin(v);var cos=-Math.cos(v);// normal
	normal.x=cos*N.x+sin*B.x;normal.y=cos*N.y+sin*B.y;normal.z=cos*N.z+sin*B.z;normal.normalize();normals.push(normal.x,normal.y,normal.z);// vertex
	vertex.x=P.x+radius*normal.x;vertex.y=P.y+radius*normal.y;vertex.z=P.z+radius*normal.z;vertices.push(vertex.x,vertex.y,vertex.z);}}function generateIndices(){for(j=1;j<=tubularSegments;j++){for(i=1;i<=radialSegments;i++){var a=(radialSegments+1)*(j-1)+(i-1);var b=(radialSegments+1)*j+(i-1);var c=(radialSegments+1)*j+i;var d=(radialSegments+1)*(j-1)+i;// faces
	indices.push(a,b,d);indices.push(b,c,d);}}}function generateUVs(){for(i=0;i<=tubularSegments;i++){for(j=0;j<=radialSegments;j++){uv.x=i/tubularSegments;uv.y=j/radialSegments;uvs.push(uv.x,uv.y);}}}}TubeBufferGeometry.prototype=Object.create(BufferGeometry.prototype);TubeBufferGeometry.prototype.constructor=TubeBufferGeometry;/**
		 * @author mrdoob / http://mrdoob.com/
		 * @author benaadams / https://twitter.com/ben_a_adams
		 * @author Mugen87 / https://github.com/Mugen87
		 */// SphereGeometry
	function SphereGeometry(radius,widthSegments,heightSegments,phiStart,phiLength,thetaStart,thetaLength){Geometry.call(this);this.type='SphereGeometry';this.parameters={radius:radius,widthSegments:widthSegments,heightSegments:heightSegments,phiStart:phiStart,phiLength:phiLength,thetaStart:thetaStart,thetaLength:thetaLength};this.fromBufferGeometry(new SphereBufferGeometry(radius,widthSegments,heightSegments,phiStart,phiLength,thetaStart,thetaLength));this.mergeVertices();}SphereGeometry.prototype=Object.create(Geometry.prototype);SphereGeometry.prototype.constructor=SphereGeometry;// SphereBufferGeometry
	function SphereBufferGeometry(radius,widthSegments,heightSegments,phiStart,phiLength,thetaStart,thetaLength){BufferGeometry.call(this);this.type='SphereBufferGeometry';this.parameters={radius:radius,widthSegments:widthSegments,heightSegments:heightSegments,phiStart:phiStart,phiLength:phiLength,thetaStart:thetaStart,thetaLength:thetaLength};radius=radius||50;widthSegments=Math.max(3,Math.floor(widthSegments)||8);heightSegments=Math.max(2,Math.floor(heightSegments)||6);phiStart=phiStart!==undefined?phiStart:0;phiLength=phiLength!==undefined?phiLength:Math.PI*2;thetaStart=thetaStart!==undefined?thetaStart:0;thetaLength=thetaLength!==undefined?thetaLength:Math.PI;var thetaEnd=thetaStart+thetaLength;var ix,iy;var index=0;var grid=[];var vertex=new Vector3();var normal=new Vector3();// buffers
	var indices=[];var vertices=[];var normals=[];var uvs=[];// generate vertices, normals and uvs
	for(iy=0;iy<=heightSegments;iy++){var verticesRow=[];var v=iy/heightSegments;for(ix=0;ix<=widthSegments;ix++){var u=ix/widthSegments;// vertex
	vertex.x=-radius*Math.cos(phiStart+u*phiLength)*Math.sin(thetaStart+v*thetaLength);vertex.y=radius*Math.cos(thetaStart+v*thetaLength);vertex.z=radius*Math.sin(phiStart+u*phiLength)*Math.sin(thetaStart+v*thetaLength);vertices.push(vertex.x,vertex.y,vertex.z);// normal
	normal.set(vertex.x,vertex.y,vertex.z).normalize();normals.push(normal.x,normal.y,normal.z);// uv
	uvs.push(u,1-v);verticesRow.push(index++);}grid.push(verticesRow);}// indices
	for(iy=0;iy<heightSegments;iy++){for(ix=0;ix<widthSegments;ix++){var a=grid[iy][ix+1];var b=grid[iy][ix];var c=grid[iy+1][ix];var d=grid[iy+1][ix+1];if(iy!==0||thetaStart>0)indices.push(a,b,d);if(iy!==heightSegments-1||thetaEnd<Math.PI)indices.push(b,c,d);}}// build geometry
	this.setIndex(indices);this.addAttribute('position',new Float32BufferAttribute(vertices,3));this.addAttribute('normal',new Float32BufferAttribute(normals,3));this.addAttribute('uv',new Float32BufferAttribute(uvs,2));}SphereBufferGeometry.prototype=Object.create(BufferGeometry.prototype);SphereBufferGeometry.prototype.constructor=SphereBufferGeometry;/**
		 * @author zz85 / http://www.lab4games.net/zz85/blog
		 */var ShapeUtils={// calculate area of the contour polygon
	area:function area(contour){var n=contour.length;var a=0.0;for(var p=n-1,q=0;q<n;p=q++){a+=contour[p].x*contour[q].y-contour[q].x*contour[p].y;}return a*0.5;},triangulate:function(){/**
				 * This code is a quick port of code written in C++ which was submitted to
				 * flipcode.com by John W. Ratcliff  // July 22, 2000
				 * See original code and more information here:
				 * http://www.flipcode.com/archives/Efficient_Polygon_Triangulation.shtml
				 *
				 * ported to actionscript by Zevan Rosser
				 * www.actionsnippet.com
				 *
				 * ported to javascript by Joshua Koo
				 * http://www.lab4games.net/zz85/blog
				 *
				 */function snip(contour,u,v,w,n,verts){var p;var ax,ay,bx,by;var cx,cy,px,py;ax=contour[verts[u]].x;ay=contour[verts[u]].y;bx=contour[verts[v]].x;by=contour[verts[v]].y;cx=contour[verts[w]].x;cy=contour[verts[w]].y;if((bx-ax)*(cy-ay)-(by-ay)*(cx-ax)<=0)return false;var aX,aY,bX,bY,cX,cY;var apx,apy,bpx,bpy,cpx,cpy;var cCROSSap,bCROSScp,aCROSSbp;aX=cx-bx;aY=cy-by;bX=ax-cx;bY=ay-cy;cX=bx-ax;cY=by-ay;for(p=0;p<n;p++){px=contour[verts[p]].x;py=contour[verts[p]].y;if(px===ax&&py===ay||px===bx&&py===by||px===cx&&py===cy)continue;apx=px-ax;apy=py-ay;bpx=px-bx;bpy=py-by;cpx=px-cx;cpy=py-cy;// see if p is inside triangle abc
	aCROSSbp=aX*bpy-aY*bpx;cCROSSap=cX*apy-cY*apx;bCROSScp=bX*cpy-bY*cpx;if(aCROSSbp>=-Number.EPSILON&&bCROSScp>=-Number.EPSILON&&cCROSSap>=-Number.EPSILON)return false;}return true;}// takes in an contour array and returns
	return function triangulate(contour,indices){var n=contour.length;if(n<3)return null;var result=[],verts=[],vertIndices=[];/* we want a counter-clockwise polygon in verts */var u,v,w;if(ShapeUtils.area(contour)>0.0){for(v=0;v<n;v++){verts[v]=v;}}else{for(v=0;v<n;v++){verts[v]=n-1-v;}}var nv=n;/*  remove nv - 2 vertices, creating 1 triangle every time */var count=2*nv;/* error detection */for(v=nv-1;nv>2;){/* if we loop, it is probably a non-simple polygon */if(count--<=0){//** Triangulate: ERROR - probable bad polygon!
	//throw ( "Warning, unable to triangulate polygon!" );
	//return null;
	// Sometimes warning is fine, especially polygons are triangulated in reverse.
	console.warn('THREE.ShapeUtils: Unable to triangulate polygon! in triangulate()');if(indices)return vertIndices;return result;}/* three consecutive vertices in current polygon, <u,v,w> */u=v;if(nv<=u)u=0;/* previous */v=u+1;if(nv<=v)v=0;/* new v    */w=v+1;if(nv<=w)w=0;/* next     */if(snip(contour,u,v,w,nv,verts)){var a,b,c,s,t;/* true names of the vertices */a=verts[u];b=verts[v];c=verts[w];/* output Triangle */result.push([contour[a],contour[b],contour[c]]);vertIndices.push([verts[u],verts[v],verts[w]]);/* remove v from the remaining polygon */for(s=v,t=v+1;t<nv;s++,t++){verts[s]=verts[t];}nv--;/* reset error detection counter */count=2*nv;}}if(indices)return vertIndices;return result;};}(),triangulateShape:function triangulateShape(contour,holes){function removeDupEndPts(points){var l=points.length;if(l>2&&points[l-1].equals(points[0])){points.pop();}}removeDupEndPts(contour);holes.forEach(removeDupEndPts);function point_in_segment_2D_colin(inSegPt1,inSegPt2,inOtherPt){// inOtherPt needs to be collinear to the inSegment
	if(inSegPt1.x!==inSegPt2.x){if(inSegPt1.x<inSegPt2.x){return inSegPt1.x<=inOtherPt.x&&inOtherPt.x<=inSegPt2.x;}else{return inSegPt2.x<=inOtherPt.x&&inOtherPt.x<=inSegPt1.x;}}else{if(inSegPt1.y<inSegPt2.y){return inSegPt1.y<=inOtherPt.y&&inOtherPt.y<=inSegPt2.y;}else{return inSegPt2.y<=inOtherPt.y&&inOtherPt.y<=inSegPt1.y;}}}function intersect_segments_2D(inSeg1Pt1,inSeg1Pt2,inSeg2Pt1,inSeg2Pt2,inExcludeAdjacentSegs){var seg1dx=inSeg1Pt2.x-inSeg1Pt1.x,seg1dy=inSeg1Pt2.y-inSeg1Pt1.y;var seg2dx=inSeg2Pt2.x-inSeg2Pt1.x,seg2dy=inSeg2Pt2.y-inSeg2Pt1.y;var seg1seg2dx=inSeg1Pt1.x-inSeg2Pt1.x;var seg1seg2dy=inSeg1Pt1.y-inSeg2Pt1.y;var limit=seg1dy*seg2dx-seg1dx*seg2dy;var perpSeg1=seg1dy*seg1seg2dx-seg1dx*seg1seg2dy;if(Math.abs(limit)>Number.EPSILON){// not parallel
	var perpSeg2;if(limit>0){if(perpSeg1<0||perpSeg1>limit)return[];perpSeg2=seg2dy*seg1seg2dx-seg2dx*seg1seg2dy;if(perpSeg2<0||perpSeg2>limit)return[];}else{if(perpSeg1>0||perpSeg1<limit)return[];perpSeg2=seg2dy*seg1seg2dx-seg2dx*seg1seg2dy;if(perpSeg2>0||perpSeg2<limit)return[];}// i.e. to reduce rounding errors
	// intersection at endpoint of segment#1?
	if(perpSeg2===0){if(inExcludeAdjacentSegs&&(perpSeg1===0||perpSeg1===limit))return[];return[inSeg1Pt1];}if(perpSeg2===limit){if(inExcludeAdjacentSegs&&(perpSeg1===0||perpSeg1===limit))return[];return[inSeg1Pt2];}// intersection at endpoint of segment#2?
	if(perpSeg1===0)return[inSeg2Pt1];if(perpSeg1===limit)return[inSeg2Pt2];// return real intersection point
	var factorSeg1=perpSeg2/limit;return[{x:inSeg1Pt1.x+factorSeg1*seg1dx,y:inSeg1Pt1.y+factorSeg1*seg1dy}];}else{// parallel or collinear
	if(perpSeg1!==0||seg2dy*seg1seg2dx!==seg2dx*seg1seg2dy)return[];// they are collinear or degenerate
	var seg1Pt=seg1dx===0&&seg1dy===0;// segment1 is just a point?
	var seg2Pt=seg2dx===0&&seg2dy===0;// segment2 is just a point?
	// both segments are points
	if(seg1Pt&&seg2Pt){if(inSeg1Pt1.x!==inSeg2Pt1.x||inSeg1Pt1.y!==inSeg2Pt1.y)return[];// they are distinct  points
	return[inSeg1Pt1];// they are the same point
	}// segment#1  is a single point
	if(seg1Pt){if(!point_in_segment_2D_colin(inSeg2Pt1,inSeg2Pt2,inSeg1Pt1))return[];// but not in segment#2
	return[inSeg1Pt1];}// segment#2  is a single point
	if(seg2Pt){if(!point_in_segment_2D_colin(inSeg1Pt1,inSeg1Pt2,inSeg2Pt1))return[];// but not in segment#1
	return[inSeg2Pt1];}// they are collinear segments, which might overlap
	var seg1min,seg1max,seg1minVal,seg1maxVal;var seg2min,seg2max,seg2minVal,seg2maxVal;if(seg1dx!==0){// the segments are NOT on a vertical line
	if(inSeg1Pt1.x<inSeg1Pt2.x){seg1min=inSeg1Pt1;seg1minVal=inSeg1Pt1.x;seg1max=inSeg1Pt2;seg1maxVal=inSeg1Pt2.x;}else{seg1min=inSeg1Pt2;seg1minVal=inSeg1Pt2.x;seg1max=inSeg1Pt1;seg1maxVal=inSeg1Pt1.x;}if(inSeg2Pt1.x<inSeg2Pt2.x){seg2min=inSeg2Pt1;seg2minVal=inSeg2Pt1.x;seg2max=inSeg2Pt2;seg2maxVal=inSeg2Pt2.x;}else{seg2min=inSeg2Pt2;seg2minVal=inSeg2Pt2.x;seg2max=inSeg2Pt1;seg2maxVal=inSeg2Pt1.x;}}else{// the segments are on a vertical line
	if(inSeg1Pt1.y<inSeg1Pt2.y){seg1min=inSeg1Pt1;seg1minVal=inSeg1Pt1.y;seg1max=inSeg1Pt2;seg1maxVal=inSeg1Pt2.y;}else{seg1min=inSeg1Pt2;seg1minVal=inSeg1Pt2.y;seg1max=inSeg1Pt1;seg1maxVal=inSeg1Pt1.y;}if(inSeg2Pt1.y<inSeg2Pt2.y){seg2min=inSeg2Pt1;seg2minVal=inSeg2Pt1.y;seg2max=inSeg2Pt2;seg2maxVal=inSeg2Pt2.y;}else{seg2min=inSeg2Pt2;seg2minVal=inSeg2Pt2.y;seg2max=inSeg2Pt1;seg2maxVal=inSeg2Pt1.y;}}if(seg1minVal<=seg2minVal){if(seg1maxVal<seg2minVal)return[];if(seg1maxVal===seg2minVal){if(inExcludeAdjacentSegs)return[];return[seg2min];}if(seg1maxVal<=seg2maxVal)return[seg2min,seg1max];return[seg2min,seg2max];}else{if(seg1minVal>seg2maxVal)return[];if(seg1minVal===seg2maxVal){if(inExcludeAdjacentSegs)return[];return[seg1min];}if(seg1maxVal<=seg2maxVal)return[seg1min,seg1max];return[seg1min,seg2max];}}}function isPointInsideAngle(inVertex,inLegFromPt,inLegToPt,inOtherPt){// The order of legs is important
	// translation of all points, so that Vertex is at (0,0)
	var legFromPtX=inLegFromPt.x-inVertex.x,legFromPtY=inLegFromPt.y-inVertex.y;var legToPtX=inLegToPt.x-inVertex.x,legToPtY=inLegToPt.y-inVertex.y;var otherPtX=inOtherPt.x-inVertex.x,otherPtY=inOtherPt.y-inVertex.y;// main angle >0: < 180 deg.; 0: 180 deg.; <0: > 180 deg.
	var from2toAngle=legFromPtX*legToPtY-legFromPtY*legToPtX;var from2otherAngle=legFromPtX*otherPtY-legFromPtY*otherPtX;if(Math.abs(from2toAngle)>Number.EPSILON){// angle != 180 deg.
	var other2toAngle=otherPtX*legToPtY-otherPtY*legToPtX;// console.log( "from2to: " + from2toAngle + ", from2other: " + from2otherAngle + ", other2to: " + other2toAngle );
	if(from2toAngle>0){// main angle < 180 deg.
	return from2otherAngle>=0&&other2toAngle>=0;}else{// main angle > 180 deg.
	return from2otherAngle>=0||other2toAngle>=0;}}else{// angle == 180 deg.
	// console.log( "from2to: 180 deg., from2other: " + from2otherAngle  );
	return from2otherAngle>0;}}function removeHoles(contour,holes){var shape=contour.concat();// work on this shape
	var hole;function isCutLineInsideAngles(inShapeIdx,inHoleIdx){// Check if hole point lies within angle around shape point
	var lastShapeIdx=shape.length-1;var prevShapeIdx=inShapeIdx-1;if(prevShapeIdx<0)prevShapeIdx=lastShapeIdx;var nextShapeIdx=inShapeIdx+1;if(nextShapeIdx>lastShapeIdx)nextShapeIdx=0;var insideAngle=isPointInsideAngle(shape[inShapeIdx],shape[prevShapeIdx],shape[nextShapeIdx],hole[inHoleIdx]);if(!insideAngle){// console.log( "Vertex (Shape): " + inShapeIdx + ", Point: " + hole[inHoleIdx].x + "/" + hole[inHoleIdx].y );
	return false;}// Check if shape point lies within angle around hole point
	var lastHoleIdx=hole.length-1;var prevHoleIdx=inHoleIdx-1;if(prevHoleIdx<0)prevHoleIdx=lastHoleIdx;var nextHoleIdx=inHoleIdx+1;if(nextHoleIdx>lastHoleIdx)nextHoleIdx=0;insideAngle=isPointInsideAngle(hole[inHoleIdx],hole[prevHoleIdx],hole[nextHoleIdx],shape[inShapeIdx]);if(!insideAngle){// console.log( "Vertex (Hole): " + inHoleIdx + ", Point: " + shape[inShapeIdx].x + "/" + shape[inShapeIdx].y );
	return false;}return true;}function intersectsShapeEdge(inShapePt,inHolePt){// checks for intersections with shape edges
	var sIdx,nextIdx,intersection;for(sIdx=0;sIdx<shape.length;sIdx++){nextIdx=sIdx+1;nextIdx%=shape.length;intersection=intersect_segments_2D(inShapePt,inHolePt,shape[sIdx],shape[nextIdx],true);if(intersection.length>0)return true;}return false;}var indepHoles=[];function intersectsHoleEdge(inShapePt,inHolePt){// checks for intersections with hole edges
	var ihIdx,chkHole,hIdx,nextIdx,intersection;for(ihIdx=0;ihIdx<indepHoles.length;ihIdx++){chkHole=holes[indepHoles[ihIdx]];for(hIdx=0;hIdx<chkHole.length;hIdx++){nextIdx=hIdx+1;nextIdx%=chkHole.length;intersection=intersect_segments_2D(inShapePt,inHolePt,chkHole[hIdx],chkHole[nextIdx],true);if(intersection.length>0)return true;}}return false;}var holeIndex,shapeIndex,shapePt,holePt,holeIdx,cutKey,failedCuts=[],tmpShape1,tmpShape2,tmpHole1,tmpHole2;for(var h=0,hl=holes.length;h<hl;h++){indepHoles.push(h);}var minShapeIndex=0;var counter=indepHoles.length*2;while(indepHoles.length>0){counter--;if(counter<0){console.log("Infinite Loop! Holes left:"+indepHoles.length+", Probably Hole outside Shape!");break;}// search for shape-vertex and hole-vertex,
	// which can be connected without intersections
	for(shapeIndex=minShapeIndex;shapeIndex<shape.length;shapeIndex++){shapePt=shape[shapeIndex];holeIndex=-1;// search for hole which can be reached without intersections
	for(var h=0;h<indepHoles.length;h++){holeIdx=indepHoles[h];// prevent multiple checks
	cutKey=shapePt.x+":"+shapePt.y+":"+holeIdx;if(failedCuts[cutKey]!==undefined)continue;hole=holes[holeIdx];for(var h2=0;h2<hole.length;h2++){holePt=hole[h2];if(!isCutLineInsideAngles(shapeIndex,h2))continue;if(intersectsShapeEdge(shapePt,holePt))continue;if(intersectsHoleEdge(shapePt,holePt))continue;holeIndex=h2;indepHoles.splice(h,1);tmpShape1=shape.slice(0,shapeIndex+1);tmpShape2=shape.slice(shapeIndex);tmpHole1=hole.slice(holeIndex);tmpHole2=hole.slice(0,holeIndex+1);shape=tmpShape1.concat(tmpHole1).concat(tmpHole2).concat(tmpShape2);minShapeIndex=shapeIndex;// Debug only, to show the selected cuts
	// glob_CutLines.push( [ shapePt, holePt ] );
	break;}if(holeIndex>=0)break;// hole-vertex found
	failedCuts[cutKey]=true;// remember failure
	}if(holeIndex>=0)break;// hole-vertex found
	}}return shape;/* shape with no holes */}var i,il,f,face,key,index,allPointsMap={};// To maintain reference to old shape, one must match coordinates, or offset the indices from original arrays. It's probably easier to do the first.
	var allpoints=contour.concat();for(var h=0,hl=holes.length;h<hl;h++){Array.prototype.push.apply(allpoints,holes[h]);}//console.log( "allpoints",allpoints, allpoints.length );
	// prepare all points map
	for(i=0,il=allpoints.length;i<il;i++){key=allpoints[i].x+":"+allpoints[i].y;if(allPointsMap[key]!==undefined){console.warn("THREE.ShapeUtils: Duplicate point",key,i);}allPointsMap[key]=i;}// remove holes by cutting paths to holes and adding them to the shape
	var shapeWithoutHoles=removeHoles(contour,holes);var triangles=ShapeUtils.triangulate(shapeWithoutHoles,false);// True returns indices for points of spooled shape
	//console.log( "triangles",triangles, triangles.length );
	// check all face vertices against all points map
	for(i=0,il=triangles.length;i<il;i++){face=triangles[i];for(f=0;f<3;f++){key=face[f].x+":"+face[f].y;index=allPointsMap[key];if(index!==undefined){face[f]=index;}}}return triangles.concat();},isClockWise:function isClockWise(pts){return ShapeUtils.area(pts)<0;}};/**
		 * @author jonobr1 / http://jonobr1.com
		 * @author Mugen87 / https://github.com/Mugen87
		 */// ShapeGeometry
	function ShapeGeometry(shapes,curveSegments){Geometry.call(this);this.type='ShapeGeometry';if((typeof curveSegments==='undefined'?'undefined':_typeof(curveSegments))==='object'){console.warn('THREE.ShapeGeometry: Options parameter has been removed.');curveSegments=curveSegments.curveSegments;}this.parameters={shapes:shapes,curveSegments:curveSegments};this.fromBufferGeometry(new ShapeBufferGeometry(shapes,curveSegments));this.mergeVertices();}ShapeGeometry.prototype=Object.create(Geometry.prototype);ShapeGeometry.prototype.constructor=ShapeGeometry;// ShapeBufferGeometry
	function ShapeBufferGeometry(shapes,curveSegments){BufferGeometry.call(this);this.type='ShapeBufferGeometry';this.parameters={shapes:shapes,curveSegments:curveSegments};curveSegments=curveSegments||12;// buffers
	var indices=[];var vertices=[];var normals=[];var uvs=[];// helper variables
	var groupStart=0;var groupCount=0;// allow single and array values for "shapes" parameter
	if(Array.isArray(shapes)===false){addShape(shapes);}else{for(var i=0;i<shapes.length;i++){addShape(shapes[i]);this.addGroup(groupStart,groupCount,i);// enables MultiMaterial support
	groupStart+=groupCount;groupCount=0;}}// build geometry
	this.setIndex(indices);this.addAttribute('position',new Float32BufferAttribute(vertices,3));this.addAttribute('normal',new Float32BufferAttribute(normals,3));this.addAttribute('uv',new Float32BufferAttribute(uvs,2));// helper functions
	function addShape(shape){var i,l,shapeHole;var indexOffset=vertices.length/3;var points=shape.extractPoints(curveSegments);var shapeVertices=points.shape;var shapeHoles=points.holes;// check direction of vertices
	if(ShapeUtils.isClockWise(shapeVertices)===false){shapeVertices=shapeVertices.reverse();// also check if holes are in the opposite direction
	for(i=0,l=shapeHoles.length;i<l;i++){shapeHole=shapeHoles[i];if(ShapeUtils.isClockWise(shapeHole)===true){shapeHoles[i]=shapeHole.reverse();}}}var faces=ShapeUtils.triangulateShape(shapeVertices,shapeHoles);// join vertices of inner and outer paths to a single array
	for(i=0,l=shapeHoles.length;i<l;i++){shapeHole=shapeHoles[i];shapeVertices=shapeVertices.concat(shapeHole);}// vertices, normals, uvs
	for(i=0,l=shapeVertices.length;i<l;i++){var vertex=shapeVertices[i];vertices.push(vertex.x,vertex.y,0);normals.push(0,0,1);uvs.push(vertex.x,vertex.y);// world uvs
	}// incides
	for(i=0,l=faces.length;i<l;i++){var face=faces[i];var a=face[0]+indexOffset;var b=face[1]+indexOffset;var c=face[2]+indexOffset;indices.push(a,b,c);groupCount+=3;}}}ShapeBufferGeometry.prototype=Object.create(BufferGeometry.prototype);ShapeBufferGeometry.prototype.constructor=ShapeBufferGeometry;/**
		 * @author zz85 / http://www.lab4games.net/zz85/blog
		 *
		 * Creates extruded geometry from a path shape.
		 *
		 * parameters = {
		 *
		 *  curveSegments: <int>, // number of points on the curves
		 *  steps: <int>, // number of points for z-side extrusions / used for subdividing segments of extrude spline too
		 *  amount: <int>, // Depth to extrude the shape
		 *
		 *  bevelEnabled: <bool>, // turn on bevel
		 *  bevelThickness: <float>, // how deep into the original shape bevel goes
		 *  bevelSize: <float>, // how far from shape outline is bevel
		 *  bevelSegments: <int>, // number of bevel layers
		 *
		 *  extrudePath: <THREE.Curve> // curve to extrude shape along
		 *  frames: <Object> // containing arrays of tangents, normals, binormals
		 *
		 *  UVGenerator: <Object> // object that provides UV generator functions
		 *
		 * }
		 */// ExtrudeGeometry
	function ExtrudeGeometry(shapes,options){Geometry.call(this);this.type='ExtrudeGeometry';this.parameters={shapes:shapes,options:options};this.fromBufferGeometry(new ExtrudeBufferGeometry(shapes,options));this.mergeVertices();}ExtrudeGeometry.prototype=Object.create(Geometry.prototype);ExtrudeGeometry.prototype.constructor=ExtrudeGeometry;// ExtrudeBufferGeometry
	function ExtrudeBufferGeometry(shapes,options){if(typeof shapes==="undefined"){shapes=[];return;}BufferGeometry.call(this);this.type='ExtrudeBufferGeometry';shapes=Array.isArray(shapes)?shapes:[shapes];this.addShapeList(shapes,options);this.computeVertexNormals();// can't really use automatic vertex normals
	// as then front and back sides get smoothed too
	// should do separate smoothing just for sides
	//this.computeVertexNormals();
	//console.log( "took", ( Date.now() - startTime ) );
	}ExtrudeBufferGeometry.prototype=Object.create(BufferGeometry.prototype);ExtrudeBufferGeometry.prototype.constructor=ExtrudeBufferGeometry;ExtrudeBufferGeometry.prototype.getArrays=function(){var positionAttribute=this.getAttribute("position");var verticesArray=positionAttribute?Array.prototype.slice.call(positionAttribute.array):[];var uvAttribute=this.getAttribute("uv");var uvArray=uvAttribute?Array.prototype.slice.call(uvAttribute.array):[];var IndexAttribute=this.index;var indicesArray=IndexAttribute?Array.prototype.slice.call(IndexAttribute.array):[];return{position:verticesArray,uv:uvArray,index:indicesArray};};ExtrudeBufferGeometry.prototype.addShapeList=function(shapes,options){var sl=shapes.length;options.arrays=this.getArrays();for(var s=0;s<sl;s++){var shape=shapes[s];this.addShape(shape,options);}this.setIndex(options.arrays.index);this.addAttribute('position',new Float32BufferAttribute(options.arrays.position,3));this.addAttribute('uv',new Float32BufferAttribute(options.arrays.uv,2));};ExtrudeBufferGeometry.prototype.addShape=function(shape,options){var arrays=options.arrays?options.arrays:this.getArrays();var verticesArray=arrays.position;var indicesArray=arrays.index;var uvArray=arrays.uv;var placeholder=[];var amount=options.amount!==undefined?options.amount:100;var bevelThickness=options.bevelThickness!==undefined?options.bevelThickness:6;// 10
	var bevelSize=options.bevelSize!==undefined?options.bevelSize:bevelThickness-2;// 8
	var bevelSegments=options.bevelSegments!==undefined?options.bevelSegments:3;var bevelEnabled=options.bevelEnabled!==undefined?options.bevelEnabled:true;// false
	var curveSegments=options.curveSegments!==undefined?options.curveSegments:12;var steps=options.steps!==undefined?options.steps:1;var extrudePath=options.extrudePath;var extrudePts,extrudeByPath=false;// Use default WorldUVGenerator if no UV generators are specified.
	var uvgen=options.UVGenerator!==undefined?options.UVGenerator:ExtrudeGeometry.WorldUVGenerator;var splineTube,binormal,normal,position2;if(extrudePath){extrudePts=extrudePath.getSpacedPoints(steps);extrudeByPath=true;bevelEnabled=false;// bevels not supported for path extrusion
	// SETUP TNB variables
	// TODO1 - have a .isClosed in spline?
	splineTube=options.frames!==undefined?options.frames:extrudePath.computeFrenetFrames(steps,false);// console.log(splineTube, 'splineTube', splineTube.normals.length, 'steps', steps, 'extrudePts', extrudePts.length);
	binormal=new Vector3();normal=new Vector3();position2=new Vector3();}// Safeguards if bevels are not enabled
	if(!bevelEnabled){bevelSegments=0;bevelThickness=0;bevelSize=0;}// Variables initialization
	var ahole,h,hl;// looping of holes
	var scope=this;var shapePoints=shape.extractPoints(curveSegments);var vertices=shapePoints.shape;var holes=shapePoints.holes;var reverse=!ShapeUtils.isClockWise(vertices);if(reverse){vertices=vertices.reverse();// Maybe we should also check if holes are in the opposite direction, just to be safe ...
	for(h=0,hl=holes.length;h<hl;h++){ahole=holes[h];if(ShapeUtils.isClockWise(ahole)){holes[h]=ahole.reverse();}}reverse=false;// If vertices are in order now, we shouldn't need to worry about them again (hopefully)!
	}var faces=ShapeUtils.triangulateShape(vertices,holes);/* Vertices */var contour=vertices;// vertices has all points but contour has only points of circumference
	for(h=0,hl=holes.length;h<hl;h++){ahole=holes[h];vertices=vertices.concat(ahole);}function scalePt2(pt,vec,size){if(!vec)console.error("THREE.ExtrudeGeometry: vec does not exist");return vec.clone().multiplyScalar(size).add(pt);}var b,bs,t,z,vert,vlen=vertices.length,face,flen=faces.length;// Find directions for point movement
	function getBevelVec(inPt,inPrev,inNext){// computes for inPt the corresponding point inPt' on a new contour
	//   shifted by 1 unit (length of normalized vector) to the left
	// if we walk along contour clockwise, this new contour is outside the old one
	//
	// inPt' is the intersection of the two lines parallel to the two
	//  adjacent edges of inPt at a distance of 1 unit on the left side.
	var v_trans_x,v_trans_y,shrink_by=1;// resulting translation vector for inPt
	// good reading for geometry algorithms (here: line-line intersection)
	// http://geomalgorithms.com/a05-_intersect-1.html
	var v_prev_x=inPt.x-inPrev.x,v_prev_y=inPt.y-inPrev.y;var v_next_x=inNext.x-inPt.x,v_next_y=inNext.y-inPt.y;var v_prev_lensq=v_prev_x*v_prev_x+v_prev_y*v_prev_y;// check for collinear edges
	var collinear0=v_prev_x*v_next_y-v_prev_y*v_next_x;if(Math.abs(collinear0)>Number.EPSILON){// not collinear
	// length of vectors for normalizing
	var v_prev_len=Math.sqrt(v_prev_lensq);var v_next_len=Math.sqrt(v_next_x*v_next_x+v_next_y*v_next_y);// shift adjacent points by unit vectors to the left
	var ptPrevShift_x=inPrev.x-v_prev_y/v_prev_len;var ptPrevShift_y=inPrev.y+v_prev_x/v_prev_len;var ptNextShift_x=inNext.x-v_next_y/v_next_len;var ptNextShift_y=inNext.y+v_next_x/v_next_len;// scaling factor for v_prev to intersection point
	var sf=((ptNextShift_x-ptPrevShift_x)*v_next_y-(ptNextShift_y-ptPrevShift_y)*v_next_x)/(v_prev_x*v_next_y-v_prev_y*v_next_x);// vector from inPt to intersection point
	v_trans_x=ptPrevShift_x+v_prev_x*sf-inPt.x;v_trans_y=ptPrevShift_y+v_prev_y*sf-inPt.y;// Don't normalize!, otherwise sharp corners become ugly
	//  but prevent crazy spikes
	var v_trans_lensq=v_trans_x*v_trans_x+v_trans_y*v_trans_y;if(v_trans_lensq<=2){return new Vector2(v_trans_x,v_trans_y);}else{shrink_by=Math.sqrt(v_trans_lensq/2);}}else{// handle special case of collinear edges
	var direction_eq=false;// assumes: opposite
	if(v_prev_x>Number.EPSILON){if(v_next_x>Number.EPSILON){direction_eq=true;}}else{if(v_prev_x<-Number.EPSILON){if(v_next_x<-Number.EPSILON){direction_eq=true;}}else{if(Math.sign(v_prev_y)===Math.sign(v_next_y)){direction_eq=true;}}}if(direction_eq){// console.log("Warning: lines are a straight sequence");
	v_trans_x=-v_prev_y;v_trans_y=v_prev_x;shrink_by=Math.sqrt(v_prev_lensq);}else{// console.log("Warning: lines are a straight spike");
	v_trans_x=v_prev_x;v_trans_y=v_prev_y;shrink_by=Math.sqrt(v_prev_lensq/2);}}return new Vector2(v_trans_x/shrink_by,v_trans_y/shrink_by);}var contourMovements=[];for(var i=0,il=contour.length,j=il-1,k=i+1;i<il;i++,j++,k++){if(j===il)j=0;if(k===il)k=0;//  (j)---(i)---(k)
	// console.log('i,j,k', i, j , k)
	contourMovements[i]=getBevelVec(contour[i],contour[j],contour[k]);}var holesMovements=[],oneHoleMovements,verticesMovements=contourMovements.concat();for(h=0,hl=holes.length;h<hl;h++){ahole=holes[h];oneHoleMovements=[];for(i=0,il=ahole.length,j=il-1,k=i+1;i<il;i++,j++,k++){if(j===il)j=0;if(k===il)k=0;//  (j)---(i)---(k)
	oneHoleMovements[i]=getBevelVec(ahole[i],ahole[j],ahole[k]);}holesMovements.push(oneHoleMovements);verticesMovements=verticesMovements.concat(oneHoleMovements);}// Loop bevelSegments, 1 for the front, 1 for the back
	for(b=0;b<bevelSegments;b++){//for ( b = bevelSegments; b > 0; b -- ) {
	t=b/bevelSegments;z=bevelThickness*Math.cos(t*Math.PI/2);bs=bevelSize*Math.sin(t*Math.PI/2);// contract shape
	for(i=0,il=contour.length;i<il;i++){vert=scalePt2(contour[i],contourMovements[i],bs);v(vert.x,vert.y,-z);}// expand holes
	for(h=0,hl=holes.length;h<hl;h++){ahole=holes[h];oneHoleMovements=holesMovements[h];for(i=0,il=ahole.length;i<il;i++){vert=scalePt2(ahole[i],oneHoleMovements[i],bs);v(vert.x,vert.y,-z);}}}bs=bevelSize;// Back facing vertices
	for(i=0;i<vlen;i++){vert=bevelEnabled?scalePt2(vertices[i],verticesMovements[i],bs):vertices[i];if(!extrudeByPath){v(vert.x,vert.y,0);}else{// v( vert.x, vert.y + extrudePts[ 0 ].y, extrudePts[ 0 ].x );
	normal.copy(splineTube.normals[0]).multiplyScalar(vert.x);binormal.copy(splineTube.binormals[0]).multiplyScalar(vert.y);position2.copy(extrudePts[0]).add(normal).add(binormal);v(position2.x,position2.y,position2.z);}}// Add stepped vertices...
	// Including front facing vertices
	var s;for(s=1;s<=steps;s++){for(i=0;i<vlen;i++){vert=bevelEnabled?scalePt2(vertices[i],verticesMovements[i],bs):vertices[i];if(!extrudeByPath){v(vert.x,vert.y,amount/steps*s);}else{// v( vert.x, vert.y + extrudePts[ s - 1 ].y, extrudePts[ s - 1 ].x );
	normal.copy(splineTube.normals[s]).multiplyScalar(vert.x);binormal.copy(splineTube.binormals[s]).multiplyScalar(vert.y);position2.copy(extrudePts[s]).add(normal).add(binormal);v(position2.x,position2.y,position2.z);}}}// Add bevel segments planes
	//for ( b = 1; b <= bevelSegments; b ++ ) {
	for(b=bevelSegments-1;b>=0;b--){t=b/bevelSegments;z=bevelThickness*Math.cos(t*Math.PI/2);bs=bevelSize*Math.sin(t*Math.PI/2);// contract shape
	for(i=0,il=contour.length;i<il;i++){vert=scalePt2(contour[i],contourMovements[i],bs);v(vert.x,vert.y,amount+z);}// expand holes
	for(h=0,hl=holes.length;h<hl;h++){ahole=holes[h];oneHoleMovements=holesMovements[h];for(i=0,il=ahole.length;i<il;i++){vert=scalePt2(ahole[i],oneHoleMovements[i],bs);if(!extrudeByPath){v(vert.x,vert.y,amount+z);}else{v(vert.x,vert.y+extrudePts[steps-1].y,extrudePts[steps-1].x+z);}}}}/* Faces */// Top and bottom faces
	buildLidFaces();// Sides faces
	buildSideFaces();/////  Internal functions
	function buildLidFaces(){var start=verticesArray.length/3;if(bevelEnabled){var layer=0;// steps + 1
	var offset=vlen*layer;// Bottom faces
	for(i=0;i<flen;i++){face=faces[i];f3(face[2]+offset,face[1]+offset,face[0]+offset);}layer=steps+bevelSegments*2;offset=vlen*layer;// Top faces
	for(i=0;i<flen;i++){face=faces[i];f3(face[0]+offset,face[1]+offset,face[2]+offset);}}else{// Bottom faces
	for(i=0;i<flen;i++){face=faces[i];f3(face[2],face[1],face[0]);}// Top faces
	for(i=0;i<flen;i++){face=faces[i];f3(face[0]+vlen*steps,face[1]+vlen*steps,face[2]+vlen*steps);}}scope.addGroup(start,verticesArray.length/3-start,options.material!==undefined?options.material:0);}// Create faces for the z-sides of the shape
	function buildSideFaces(){var start=verticesArray.length/3;var layeroffset=0;sidewalls(contour,layeroffset);layeroffset+=contour.length;for(h=0,hl=holes.length;h<hl;h++){ahole=holes[h];sidewalls(ahole,layeroffset);//, true
	layeroffset+=ahole.length;}scope.addGroup(start,verticesArray.length/3-start,options.extrudeMaterial!==undefined?options.extrudeMaterial:1);}function sidewalls(contour,layeroffset){var j,k;i=contour.length;while(--i>=0){j=i;k=i-1;if(k<0)k=contour.length-1;//console.log('b', i,j, i-1, k,vertices.length);
	var s=0,sl=steps+bevelSegments*2;for(s=0;s<sl;s++){var slen1=vlen*s;var slen2=vlen*(s+1);var a=layeroffset+j+slen1,b=layeroffset+k+slen1,c=layeroffset+k+slen2,d=layeroffset+j+slen2;f4(a,b,c,d,contour,s,sl,j,k);}}}function v(x,y,z){placeholder.push(x);placeholder.push(y);placeholder.push(z);}function f3(a,b,c){addVertex(a);addVertex(b);addVertex(c);var nextIndex=verticesArray.length/3;var uvs=uvgen.generateTopUV(scope,verticesArray,nextIndex-3,nextIndex-2,nextIndex-1);addUV(uvs[0]);addUV(uvs[1]);addUV(uvs[2]);}function f4(a,b,c,d,wallContour,stepIndex,stepsLength,contourIndex1,contourIndex2){addVertex(a);addVertex(b);addVertex(d);addVertex(b);addVertex(c);addVertex(d);var nextIndex=verticesArray.length/3;var uvs=uvgen.generateSideWallUV(scope,verticesArray,nextIndex-6,nextIndex-3,nextIndex-2,nextIndex-1);addUV(uvs[0]);addUV(uvs[1]);addUV(uvs[3]);addUV(uvs[1]);addUV(uvs[2]);addUV(uvs[3]);}function addVertex(index){indicesArray.push(verticesArray.length/3);verticesArray.push(placeholder[index*3+0]);verticesArray.push(placeholder[index*3+1]);verticesArray.push(placeholder[index*3+2]);}function addUV(vector2){uvArray.push(vector2.x);uvArray.push(vector2.y);}if(!options.arrays){this.setIndex(indicesArray);this.addAttribute('position',new Float32BufferAttribute(verticesArray,3));this.addAttribute('uv',new Float32BufferAttribute(options.arrays.uv,2));}};ExtrudeGeometry.WorldUVGenerator={generateTopUV:function generateTopUV(geometry,vertices,indexA,indexB,indexC){var a_x=vertices[indexA*3];var a_y=vertices[indexA*3+1];var b_x=vertices[indexB*3];var b_y=vertices[indexB*3+1];var c_x=vertices[indexC*3];var c_y=vertices[indexC*3+1];return[new Vector2(a_x,a_y),new Vector2(b_x,b_y),new Vector2(c_x,c_y)];},generateSideWallUV:function generateSideWallUV(geometry,vertices,indexA,indexB,indexC,indexD){var a_x=vertices[indexA*3];var a_y=vertices[indexA*3+1];var a_z=vertices[indexA*3+2];var b_x=vertices[indexB*3];var b_y=vertices[indexB*3+1];var b_z=vertices[indexB*3+2];var c_x=vertices[indexC*3];var c_y=vertices[indexC*3+1];var c_z=vertices[indexC*3+2];var d_x=vertices[indexD*3];var d_y=vertices[indexD*3+1];var d_z=vertices[indexD*3+2];if(Math.abs(a_y-b_y)<0.01){return[new Vector2(a_x,1-a_z),new Vector2(b_x,1-b_z),new Vector2(c_x,1-c_z),new Vector2(d_x,1-d_z)];}else{return[new Vector2(a_y,1-a_z),new Vector2(b_y,1-b_z),new Vector2(c_y,1-c_z),new Vector2(d_y,1-d_z)];}}};// export { WireframeGeometry } from './WireframeGeometry.js';
	// export { ParametricGeometry, ParametricBufferGeometry } from './ParametricGeometry.js';
	// export { TetrahedronGeometry, TetrahedronBufferGeometry } from './TetrahedronGeometry.js';
	// export { OctahedronGeometry, OctahedronBufferGeometry } from './OctahedronGeometry.js';
	// export { IcosahedronGeometry, IcosahedronBufferGeometry } from './IcosahedronGeometry.js';
	// export { DodecahedronGeometry, DodecahedronBufferGeometry } from './DodecahedronGeometry.js';
	// export { PolyhedronGeometry, PolyhedronBufferGeometry } from './PolyhedronGeometry.js';
	// export { EdgesGeometry } from './EdgesGeometry.js';
	// export { ConeGeometry, ConeBufferGeometry } from './ConeGeometry.js';
	// export { CylinderGeometry, CylinderBufferGeometry } from './CylinderGeometry.js';
	// export { CircleGeometry, CircleBufferGeometry } from './CircleGeometry.js';
	// export { BoxGeometry, BoxBufferGeometry } from './BoxGeometry.js';
	/**
		 * @author mrdoob / http://mrdoob.com/
		 * @author alteredq / http://alteredqualia.com/
		 *
		 * parameters = {
		 *  color: <hex>,
		 *  specular: <hex>,
		 *  shininess: <float>,
		 *  opacity: <float>,
		 *
		 *  map: new THREE.Texture( <Image> ),
		 *
		 *  lightMap: new THREE.Texture( <Image> ),
		 *  lightMapIntensity: <float>
		 *
		 *  aoMap: new THREE.Texture( <Image> ),
		 *  aoMapIntensity: <float>
		 *
		 *  emissive: <hex>,
		 *  emissiveIntensity: <float>
		 *  emissiveMap: new THREE.Texture( <Image> ),
		 *
		 *  bumpMap: new THREE.Texture( <Image> ),
		 *  bumpScale: <float>,
		 *
		 *  normalMap: new THREE.Texture( <Image> ),
		 *  normalScale: <Vector2>,
		 *
		 *  displacementMap: new THREE.Texture( <Image> ),
		 *  displacementScale: <float>,
		 *  displacementBias: <float>,
		 *
		 *  specularMap: new THREE.Texture( <Image> ),
		 *
		 *  alphaMap: new THREE.Texture( <Image> ),
		 *
		 *  envMap: new THREE.TextureCube( [posx, negx, posy, negy, posz, negz] ),
		 *  combine: THREE.Multiply,
		 *  reflectivity: <float>,
		 *  refractionRatio: <float>,
		 *
		 *  wireframe: <boolean>,
		 *  wireframeLinewidth: <float>,
		 *
		 *  skinning: <bool>,
		 *  morphTargets: <bool>,
		 *  morphNormals: <bool>
		 * }
		 */function MeshPhongMaterial(parameters){Material.call(this);this.type='MeshPhongMaterial';this.color=new Color(0xffffff);// diffuse
	this.specular=new Color(0x111111);this.shininess=30;this.map=null;this.lightMap=null;this.lightMapIntensity=1.0;this.aoMap=null;this.aoMapIntensity=1.0;this.emissive=new Color(0x000000);this.emissiveIntensity=1.0;this.emissiveMap=null;this.bumpMap=null;this.bumpScale=1;this.normalMap=null;this.normalScale=new Vector2(1,1);this.displacementMap=null;this.displacementScale=1;this.displacementBias=0;this.specularMap=null;this.alphaMap=null;this.envMap=null;this.combine=MultiplyOperation;this.reflectivity=1;this.refractionRatio=0.98;this.wireframe=false;this.wireframeLinewidth=1;this.wireframeLinecap='round';this.wireframeLinejoin='round';this.skinning=false;this.morphTargets=false;this.morphNormals=false;this.setValues(parameters);}MeshPhongMaterial.prototype=Object.create(Material.prototype);MeshPhongMaterial.prototype.constructor=MeshPhongMaterial;MeshPhongMaterial.prototype.isMeshPhongMaterial=true;MeshPhongMaterial.prototype.copy=function(source){Material.prototype.copy.call(this,source);this.color.copy(source.color);this.specular.copy(source.specular);this.shininess=source.shininess;this.map=source.map;this.lightMap=source.lightMap;this.lightMapIntensity=source.lightMapIntensity;this.aoMap=source.aoMap;this.aoMapIntensity=source.aoMapIntensity;this.emissive.copy(source.emissive);this.emissiveMap=source.emissiveMap;this.emissiveIntensity=source.emissiveIntensity;this.bumpMap=source.bumpMap;this.bumpScale=source.bumpScale;this.normalMap=source.normalMap;this.normalScale.copy(source.normalScale);this.displacementMap=source.displacementMap;this.displacementScale=source.displacementScale;this.displacementBias=source.displacementBias;this.specularMap=source.specularMap;this.alphaMap=source.alphaMap;this.envMap=source.envMap;this.combine=source.combine;this.reflectivity=source.reflectivity;this.refractionRatio=source.refractionRatio;this.wireframe=source.wireframe;this.wireframeLinewidth=source.wireframeLinewidth;this.wireframeLinecap=source.wireframeLinecap;this.wireframeLinejoin=source.wireframeLinejoin;this.skinning=source.skinning;this.morphTargets=source.morphTargets;this.morphNormals=source.morphNormals;return this;};// export { ShadowMaterial } from './ShadowMaterial.js';
	var Materials=Object.freeze({SpriteMaterial:SpriteMaterial,ShaderMaterial:ShaderMaterial,MeshPhongMaterial:MeshPhongMaterial,MeshBasicMaterial:MeshBasicMaterial,LineBasicMaterial:LineBasicMaterial,Material:Material});/**
		 * @author mrdoob / http://mrdoob.com/
		 */var Cache={enabled:false,files:{},add:function add(key,file){if(this.enabled===false)return;// console.log( 'THREE.Cache', 'Adding key:', key );
	this.files[key]=file;},get:function get(key){if(this.enabled===false)return;// console.log( 'THREE.Cache', 'Checking key:', key );
	return this.files[key];},remove:function remove(key){delete this.files[key];},clear:function clear(){this.files={};}};/**
		 * @author mrdoob / http://mrdoob.com/
		 */function LoadingManager(onLoad,onProgress,onError){var scope=this;var isLoading=false,itemsLoaded=0,itemsTotal=0;this.onStart=undefined;this.onLoad=onLoad;this.onProgress=onProgress;this.onError=onError;this.itemStart=function(url){itemsTotal++;if(isLoading===false){if(scope.onStart!==undefined){scope.onStart(url,itemsLoaded,itemsTotal);}}isLoading=true;};this.itemEnd=function(url){itemsLoaded++;if(scope.onProgress!==undefined){scope.onProgress(url,itemsLoaded,itemsTotal);}if(itemsLoaded===itemsTotal){isLoading=false;if(scope.onLoad!==undefined){scope.onLoad();}}};this.itemError=function(url){if(scope.onError!==undefined){scope.onError(url);}};}var DefaultLoadingManager=new LoadingManager();/**
		 * @author mrdoob / http://mrdoob.com/
		 */function ImageLoader(manager){this.manager=manager!==undefined?manager:DefaultLoadingManager;}_assign(ImageLoader.prototype,{load:function load(url,onLoad,onProgress,onError){if(url===undefined)url='';if(this.path!==undefined)url=this.path+url;var scope=this;var cached=Cache.get(url);if(cached!==undefined){scope.manager.itemStart(url);setTimeout(function(){if(onLoad)onLoad(cached);scope.manager.itemEnd(url);},0);return cached;}var image=document.createElementNS('http://www.w3.org/1999/xhtml','img');image.addEventListener('load',function(){Cache.add(url,this);if(onLoad)onLoad(this);scope.manager.itemEnd(url);},false);/*
				image.addEventListener( 'progress', function ( event ) {
	
					if ( onProgress ) onProgress( event );
	
				}, false );
				*/image.addEventListener('error',function(event){if(onError)onError(event);scope.manager.itemEnd(url);scope.manager.itemError(url);},false);if(url.substr(0,5)!=='data:'){if(this.crossOrigin!==undefined)image.crossOrigin=this.crossOrigin;}scope.manager.itemStart(url);image.src=url;return image;},setCrossOrigin:function setCrossOrigin(value){this.crossOrigin=value;return this;},setPath:function setPath(value){this.path=value;return this;}});/**
		 * @author mrdoob / http://mrdoob.com/
		 */function TextureLoader(manager){this.manager=manager!==undefined?manager:DefaultLoadingManager;}_assign(TextureLoader.prototype,{load:function load(url,onLoad,onProgress,onError){var loader=new ImageLoader(this.manager);loader.setCrossOrigin(this.crossOrigin);loader.setPath(this.path);var texture=new Texture();texture.image=loader.load(url,function(){// JPEGs can't have an alpha channel, so memory can be saved by storing them as RGB.
	var isJPEG=url.search(/\.(jpg|jpeg)$/)>0||url.search(/^data\:image\/jpeg/)===0;texture.format=isJPEG?RGBFormat:RGBAFormat;texture.needsUpdate=true;if(onLoad!==undefined){onLoad(texture);}},onProgress,onError);return texture;},setCrossOrigin:function setCrossOrigin(value){this.crossOrigin=value;return this;},setPath:function setPath(value){this.path=value;return this;}});/**
		 * @author mrdoob / http://mrdoob.com/
		 */function FileLoader(manager){this.manager=manager!==undefined?manager:DefaultLoadingManager;}_assign(FileLoader.prototype,{load:function load(url,onLoad,onProgress,onError){if(url===undefined)url='';if(this.path!==undefined)url=this.path+url;var scope=this;var cached=Cache.get(url);if(cached!==undefined){scope.manager.itemStart(url);setTimeout(function(){if(onLoad)onLoad(cached);scope.manager.itemEnd(url);},0);return cached;}// Check for data: URI
	var dataUriRegex=/^data:(.*?)(;base64)?,(.*)$/;var dataUriRegexResult=url.match(dataUriRegex);// Safari can not handle Data URIs through XMLHttpRequest so process manually
	if(dataUriRegexResult){var mimeType=dataUriRegexResult[1];var isBase64=!!dataUriRegexResult[2];var data=dataUriRegexResult[3];data=window.decodeURIComponent(data);if(isBase64)data=window.atob(data);try{var response;var responseType=(this.responseType||'').toLowerCase();switch(responseType){case'arraybuffer':case'blob':response=new ArrayBuffer(data.length);var view=new Uint8Array(response);for(var i=0;i<data.length;i++){view[i]=data.charCodeAt(i);}if(responseType==='blob'){response=new Blob([response],{type:mimeType});}break;case'document':var parser=new DOMParser();response=parser.parseFromString(data,mimeType);break;case'json':response=JSON.parse(data);break;default:// 'text' or other
	response=data;break;}// Wait for next browser tick
	window.setTimeout(function(){if(onLoad)onLoad(response);scope.manager.itemEnd(url);},0);}catch(error){// Wait for next browser tick
	window.setTimeout(function(){if(onError)onError(error);scope.manager.itemEnd(url);scope.manager.itemError(url);},0);}}else{var request=new XMLHttpRequest();request.open('GET',url,true);request.addEventListener('load',function(event){var response=event.target.response;Cache.add(url,response);if(this.status===200){if(onLoad)onLoad(response);scope.manager.itemEnd(url);}else if(this.status===0){// Some browsers return HTTP Status 0 when using non-http protocol
	// e.g. 'file://' or 'data://'. Handle as success.
	console.warn('THREE.FileLoader: HTTP Status 0 received.');if(onLoad)onLoad(response);scope.manager.itemEnd(url);}else{if(onError)onError(event);scope.manager.itemEnd(url);scope.manager.itemError(url);}},false);if(onProgress!==undefined){request.addEventListener('progress',function(event){onProgress(event);},false);}request.addEventListener('error',function(event){if(onError)onError(event);scope.manager.itemEnd(url);scope.manager.itemError(url);},false);if(this.responseType!==undefined)request.responseType=this.responseType;if(this.withCredentials!==undefined)request.withCredentials=this.withCredentials;if(request.overrideMimeType)request.overrideMimeType(this.mimeType!==undefined?this.mimeType:'text/plain');for(var header in this.requestHeader){request.setRequestHeader(header,this.requestHeader[header]);}request.send(null);}scope.manager.itemStart(url);return request;},setPath:function setPath(value){this.path=value;return this;},setResponseType:function setResponseType(value){this.responseType=value;return this;},setWithCredentials:function setWithCredentials(value){this.withCredentials=value;return this;},setMimeType:function setMimeType(value){this.mimeType=value;return this;},setRequestHeader:function setRequestHeader(value){this.requestHeader=value;return this;}});/**
		 * @author mrdoob / http://mrdoob.com/
		 */function MaterialLoader(manager){this.manager=manager!==undefined?manager:DefaultLoadingManager;this.textures={};}_assign(MaterialLoader.prototype,{load:function load(url,onLoad,onProgress,onError){var scope=this;var loader=new FileLoader(scope.manager);loader.setResponseType('json');loader.load(url,function(json){onLoad(scope.parse(json));},onProgress,onError);},setTextures:function setTextures(value){this.textures=value;},parse:function parse(json){var textures=this.textures;function getTexture(name){if(textures[name]===undefined){console.warn('THREE.MaterialLoader: Undefined texture',name);}return textures[name];}var material=new Materials[json.type]();if(json.uuid!==undefined)material.uuid=json.uuid;if(json.name!==undefined)material.name=json.name;if(json.color!==undefined)material.color.setHex(json.color);if(json.roughness!==undefined)material.roughness=json.roughness;if(json.metalness!==undefined)material.metalness=json.metalness;if(json.emissive!==undefined)material.emissive.setHex(json.emissive);if(json.specular!==undefined)material.specular.setHex(json.specular);if(json.shininess!==undefined)material.shininess=json.shininess;if(json.clearCoat!==undefined)material.clearCoat=json.clearCoat;if(json.clearCoatRoughness!==undefined)material.clearCoatRoughness=json.clearCoatRoughness;if(json.uniforms!==undefined)material.uniforms=json.uniforms;if(json.vertexShader!==undefined)material.vertexShader=json.vertexShader;if(json.fragmentShader!==undefined)material.fragmentShader=json.fragmentShader;if(json.vertexColors!==undefined)material.vertexColors=json.vertexColors;if(json.fog!==undefined)material.fog=json.fog;if(json.shading!==undefined)material.shading=json.shading;if(json.blending!==undefined)material.blending=json.blending;if(json.side!==undefined)material.side=json.side;if(json.opacity!==undefined)material.opacity=json.opacity;if(json.transparent!==undefined)material.transparent=json.transparent;if(json.alphaTest!==undefined)material.alphaTest=json.alphaTest;if(json.depthTest!==undefined)material.depthTest=json.depthTest;if(json.depthWrite!==undefined)material.depthWrite=json.depthWrite;if(json.colorWrite!==undefined)material.colorWrite=json.colorWrite;if(json.wireframe!==undefined)material.wireframe=json.wireframe;if(json.wireframeLinewidth!==undefined)material.wireframeLinewidth=json.wireframeLinewidth;if(json.wireframeLinecap!==undefined)material.wireframeLinecap=json.wireframeLinecap;if(json.wireframeLinejoin!==undefined)material.wireframeLinejoin=json.wireframeLinejoin;if(json.skinning!==undefined)material.skinning=json.skinning;if(json.morphTargets!==undefined)material.morphTargets=json.morphTargets;// for PointsMaterial
	if(json.size!==undefined)material.size=json.size;if(json.sizeAttenuation!==undefined)material.sizeAttenuation=json.sizeAttenuation;// maps
	if(json.map!==undefined)material.map=getTexture(json.map);if(json.alphaMap!==undefined){material.alphaMap=getTexture(json.alphaMap);material.transparent=true;}if(json.bumpMap!==undefined)material.bumpMap=getTexture(json.bumpMap);if(json.bumpScale!==undefined)material.bumpScale=json.bumpScale;if(json.normalMap!==undefined)material.normalMap=getTexture(json.normalMap);if(json.normalScale!==undefined){var normalScale=json.normalScale;if(Array.isArray(normalScale)===false){// Blender exporter used to export a scalar. See #7459
	normalScale=[normalScale,normalScale];}material.normalScale=new Vector2().fromArray(normalScale);}if(json.displacementMap!==undefined)material.displacementMap=getTexture(json.displacementMap);if(json.displacementScale!==undefined)material.displacementScale=json.displacementScale;if(json.displacementBias!==undefined)material.displacementBias=json.displacementBias;if(json.roughnessMap!==undefined)material.roughnessMap=getTexture(json.roughnessMap);if(json.metalnessMap!==undefined)material.metalnessMap=getTexture(json.metalnessMap);if(json.emissiveMap!==undefined)material.emissiveMap=getTexture(json.emissiveMap);if(json.emissiveIntensity!==undefined)material.emissiveIntensity=json.emissiveIntensity;if(json.specularMap!==undefined)material.specularMap=getTexture(json.specularMap);if(json.envMap!==undefined)material.envMap=getTexture(json.envMap);if(json.reflectivity!==undefined)material.reflectivity=json.reflectivity;if(json.lightMap!==undefined)material.lightMap=getTexture(json.lightMap);if(json.lightMapIntensity!==undefined)material.lightMapIntensity=json.lightMapIntensity;if(json.aoMap!==undefined)material.aoMap=getTexture(json.aoMap);if(json.aoMapIntensity!==undefined)material.aoMapIntensity=json.aoMapIntensity;if(json.gradientMap!==undefined)material.gradientMap=getTexture(json.gradientMap);// MultiMaterial
	if(json.materials!==undefined){for(var i=0,l=json.materials.length;i<l;i++){material.materials.push(this.parse(json.materials[i]));}}return material;}});/**
		 * @author alteredq / http://alteredqualia.com/
		 */function Loader(){this.onLoadStart=function(){};this.onLoadProgress=function(){};this.onLoadComplete=function(){};}Loader.Handlers={handlers:[],add:function add(regex,loader){this.handlers.push(regex,loader);},get:function get(file){var handlers=this.handlers;for(var i=0,l=handlers.length;i<l;i+=2){var regex=handlers[i];var loader=handlers[i+1];if(regex.test(file)){return loader;}}return null;}};_assign(Loader.prototype,{crossOrigin:undefined,extractUrlBase:function extractUrlBase(url){var parts=url.split('/');if(parts.length===1)return'./';parts.pop();return parts.join('/')+'/';},initMaterials:function initMaterials(materials,texturePath,crossOrigin){var array=[];for(var i=0;i<materials.length;++i){array[i]=this.createMaterial(materials[i],texturePath,crossOrigin);}return array;},createMaterial:function(){var BlendingMode={NoBlending:NoBlending,NormalBlending:NormalBlending,AdditiveBlending:AdditiveBlending,SubtractiveBlending:SubtractiveBlending,MultiplyBlending:MultiplyBlending,CustomBlending:CustomBlending};var color=new Color();var textureLoader=new TextureLoader();var materialLoader=new MaterialLoader();return function createMaterial(m,texturePath,crossOrigin){// convert from old material format
	var textures={};function loadTexture(path,repeat,offset,wrap,anisotropy){var fullPath=texturePath+path;var loader=Loader.Handlers.get(fullPath);var texture;if(loader!==null){texture=loader.load(fullPath);}else{textureLoader.setCrossOrigin(crossOrigin);texture=textureLoader.load(fullPath);}if(repeat!==undefined){texture.repeat.fromArray(repeat);if(repeat[0]!==1)texture.wrapS=RepeatWrapping;if(repeat[1]!==1)texture.wrapT=RepeatWrapping;}if(offset!==undefined){texture.offset.fromArray(offset);}if(wrap!==undefined){if(wrap[0]==='repeat')texture.wrapS=RepeatWrapping;if(wrap[0]==='mirror')texture.wrapS=MirroredRepeatWrapping;if(wrap[1]==='repeat')texture.wrapT=RepeatWrapping;if(wrap[1]==='mirror')texture.wrapT=MirroredRepeatWrapping;}if(anisotropy!==undefined){texture.anisotropy=anisotropy;}var uuid=_Math.generateUUID();textures[uuid]=texture;return uuid;}//
	var json={uuid:_Math.generateUUID(),type:'MeshLambertMaterial'};for(var name in m){var value=m[name];switch(name){case'DbgColor':case'DbgIndex':case'opticalDensity':case'illumination':break;case'DbgName':json.name=value;break;case'blending':json.blending=BlendingMode[value];break;case'colorAmbient':case'mapAmbient':console.warn('THREE.Loader.createMaterial:',name,'is no longer supported.');break;case'colorDiffuse':json.color=color.fromArray(value).getHex();break;case'colorSpecular':json.specular=color.fromArray(value).getHex();break;case'colorEmissive':json.emissive=color.fromArray(value).getHex();break;case'specularCoef':json.shininess=value;break;case'shading':if(value.toLowerCase()==='basic')json.type='MeshBasicMaterial';if(value.toLowerCase()==='phong')json.type='MeshPhongMaterial';if(value.toLowerCase()==='standard')json.type='MeshStandardMaterial';break;case'mapDiffuse':json.map=loadTexture(value,m.mapDiffuseRepeat,m.mapDiffuseOffset,m.mapDiffuseWrap,m.mapDiffuseAnisotropy);break;case'mapDiffuseRepeat':case'mapDiffuseOffset':case'mapDiffuseWrap':case'mapDiffuseAnisotropy':break;case'mapEmissive':json.emissiveMap=loadTexture(value,m.mapEmissiveRepeat,m.mapEmissiveOffset,m.mapEmissiveWrap,m.mapEmissiveAnisotropy);break;case'mapEmissiveRepeat':case'mapEmissiveOffset':case'mapEmissiveWrap':case'mapEmissiveAnisotropy':break;case'mapLight':json.lightMap=loadTexture(value,m.mapLightRepeat,m.mapLightOffset,m.mapLightWrap,m.mapLightAnisotropy);break;case'mapLightRepeat':case'mapLightOffset':case'mapLightWrap':case'mapLightAnisotropy':break;case'mapAO':json.aoMap=loadTexture(value,m.mapAORepeat,m.mapAOOffset,m.mapAOWrap,m.mapAOAnisotropy);break;case'mapAORepeat':case'mapAOOffset':case'mapAOWrap':case'mapAOAnisotropy':break;case'mapBump':json.bumpMap=loadTexture(value,m.mapBumpRepeat,m.mapBumpOffset,m.mapBumpWrap,m.mapBumpAnisotropy);break;case'mapBumpScale':json.bumpScale=value;break;case'mapBumpRepeat':case'mapBumpOffset':case'mapBumpWrap':case'mapBumpAnisotropy':break;case'mapNormal':json.normalMap=loadTexture(value,m.mapNormalRepeat,m.mapNormalOffset,m.mapNormalWrap,m.mapNormalAnisotropy);break;case'mapNormalFactor':json.normalScale=[value,value];break;case'mapNormalRepeat':case'mapNormalOffset':case'mapNormalWrap':case'mapNormalAnisotropy':break;case'mapSpecular':json.specularMap=loadTexture(value,m.mapSpecularRepeat,m.mapSpecularOffset,m.mapSpecularWrap,m.mapSpecularAnisotropy);break;case'mapSpecularRepeat':case'mapSpecularOffset':case'mapSpecularWrap':case'mapSpecularAnisotropy':break;case'mapMetalness':json.metalnessMap=loadTexture(value,m.mapMetalnessRepeat,m.mapMetalnessOffset,m.mapMetalnessWrap,m.mapMetalnessAnisotropy);break;case'mapMetalnessRepeat':case'mapMetalnessOffset':case'mapMetalnessWrap':case'mapMetalnessAnisotropy':break;case'mapRoughness':json.roughnessMap=loadTexture(value,m.mapRoughnessRepeat,m.mapRoughnessOffset,m.mapRoughnessWrap,m.mapRoughnessAnisotropy);break;case'mapRoughnessRepeat':case'mapRoughnessOffset':case'mapRoughnessWrap':case'mapRoughnessAnisotropy':break;case'mapAlpha':json.alphaMap=loadTexture(value,m.mapAlphaRepeat,m.mapAlphaOffset,m.mapAlphaWrap,m.mapAlphaAnisotropy);break;case'mapAlphaRepeat':case'mapAlphaOffset':case'mapAlphaWrap':case'mapAlphaAnisotropy':break;case'flipSided':json.side=BackSide;break;case'doubleSided':json.side=DoubleSide;break;case'transparency':console.warn('THREE.Loader.createMaterial: transparency has been renamed to opacity');json.opacity=value;break;case'depthTest':case'depthWrite':case'colorWrite':case'opacity':case'reflectivity':case'transparent':case'visible':case'wireframe':json[name]=value;break;case'vertexColors':if(value===true)json.vertexColors=VertexColors;if(value==='face')json.vertexColors=FaceColors;break;default:console.error('THREE.Loader.createMaterial: Unsupported',name,value);break;}}if(json.type==='MeshBasicMaterial')delete json.emissive;if(json.type!=='MeshPhongMaterial')delete json.specular;if(json.opacity<1)json.transparent=true;materialLoader.setTextures(textures);return materialLoader.parse(json);};}()});/**
		 * @author tschw
		 * @author Ben Houston / http://clara.io/
		 * @author David Sarno / http://lighthaus.us/
		 */var AnimationUtils={// same as Array.prototype.slice, but also works on typed arrays
	arraySlice:function arraySlice(array,from,to){if(AnimationUtils.isTypedArray(array)){// in ios9 array.subarray(from, undefined) will return empty array
	// but array.subarray(from) or array.subarray(from, len) is correct
	return new array.constructor(array.subarray(from,to!==undefined?to:array.length));}return array.slice(from,to);},// converts an array to a specific type
	convertArray:function convertArray(array,type,forceClone){if(!array||// let 'undefined' and 'null' pass
	!forceClone&&array.constructor===type)return array;if(typeof type.BYTES_PER_ELEMENT==='number'){return new type(array);// create typed array
	}return Array.prototype.slice.call(array);// create Array
	},isTypedArray:function isTypedArray(object){return ArrayBuffer.isView(object)&&!(object instanceof DataView);},// returns an array by which times and values can be sorted
	getKeyframeOrder:function getKeyframeOrder(times){function compareTime(i,j){return times[i]-times[j];}var n=times.length;var result=new Array(n);for(var i=0;i!==n;++i){result[i]=i;}result.sort(compareTime);return result;},// uses the array previously returned by 'getKeyframeOrder' to sort data
	sortedArray:function sortedArray(values,stride,order){var nValues=values.length;var result=new values.constructor(nValues);for(var i=0,dstOffset=0;dstOffset!==nValues;++i){var srcOffset=order[i]*stride;for(var j=0;j!==stride;++j){result[dstOffset++]=values[srcOffset+j];}}return result;},// function for parsing AOS keyframe formats
	flattenJSON:function flattenJSON(jsonKeys,times,values,valuePropertyName){var i=1,key=jsonKeys[0];while(key!==undefined&&key[valuePropertyName]===undefined){key=jsonKeys[i++];}if(key===undefined)return;// no data
	var value=key[valuePropertyName];if(value===undefined)return;// no data
	if(Array.isArray(value)){do{value=key[valuePropertyName];if(value!==undefined){times.push(key.time);values.push.apply(values,value);// push all elements
	}key=jsonKeys[i++];}while(key!==undefined);}else if(value.toArray!==undefined){// ...assume THREE.Math-ish
	do{value=key[valuePropertyName];if(value!==undefined){times.push(key.time);value.toArray(values,values.length);}key=jsonKeys[i++];}while(key!==undefined);}else{// otherwise push as-is
	do{value=key[valuePropertyName];if(value!==undefined){times.push(key.time);values.push(value);}key=jsonKeys[i++];}while(key!==undefined);}}};/**
		 * Abstract base class of interpolants over parametric samples.
		 *
		 * The parameter domain is one dimensional, typically the time or a path
		 * along a curve defined by the data.
		 *
		 * The sample values can have any dimensionality and derived classes may
		 * apply special interpretations to the data.
		 *
		 * This class provides the interval seek in a Template Method, deferring
		 * the actual interpolation to derived classes.
		 *
		 * Time complexity is O(1) for linear access crossing at most two points
		 * and O(log N) for random access, where N is the number of positions.
		 *
		 * References:
		 *
		 * 		http://www.oodesign.com/template-method-pattern.html
		 *
		 * @author tschw
		 */function Interpolant(parameterPositions,sampleValues,sampleSize,resultBuffer){this.parameterPositions=parameterPositions;this._cachedIndex=0;this.resultBuffer=resultBuffer!==undefined?resultBuffer:new sampleValues.constructor(sampleSize);this.sampleValues=sampleValues;this.valueSize=sampleSize;}_assign(Interpolant.prototype,{evaluate:function evaluate(t){var pp=this.parameterPositions,i1=this._cachedIndex,t1=pp[i1],t0=pp[i1-1];validate_interval:{seek:{var right;linear_scan:{//- See http://jsperf.com/comparison-to-undefined/3
	//- slower code:
	//-
	//- 				if ( t >= t1 || t1 === undefined ) {
	forward_scan:if(!(t<t1)){for(var giveUpAt=i1+2;;){if(t1===undefined){if(t<t0)break forward_scan;// after end
	i1=pp.length;this._cachedIndex=i1;return this.afterEnd_(i1-1,t,t0);}if(i1===giveUpAt)break;// this loop
	t0=t1;t1=pp[++i1];if(t<t1){// we have arrived at the sought interval
	break seek;}}// prepare binary search on the right side of the index
	right=pp.length;break linear_scan;}//- slower code:
	//-					if ( t < t0 || t0 === undefined ) {
	if(!(t>=t0)){// looping?
	var t1global=pp[1];if(t<t1global){i1=2;// + 1, using the scan for the details
	t0=t1global;}// linear reverse scan
	for(var giveUpAt=i1-2;;){if(t0===undefined){// before start
	this._cachedIndex=0;return this.beforeStart_(0,t,t1);}if(i1===giveUpAt)break;// this loop
	t1=t0;t0=pp[--i1-1];if(t>=t0){// we have arrived at the sought interval
	break seek;}}// prepare binary search on the left side of the index
	right=i1;i1=0;break linear_scan;}// the interval is valid
	break validate_interval;}// linear scan
	// binary search
	while(i1<right){var mid=i1+right>>>1;if(t<pp[mid]){right=mid;}else{i1=mid+1;}}t1=pp[i1];t0=pp[i1-1];// check boundary cases, again
	if(t0===undefined){this._cachedIndex=0;return this.beforeStart_(0,t,t1);}if(t1===undefined){i1=pp.length;this._cachedIndex=i1;return this.afterEnd_(i1-1,t0,t);}}// seek
	this._cachedIndex=i1;this.intervalChanged_(i1,t0,t1);}// validate_interval
	return this.interpolate_(i1,t0,t,t1);},settings:null,// optional, subclass-specific settings structure
	// Note: The indirection allows central control of many interpolants.
	// --- Protected interface
	DefaultSettings_:{},getSettings_:function getSettings_(){return this.settings||this.DefaultSettings_;},copySampleValue_:function copySampleValue_(index){// copies a sample value to the result buffer
	var result=this.resultBuffer,values=this.sampleValues,stride=this.valueSize,offset=index*stride;for(var i=0;i!==stride;++i){result[i]=values[offset+i];}return result;},// Template methods for derived classes:
	interpolate_:function interpolate_(i1,t0,t,t1){throw new Error("call to abstract method");// implementations shall return this.resultBuffer
	},intervalChanged_:function intervalChanged_(i1,t0,t1){// empty
	}});//!\ DECLARE ALIAS AFTER assign prototype !
	_assign(Interpolant.prototype,{//( 0, t, t0 ), returns this.resultBuffer
	beforeStart_:Interpolant.prototype.copySampleValue_,//( N-1, tN-1, t ), returns this.resultBuffer
	afterEnd_:Interpolant.prototype.copySampleValue_});/**
		 * Fast and simple cubic spline interpolant.
		 *
		 * It was derived from a Hermitian construction setting the first derivative
		 * at each sample position to the linear slope between neighboring positions
		 * over their parameter interval.
		 *
		 * @author tschw
		 */function CubicInterpolant(parameterPositions,sampleValues,sampleSize,resultBuffer){Interpolant.call(this,parameterPositions,sampleValues,sampleSize,resultBuffer);this._weightPrev=-0;this._offsetPrev=-0;this._weightNext=-0;this._offsetNext=-0;}CubicInterpolant.prototype=_assign(Object.create(Interpolant.prototype),{constructor:CubicInterpolant,DefaultSettings_:{endingStart:ZeroCurvatureEnding,endingEnd:ZeroCurvatureEnding},intervalChanged_:function intervalChanged_(i1,t0,t1){var pp=this.parameterPositions,iPrev=i1-2,iNext=i1+1,tPrev=pp[iPrev],tNext=pp[iNext];if(tPrev===undefined){switch(this.getSettings_().endingStart){case ZeroSlopeEnding:// f'(t0) = 0
	iPrev=i1;tPrev=2*t0-t1;break;case WrapAroundEnding:// use the other end of the curve
	iPrev=pp.length-2;tPrev=t0+pp[iPrev]-pp[iPrev+1];break;default:// ZeroCurvatureEnding
	// f''(t0) = 0 a.k.a. Natural Spline
	iPrev=i1;tPrev=t1;}}if(tNext===undefined){switch(this.getSettings_().endingEnd){case ZeroSlopeEnding:// f'(tN) = 0
	iNext=i1;tNext=2*t1-t0;break;case WrapAroundEnding:// use the other end of the curve
	iNext=1;tNext=t1+pp[1]-pp[0];break;default:// ZeroCurvatureEnding
	// f''(tN) = 0, a.k.a. Natural Spline
	iNext=i1-1;tNext=t0;}}var halfDt=(t1-t0)*0.5,stride=this.valueSize;this._weightPrev=halfDt/(t0-tPrev);this._weightNext=halfDt/(tNext-t1);this._offsetPrev=iPrev*stride;this._offsetNext=iNext*stride;},interpolate_:function interpolate_(i1,t0,t,t1){var result=this.resultBuffer,values=this.sampleValues,stride=this.valueSize,o1=i1*stride,o0=o1-stride,oP=this._offsetPrev,oN=this._offsetNext,wP=this._weightPrev,wN=this._weightNext,p=(t-t0)/(t1-t0),pp=p*p,ppp=pp*p;// evaluate polynomials
	var sP=-wP*ppp+2*wP*pp-wP*p;var s0=(1+wP)*ppp+(-1.5-2*wP)*pp+(-0.5+wP)*p+1;var s1=(-1-wN)*ppp+(1.5+wN)*pp+0.5*p;var sN=wN*ppp-wN*pp;// combine data linearly
	for(var i=0;i!==stride;++i){result[i]=sP*values[oP+i]+s0*values[o0+i]+s1*values[o1+i]+sN*values[oN+i];}return result;}});/**
		 * @author tschw
		 */function LinearInterpolant(parameterPositions,sampleValues,sampleSize,resultBuffer){Interpolant.call(this,parameterPositions,sampleValues,sampleSize,resultBuffer);}LinearInterpolant.prototype=_assign(Object.create(Interpolant.prototype),{constructor:LinearInterpolant,interpolate_:function interpolate_(i1,t0,t,t1){var result=this.resultBuffer,values=this.sampleValues,stride=this.valueSize,offset1=i1*stride,offset0=offset1-stride,weight1=(t-t0)/(t1-t0),weight0=1-weight1;for(var i=0;i!==stride;++i){result[i]=values[offset0+i]*weight0+values[offset1+i]*weight1;}return result;}});/**
		 *
		 * Interpolant that evaluates to the sample value at the position preceeding
		 * the parameter.
		 *
		 * @author tschw
		 */function DiscreteInterpolant(parameterPositions,sampleValues,sampleSize,resultBuffer){Interpolant.call(this,parameterPositions,sampleValues,sampleSize,resultBuffer);}DiscreteInterpolant.prototype=_assign(Object.create(Interpolant.prototype),{constructor:DiscreteInterpolant,interpolate_:function interpolate_(i1,t0,t,t1){return this.copySampleValue_(i1-1);}});var KeyframeTrackPrototype;KeyframeTrackPrototype={TimeBufferType:Float32Array,ValueBufferType:Float32Array,DefaultInterpolation:InterpolateLinear,InterpolantFactoryMethodDiscrete:function InterpolantFactoryMethodDiscrete(result){return new DiscreteInterpolant(this.times,this.values,this.getValueSize(),result);},InterpolantFactoryMethodLinear:function InterpolantFactoryMethodLinear(result){return new LinearInterpolant(this.times,this.values,this.getValueSize(),result);},InterpolantFactoryMethodSmooth:function InterpolantFactoryMethodSmooth(result){return new CubicInterpolant(this.times,this.values,this.getValueSize(),result);},setInterpolation:function setInterpolation(interpolation){var factoryMethod;switch(interpolation){case InterpolateDiscrete:factoryMethod=this.InterpolantFactoryMethodDiscrete;break;case InterpolateLinear:factoryMethod=this.InterpolantFactoryMethodLinear;break;case InterpolateSmooth:factoryMethod=this.InterpolantFactoryMethodSmooth;break;}if(factoryMethod===undefined){var message="unsupported interpolation for "+this.ValueTypeName+" keyframe track named "+this.name;if(this.createInterpolant===undefined){// fall back to default, unless the default itself is messed up
	if(interpolation!==this.DefaultInterpolation){this.setInterpolation(this.DefaultInterpolation);}else{throw new Error(message);// fatal, in this case
	}}console.warn(message);return;}this.createInterpolant=factoryMethod;},getInterpolation:function getInterpolation(){switch(this.createInterpolant){case this.InterpolantFactoryMethodDiscrete:return InterpolateDiscrete;case this.InterpolantFactoryMethodLinear:return InterpolateLinear;case this.InterpolantFactoryMethodSmooth:return InterpolateSmooth;}},getValueSize:function getValueSize(){return this.values.length/this.times.length;},// move all keyframes either forwards or backwards in time
	shift:function shift(timeOffset){if(timeOffset!==0.0){var times=this.times;for(var i=0,n=times.length;i!==n;++i){times[i]+=timeOffset;}}return this;},// scale all keyframe times by a factor (useful for frame <-> seconds conversions)
	scale:function scale(timeScale){if(timeScale!==1.0){var times=this.times;for(var i=0,n=times.length;i!==n;++i){times[i]*=timeScale;}}return this;},// removes keyframes before and after animation without changing any values within the range [startTime, endTime].
	// IMPORTANT: We do not shift around keys to the start of the track time, because for interpolated keys this will change their values
	trim:function trim(startTime,endTime){var times=this.times,nKeys=times.length,from=0,to=nKeys-1;while(from!==nKeys&&times[from]<startTime){++from;}while(to!==-1&&times[to]>endTime){--to;}++to;// inclusive -> exclusive bound
	if(from!==0||to!==nKeys){// empty tracks are forbidden, so keep at least one keyframe
	if(from>=to)to=Math.max(to,1),from=to-1;var stride=this.getValueSize();this.times=AnimationUtils.arraySlice(times,from,to);this.values=AnimationUtils.arraySlice(this.values,from*stride,to*stride);}return this;},// ensure we do not get a GarbageInGarbageOut situation, make sure tracks are at least minimally viable
	validate:function validate(){var valid=true;var valueSize=this.getValueSize();if(valueSize-Math.floor(valueSize)!==0){console.error("invalid value size in track",this);valid=false;}var times=this.times,values=this.values,nKeys=times.length;if(nKeys===0){console.error("track is empty",this);valid=false;}var prevTime=null;for(var i=0;i!==nKeys;i++){var currTime=times[i];if(typeof currTime==='number'&&isNaN(currTime)){console.error("time is not a valid number",this,i,currTime);valid=false;break;}if(prevTime!==null&&prevTime>currTime){console.error("out of order keys",this,i,currTime,prevTime);valid=false;break;}prevTime=currTime;}if(values!==undefined){if(AnimationUtils.isTypedArray(values)){for(var i=0,n=values.length;i!==n;++i){var value=values[i];if(isNaN(value)){console.error("value is not a valid number",this,i,value);valid=false;break;}}}}return valid;},// removes equivalent sequential keys as common in morph target sequences
	// (0,0,0,0,1,1,1,0,0,0,0,0,0,0) --> (0,0,1,1,0,0)
	optimize:function optimize(){var times=this.times,values=this.values,stride=this.getValueSize(),smoothInterpolation=this.getInterpolation()===InterpolateSmooth,writeIndex=1,lastIndex=times.length-1;for(var i=1;i<lastIndex;++i){var keep=false;var time=times[i];var timeNext=times[i+1];// remove adjacent keyframes scheduled at the same time
	if(time!==timeNext&&(i!==1||time!==time[0])){if(!smoothInterpolation){// remove unnecessary keyframes same as their neighbors
	var offset=i*stride,offsetP=offset-stride,offsetN=offset+stride;for(var j=0;j!==stride;++j){var value=values[offset+j];if(value!==values[offsetP+j]||value!==values[offsetN+j]){keep=true;break;}}}else keep=true;}// in-place compaction
	if(keep){if(i!==writeIndex){times[writeIndex]=times[i];var readOffset=i*stride,writeOffset=writeIndex*stride;for(var j=0;j!==stride;++j){values[writeOffset+j]=values[readOffset+j];}}++writeIndex;}}// flush last keyframe (compaction looks ahead)
	if(lastIndex>0){times[writeIndex]=times[lastIndex];for(var readOffset=lastIndex*stride,writeOffset=writeIndex*stride,j=0;j!==stride;++j){values[writeOffset+j]=values[readOffset+j];}++writeIndex;}if(writeIndex!==times.length){this.times=AnimationUtils.arraySlice(times,0,writeIndex);this.values=AnimationUtils.arraySlice(values,0,writeIndex*stride);}return this;}};function KeyframeTrackConstructor(name,times,values,interpolation){if(name===undefined)throw new Error("track name is undefined");if(times===undefined||times.length===0){throw new Error("no keyframes in track named "+name);}this.name=name;this.times=AnimationUtils.convertArray(times,this.TimeBufferType);this.values=AnimationUtils.convertArray(values,this.ValueBufferType);this.setInterpolation(interpolation||this.DefaultInterpolation);this.validate();this.optimize();}/**
		 *
		 * A Track of vectored keyframe values.
		 *
		 *
		 * @author Ben Houston / http://clara.io/
		 * @author David Sarno / http://lighthaus.us/
		 * @author tschw
		 */function VectorKeyframeTrack(name,times,values,interpolation){KeyframeTrackConstructor.call(this,name,times,values,interpolation);}VectorKeyframeTrack.prototype=_assign(Object.create(KeyframeTrackPrototype),{constructor:VectorKeyframeTrack,ValueTypeName:'vector'// ValueBufferType is inherited
	// DefaultInterpolation is inherited
	});/**
		 * Spherical linear unit quaternion interpolant.
		 *
		 * @author tschw
		 */function QuaternionLinearInterpolant(parameterPositions,sampleValues,sampleSize,resultBuffer){Interpolant.call(this,parameterPositions,sampleValues,sampleSize,resultBuffer);}QuaternionLinearInterpolant.prototype=_assign(Object.create(Interpolant.prototype),{constructor:QuaternionLinearInterpolant,interpolate_:function interpolate_(i1,t0,t,t1){var result=this.resultBuffer,values=this.sampleValues,stride=this.valueSize,offset=i1*stride,alpha=(t-t0)/(t1-t0);for(var end=offset+stride;offset!==end;offset+=4){Quaternion.slerpFlat(result,0,values,offset-stride,values,offset,alpha);}return result;}});/**
		 *
		 * A Track of quaternion keyframe values.
		 *
		 * @author Ben Houston / http://clara.io/
		 * @author David Sarno / http://lighthaus.us/
		 * @author tschw
		 */function QuaternionKeyframeTrack(name,times,values,interpolation){KeyframeTrackConstructor.call(this,name,times,values,interpolation);}QuaternionKeyframeTrack.prototype=_assign(Object.create(KeyframeTrackPrototype),{constructor:QuaternionKeyframeTrack,ValueTypeName:'quaternion',// ValueBufferType is inherited
	DefaultInterpolation:InterpolateLinear,InterpolantFactoryMethodLinear:function InterpolantFactoryMethodLinear(result){return new QuaternionLinearInterpolant(this.times,this.values,this.getValueSize(),result);},InterpolantFactoryMethodSmooth:undefined// not yet implemented
	});/**
		 *
		 * A Track of numeric keyframe values.
		 *
		 * @author Ben Houston / http://clara.io/
		 * @author David Sarno / http://lighthaus.us/
		 * @author tschw
		 */function NumberKeyframeTrack(name,times,values,interpolation){KeyframeTrackConstructor.call(this,name,times,values,interpolation);}NumberKeyframeTrack.prototype=_assign(Object.create(KeyframeTrackPrototype),{constructor:NumberKeyframeTrack,ValueTypeName:'number'// ValueBufferType is inherited
	// DefaultInterpolation is inherited
	});/**
		 *
		 * A Track that interpolates Strings
		 *
		 *
		 * @author Ben Houston / http://clara.io/
		 * @author David Sarno / http://lighthaus.us/
		 * @author tschw
		 */function StringKeyframeTrack(name,times,values,interpolation){KeyframeTrackConstructor.call(this,name,times,values,interpolation);}StringKeyframeTrack.prototype=_assign(Object.create(KeyframeTrackPrototype),{constructor:StringKeyframeTrack,ValueTypeName:'string',ValueBufferType:Array,DefaultInterpolation:InterpolateDiscrete,InterpolantFactoryMethodLinear:undefined,InterpolantFactoryMethodSmooth:undefined});/**
		 *
		 * A Track of Boolean keyframe values.
		 *
		 *
		 * @author Ben Houston / http://clara.io/
		 * @author David Sarno / http://lighthaus.us/
		 * @author tschw
		 */function BooleanKeyframeTrack(name,times,values){KeyframeTrackConstructor.call(this,name,times,values);}BooleanKeyframeTrack.prototype=_assign(Object.create(KeyframeTrackPrototype),{constructor:BooleanKeyframeTrack,ValueTypeName:'bool',ValueBufferType:Array,DefaultInterpolation:InterpolateDiscrete,InterpolantFactoryMethodLinear:undefined,InterpolantFactoryMethodSmooth:undefined// Note: Actually this track could have a optimized / compressed
	// representation of a single value and a custom interpolant that
	// computes "firstValue ^ isOdd( index )".
	});/**
		 *
		 * A Track of keyframe values that represent color.
		 *
		 *
		 * @author Ben Houston / http://clara.io/
		 * @author David Sarno / http://lighthaus.us/
		 * @author tschw
		 */function ColorKeyframeTrack(name,times,values,interpolation){KeyframeTrackConstructor.call(this,name,times,values,interpolation);}ColorKeyframeTrack.prototype=_assign(Object.create(KeyframeTrackPrototype),{constructor:ColorKeyframeTrack,ValueTypeName:'color'// ValueBufferType is inherited
	// DefaultInterpolation is inherited
	// Note: Very basic implementation and nothing special yet.
	// However, this is the place for color space parameterization.
	});/**
		 *
		 * A timed sequence of keyframes for a specific property.
		 *
		 *
		 * @author Ben Houston / http://clara.io/
		 * @author David Sarno / http://lighthaus.us/
		 * @author tschw
		 */function KeyframeTrack(name,times,values,interpolation){KeyframeTrackConstructor.apply(this,arguments);}KeyframeTrack.prototype=KeyframeTrackPrototype;KeyframeTrackPrototype.constructor=KeyframeTrack;// Static methods:
	_assign(KeyframeTrack,{// Serialization (in static context, because of constructor invocation
	// and automatic invocation of .toJSON):
	parse:function parse(json){if(json.type===undefined){throw new Error("track type undefined, can not parse");}var trackType=KeyframeTrack._getTrackTypeForValueTypeName(json.type);if(json.times===undefined){var times=[],values=[];AnimationUtils.flattenJSON(json.keys,times,values,'value');json.times=times;json.values=values;}// derived classes can define a static parse method
	if(trackType.parse!==undefined){return trackType.parse(json);}else{// by default, we asssume a constructor compatible with the base
	return new trackType(json.name,json.times,json.values,json.interpolation);}},toJSON:function toJSON(track){var trackType=track.constructor;var json;// derived classes can define a static toJSON method
	if(trackType.toJSON!==undefined){json=trackType.toJSON(track);}else{// by default, we assume the data can be serialized as-is
	json={'name':track.name,'times':AnimationUtils.convertArray(track.times,Array),'values':AnimationUtils.convertArray(track.values,Array)};var interpolation=track.getInterpolation();if(interpolation!==track.DefaultInterpolation){json.interpolation=interpolation;}}json.type=track.ValueTypeName;// mandatory
	return json;},_getTrackTypeForValueTypeName:function _getTrackTypeForValueTypeName(typeName){switch(typeName.toLowerCase()){case"scalar":case"double":case"float":case"number":case"integer":return NumberKeyframeTrack;case"vector":case"vector2":case"vector3":case"vector4":return VectorKeyframeTrack;case"color":return ColorKeyframeTrack;case"quaternion":return QuaternionKeyframeTrack;case"bool":case"boolean":return BooleanKeyframeTrack;case"string":return StringKeyframeTrack;}throw new Error("Unsupported typeName: "+typeName);}});/**
		 *
		 * Reusable set of Tracks that represent an animation.
		 *
		 * @author Ben Houston / http://clara.io/
		 * @author David Sarno / http://lighthaus.us/
		 */function AnimationClip(name,duration,tracks){this.name=name;this.tracks=tracks;this.duration=duration!==undefined?duration:-1;this.uuid=_Math.generateUUID();// this means it should figure out its duration by scanning the tracks
	if(this.duration<0){this.resetDuration();}this.optimize();}_assign(AnimationClip,{parse:function parse(json){var tracks=[],jsonTracks=json.tracks,frameTime=1.0/(json.fps||1.0);for(var i=0,n=jsonTracks.length;i!==n;++i){tracks.push(KeyframeTrack.parse(jsonTracks[i]).scale(frameTime));}return new AnimationClip(json.name,json.duration,tracks);},toJSON:function toJSON(clip){var tracks=[],clipTracks=clip.tracks;var json={'name':clip.name,'duration':clip.duration,'tracks':tracks};for(var i=0,n=clipTracks.length;i!==n;++i){tracks.push(KeyframeTrack.toJSON(clipTracks[i]));}return json;},CreateFromMorphTargetSequence:function CreateFromMorphTargetSequence(name,morphTargetSequence,fps,noLoop){var numMorphTargets=morphTargetSequence.length;var tracks=[];for(var i=0;i<numMorphTargets;i++){var times=[];var values=[];times.push((i+numMorphTargets-1)%numMorphTargets,i,(i+1)%numMorphTargets);values.push(0,1,0);var order=AnimationUtils.getKeyframeOrder(times);times=AnimationUtils.sortedArray(times,1,order);values=AnimationUtils.sortedArray(values,1,order);// if there is a key at the first frame, duplicate it as the
	// last frame as well for perfect loop.
	if(!noLoop&&times[0]===0){times.push(numMorphTargets);values.push(values[0]);}tracks.push(new NumberKeyframeTrack('.morphTargetInfluences['+morphTargetSequence[i].name+']',times,values).scale(1.0/fps));}return new AnimationClip(name,-1,tracks);},findByName:function findByName(objectOrClipArray,name){var clipArray=objectOrClipArray;if(!Array.isArray(objectOrClipArray)){var o=objectOrClipArray;clipArray=o.geometry&&o.geometry.animations||o.animations;}for(var i=0;i<clipArray.length;i++){if(clipArray[i].name===name){return clipArray[i];}}return null;},CreateClipsFromMorphTargetSequences:function CreateClipsFromMorphTargetSequences(morphTargets,fps,noLoop){var animationToMorphTargets={};// tested with https://regex101.com/ on trick sequences
	// such flamingo_flyA_003, flamingo_run1_003, crdeath0059
	var pattern=/^([\w-]*?)([\d]+)$/;// sort morph target names into animation groups based
	// patterns like Walk_001, Walk_002, Run_001, Run_002
	for(var i=0,il=morphTargets.length;i<il;i++){var morphTarget=morphTargets[i];var parts=morphTarget.name.match(pattern);if(parts&&parts.length>1){var name=parts[1];var animationMorphTargets=animationToMorphTargets[name];if(!animationMorphTargets){animationToMorphTargets[name]=animationMorphTargets=[];}animationMorphTargets.push(morphTarget);}}var clips=[];for(var name in animationToMorphTargets){clips.push(AnimationClip.CreateFromMorphTargetSequence(name,animationToMorphTargets[name],fps,noLoop));}return clips;},// parse the animation.hierarchy format
	parseAnimation:function parseAnimation(animation,bones){if(!animation){console.error("  no animation in JSONLoader data");return null;}var addNonemptyTrack=function addNonemptyTrack(trackType,trackName,animationKeys,propertyName,destTracks){// only return track if there are actually keys.
	if(animationKeys.length!==0){var times=[];var values=[];AnimationUtils.flattenJSON(animationKeys,times,values,propertyName);// empty keys are filtered out, so check again
	if(times.length!==0){destTracks.push(new trackType(trackName,times,values));}}};var tracks=[];var clipName=animation.name||'default';// automatic length determination in AnimationClip.
	var duration=animation.length||-1;var fps=animation.fps||30;var hierarchyTracks=animation.hierarchy||[];for(var h=0;h<hierarchyTracks.length;h++){var animationKeys=hierarchyTracks[h].keys;// skip empty tracks
	if(!animationKeys||animationKeys.length===0)continue;// process morph targets in a way exactly compatible
	// with AnimationHandler.init( animation )
	if(animationKeys[0].morphTargets){// figure out all morph targets used in this track
	var morphTargetNames={};for(var k=0;k<animationKeys.length;k++){if(animationKeys[k].morphTargets){for(var m=0;m<animationKeys[k].morphTargets.length;m++){morphTargetNames[animationKeys[k].morphTargets[m]]=-1;}}}// create a track for each morph target with all zero
	// morphTargetInfluences except for the keys in which
	// the morphTarget is named.
	for(var morphTargetName in morphTargetNames){var times=[];var values=[];for(var m=0;m!==animationKeys[k].morphTargets.length;++m){var animationKey=animationKeys[k];times.push(animationKey.time);values.push(animationKey.morphTarget===morphTargetName?1:0);}tracks.push(new NumberKeyframeTrack('.morphTargetInfluence['+morphTargetName+']',times,values));}duration=morphTargetNames.length*(fps||1.0);}else{// ...assume skeletal animation
	var boneName='.bones['+bones[h].name+']';addNonemptyTrack(VectorKeyframeTrack,boneName+'.position',animationKeys,'pos',tracks);addNonemptyTrack(QuaternionKeyframeTrack,boneName+'.quaternion',animationKeys,'rot',tracks);addNonemptyTrack(VectorKeyframeTrack,boneName+'.scale',animationKeys,'scl',tracks);}}if(tracks.length===0){return null;}var clip=new AnimationClip(clipName,duration,tracks);return clip;}});_assign(AnimationClip.prototype,{resetDuration:function resetDuration(){var tracks=this.tracks,duration=0;for(var i=0,n=tracks.length;i!==n;++i){var track=this.tracks[i];duration=Math.max(duration,track.times[track.times.length-1]);}this.duration=duration;},trim:function trim(){for(var i=0;i<this.tracks.length;i++){this.tracks[i].trim(0,this.duration);}return this;},optimize:function optimize(){for(var i=0;i<this.tracks.length;i++){this.tracks[i].optimize();}return this;}});/**
		 * @author mrdoob / http://mrdoob.com/
		 * @author alteredq / http://alteredqualia.com/
		 */function JSONLoader(manager){if(typeof manager==='boolean'){console.warn('THREE.JSONLoader: showStatus parameter has been removed from constructor.');manager=undefined;}this.manager=manager!==undefined?manager:DefaultLoadingManager;this.withCredentials=false;}_assign(JSONLoader.prototype,{load:function load(url,onLoad,onProgress,onError){var scope=this;var texturePath=this.texturePath&&typeof this.texturePath==="string"?this.texturePath:Loader.prototype.extractUrlBase(url);var loader=new FileLoader(this.manager);loader.setResponseType('json');loader.setWithCredentials(this.withCredentials);loader.load(url,function(json){var metadata=json.metadata;if(metadata!==undefined){var type=metadata.type;if(type!==undefined){if(type.toLowerCase()==='object'){console.error('THREE.JSONLoader: '+url+' should be loaded with THREE.ObjectLoader instead.');return;}if(type.toLowerCase()==='scene'){console.error('THREE.JSONLoader: '+url+' should be loaded with THREE.SceneLoader instead.');return;}}}var object=scope.parse(json,texturePath);onLoad(object.geometry,object.materials);},onProgress,onError);},setTexturePath:function setTexturePath(value){this.texturePath=value;},parse:function(){function parseModel(json,geometry){function isBitSet(value,position){return value&1<<position;}var i,j,fi,offset,zLength,colorIndex,normalIndex,uvIndex,materialIndex,type,isQuad,hasMaterial,hasFaceVertexUv,hasFaceNormal,hasFaceVertexNormal,hasFaceColor,hasFaceVertexColor,vertex,face,faceA,faceB,hex,normal,uvLayer,uv,u,v,faces=json.faces,vertices=json.vertices,normals=json.normals,colors=json.colors,scale=json.scale,nUvLayers=0;if(json.uvs!==undefined){// disregard empty arrays
	for(i=0;i<json.uvs.length;i++){if(json.uvs[i].length)nUvLayers++;}for(i=0;i<nUvLayers;i++){geometry.faceVertexUvs[i]=[];}}offset=0;zLength=vertices.length;while(offset<zLength){vertex=new Vector3();vertex.x=vertices[offset++]*scale;vertex.y=vertices[offset++]*scale;vertex.z=vertices[offset++]*scale;geometry.vertices.push(vertex);}offset=0;zLength=faces.length;while(offset<zLength){type=faces[offset++];isQuad=isBitSet(type,0);hasMaterial=isBitSet(type,1);hasFaceVertexUv=isBitSet(type,3);hasFaceNormal=isBitSet(type,4);hasFaceVertexNormal=isBitSet(type,5);hasFaceColor=isBitSet(type,6);hasFaceVertexColor=isBitSet(type,7);// console.log("type", type, "bits", isQuad, hasMaterial, hasFaceVertexUv, hasFaceNormal, hasFaceVertexNormal, hasFaceColor, hasFaceVertexColor);
	if(isQuad){faceA=new Face3();faceA.a=faces[offset];faceA.b=faces[offset+1];faceA.c=faces[offset+3];faceB=new Face3();faceB.a=faces[offset+1];faceB.b=faces[offset+2];faceB.c=faces[offset+3];offset+=4;if(hasMaterial){materialIndex=faces[offset++];faceA.materialIndex=materialIndex;faceB.materialIndex=materialIndex;}// to get face <=> uv index correspondence
	fi=geometry.faces.length;if(hasFaceVertexUv){for(i=0;i<nUvLayers;i++){uvLayer=json.uvs[i];geometry.faceVertexUvs[i][fi]=[];geometry.faceVertexUvs[i][fi+1]=[];for(j=0;j<4;j++){uvIndex=faces[offset++];u=uvLayer[uvIndex*2];v=uvLayer[uvIndex*2+1];uv=new Vector2(u,v);if(j!==2)geometry.faceVertexUvs[i][fi].push(uv);if(j!==0)geometry.faceVertexUvs[i][fi+1].push(uv);}}}if(hasFaceNormal){normalIndex=faces[offset++]*3;faceA.normal.set(normals[normalIndex++],normals[normalIndex++],normals[normalIndex]);faceB.normal.copy(faceA.normal);}if(hasFaceVertexNormal){for(i=0;i<4;i++){normalIndex=faces[offset++]*3;normal=new Vector3(normals[normalIndex++],normals[normalIndex++],normals[normalIndex]);if(i!==2)faceA.vertexNormals.push(normal);if(i!==0)faceB.vertexNormals.push(normal);}}if(hasFaceColor){colorIndex=faces[offset++];hex=colors[colorIndex];faceA.color.setHex(hex);faceB.color.setHex(hex);}if(hasFaceVertexColor){for(i=0;i<4;i++){colorIndex=faces[offset++];hex=colors[colorIndex];if(i!==2)faceA.vertexColors.push(new Color(hex));if(i!==0)faceB.vertexColors.push(new Color(hex));}}geometry.faces.push(faceA);geometry.faces.push(faceB);}else{face=new Face3();face.a=faces[offset++];face.b=faces[offset++];face.c=faces[offset++];if(hasMaterial){materialIndex=faces[offset++];face.materialIndex=materialIndex;}// to get face <=> uv index correspondence
	fi=geometry.faces.length;if(hasFaceVertexUv){for(i=0;i<nUvLayers;i++){uvLayer=json.uvs[i];geometry.faceVertexUvs[i][fi]=[];for(j=0;j<3;j++){uvIndex=faces[offset++];u=uvLayer[uvIndex*2];v=uvLayer[uvIndex*2+1];uv=new Vector2(u,v);geometry.faceVertexUvs[i][fi].push(uv);}}}if(hasFaceNormal){normalIndex=faces[offset++]*3;face.normal.set(normals[normalIndex++],normals[normalIndex++],normals[normalIndex]);}if(hasFaceVertexNormal){for(i=0;i<3;i++){normalIndex=faces[offset++]*3;normal=new Vector3(normals[normalIndex++],normals[normalIndex++],normals[normalIndex]);face.vertexNormals.push(normal);}}if(hasFaceColor){colorIndex=faces[offset++];face.color.setHex(colors[colorIndex]);}if(hasFaceVertexColor){for(i=0;i<3;i++){colorIndex=faces[offset++];face.vertexColors.push(new Color(colors[colorIndex]));}}geometry.faces.push(face);}}}function parseSkin(json,geometry){var influencesPerVertex=json.influencesPerVertex!==undefined?json.influencesPerVertex:2;if(json.skinWeights){for(var i=0,l=json.skinWeights.length;i<l;i+=influencesPerVertex){var x=json.skinWeights[i];var y=influencesPerVertex>1?json.skinWeights[i+1]:0;var z=influencesPerVertex>2?json.skinWeights[i+2]:0;var w=influencesPerVertex>3?json.skinWeights[i+3]:0;geometry.skinWeights.push(new Vector4(x,y,z,w));}}if(json.skinIndices){for(var i=0,l=json.skinIndices.length;i<l;i+=influencesPerVertex){var a=json.skinIndices[i];var b=influencesPerVertex>1?json.skinIndices[i+1]:0;var c=influencesPerVertex>2?json.skinIndices[i+2]:0;var d=influencesPerVertex>3?json.skinIndices[i+3]:0;geometry.skinIndices.push(new Vector4(a,b,c,d));}}geometry.bones=json.bones;if(geometry.bones&&geometry.bones.length>0&&(geometry.skinWeights.length!==geometry.skinIndices.length||geometry.skinIndices.length!==geometry.vertices.length)){console.warn('When skinning, number of vertices ('+geometry.vertices.length+'), skinIndices ('+geometry.skinIndices.length+'), and skinWeights ('+geometry.skinWeights.length+') should match.');}}function parseMorphing(json,geometry){var scale=json.scale;if(json.morphTargets!==undefined){for(var i=0,l=json.morphTargets.length;i<l;i++){geometry.morphTargets[i]={};geometry.morphTargets[i].name=json.morphTargets[i].name;geometry.morphTargets[i].vertices=[];var dstVertices=geometry.morphTargets[i].vertices;var srcVertices=json.morphTargets[i].vertices;for(var v=0,vl=srcVertices.length;v<vl;v+=3){var vertex=new Vector3();vertex.x=srcVertices[v]*scale;vertex.y=srcVertices[v+1]*scale;vertex.z=srcVertices[v+2]*scale;dstVertices.push(vertex);}}}if(json.morphColors!==undefined&&json.morphColors.length>0){console.warn('THREE.JSONLoader: "morphColors" no longer supported. Using them as face colors.');var faces=geometry.faces;var morphColors=json.morphColors[0].colors;for(var i=0,l=faces.length;i<l;i++){faces[i].color.fromArray(morphColors,i*3);}}}function parseAnimations(json,geometry){var outputAnimations=[];// parse old style Bone/Hierarchy animations
	var animations=[];if(json.animation!==undefined){animations.push(json.animation);}if(json.animations!==undefined){if(json.animations.length){animations=animations.concat(json.animations);}else{animations.push(json.animations);}}for(var i=0;i<animations.length;i++){var clip=AnimationClip.parseAnimation(animations[i],geometry.bones);if(clip)outputAnimations.push(clip);}// parse implicit morph animations
	if(geometry.morphTargets){// TODO: Figure out what an appropraite FPS is for morph target animations -- defaulting to 10, but really it is completely arbitrary.
	var morphAnimationClips=AnimationClip.CreateClipsFromMorphTargetSequences(geometry.morphTargets,10);outputAnimations=outputAnimations.concat(morphAnimationClips);}if(outputAnimations.length>0)geometry.animations=outputAnimations;}return function(json,texturePath){if(json.data!==undefined){// Geometry 4.0 spec
	json=json.data;}if(json.scale!==undefined){json.scale=1.0/json.scale;}else{json.scale=1.0;}var geometry=new Geometry();parseModel(json,geometry);parseSkin(json,geometry);parseMorphing(json,geometry);parseAnimations(json,geometry);geometry.computeFaceNormals();geometry.computeBoundingSphere();if(json.materials===undefined||json.materials.length===0){return{geometry:geometry};}else{var materials=Loader.prototype.initMaterials(json.materials,texturePath,this.crossOrigin);return{geometry:geometry,materials:materials};}};}()});/**
		 * @author mrdoob / http://mrdoob.com/
		 * @author alteredq / http://alteredqualia.com/
		 */function Light(color,intensity){Object3D.call(this);this.type='Light';this.color=new Color(color);this.intensity=intensity!==undefined?intensity:1;this.receiveShadow=undefined;}Light.prototype=_assign(Object.create(Object3D.prototype),{constructor:Light,isLight:true,copy:function copy(source){Object3D.prototype.copy.call(this,source);this.color.copy(source.color);this.intensity=source.intensity;return this;},toJSON:function toJSON(meta){var data=Object3D.prototype.toJSON.call(this,meta);data.object.color=this.color.getHex();data.object.intensity=this.intensity;if(this.groundColor!==undefined)data.object.groundColor=this.groundColor.getHex();if(this.distance!==undefined)data.object.distance=this.distance;if(this.angle!==undefined)data.object.angle=this.angle;if(this.decay!==undefined)data.object.decay=this.decay;if(this.penumbra!==undefined)data.object.penumbra=this.penumbra;if(this.shadow!==undefined)data.object.shadow=this.shadow.toJSON();return data;}});/**
		 * @author alteredq / http://alteredqualia.com/
		 */function HemisphereLight(skyColor,groundColor,intensity){Light.call(this,skyColor,intensity);this.type='HemisphereLight';this.castShadow=undefined;this.position.copy(Object3D.DefaultUp);this.updateMatrix();this.groundColor=new Color(groundColor);}HemisphereLight.prototype=_assign(Object.create(Light.prototype),{constructor:HemisphereLight,isHemisphereLight:true,copy:function copy(source){Light.prototype.copy.call(this,source);this.groundColor.copy(source.groundColor);return this;}});/**
		 * @author mrdoob / http://mrdoob.com/
		 */function LightShadow(camera){this.camera=camera;this.bias=0;this.radius=1;this.mapSize=new Vector2(512,512);this.map=null;this.matrix=new Matrix4();}_assign(LightShadow.prototype,{copy:function copy(source){this.camera=source.camera.clone();this.bias=source.bias;this.radius=source.radius;this.mapSize.copy(source.mapSize);return this;},clone:function clone(){return new this.constructor().copy(this);},toJSON:function toJSON(){var object={};if(this.bias!==0)object.bias=this.bias;if(this.radius!==1)object.radius=this.radius;if(this.mapSize.x!==512||this.mapSize.y!==512)object.mapSize=this.mapSize.toArray();object.camera=this.camera.toJSON(false).object;delete object.camera.matrix;return object;}});/**
		 * @author mrdoob / http://mrdoob.com/
		 */function DirectionalLightShadow(){LightShadow.call(this,new OrthographicCamera(-5,5,5,-5,0.5,500));}DirectionalLightShadow.prototype=_assign(Object.create(LightShadow.prototype),{constructor:DirectionalLightShadow});/**
		 * @author mrdoob / http://mrdoob.com/
		 * @author alteredq / http://alteredqualia.com/
		 */function DirectionalLight(color,intensity){Light.call(this,color,intensity);this.type='DirectionalLight';this.position.copy(Object3D.DefaultUp);this.updateMatrix();this.target=new Object3D();this.shadow=new DirectionalLightShadow();}DirectionalLight.prototype=_assign(Object.create(Light.prototype),{constructor:DirectionalLight,isDirectionalLight:true,copy:function copy(source){Light.prototype.copy.call(this,source);this.target=source.target.clone();this.shadow=source.shadow.clone();return this;}});/**
		 * @author mrdoob / http://mrdoob.com/
		 */function Uniform(value){if(typeof value==='string'){console.warn('THREE.Uniform: Type parameter is no longer needed.');value=arguments[1];}this.value=value;}Uniform.prototype.clone=function(){return new Uniform(this.value.clone===undefined?this.value:this.value.clone());};/**
		 * @author mrdoob / http://mrdoob.com/
		 * @author bhouston / http://clara.io/
		 * @author stephomi / http://stephaneginier.com/
		 */function Raycaster(origin,direction,near,far){this.ray=new Ray(origin,direction);// direction is assumed to be normalized (for accurate distance calculations)
	this.near=near||0;this.far=far||Infinity;this.params={Mesh:{},Line:{},LOD:{},Points:{threshold:1},Sprite:{}};Object.defineProperties(this.params,{PointCloud:{get:function get(){console.warn('THREE.Raycaster: params.PointCloud has been renamed to params.Points.');return this.Points;}}});}function ascSort(a,b){return a.distance-b.distance;}function _intersectObject(object,raycaster,intersects,recursive){if(object.visible===false)return;object.raycast(raycaster,intersects);if(recursive===true){var children=object.children;for(var i=0,l=children.length;i<l;i++){_intersectObject(children[i],raycaster,intersects,true);}}}_assign(Raycaster.prototype,{linePrecision:1,set:function set(origin,direction){// direction is assumed to be normalized (for accurate distance calculations)
	this.ray.set(origin,direction);},setFromCamera:function setFromCamera(coords,camera){if(camera&&camera.isPerspectiveCamera){this.ray.origin.setFromMatrixPosition(camera.matrixWorld);this.ray.direction.set(coords.x,coords.y,0.5).unproject(camera).sub(this.ray.origin).normalize();}else if(camera&&camera.isOrthographicCamera){this.ray.origin.set(coords.x,coords.y,(camera.near+camera.far)/(camera.near-camera.far)).unproject(camera);// set origin in plane of camera
	this.ray.direction.set(0,0,-1).transformDirection(camera.matrixWorld);}else{console.error('THREE.Raycaster: Unsupported camera type.');}},intersectObject:function intersectObject(object,recursive){var intersects=[];_intersectObject(object,this,intersects,recursive);intersects.sort(ascSort);return intersects;},intersectObjects:function intersectObjects(objects,recursive){var intersects=[];if(Array.isArray(objects)===false){console.warn('THREE.Raycaster.intersectObjects: objects is not an Array.');return intersects;}for(var i=0,l=objects.length;i<l;i++){_intersectObject(objects[i],this,intersects,recursive);}intersects.sort(ascSort);return intersects;}});/**
		 * @author alteredq / http://alteredqualia.com/
		 */function Clock(autoStart){this.autoStart=autoStart!==undefined?autoStart:true;this.startTime=0;this.oldTime=0;this.elapsedTime=0;this.running=false;}_assign(Clock.prototype,{start:function start(){this.startTime=(typeof performance==='undefined'?Date:performance).now();// see #10732
	this.oldTime=this.startTime;this.elapsedTime=0;this.running=true;},stop:function stop(){this.getElapsedTime();this.running=false;},getElapsedTime:function getElapsedTime(){this.getDelta();return this.elapsedTime;},getDelta:function getDelta(){var diff=0;if(this.autoStart&&!this.running){this.start();return 0;}if(this.running){var newTime=(typeof performance==='undefined'?Date:performance).now();diff=(newTime-this.oldTime)/1000;this.oldTime=newTime;this.elapsedTime+=diff;}return diff;}});/**
		 * @author bhouston / http://clara.io
		 * @author WestLangley / http://github.com/WestLangley
		 *
		 * Ref: https://en.wikipedia.org/wiki/Spherical_coordinate_system
		 *
		 * The poles (phi) are at the positive and negative y axis.
		 * The equator starts at positive z.
		 */function Spherical(radius,phi,theta){this.radius=radius!==undefined?radius:1.0;this.phi=phi!==undefined?phi:0;// up / down towards top and bottom pole
	this.theta=theta!==undefined?theta:0;// around the equator of the sphere
	return this;}_assign(Spherical.prototype,{set:function set(radius,phi,theta){this.radius=radius;this.phi=phi;this.theta=theta;return this;},clone:function clone(){return new this.constructor().copy(this);},copy:function copy(other){this.radius=other.radius;this.phi=other.phi;this.theta=other.theta;return this;},// restrict phi to be betwee EPS and PI-EPS
	makeSafe:function makeSafe(){var EPS=0.000001;this.phi=Math.max(EPS,Math.min(Math.PI-EPS,this.phi));return this;},setFromVector3:function setFromVector3(vec3){this.radius=vec3.length();if(this.radius===0){this.theta=0;this.phi=0;}else{this.theta=Math.atan2(vec3.x,vec3.z);// equator angle around y-up axis
	this.phi=Math.acos(_Math.clamp(vec3.y/this.radius,-1,1));// polar angle
	}return this;}});/**
		 * @author bhouston / http://clara.io
		 */function Box2(min,max){this.min=min!==undefined?min:new Vector2(+Infinity,+Infinity);this.max=max!==undefined?max:new Vector2(-Infinity,-Infinity);}_assign(Box2.prototype,{set:function set(min,max){this.min.copy(min);this.max.copy(max);return this;},setFromPoints:function setFromPoints(points){this.makeEmpty();for(var i=0,il=points.length;i<il;i++){this.expandByPoint(points[i]);}return this;},setFromCenterAndSize:function(){var v1=new Vector2();return function setFromCenterAndSize(center,size){var halfSize=v1.copy(size).multiplyScalar(0.5);this.min.copy(center).sub(halfSize);this.max.copy(center).add(halfSize);return this;};}(),clone:function clone(){return new this.constructor().copy(this);},copy:function copy(box){this.min.copy(box.min);this.max.copy(box.max);return this;},makeEmpty:function makeEmpty(){this.min.x=this.min.y=+Infinity;this.max.x=this.max.y=-Infinity;return this;},isEmpty:function isEmpty(){// this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes
	return this.max.x<this.min.x||this.max.y<this.min.y;},getCenter:function getCenter(optionalTarget){var result=optionalTarget||new Vector2();return this.isEmpty()?result.set(0,0):result.addVectors(this.min,this.max).multiplyScalar(0.5);},getSize:function getSize(optionalTarget){var result=optionalTarget||new Vector2();return this.isEmpty()?result.set(0,0):result.subVectors(this.max,this.min);},expandByPoint:function expandByPoint(point){this.min.min(point);this.max.max(point);return this;},expandByVector:function expandByVector(vector){this.min.sub(vector);this.max.add(vector);return this;},expandByScalar:function expandByScalar(scalar){this.min.addScalar(-scalar);this.max.addScalar(scalar);return this;},containsPoint:function containsPoint(point){return point.x<this.min.x||point.x>this.max.x||point.y<this.min.y||point.y>this.max.y?false:true;},containsBox:function containsBox(box){return this.min.x<=box.min.x&&box.max.x<=this.max.x&&this.min.y<=box.min.y&&box.max.y<=this.max.y;},getParameter:function getParameter(point,optionalTarget){// This can potentially have a divide by zero if the box
	// has a size dimension of 0.
	var result=optionalTarget||new Vector2();return result.set((point.x-this.min.x)/(this.max.x-this.min.x),(point.y-this.min.y)/(this.max.y-this.min.y));},intersectsBox:function intersectsBox(box){// using 4 splitting planes to rule out intersections
	return box.max.x<this.min.x||box.min.x>this.max.x||box.max.y<this.min.y||box.min.y>this.max.y?false:true;},clampPoint:function clampPoint(point,optionalTarget){var result=optionalTarget||new Vector2();return result.copy(point).clamp(this.min,this.max);},distanceToPoint:function(){var v1=new Vector2();return function distanceToPoint(point){var clampedPoint=v1.copy(point).clamp(this.min,this.max);return clampedPoint.sub(point).length();};}(),intersect:function intersect(box){this.min.max(box.min);this.max.min(box.max);return this;},union:function union(box){this.min.min(box.min);this.max.max(box.max);return this;},translate:function translate(offset){this.min.add(offset);this.max.add(offset);return this;},equals:function equals(box){return box.min.equals(this.min)&&box.max.equals(this.max);}});/**
		 * @author zz85 / http://www.lab4games.net/zz85/blog
		 * Extensible curve object
		 *
		 * Some common of curve methods:
		 * .getPoint(t), getTangent(t)
		 * .getPointAt(u), getTangentAt(u)
		 * .getPoints(), .getSpacedPoints()
		 * .getLength()
		 * .updateArcLengths()
		 *
		 * This following curves inherit from THREE.Curve:
		 *
		 * -- 2D curves --
		 * THREE.ArcCurve
		 * THREE.CubicBezierCurve
		 * THREE.EllipseCurve
		 * THREE.LineCurve
		 * THREE.QuadraticBezierCurve
		 * THREE.SplineCurve
		 *
		 * -- 3D curves --
		 * THREE.CatmullRomCurve3
		 * THREE.CubicBezierCurve3
		 * THREE.LineCurve3
		 * THREE.QuadraticBezierCurve3
		 *
		 * A series of curves can be represented as a THREE.CurvePath.
		 *
		 **//**************************************************************
		 *	Abstract Curve base class
		 **************************************************************/function Curve(){this.arcLengthDivisions=200;}_assign(Curve.prototype,{// Virtual base class method to overwrite and implement in subclasses
	//	- t [0 .. 1]
	getPoint:function getPoint(){console.warn('THREE.Curve: .getPoint() not implemented.');return null;},// Get point at relative position in curve according to arc length
	// - u [0 .. 1]
	getPointAt:function getPointAt(u){var t=this.getUtoTmapping(u);return this.getPoint(t);},// Get sequence of points using getPoint( t )
	getPoints:function getPoints(divisions){if(divisions===undefined)divisions=5;var points=[];for(var d=0;d<=divisions;d++){points.push(this.getPoint(d/divisions));}return points;},// Get sequence of points using getPointAt( u )
	getSpacedPoints:function getSpacedPoints(divisions){if(divisions===undefined)divisions=5;var points=[];for(var d=0;d<=divisions;d++){points.push(this.getPointAt(d/divisions));}return points;},// Get total curve arc length
	getLength:function getLength(){var lengths=this.getLengths();return lengths[lengths.length-1];},// Get list of cumulative segment lengths
	getLengths:function getLengths(divisions){if(divisions===undefined)divisions=this.arcLengthDivisions;if(this.cacheArcLengths&&this.cacheArcLengths.length===divisions+1&&!this.needsUpdate){return this.cacheArcLengths;}this.needsUpdate=false;var cache=[];var current,last=this.getPoint(0);var p,sum=0;cache.push(0);for(p=1;p<=divisions;p++){current=this.getPoint(p/divisions);sum+=current.distanceTo(last);cache.push(sum);last=current;}this.cacheArcLengths=cache;return cache;// { sums: cache, sum: sum }; Sum is in the last element.
	},updateArcLengths:function updateArcLengths(){this.needsUpdate=true;this.getLengths();},// Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equidistant
	getUtoTmapping:function getUtoTmapping(u,distance){var arcLengths=this.getLengths();var i=0,il=arcLengths.length;var targetArcLength;// The targeted u distance value to get
	if(distance){targetArcLength=distance;}else{targetArcLength=u*arcLengths[il-1];}// binary search for the index with largest value smaller than target u distance
	var low=0,high=il-1,comparison;while(low<=high){i=Math.floor(low+(high-low)/2);// less likely to overflow, though probably not issue here, JS doesn't really have integers, all numbers are floats
	comparison=arcLengths[i]-targetArcLength;if(comparison<0){low=i+1;}else if(comparison>0){high=i-1;}else{high=i;break;// DONE
	}}i=high;if(arcLengths[i]===targetArcLength){return i/(il-1);}// we could get finer grain at lengths, or use simple interpolation between two points
	var lengthBefore=arcLengths[i];var lengthAfter=arcLengths[i+1];var segmentLength=lengthAfter-lengthBefore;// determine where we are between the 'before' and 'after' points
	var segmentFraction=(targetArcLength-lengthBefore)/segmentLength;// add that fractional amount to t
	var t=(i+segmentFraction)/(il-1);return t;},// Returns a unit vector tangent at t
	// In case any sub curve does not implement its tangent derivation,
	// 2 points a small delta apart will be used to find its gradient
	// which seems to give a reasonable approximation
	getTangent:function getTangent(t){var delta=0.0001;var t1=t-delta;var t2=t+delta;// Capping in case of danger
	if(t1<0)t1=0;if(t2>1)t2=1;var pt1=this.getPoint(t1);var pt2=this.getPoint(t2);var vec=pt2.clone().sub(pt1);return vec.normalize();},getTangentAt:function getTangentAt(u){var t=this.getUtoTmapping(u);return this.getTangent(t);},computeFrenetFrames:function computeFrenetFrames(segments,closed){// see http://www.cs.indiana.edu/pub/techreports/TR425.pdf
	var normal=new Vector3();var tangents=[];var normals=[];var binormals=[];var vec=new Vector3();var mat=new Matrix4();var i,u,theta;// compute the tangent vectors for each segment on the curve
	for(i=0;i<=segments;i++){u=i/segments;tangents[i]=this.getTangentAt(u);tangents[i].normalize();}// select an initial normal vector perpendicular to the first tangent vector,
	// and in the direction of the minimum tangent xyz component
	normals[0]=new Vector3();binormals[0]=new Vector3();var min=Number.MAX_VALUE;var tx=Math.abs(tangents[0].x);var ty=Math.abs(tangents[0].y);var tz=Math.abs(tangents[0].z);if(tx<=min){min=tx;normal.set(1,0,0);}if(ty<=min){min=ty;normal.set(0,1,0);}if(tz<=min){normal.set(0,0,1);}vec.crossVectors(tangents[0],normal).normalize();normals[0].crossVectors(tangents[0],vec);binormals[0].crossVectors(tangents[0],normals[0]);// compute the slowly-varying normal and binormal vectors for each segment on the curve
	for(i=1;i<=segments;i++){normals[i]=normals[i-1].clone();binormals[i]=binormals[i-1].clone();vec.crossVectors(tangents[i-1],tangents[i]);if(vec.length()>Number.EPSILON){vec.normalize();theta=Math.acos(_Math.clamp(tangents[i-1].dot(tangents[i]),-1,1));// clamp for floating pt errors
	normals[i].applyMatrix4(mat.makeRotationAxis(vec,theta));}binormals[i].crossVectors(tangents[i],normals[i]);}// if the curve is closed, postprocess the vectors so the first and last normal vectors are the same
	if(closed===true){theta=Math.acos(_Math.clamp(normals[0].dot(normals[segments]),-1,1));theta/=segments;if(tangents[0].dot(vec.crossVectors(normals[0],normals[segments]))>0){theta=-theta;}for(i=1;i<=segments;i++){// twist a little...
	normals[i].applyMatrix4(mat.makeRotationAxis(tangents[i],theta*i));binormals[i].crossVectors(tangents[i],normals[i]);}}return{tangents:tangents,normals:normals,binormals:binormals};}});/**
		 * @author zz85 https://github.com/zz85
		 *
		 * Centripetal CatmullRom Curve - which is useful for avoiding
		 * cusps and self-intersections in non-uniform catmull rom curves.
		 * http://www.cemyuksel.com/research/catmullrom_param/catmullrom.pdf
		 *
		 * curve.type accepts centripetal(default), chordal and catmullrom
		 * curve.tension is used for catmullrom which defaults to 0.5
		 *//*
		Based on an optimized c++ solution in
		 - http://stackoverflow.com/questions/9489736/catmull-rom-curve-with-no-cusps-and-no-self-intersections/
		 - http://ideone.com/NoEbVM
	
		This CubicPoly class could be used for reusing some variables and calculations,
		but for three.js curve use, it could be possible inlined and flatten into a single function call
		which can be placed in CurveUtils.
		*/function CubicPoly(){var c0=0,c1=0,c2=0,c3=0;/*
			 * Compute coefficients for a cubic polynomial
			 *   p(s) = c0 + c1*s + c2*s^2 + c3*s^3
			 * such that
			 *   p(0) = x0, p(1) = x1
			 *  and
			 *   p'(0) = t0, p'(1) = t1.
			 */function init(x0,x1,t0,t1){c0=x0;c1=t0;c2=-3*x0+3*x1-2*t0-t1;c3=2*x0-2*x1+t0+t1;}return{initCatmullRom:function initCatmullRom(x0,x1,x2,x3,tension){init(x1,x2,tension*(x2-x0),tension*(x3-x1));},initNonuniformCatmullRom:function initNonuniformCatmullRom(x0,x1,x2,x3,dt0,dt1,dt2){// compute tangents when parameterized in [t1,t2]
	var t1=(x1-x0)/dt0-(x2-x0)/(dt0+dt1)+(x2-x1)/dt1;var t2=(x2-x1)/dt1-(x3-x1)/(dt1+dt2)+(x3-x2)/dt2;// rescale tangents for parametrization in [0,1]
	t1*=dt1;t2*=dt1;init(x1,x2,t1,t2);},calc:function calc(t){var t2=t*t;var t3=t2*t;return c0+c1*t+c2*t2+c3*t3;}};}//
	var tmp=new Vector3();var px=new CubicPoly();var py=new CubicPoly();var pz=new CubicPoly();function CatmullRomCurve3(p/* array of Vector3 */){Curve.call(this);this.points=p||[];this.closed=false;}CatmullRomCurve3.prototype=Object.create(Curve.prototype);CatmullRomCurve3.prototype.constructor=CatmullRomCurve3;CatmullRomCurve3.prototype.getPoint=function(t){var points=this.points;var l=points.length;if(l<2)console.log('duh, you need at least 2 points');var point=(l-(this.closed?0:1))*t;var intPoint=Math.floor(point);var weight=point-intPoint;if(this.closed){intPoint+=intPoint>0?0:(Math.floor(Math.abs(intPoint)/points.length)+1)*points.length;}else if(weight===0&&intPoint===l-1){intPoint=l-2;weight=1;}var p0,p1,p2,p3;// 4 points
	if(this.closed||intPoint>0){p0=points[(intPoint-1)%l];}else{// extrapolate first point
	tmp.subVectors(points[0],points[1]).add(points[0]);p0=tmp;}p1=points[intPoint%l];p2=points[(intPoint+1)%l];if(this.closed||intPoint+2<l){p3=points[(intPoint+2)%l];}else{// extrapolate last point
	tmp.subVectors(points[l-1],points[l-2]).add(points[l-1]);p3=tmp;}if(this.type===undefined||this.type==='centripetal'||this.type==='chordal'){// init Centripetal / Chordal Catmull-Rom
	var pow=this.type==='chordal'?0.5:0.25;var dt0=Math.pow(p0.distanceToSquared(p1),pow);var dt1=Math.pow(p1.distanceToSquared(p2),pow);var dt2=Math.pow(p2.distanceToSquared(p3),pow);// safety check for repeated points
	if(dt1<1e-4)dt1=1.0;if(dt0<1e-4)dt0=dt1;if(dt2<1e-4)dt2=dt1;px.initNonuniformCatmullRom(p0.x,p1.x,p2.x,p3.x,dt0,dt1,dt2);py.initNonuniformCatmullRom(p0.y,p1.y,p2.y,p3.y,dt0,dt1,dt2);pz.initNonuniformCatmullRom(p0.z,p1.z,p2.z,p3.z,dt0,dt1,dt2);}else if(this.type==='catmullrom'){var tension=this.tension!==undefined?this.tension:0.5;px.initCatmullRom(p0.x,p1.x,p2.x,p3.x,tension);py.initCatmullRom(p0.y,p1.y,p2.y,p3.y,tension);pz.initCatmullRom(p0.z,p1.z,p2.z,p3.z,tension);}return new Vector3(px.calc(weight),py.calc(weight),pz.calc(weight));};function LineCurve3(v1,v2){Curve.call(this);this.v1=v1;this.v2=v2;}LineCurve3.prototype=Object.create(Curve.prototype);LineCurve3.prototype.constructor=LineCurve3;LineCurve3.prototype.getPoint=function(t){if(t===1){return this.v2.clone();}var vector=new Vector3();vector.subVectors(this.v2,this.v1);// diff
	vector.multiplyScalar(t);vector.add(this.v1);return vector;};function LineCurve(v1,v2){Curve.call(this);this.v1=v1;this.v2=v2;}LineCurve.prototype=Object.create(Curve.prototype);LineCurve.prototype.constructor=LineCurve;LineCurve.prototype.isLineCurve=true;LineCurve.prototype.getPoint=function(t){if(t===1){return this.v2.clone();}var point=this.v2.clone().sub(this.v1);point.multiplyScalar(t).add(this.v1);return point;};// Line curve is linear, so we can overwrite default getPointAt
	LineCurve.prototype.getPointAt=function(u){return this.getPoint(u);};LineCurve.prototype.getTangent=function(t){var tangent=this.v2.clone().sub(this.v1);return tangent.normalize();};/**
		 * @author zz85 / http://www.lab4games.net/zz85/blog
		 *
		 **//**************************************************************
		 *	Curved Path - a curve path is simply a array of connected
		 *  curves, but retains the api of a curve
		 **************************************************************/function CurvePath(){Curve.call(this);this.curves=[];this.autoClose=false;// Automatically closes the path
	}CurvePath.prototype=_assign(Object.create(Curve.prototype),{constructor:CurvePath,add:function add(curve){this.curves.push(curve);},closePath:function closePath(){// Add a line curve if start and end of lines are not connected
	var startPoint=this.curves[0].getPoint(0);var endPoint=this.curves[this.curves.length-1].getPoint(1);if(!startPoint.equals(endPoint)){this.curves.push(new LineCurve(endPoint,startPoint));}},// To get accurate point with reference to
	// entire path distance at time t,
	// following has to be done:
	// 1. Length of each sub path have to be known
	// 2. Locate and identify type of curve
	// 3. Get t for the curve
	// 4. Return curve.getPointAt(t')
	getPoint:function getPoint(t){var d=t*this.getLength();var curveLengths=this.getCurveLengths();var i=0;// To think about boundaries points.
	while(i<curveLengths.length){if(curveLengths[i]>=d){var diff=curveLengths[i]-d;var curve=this.curves[i];var segmentLength=curve.getLength();var u=segmentLength===0?0:1-diff/segmentLength;return curve.getPointAt(u);}i++;}return null;// loop where sum != 0, sum > d , sum+1 <d
	},// We cannot use the default THREE.Curve getPoint() with getLength() because in
	// THREE.Curve, getLength() depends on getPoint() but in THREE.CurvePath
	// getPoint() depends on getLength
	getLength:function getLength(){var lens=this.getCurveLengths();return lens[lens.length-1];},// cacheLengths must be recalculated.
	updateArcLengths:function updateArcLengths(){this.needsUpdate=true;this.cacheLengths=null;this.getCurveLengths();},// Compute lengths and cache them
	// We cannot overwrite getLengths() because UtoT mapping uses it.
	getCurveLengths:function getCurveLengths(){// We use cache values if curves and cache array are same length
	if(this.cacheLengths&&this.cacheLengths.length===this.curves.length){return this.cacheLengths;}// Get length of sub-curve
	// Push sums into cached array
	var lengths=[],sums=0;for(var i=0,l=this.curves.length;i<l;i++){sums+=this.curves[i].getLength();lengths.push(sums);}this.cacheLengths=lengths;return lengths;},getSpacedPoints:function getSpacedPoints(divisions){if(divisions===undefined)divisions=40;var points=[];for(var i=0;i<=divisions;i++){points.push(this.getPoint(i/divisions));}if(this.autoClose){points.push(points[0]);}return points;},getPoints:function getPoints(divisions){divisions=divisions||12;var points=[],last;for(var i=0,curves=this.curves;i<curves.length;i++){var curve=curves[i];var resolution=curve&&curve.isEllipseCurve?divisions*2:curve&&curve.isLineCurve?1:curve&&curve.isSplineCurve?divisions*curve.points.length:divisions;var pts=curve.getPoints(resolution);for(var j=0;j<pts.length;j++){var point=pts[j];if(last&&last.equals(point))continue;// ensures no consecutive points are duplicates
	points.push(point);last=point;}}if(this.autoClose&&points.length>1&&!points[points.length-1].equals(points[0])){points.push(points[0]);}return points;},/**************************************************************
			 *	Create Geometries Helpers
			 **************************************************************//// Generate geometry from path points (for Line or Points objects)
	createPointsGeometry:function createPointsGeometry(divisions){var pts=this.getPoints(divisions);return this.createGeometry(pts);},// Generate geometry from equidistant sampling along the path
	createSpacedPointsGeometry:function createSpacedPointsGeometry(divisions){var pts=this.getSpacedPoints(divisions);return this.createGeometry(pts);},createGeometry:function createGeometry(points){var geometry=new Geometry();for(var i=0,l=points.length;i<l;i++){var point=points[i];geometry.vertices.push(new Vector3(point.x,point.y,point.z||0));}return geometry;}});function EllipseCurve(aX,aY,xRadius,yRadius,aStartAngle,aEndAngle,aClockwise,aRotation){Curve.call(this);this.aX=aX;this.aY=aY;this.xRadius=xRadius;this.yRadius=yRadius;this.aStartAngle=aStartAngle;this.aEndAngle=aEndAngle;this.aClockwise=aClockwise;this.aRotation=aRotation||0;}EllipseCurve.prototype=Object.create(Curve.prototype);EllipseCurve.prototype.constructor=EllipseCurve;EllipseCurve.prototype.isEllipseCurve=true;EllipseCurve.prototype.getPoint=function(t){var twoPi=Math.PI*2;var deltaAngle=this.aEndAngle-this.aStartAngle;var samePoints=Math.abs(deltaAngle)<Number.EPSILON;// ensures that deltaAngle is 0 .. 2 PI
	while(deltaAngle<0){deltaAngle+=twoPi;}while(deltaAngle>twoPi){deltaAngle-=twoPi;}if(deltaAngle<Number.EPSILON){if(samePoints){deltaAngle=0;}else{deltaAngle=twoPi;}}if(this.aClockwise===true&&!samePoints){if(deltaAngle===twoPi){deltaAngle=-twoPi;}else{deltaAngle=deltaAngle-twoPi;}}var angle=this.aStartAngle+t*deltaAngle;var x=this.aX+this.xRadius*Math.cos(angle);var y=this.aY+this.yRadius*Math.sin(angle);if(this.aRotation!==0){var cos=Math.cos(this.aRotation);var sin=Math.sin(this.aRotation);var tx=x-this.aX;var ty=y-this.aY;// Rotate the point about the center of the ellipse.
	x=tx*cos-ty*sin+this.aX;y=tx*sin+ty*cos+this.aY;}return new Vector2(x,y);};/**
		 * @author zz85 / http://www.lab4games.net/zz85/blog
		 *
		 * Bezier Curves formulas obtained from
		 * http://en.wikipedia.org/wiki/Bézier_curve
		 */function CatmullRom(t,p0,p1,p2,p3){var v0=(p2-p0)*0.5;var v1=(p3-p1)*0.5;var t2=t*t;var t3=t*t2;return(2*p1-2*p2+v0+v1)*t3+(-3*p1+3*p2-2*v0-v1)*t2+v0*t+p1;}//
	function QuadraticBezierP0(t,p){var k=1-t;return k*k*p;}function QuadraticBezierP1(t,p){return 2*(1-t)*t*p;}function QuadraticBezierP2(t,p){return t*t*p;}function QuadraticBezier(t,p0,p1,p2){return QuadraticBezierP0(t,p0)+QuadraticBezierP1(t,p1)+QuadraticBezierP2(t,p2);}//
	function CubicBezierP0(t,p){var k=1-t;return k*k*k*p;}function CubicBezierP1(t,p){var k=1-t;return 3*k*k*t*p;}function CubicBezierP2(t,p){return 3*(1-t)*t*t*p;}function CubicBezierP3(t,p){return t*t*t*p;}function CubicBezier(t,p0,p1,p2,p3){return CubicBezierP0(t,p0)+CubicBezierP1(t,p1)+CubicBezierP2(t,p2)+CubicBezierP3(t,p3);}function SplineCurve(points/* array of Vector2 */){Curve.call(this);this.points=points===undefined?[]:points;}SplineCurve.prototype=Object.create(Curve.prototype);SplineCurve.prototype.constructor=SplineCurve;SplineCurve.prototype.isSplineCurve=true;SplineCurve.prototype.getPoint=function(t){var points=this.points;var point=(points.length-1)*t;var intPoint=Math.floor(point);var weight=point-intPoint;var point0=points[intPoint===0?intPoint:intPoint-1];var point1=points[intPoint];var point2=points[intPoint>points.length-2?points.length-1:intPoint+1];var point3=points[intPoint>points.length-3?points.length-1:intPoint+2];return new Vector2(CatmullRom(weight,point0.x,point1.x,point2.x,point3.x),CatmullRom(weight,point0.y,point1.y,point2.y,point3.y));};function CubicBezierCurve(v0,v1,v2,v3){Curve.call(this);this.v0=v0;this.v1=v1;this.v2=v2;this.v3=v3;}CubicBezierCurve.prototype=Object.create(Curve.prototype);CubicBezierCurve.prototype.constructor=CubicBezierCurve;CubicBezierCurve.prototype.getPoint=function(t){var v0=this.v0,v1=this.v1,v2=this.v2,v3=this.v3;return new Vector2(CubicBezier(t,v0.x,v1.x,v2.x,v3.x),CubicBezier(t,v0.y,v1.y,v2.y,v3.y));};function QuadraticBezierCurve(v0,v1,v2){Curve.call(this);this.v0=v0;this.v1=v1;this.v2=v2;}QuadraticBezierCurve.prototype=Object.create(Curve.prototype);QuadraticBezierCurve.prototype.constructor=QuadraticBezierCurve;QuadraticBezierCurve.prototype.getPoint=function(t){var v0=this.v0,v1=this.v1,v2=this.v2;return new Vector2(QuadraticBezier(t,v0.x,v1.x,v2.x),QuadraticBezier(t,v0.y,v1.y,v2.y));};var PathPrototype=_assign(Object.create(CurvePath.prototype),{fromPoints:function fromPoints(vectors){this.moveTo(vectors[0].x,vectors[0].y);for(var i=1,l=vectors.length;i<l;i++){this.lineTo(vectors[i].x,vectors[i].y);}},moveTo:function moveTo(x,y){this.currentPoint.set(x,y);// TODO consider referencing vectors instead of copying?
	},lineTo:function lineTo(x,y){var curve=new LineCurve(this.currentPoint.clone(),new Vector2(x,y));this.curves.push(curve);this.currentPoint.set(x,y);},quadraticCurveTo:function quadraticCurveTo(aCPx,aCPy,aX,aY){var curve=new QuadraticBezierCurve(this.currentPoint.clone(),new Vector2(aCPx,aCPy),new Vector2(aX,aY));this.curves.push(curve);this.currentPoint.set(aX,aY);},bezierCurveTo:function bezierCurveTo(aCP1x,aCP1y,aCP2x,aCP2y,aX,aY){var curve=new CubicBezierCurve(this.currentPoint.clone(),new Vector2(aCP1x,aCP1y),new Vector2(aCP2x,aCP2y),new Vector2(aX,aY));this.curves.push(curve);this.currentPoint.set(aX,aY);},splineThru:function splineThru(pts/*Array of Vector*/){var npts=[this.currentPoint.clone()].concat(pts);var curve=new SplineCurve(npts);this.curves.push(curve);this.currentPoint.copy(pts[pts.length-1]);},arc:function arc(aX,aY,aRadius,aStartAngle,aEndAngle,aClockwise){var x0=this.currentPoint.x;var y0=this.currentPoint.y;this.absarc(aX+x0,aY+y0,aRadius,aStartAngle,aEndAngle,aClockwise);},absarc:function absarc(aX,aY,aRadius,aStartAngle,aEndAngle,aClockwise){this.absellipse(aX,aY,aRadius,aRadius,aStartAngle,aEndAngle,aClockwise);},ellipse:function ellipse(aX,aY,xRadius,yRadius,aStartAngle,aEndAngle,aClockwise,aRotation){var x0=this.currentPoint.x;var y0=this.currentPoint.y;this.absellipse(aX+x0,aY+y0,xRadius,yRadius,aStartAngle,aEndAngle,aClockwise,aRotation);},absellipse:function absellipse(aX,aY,xRadius,yRadius,aStartAngle,aEndAngle,aClockwise,aRotation){var curve=new EllipseCurve(aX,aY,xRadius,yRadius,aStartAngle,aEndAngle,aClockwise,aRotation);if(this.curves.length>0){// if a previous curve is present, attempt to join
	var firstPoint=curve.getPoint(0);if(!firstPoint.equals(this.currentPoint)){this.lineTo(firstPoint.x,firstPoint.y);}}this.curves.push(curve);var lastPoint=curve.getPoint(1);this.currentPoint.copy(lastPoint);}});/**
		 * @author zz85 / http://www.lab4games.net/zz85/blog
		 * Creates free form 2d path using series of points, lines or curves.
		 **/function Path(points){CurvePath.call(this);this.currentPoint=new Vector2();if(points){this.fromPoints(points);}}Path.prototype=PathPrototype;PathPrototype.constructor=Path;/**
		 * @author zz85 / http://www.lab4games.net/zz85/blog
		 * Defines a 2d shape plane using paths.
		 **/// STEP 1 Create a path.
	// STEP 2 Turn path into shape.
	// STEP 3 ExtrudeGeometry takes in Shape/Shapes
	// STEP 3a - Extract points from each shape, turn to vertices
	// STEP 3b - Triangulate each shape, add faces.
	function Shape(){Path.apply(this,arguments);this.holes=[];}Shape.prototype=_assign(Object.create(PathPrototype),{constructor:Shape,getPointsHoles:function getPointsHoles(divisions){var holesPts=[];for(var i=0,l=this.holes.length;i<l;i++){holesPts[i]=this.holes[i].getPoints(divisions);}return holesPts;},// Get points of shape and holes (keypoints based on segments parameter)
	extractAllPoints:function extractAllPoints(divisions){return{shape:this.getPoints(divisions),holes:this.getPointsHoles(divisions)};},extractPoints:function extractPoints(divisions){return this.extractAllPoints(divisions);}});/**
		 * @author zz85 / http://www.lab4games.net/zz85/blog
		 * minimal class for proxing functions to Path. Replaces old "extractSubpaths()"
		 **/function ShapePath(){this.subPaths=[];this.currentPath=null;}_assign(ShapePath.prototype,{moveTo:function moveTo(x,y){this.currentPath=new Path();this.subPaths.push(this.currentPath);this.currentPath.moveTo(x,y);},lineTo:function lineTo(x,y){this.currentPath.lineTo(x,y);},quadraticCurveTo:function quadraticCurveTo(aCPx,aCPy,aX,aY){this.currentPath.quadraticCurveTo(aCPx,aCPy,aX,aY);},bezierCurveTo:function bezierCurveTo(aCP1x,aCP1y,aCP2x,aCP2y,aX,aY){this.currentPath.bezierCurveTo(aCP1x,aCP1y,aCP2x,aCP2y,aX,aY);},splineThru:function splineThru(pts){this.currentPath.splineThru(pts);},toShapes:function toShapes(isCCW,noHoles){function toShapesNoHoles(inSubpaths){var shapes=[];for(var i=0,l=inSubpaths.length;i<l;i++){var tmpPath=inSubpaths[i];var tmpShape=new Shape();tmpShape.curves=tmpPath.curves;shapes.push(tmpShape);}return shapes;}function isPointInsidePolygon(inPt,inPolygon){var polyLen=inPolygon.length;// inPt on polygon contour => immediate success    or
	// toggling of inside/outside at every single! intersection point of an edge
	//  with the horizontal line through inPt, left of inPt
	//  not counting lowerY endpoints of edges and whole edges on that line
	var inside=false;for(var p=polyLen-1,q=0;q<polyLen;p=q++){var edgeLowPt=inPolygon[p];var edgeHighPt=inPolygon[q];var edgeDx=edgeHighPt.x-edgeLowPt.x;var edgeDy=edgeHighPt.y-edgeLowPt.y;if(Math.abs(edgeDy)>Number.EPSILON){// not parallel
	if(edgeDy<0){edgeLowPt=inPolygon[q];edgeDx=-edgeDx;edgeHighPt=inPolygon[p];edgeDy=-edgeDy;}if(inPt.y<edgeLowPt.y||inPt.y>edgeHighPt.y)continue;if(inPt.y===edgeLowPt.y){if(inPt.x===edgeLowPt.x)return true;// inPt is on contour ?
	// continue;				// no intersection or edgeLowPt => doesn't count !!!
	}else{var perpEdge=edgeDy*(inPt.x-edgeLowPt.x)-edgeDx*(inPt.y-edgeLowPt.y);if(perpEdge===0)return true;// inPt is on contour ?
	if(perpEdge<0)continue;inside=!inside;// true intersection left of inPt
	}}else{// parallel or collinear
	if(inPt.y!==edgeLowPt.y)continue;// parallel
	// edge lies on the same horizontal line as inPt
	if(edgeHighPt.x<=inPt.x&&inPt.x<=edgeLowPt.x||edgeLowPt.x<=inPt.x&&inPt.x<=edgeHighPt.x)return true;// inPt: Point on contour !
	// continue;
	}}return inside;}var isClockWise=ShapeUtils.isClockWise;var subPaths=this.subPaths;if(subPaths.length===0)return[];if(noHoles===true)return toShapesNoHoles(subPaths);var solid,tmpPath,tmpShape,shapes=[];if(subPaths.length===1){tmpPath=subPaths[0];tmpShape=new Shape();tmpShape.curves=tmpPath.curves;shapes.push(tmpShape);return shapes;}var holesFirst=!isClockWise(subPaths[0].getPoints());holesFirst=isCCW?!holesFirst:holesFirst;// console.log("Holes first", holesFirst);
	var betterShapeHoles=[];var newShapes=[];var newShapeHoles=[];var mainIdx=0;var tmpPoints;newShapes[mainIdx]=undefined;newShapeHoles[mainIdx]=[];for(var i=0,l=subPaths.length;i<l;i++){tmpPath=subPaths[i];tmpPoints=tmpPath.getPoints();solid=isClockWise(tmpPoints);solid=isCCW?!solid:solid;if(solid){if(!holesFirst&&newShapes[mainIdx])mainIdx++;newShapes[mainIdx]={s:new Shape(),p:tmpPoints};newShapes[mainIdx].s.curves=tmpPath.curves;if(holesFirst)mainIdx++;newShapeHoles[mainIdx]=[];//console.log('cw', i);
	}else{newShapeHoles[mainIdx].push({h:tmpPath,p:tmpPoints[0]});//console.log('ccw', i);
	}}// only Holes? -> probably all Shapes with wrong orientation
	if(!newShapes[0])return toShapesNoHoles(subPaths);if(newShapes.length>1){var ambiguous=false;var toChange=[];for(var sIdx=0,sLen=newShapes.length;sIdx<sLen;sIdx++){betterShapeHoles[sIdx]=[];}for(var sIdx=0,sLen=newShapes.length;sIdx<sLen;sIdx++){var sho=newShapeHoles[sIdx];for(var hIdx=0;hIdx<sho.length;hIdx++){var ho=sho[hIdx];var hole_unassigned=true;for(var s2Idx=0;s2Idx<newShapes.length;s2Idx++){if(isPointInsidePolygon(ho.p,newShapes[s2Idx].p)){if(sIdx!==s2Idx)toChange.push({froms:sIdx,tos:s2Idx,hole:hIdx});if(hole_unassigned){hole_unassigned=false;betterShapeHoles[s2Idx].push(ho);}else{ambiguous=true;}}}if(hole_unassigned){betterShapeHoles[sIdx].push(ho);}}}// console.log("ambiguous: ", ambiguous);
	if(toChange.length>0){// console.log("to change: ", toChange);
	if(!ambiguous)newShapeHoles=betterShapeHoles;}}var tmpHoles;for(var i=0,il=newShapes.length;i<il;i++){tmpShape=newShapes[i].s;shapes.push(tmpShape);tmpHoles=newShapeHoles[i];for(var j=0,jl=tmpHoles.length;j<jl;j++){tmpShape.holes.push(tmpHoles[j].h);}}//console.log("shape", shapes);
	return shapes;}});/**
		 * @author alteredq / http://alteredqualia.com/
		 */var SceneUtils={createMultiMaterialObject:function createMultiMaterialObject(geometry,materials){var group=new Group();for(var i=0,l=materials.length;i<l;i++){group.add(new Mesh(geometry,materials[i]));}return group;},detach:function detach(child,parent,scene){child.applyMatrix(parent.matrixWorld);parent.remove(child);scene.add(child);},attach:function attach(child,scene,parent){var matrixWorldInverse=new Matrix4();matrixWorldInverse.getInverse(parent.matrixWorld);child.applyMatrix(matrixWorldInverse);scene.remove(child);parent.add(child);}};// export * from './Three.Legacy.js';
	exports.WebGLRenderer=WebGLRenderer;exports.ShaderChunk=ShaderChunk;exports.Scene=Scene;exports.Sprite=Sprite;exports.Mesh=Mesh;exports.LineSegments=LineSegments;exports.Line=Line;exports.Points=Points;exports.Group=Group;exports.Texture=Texture;exports.TextureLoader=TextureLoader;exports.JSONLoader=JSONLoader;exports.ImageLoader=ImageLoader;exports.FileLoader=FileLoader;exports.Loader=Loader;exports.Cache=Cache;exports.HemisphereLight=HemisphereLight;exports.DirectionalLightShadow=DirectionalLightShadow;exports.DirectionalLight=DirectionalLight;exports.Light=Light;exports.PerspectiveCamera=PerspectiveCamera;exports.Camera=Camera;exports.Uniform=Uniform;exports.BufferGeometry=BufferGeometry;exports.GeometryIdCount=GeometryIdCount;exports.Geometry=Geometry;exports.Face3=Face3;exports.Object3D=Object3D;exports.Raycaster=Raycaster;exports.EventDispatcher=EventDispatcher;exports.Clock=Clock;exports.Interpolant=Interpolant;exports.Triangle=Triangle;exports.Math=_Math;exports.Spherical=Spherical;exports.Plane=Plane;exports.Ray=Ray;exports.Matrix4=Matrix4;exports.Matrix3=Matrix3;exports.Box3=Box3;exports.Box2=Box2;exports.Line3=Line3;exports.Euler=Euler;exports.Vector4=Vector4;exports.Vector3=Vector3;exports.Vector2=Vector2;exports.Quaternion=Quaternion;exports.Color=Color;exports.CatmullRomCurve3=CatmullRomCurve3;exports.LineCurve3=LineCurve3;exports.LineCurve=LineCurve;exports.Shape=Shape;exports.Path=Path;exports.ShapePath=ShapePath;exports.CurvePath=CurvePath;exports.Curve=Curve;exports.ShapeUtils=ShapeUtils;exports.SceneUtils=SceneUtils;exports.TubeGeometry=TubeGeometry;exports.TubeBufferGeometry=TubeBufferGeometry;exports.SphereGeometry=SphereGeometry;exports.SphereBufferGeometry=SphereBufferGeometry;exports.ShapeGeometry=ShapeGeometry;exports.ShapeBufferGeometry=ShapeBufferGeometry;exports.ExtrudeGeometry=ExtrudeGeometry;exports.ExtrudeBufferGeometry=ExtrudeBufferGeometry;exports.SpriteMaterial=SpriteMaterial;exports.ShaderMaterial=ShaderMaterial;exports.MeshPhongMaterial=MeshPhongMaterial;exports.MeshBasicMaterial=MeshBasicMaterial;exports.LineBasicMaterial=LineBasicMaterial;exports.Material=Material;exports.Float64BufferAttribute=Float64BufferAttribute;exports.Float32BufferAttribute=Float32BufferAttribute;exports.Uint32BufferAttribute=Uint32BufferAttribute;exports.Int32BufferAttribute=Int32BufferAttribute;exports.Uint16BufferAttribute=Uint16BufferAttribute;exports.Int16BufferAttribute=Int16BufferAttribute;exports.Uint8ClampedBufferAttribute=Uint8ClampedBufferAttribute;exports.Uint8BufferAttribute=Uint8BufferAttribute;exports.Int8BufferAttribute=Int8BufferAttribute;exports.BufferAttribute=BufferAttribute;exports.REVISION=REVISION;exports.MOUSE=MOUSE;exports.CullFaceNone=CullFaceNone;exports.CullFaceBack=CullFaceBack;exports.CullFaceFront=CullFaceFront;exports.CullFaceFrontBack=CullFaceFrontBack;exports.FrontFaceDirectionCW=FrontFaceDirectionCW;exports.FrontFaceDirectionCCW=FrontFaceDirectionCCW;exports.BasicShadowMap=BasicShadowMap;exports.PCFShadowMap=PCFShadowMap;exports.PCFSoftShadowMap=PCFSoftShadowMap;exports.FrontSide=FrontSide;exports.BackSide=BackSide;exports.DoubleSide=DoubleSide;exports.FlatShading=FlatShading;exports.SmoothShading=SmoothShading;exports.NoColors=NoColors;exports.FaceColors=FaceColors;exports.VertexColors=VertexColors;exports.NoBlending=NoBlending;exports.NormalBlending=NormalBlending;exports.AdditiveBlending=AdditiveBlending;exports.SubtractiveBlending=SubtractiveBlending;exports.MultiplyBlending=MultiplyBlending;exports.CustomBlending=CustomBlending;exports.AddEquation=AddEquation;exports.SubtractEquation=SubtractEquation;exports.ReverseSubtractEquation=ReverseSubtractEquation;exports.MinEquation=MinEquation;exports.MaxEquation=MaxEquation;exports.ZeroFactor=ZeroFactor;exports.OneFactor=OneFactor;exports.SrcColorFactor=SrcColorFactor;exports.OneMinusSrcColorFactor=OneMinusSrcColorFactor;exports.SrcAlphaFactor=SrcAlphaFactor;exports.OneMinusSrcAlphaFactor=OneMinusSrcAlphaFactor;exports.DstAlphaFactor=DstAlphaFactor;exports.OneMinusDstAlphaFactor=OneMinusDstAlphaFactor;exports.DstColorFactor=DstColorFactor;exports.OneMinusDstColorFactor=OneMinusDstColorFactor;exports.SrcAlphaSaturateFactor=SrcAlphaSaturateFactor;exports.NeverDepth=NeverDepth;exports.AlwaysDepth=AlwaysDepth;exports.LessDepth=LessDepth;exports.LessEqualDepth=LessEqualDepth;exports.EqualDepth=EqualDepth;exports.GreaterEqualDepth=GreaterEqualDepth;exports.GreaterDepth=GreaterDepth;exports.NotEqualDepth=NotEqualDepth;exports.MultiplyOperation=MultiplyOperation;exports.MixOperation=MixOperation;exports.AddOperation=AddOperation;exports.NoToneMapping=NoToneMapping;exports.LinearToneMapping=LinearToneMapping;exports.ReinhardToneMapping=ReinhardToneMapping;exports.Uncharted2ToneMapping=Uncharted2ToneMapping;exports.CineonToneMapping=CineonToneMapping;exports.UVMapping=UVMapping;exports.CubeReflectionMapping=CubeReflectionMapping;exports.CubeRefractionMapping=CubeRefractionMapping;exports.EquirectangularReflectionMapping=EquirectangularReflectionMapping;exports.EquirectangularRefractionMapping=EquirectangularRefractionMapping;exports.SphericalReflectionMapping=SphericalReflectionMapping;exports.CubeUVReflectionMapping=CubeUVReflectionMapping;exports.CubeUVRefractionMapping=CubeUVRefractionMapping;exports.RepeatWrapping=RepeatWrapping;exports.ClampToEdgeWrapping=ClampToEdgeWrapping;exports.MirroredRepeatWrapping=MirroredRepeatWrapping;exports.NearestFilter=NearestFilter;exports.NearestMipMapNearestFilter=NearestMipMapNearestFilter;exports.NearestMipMapLinearFilter=NearestMipMapLinearFilter;exports.LinearFilter=LinearFilter;exports.LinearMipMapNearestFilter=LinearMipMapNearestFilter;exports.LinearMipMapLinearFilter=LinearMipMapLinearFilter;exports.UnsignedByteType=UnsignedByteType;exports.ByteType=ByteType;exports.ShortType=ShortType;exports.UnsignedShortType=UnsignedShortType;exports.IntType=IntType;exports.UnsignedIntType=UnsignedIntType;exports.FloatType=FloatType;exports.HalfFloatType=HalfFloatType;exports.UnsignedShort4444Type=UnsignedShort4444Type;exports.UnsignedShort5551Type=UnsignedShort5551Type;exports.UnsignedShort565Type=UnsignedShort565Type;exports.UnsignedInt248Type=UnsignedInt248Type;exports.AlphaFormat=AlphaFormat;exports.RGBFormat=RGBFormat;exports.RGBAFormat=RGBAFormat;exports.LuminanceFormat=LuminanceFormat;exports.LuminanceAlphaFormat=LuminanceAlphaFormat;exports.RGBEFormat=RGBEFormat;exports.DepthFormat=DepthFormat;exports.DepthStencilFormat=DepthStencilFormat;exports.RGB_S3TC_DXT1_Format=RGB_S3TC_DXT1_Format;exports.RGBA_S3TC_DXT1_Format=RGBA_S3TC_DXT1_Format;exports.RGBA_S3TC_DXT3_Format=RGBA_S3TC_DXT3_Format;exports.RGBA_S3TC_DXT5_Format=RGBA_S3TC_DXT5_Format;exports.RGB_PVRTC_4BPPV1_Format=RGB_PVRTC_4BPPV1_Format;exports.RGB_PVRTC_2BPPV1_Format=RGB_PVRTC_2BPPV1_Format;exports.RGBA_PVRTC_4BPPV1_Format=RGBA_PVRTC_4BPPV1_Format;exports.RGBA_PVRTC_2BPPV1_Format=RGBA_PVRTC_2BPPV1_Format;exports.RGB_ETC1_Format=RGB_ETC1_Format;exports.LoopOnce=LoopOnce;exports.LoopRepeat=LoopRepeat;exports.LoopPingPong=LoopPingPong;exports.InterpolateDiscrete=InterpolateDiscrete;exports.InterpolateLinear=InterpolateLinear;exports.InterpolateSmooth=InterpolateSmooth;exports.ZeroCurvatureEnding=ZeroCurvatureEnding;exports.ZeroSlopeEnding=ZeroSlopeEnding;exports.WrapAroundEnding=WrapAroundEnding;exports.TrianglesDrawMode=TrianglesDrawMode;exports.TriangleStripDrawMode=TriangleStripDrawMode;exports.TriangleFanDrawMode=TriangleFanDrawMode;exports.LinearEncoding=LinearEncoding;exports.sRGBEncoding=sRGBEncoding;exports.GammaEncoding=GammaEncoding;exports.RGBEEncoding=RGBEEncoding;exports.LogLuvEncoding=LogLuvEncoding;exports.RGBM7Encoding=RGBM7Encoding;exports.RGBM16Encoding=RGBM16Encoding;exports.RGBDEncoding=RGBDEncoding;exports.BasicDepthPacking=BasicDepthPacking;exports.RGBADepthPacking=RGBADepthPacking;Object.defineProperty(exports,'__esModule',{value:true});});

/***/ }),
/* 3 */
/***/ (function(module, exports) {

	if (typeof Object.create === 'function') {
	  // implementation from standard node.js 'util' module
	  module.exports = function inherits(ctor, superCtor) {
	    ctor.super_ = superCtor
	    ctor.prototype = Object.create(superCtor.prototype, {
	      constructor: {
	        value: ctor,
	        enumerable: false,
	        writable: true,
	        configurable: true
	      }
	    });
	  };
	} else {
	  // old school shim for old browsers
	  module.exports = function inherits(ctor, superCtor) {
	    ctor.super_ = superCtor
	    var TempCtor = function () {}
	    TempCtor.prototype = superCtor.prototype
	    ctor.prototype = new TempCtor()
	    ctor.prototype.constructor = ctor
	  }
	}


/***/ }),
/* 4 */
/***/ (function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	var isPresent = exports.isPresent = function isPresent(obj) {
	  return typeof obj !== 'undefined' && obj !== null;
	};
	
	var isBlank = exports.isBlank = function isBlank(obj) {
	  return typeof obj === 'undefined' || obj === null;
	};
	
	var isBoolean = exports.isBoolean = function isBoolean(obj) {
	  return typeof obj === 'boolean';
	};
	
	var isNumber = exports.isNumber = function isNumber(obj) {
	  return typeof obj === 'number';
	};
	
	var isString = exports.isString = function isString(obj) {
	  return typeof obj === 'string';
	};
	
	// export const toArray = (obj) => {
	//   return [].concat(obj || []);
	// };
	
	var isArray = exports.isArray = function isArray(obj) {
	  try {
	    return Array.isArray(obj);
	  } catch (e) {
	    return Object.prototype.toString.call(obj) === '[object Array]';
	  }
	};
	
	var isDate = exports.isDate = function isDate(obj) {
	  return obj instanceof Date && !isNaN(obj.valueOf());
	};
	
	var isFunction = exports.isFunction = function isFunction(obj) {
	  return typeof obj === 'function';
	};
	
	var isJsObject = exports.isJsObject = function isJsObject(obj) {
	  return obj !== null && (isFunction(obj) || (typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) === 'object');
	};
	
	var isPromise = exports.isPromise = function isPromise(obj) {
	  return isPresent(obj) && isFunction(obj.then);
	};
	
	var isEmpty = exports.isEmpty = function isEmpty(obj) {
	  if (isBlank(obj)) {
	    return true;
	  }
	
	  if (obj.length === 0) {
	    return true;
	  }
	
	  for (var key in obj) {
	    if (Object.prototype.hasOwnProperty.call(obj, key)) {
	      return false;
	    }
	  }
	
	  return true;
	};
	
	// export class StringWrapper {
	//   static equals = (s1, s2) => s1 === s2;
	
	//   static contains = (s, substr) => s.indexOf(substr) !== -1;
	
	//   static compare = (a, b) => {
	//     if (a < b) {
	//       return -1;
	//     } else if (a > b) {
	//       return 1;
	//     }
	
	//     return 0;
	//   }
	// }

/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;"use strict";
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	/* eslint-disable */
	/**
	 * JSTS. See https://github.com/bjornharrtell/jsts
	 * https://github.com/bjornharrtell/jsts/blob/master/LICENSE_EDLv1.txt
	 * https://github.com/bjornharrtell/jsts/blob/master/LICENSE_EPLv1.txt
	 * https://github.com/bjornharrtell/jsts/blob/master/LICENSE_LICENSE_ES6_COLLECTIONS.txt
	 * @license
	 */
	!function (t, e) {
	  "object" == ( false ? "undefined" : _typeof(exports)) && "undefined" != typeof module ? e(exports) :  true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports], __WEBPACK_AMD_DEFINE_FACTORY__ = (e), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : e(t.jsts = t.jsts || {});
	}(undefined, function (t) {
	  "use strict";
	  function e() {}function n() {}function i() {}function r() {}function s() {}function o() {}function a() {}function u(t) {
	    this.name = "RuntimeException", this.message = t, this.stack = new Error().stack, Error.call(this, t);
	  }function l() {
	    if (0 === arguments.length) u.call(this);else if (1 === arguments.length) {
	      var t = arguments[0];u.call(this, t);
	    }
	  }function h() {}function c() {
	    if (this.x = null, this.y = null, this.z = null, 0 === arguments.length) c.call(this, 0, 0);else if (1 === arguments.length) {
	      var t = arguments[0];c.call(this, t.x, t.y, t.z);
	    } else if (2 === arguments.length) {
	      var e = arguments[0],
	          n = arguments[1];c.call(this, e, n, c.NULL_ORDINATE);
	    } else if (3 === arguments.length) {
	      var i = arguments[0],
	          r = arguments[1],
	          s = arguments[2];this.x = i, this.y = r, this.z = s;
	    }
	  }function f() {
	    if (this.dimensionsToTest = 2, 0 === arguments.length) f.call(this, 2);else if (1 === arguments.length) {
	      var t = arguments[0];if (2 !== t && 3 !== t) throw new n("only 2 or 3 dimensions may be specified");this.dimensionsToTest = t;
	    }
	  }function g() {}function d() {}function p(t) {
	    this.message = t || "";
	  }function m() {}function v(t) {
	    this.message = t || "";
	  }function y(t) {
	    this.message = t || "";
	  }function I() {
	    this.array_ = [], arguments[0] instanceof d && this.addAll(arguments[0]);
	  }function E() {
	    if (I.apply(this), 0 === arguments.length) ;else if (1 === arguments.length) {
	      var t = arguments[0];this.ensureCapacity(t.length), this.add(t, !0);
	    } else if (2 === arguments.length) {
	      var e = arguments[0],
	          n = arguments[1];this.ensureCapacity(e.length), this.add(e, n);
	    }
	  }function x() {
	    if (this.minx = null, this.maxx = null, this.miny = null, this.maxy = null, 0 === arguments.length) this.init();else if (1 === arguments.length) {
	      if (arguments[0] instanceof c) {
	        var t = arguments[0];this.init(t.x, t.x, t.y, t.y);
	      } else if (arguments[0] instanceof x) {
	        var e = arguments[0];this.init(e);
	      }
	    } else if (2 === arguments.length) {
	      var n = arguments[0],
	          i = arguments[1];this.init(n.x, i.x, n.y, i.y);
	    } else if (4 === arguments.length) {
	      var r = arguments[0],
	          s = arguments[1],
	          o = arguments[2],
	          a = arguments[3];this.init(r, s, o, a);
	    }
	  }function N() {}function C() {
	    N.call(this, "Projective point not representable on the Cartesian plane.");
	  }function S() {}function L() {}function R(t) {
	    this.str = t;
	  }function w(t) {
	    this.value = t;
	  }function T() {}function O() {
	    if (this.hi = 0, this.lo = 0, 0 === arguments.length) this.init(0);else if (1 === arguments.length) {
	      if ("number" == typeof arguments[0]) {
	        var t = arguments[0];this.init(t);
	      } else if (arguments[0] instanceof O) {
	        var e = arguments[0];this.init(e);
	      } else if ("string" == typeof arguments[0]) {
	        var n = arguments[0];O.call(this, O.parse(n));
	      }
	    } else if (2 === arguments.length) {
	      var i = arguments[0],
	          r = arguments[1];this.init(i, r);
	    }
	  }function b() {}function P() {}function _() {}function M() {
	    if (this.x = null, this.y = null, this.w = null, 0 === arguments.length) this.x = 0, this.y = 0, this.w = 1;else if (1 === arguments.length) {
	      var t = arguments[0];this.x = t.x, this.y = t.y, this.w = 1;
	    } else if (2 === arguments.length) {
	      if ("number" == typeof arguments[0] && "number" == typeof arguments[1]) {
	        var e = arguments[0],
	            n = arguments[1];this.x = e, this.y = n, this.w = 1;
	      } else if (arguments[0] instanceof M && arguments[1] instanceof M) {
	        var i = arguments[0],
	            r = arguments[1];this.x = i.y * r.w - r.y * i.w, this.y = r.x * i.w - i.x * r.w, this.w = i.x * r.y - r.x * i.y;
	      } else if (arguments[0] instanceof c && arguments[1] instanceof c) {
	        var s = arguments[0],
	            o = arguments[1];this.x = s.y - o.y, this.y = o.x - s.x, this.w = s.x * o.y - o.x * s.y;
	      }
	    } else if (3 === arguments.length) {
	      var a = arguments[0],
	          u = arguments[1],
	          l = arguments[2];this.x = a, this.y = u, this.w = l;
	    } else if (4 === arguments.length) {
	      var h = arguments[0],
	          f = arguments[1],
	          g = arguments[2],
	          d = arguments[3],
	          p = h.y - f.y,
	          m = f.x - h.x,
	          v = h.x * f.y - f.x * h.y,
	          y = g.y - d.y,
	          I = d.x - g.x,
	          E = g.x * d.y - d.x * g.y;this.x = m * E - I * v, this.y = y * v - p * E, this.w = p * I - y * m;
	    }
	  }function A() {}function D() {}function F() {
	    this.envelope = null, this.factory = null, this.SRID = null, this.userData = null;var t = arguments[0];this.factory = t, this.SRID = t.getSRID();
	  }function G() {}function B() {}function q() {}function z() {}function U() {}function Y() {}function X() {}function k() {}function V() {}function H() {}function W() {}function j() {}function K() {
	    this.array_ = [], arguments[0] instanceof d && this.addAll(arguments[0]);
	  }function J(t) {
	    return null == t ? Ar : t.color;
	  }function Q(t) {
	    return null == t ? null : t.parent;
	  }function Z(t, e) {
	    null !== t && (t.color = e);
	  }function $(t) {
	    return null == t ? null : t.left;
	  }function tt(t) {
	    return null == t ? null : t.right;
	  }function et() {
	    this.root_ = null, this.size_ = 0;
	  }function nt() {}function it() {}function rt() {
	    this.array_ = [], arguments[0] instanceof d && this.addAll(arguments[0]);
	  }function st() {}function ot() {}function at() {}function ut() {}function lt() {
	    this.geometries = null;var t = arguments[0],
	        e = arguments[1];if (F.call(this, e), null === t && (t = []), F.hasNullElements(t)) throw new n("geometries must not contain null elements");this.geometries = t;
	  }function ht() {
	    var t = arguments[0],
	        e = arguments[1];lt.call(this, t, e);
	  }function ct() {
	    if (this.geom = null, this.geomFact = null, this.bnRule = null, this.endpointMap = null, 1 === arguments.length) {
	      var t = arguments[0];ct.call(this, t, B.MOD2_BOUNDARY_RULE);
	    } else if (2 === arguments.length) {
	      var e = arguments[0],
	          n = arguments[1];this.geom = e, this.geomFact = e.getFactory(), this.bnRule = n;
	    }
	  }function ft() {
	    this.count = null;
	  }function gt() {}function dt() {}function pt() {}function mt() {}function vt() {}function yt() {}function It() {}function Et() {}function xt() {
	    this.points = null;var t = arguments[0],
	        e = arguments[1];F.call(this, e), this.init(t);
	  }function Nt() {}function Ct() {
	    this.coordinates = null;var t = arguments[0],
	        e = arguments[1];F.call(this, e), this.init(t);
	  }function St() {}function Lt() {
	    this.shell = null, this.holes = null;var t = arguments[0],
	        e = arguments[1],
	        i = arguments[2];if (F.call(this, i), null === t && (t = this.getFactory().createLinearRing()), null === e && (e = []), F.hasNullElements(e)) throw new n("holes must not contain null elements");if (t.isEmpty() && F.hasNonEmptyElements(e)) throw new n("shell is empty but holes are not");this.shell = t, this.holes = e;
	  }function Rt() {
	    var t = arguments[0],
	        e = arguments[1];lt.call(this, t, e);
	  }function wt() {
	    if (arguments[0] instanceof c && arguments[1] instanceof $t) {
	      var t = arguments[0],
	          e = arguments[1];wt.call(this, e.getCoordinateSequenceFactory().create(t), e);
	    } else if (_r(arguments[0], P) && arguments[1] instanceof $t) {
	      var n = arguments[0],
	          i = arguments[1];xt.call(this, n, i), this.validateConstruction();
	    }
	  }function Tt() {
	    var t = arguments[0],
	        e = arguments[1];lt.call(this, t, e);
	  }function Ot() {
	    if (this.factory = null, this.isUserDataCopied = !1, 0 === arguments.length) ;else if (1 === arguments.length) {
	      var t = arguments[0];this.factory = t;
	    }
	  }function bt() {}function Pt() {}function _t() {}function Mt() {}function At() {
	    if (this.dimension = 3, this.coordinates = null, 1 === arguments.length) {
	      if (arguments[0] instanceof Array) {
	        var t = arguments[0];At.call(this, t, 3);
	      } else if (Number.isInteger(arguments[0])) {
	        var e = arguments[0];this.coordinates = new Array(e).fill(null);for (var n = 0; n < e; n++) {
	          this.coordinates[n] = new c();
	        }
	      } else if (_r(arguments[0], P)) {
	        var i = arguments[0];if (null === i) return this.coordinates = new Array(0).fill(null), null;this.dimension = i.getDimension(), this.coordinates = new Array(i.size()).fill(null);for (var n = 0; n < this.coordinates.length; n++) {
	          this.coordinates[n] = i.getCoordinateCopy(n);
	        }
	      }
	    } else if (2 === arguments.length) if (arguments[0] instanceof Array && Number.isInteger(arguments[1])) {
	      var r = arguments[0],
	          s = arguments[1];this.coordinates = r, this.dimension = s, null === r && (this.coordinates = new Array(0).fill(null));
	    } else if (Number.isInteger(arguments[0]) && Number.isInteger(arguments[1])) {
	      var o = arguments[0],
	          a = arguments[1];this.coordinates = new Array(o).fill(null), this.dimension = a;for (var n = 0; n < o; n++) {
	        this.coordinates[n] = new c();
	      }
	    }
	  }function Dt() {}function Ft(t, e) {
	    return t === e || t !== t && e !== e;
	  }function Gt(t) {
	    this.add ? t.forEach(this.add, this) : t.forEach(function (t) {
	      this.set(t[0], t[1]);
	    }, this);
	  }function Bt(t) {
	    return this.has(t) && (this._keys.splice(Fr, 1), this._values.splice(Fr, 1), this._itp.forEach(function (t) {
	      Fr < t[0] && t[0]--;
	    })), Fr > -1;
	  }function qt(t) {
	    return this.has(t) ? this._values[Fr] : void 0;
	  }function zt(t, e) {
	    if (this.objectOnly && e !== Object(e)) throw new TypeError("Invalid value used as weak collection key");if (e !== e || 0 === e) for (Fr = t.length; Fr-- && !Ft(t[Fr], e);) {} else Fr = t.indexOf(e);return Fr > -1;
	  }function Ut(t) {
	    return zt.call(this, this._keys, t);
	  }function Yt(t, e) {
	    return this.has(t) ? this._values[Fr] = e : this._values[this._keys.push(t) - 1] = e, this;
	  }function Xt() {
	    (this._keys || 0).length = this._values.length = 0;
	  }function kt() {
	    return Wt(this._itp, this._keys);
	  }function Vt() {
	    return Wt(this._itp, this._values);
	  }function Ht() {
	    return Wt(this._itp, this._keys, this._values);
	  }function Wt(t, e, n) {
	    var i = [0],
	        r = !1;return t.push(i), { next: function next() {
	        var s,
	            o = i[0];return !r && o < e.length ? (s = n ? [e[o], n[o]] : e[o], i[0]++) : (r = !0, t.splice(t.indexOf(i), 1)), { done: r, value: s };
	      } };
	  }function jt() {
	    return this._values.length;
	  }function Kt(t, e) {
	    for (var n = this.entries();;) {
	      var i = n.next();if (i.done) break;t.call(e, i.value[1], i.value[0], this);
	    }
	  }function Jt() {
	    this.map_ = new qr();
	  }function Qt() {
	    if (this.modelType = null, this.scale = null, 0 === arguments.length) this.modelType = Qt.FLOATING;else if (1 === arguments.length) if (arguments[0] instanceof Zt) {
	      var t = arguments[0];this.modelType = t, t === Qt.FIXED && this.setScale(1);
	    } else if ("number" == typeof arguments[0]) {
	      var e = arguments[0];this.modelType = Qt.FIXED, this.setScale(e);
	    } else if (arguments[0] instanceof Qt) {
	      var n = arguments[0];this.modelType = n.modelType, this.scale = n.scale;
	    }
	  }function Zt() {
	    this.name = null;var t = arguments[0];this.name = t, Zt.nameToTypeMap.put(t, this);
	  }function $t() {
	    if (this.precisionModel = null, this.coordinateSequenceFactory = null, this.SRID = null, 0 === arguments.length) $t.call(this, new Qt(), 0);else if (1 === arguments.length) {
	      if (_r(arguments[0], A)) {
	        var t = arguments[0];$t.call(this, new Qt(), 0, t);
	      } else if (arguments[0] instanceof Qt) {
	        var e = arguments[0];$t.call(this, e, 0, $t.getDefaultCoordinateSequenceFactory());
	      }
	    } else if (2 === arguments.length) {
	      var n = arguments[0],
	          i = arguments[1];$t.call(this, n, i, $t.getDefaultCoordinateSequenceFactory());
	    } else if (3 === arguments.length) {
	      var r = arguments[0],
	          s = arguments[1],
	          o = arguments[2];this.precisionModel = r, this.coordinateSequenceFactory = o, this.SRID = s;
	    }
	  }function te(t) {
	    this.geometryFactory = t || new $t();
	  }function ee(t) {
	    this.parser = new te(t);
	  }function ne() {
	    this.result = null, this.inputLines = Array(2).fill().map(function () {
	      return Array(2);
	    }), this.intPt = new Array(2).fill(null), this.intLineIndex = null, this._isProper = null, this.pa = null, this.pb = null, this.precisionModel = null, this.intPt[0] = new c(), this.intPt[1] = new c(), this.pa = this.intPt[0], this.pb = this.intPt[1], this.result = 0;
	  }function ie() {
	    ne.apply(this);
	  }function re() {}function se() {
	    this.p = null, this.crossingCount = 0, this.isPointOnSegment = !1;var t = arguments[0];this.p = t;
	  }function oe() {}function ae() {
	    if (this.p0 = null, this.p1 = null, 0 === arguments.length) ae.call(this, new c(), new c());else if (1 === arguments.length) {
	      var t = arguments[0];ae.call(this, t.p0, t.p1);
	    } else if (2 === arguments.length) {
	      var e = arguments[0],
	          n = arguments[1];this.p0 = e, this.p1 = n;
	    } else if (4 === arguments.length) {
	      var i = arguments[0],
	          r = arguments[1],
	          s = arguments[2],
	          o = arguments[3];ae.call(this, new c(i, r), new c(s, o));
	    }
	  }function ue() {
	    this.items = new I(), this.subnode = new Array(4).fill(null);
	  }function le() {}function he(t, e) {
	    var n,
	        i,
	        r,
	        s,
	        o = { 32: { d: 127, c: 128, b: 0, a: 0 }, 64: { d: 32752, c: 0, b: 0, a: 0 } },
	        a = { 32: 8, 64: 11 }[t];if (s || (n = e < 0 || 1 / e < 0, isFinite(e) || (s = o[t], n && (s.d += 1 << t / 4 - 1), i = Math.pow(2, a) - 1, r = 0)), !s) {
	      for (i = { 32: 127, 64: 1023 }[t], r = Math.abs(e); r >= 2;) {
	        i++, r /= 2;
	      }for (; r < 1 && i > 0;) {
	        i--, r *= 2;
	      }i <= 0 && (r /= 2), 32 === t && i > 254 && (s = { d: n ? 255 : 127, c: 128, b: 0, a: 0 }, i = Math.pow(2, a) - 1, r = 0);
	    }return i;
	  }function ce() {
	    this.pt = new c(), this.level = 0, this.env = null;var t = arguments[0];this.computeKey(t);
	  }function fe() {
	    ue.apply(this), this.env = null, this.centrex = null, this.centrey = null, this.level = null;var t = arguments[0],
	        e = arguments[1];this.env = t, this.level = e, this.centrex = (t.getMinX() + t.getMaxX()) / 2, this.centrey = (t.getMinY() + t.getMaxY()) / 2;
	  }function ge() {}function de() {
	    ue.apply(this);
	  }function pe() {}function me() {}function ve() {
	    this.items = new I();
	  }function ye() {
	    this.root = null, this.minExtent = 1, this.root = new de();
	  }function Ie(t) {
	    this.geometryFactory = t || new $t();
	  }function Ee(t) {
	    this.geometryFactory = t || new $t(), this.precisionModel = this.geometryFactory.getPrecisionModel(), this.parser = new Ie(this.geometryFactory);
	  }function xe() {
	    this.parser = new Ie(this.geometryFactory);
	  }function Ne() {
	    this.parent = null, this.atStart = null, this.max = null, this.index = null, this.subcollectionIterator = null;var t = arguments[0];this.parent = t, this.atStart = !0, this.index = 0, this.max = t.getNumGeometries();
	  }function Ce() {
	    if (this.boundaryRule = B.OGC_SFS_BOUNDARY_RULE, this.isIn = null, this.numBoundaries = null, 0 === arguments.length) ;else if (1 === arguments.length) {
	      var t = arguments[0];if (null === t) throw new n("Rule must be non-null");this.boundaryRule = t;
	    }
	  }function Se() {
	    this.comps = null;var t = arguments[0];this.comps = t;
	  }function Le() {
	    if (this.component = null, this.segIndex = null, this.pt = null, 2 === arguments.length) {
	      var t = arguments[0],
	          e = arguments[1];Le.call(this, t, Le.INSIDE_AREA, e);
	    } else if (3 === arguments.length) {
	      var n = arguments[0],
	          i = arguments[1],
	          r = arguments[2];this.component = n, this.segIndex = i, this.pt = r;
	    }
	  }function Re() {
	    this.pts = null;var t = arguments[0];this.pts = t;
	  }function we() {
	    this.locations = null;var t = arguments[0];this.locations = t;
	  }function Te() {
	    if (this.lines = null, this.isForcedToLineString = !1, 1 === arguments.length) {
	      var t = arguments[0];this.lines = t;
	    } else if (2 === arguments.length) {
	      var e = arguments[0],
	          n = arguments[1];this.lines = e, this.isForcedToLineString = n;
	    }
	  }function Oe() {
	    if (this.geom = null, this.terminateDistance = 0, this.ptLocator = new Ce(), this.minDistanceLocation = null, this.minDistance = i.MAX_VALUE, 2 === arguments.length) {
	      var t = arguments[0],
	          e = arguments[1];Oe.call(this, t, e, 0);
	    } else if (3 === arguments.length) {
	      var n = arguments[0],
	          r = arguments[1],
	          s = arguments[2];this.geom = new Array(2).fill(null), this.geom[0] = n, this.geom[1] = r, this.terminateDistance = s;
	    }
	  }function be() {
	    this.mapOp = null;var t = arguments[0];this.mapOp = t;
	  }function Pe() {}function _e() {
	    if (this.pt = null, 1 === arguments.length) {
	      var t = arguments[0];u.call(this, t);
	    } else if (2 === arguments.length) {
	      var e = arguments[0],
	          n = arguments[1];u.call(this, _e.msgWithCoord(e, n)), this.name = "TopologyException", this.pt = new c(n);
	    }
	  }function Me() {
	    if (this.location = null, 1 === arguments.length) {
	      if (arguments[0] instanceof Array) {
	        var t = arguments[0];this.init(t.length);
	      } else if (Number.isInteger(arguments[0])) {
	        var e = arguments[0];this.init(1), this.location[Pe.ON] = e;
	      } else if (arguments[0] instanceof Me) {
	        var n = arguments[0];if (this.init(n.location.length), null !== n) for (var i = 0; i < this.location.length; i++) {
	          this.location[i] = n.location[i];
	        }
	      }
	    } else if (3 === arguments.length) {
	      var r = arguments[0],
	          s = arguments[1],
	          o = arguments[2];this.init(3), this.location[Pe.ON] = r, this.location[Pe.LEFT] = s, this.location[Pe.RIGHT] = o;
	    }
	  }function Ae() {
	    if (this.elt = new Array(2).fill(null), 1 === arguments.length) {
	      if (Number.isInteger(arguments[0])) {
	        var t = arguments[0];this.elt[0] = new Me(t), this.elt[1] = new Me(t);
	      } else if (arguments[0] instanceof Ae) {
	        var e = arguments[0];this.elt[0] = new Me(e.elt[0]), this.elt[1] = new Me(e.elt[1]);
	      }
	    } else if (2 === arguments.length) {
	      var n = arguments[0],
	          i = arguments[1];this.elt[0] = new Me(S.NONE), this.elt[1] = new Me(S.NONE), this.elt[n].setLocation(i);
	    } else if (3 === arguments.length) {
	      var r = arguments[0],
	          s = arguments[1],
	          o = arguments[2];this.elt[0] = new Me(r, s, o), this.elt[1] = new Me(r, s, o);
	    } else if (4 === arguments.length) {
	      var a = arguments[0],
	          u = arguments[1],
	          l = arguments[2],
	          h = arguments[3];this.elt[0] = new Me(S.NONE, S.NONE, S.NONE), this.elt[1] = new Me(S.NONE, S.NONE, S.NONE), this.elt[a].setLocations(u, l, h);
	    }
	  }function De() {
	    this.startDe = null, this.maxNodeDegree = -1, this.edges = new I(), this.pts = new I(), this.label = new Ae(S.NONE), this.ring = null, this._isHole = null, this.shell = null, this.holes = new I(), this.geometryFactory = null;var t = arguments[0],
	        e = arguments[1];this.geometryFactory = e, this.computePoints(t), this.computeRing();
	  }function Fe() {
	    var t = arguments[0],
	        e = arguments[1];De.call(this, t, e);
	  }function Ge() {
	    var t = arguments[0],
	        e = arguments[1];De.call(this, t, e);
	  }function Be() {}function qe() {
	    this.geom = null;var t = arguments[0];this.geom = t;
	  }function ze() {
	    this.edgeMap = new et(), this.edgeList = null, this.ptInAreaLocation = [S.NONE, S.NONE];
	  }function Ue() {}function Ye() {
	    ze.apply(this), this.resultAreaEdgeList = null, this.label = null, this.SCANNING_FOR_INCOMING = 1, this.LINKING_TO_OUTGOING = 2;
	  }function Xe() {
	    if (this.label = null, this._isInResult = !1, this._isCovered = !1, this._isCoveredSet = !1, this._isVisited = !1, 0 === arguments.length) ;else if (1 === arguments.length) {
	      var t = arguments[0];this.label = t;
	    }
	  }function ke() {
	    Xe.apply(this), this.coord = null, this.edges = null;var t = arguments[0],
	        e = arguments[1];this.coord = t, this.edges = e, this.label = new Ae(0, S.NONE);
	  }function Ve() {}function He() {
	    Ve.apply(this);
	  }function We() {
	    this.nodeMap = new et(), this.nodeFact = null;var t = arguments[0];this.nodeFact = t;
	  }function je() {
	    if (this.edge = null, this.label = null, this.node = null, this.p0 = null, this.p1 = null, this.dx = null, this.dy = null, this.quadrant = null, 1 === arguments.length) {
	      var t = arguments[0];this.edge = t;
	    } else if (3 === arguments.length) {
	      var e = arguments[0],
	          n = arguments[1],
	          i = arguments[2];je.call(this, e, n, i, null);
	    } else if (4 === arguments.length) {
	      var r = arguments[0],
	          s = arguments[1],
	          o = arguments[2],
	          a = arguments[3];je.call(this, r), this.init(s, o), this.label = a;
	    }
	  }function Ke() {
	    this._isForward = null, this._isInResult = !1, this._isVisited = !1, this.sym = null, this.next = null, this.nextMin = null, this.edgeRing = null, this.minEdgeRing = null, this.depth = [0, -999, -999];var t = arguments[0],
	        e = arguments[1];if (je.call(this, t), this._isForward = e, e) this.init(t.getCoordinate(0), t.getCoordinate(1));else {
	      var n = t.getNumPoints() - 1;this.init(t.getCoordinate(n), t.getCoordinate(n - 1));
	    }this.computeDirectedLabel();
	  }function Je() {
	    if (this.edges = new I(), this.nodes = null, this.edgeEndList = new I(), 0 === arguments.length) this.nodes = new We(new Ve());else if (1 === arguments.length) {
	      var t = arguments[0];this.nodes = new We(t);
	    }
	  }function Qe() {
	    this.geometryFactory = new $t(), this.geomGraph = null, this.disconnectedRingcoord = null;var t = arguments[0];this.geomGraph = t;
	  }function Ze() {
	    this.tempEnv1 = new x(), this.selectedSegment = new ae();
	  }function $e() {
	    this.items = new I(), this.subnode = [null, null];
	  }function tn() {
	    if (this.min = null, this.max = null, 0 === arguments.length) this.min = 0, this.max = 0;else if (1 === arguments.length) {
	      var t = arguments[0];this.init(t.min, t.max);
	    } else if (2 === arguments.length) {
	      var e = arguments[0],
	          n = arguments[1];this.init(e, n);
	    }
	  }function en() {
	    this.pt = 0, this.level = 0, this.interval = null;var t = arguments[0];this.computeKey(t);
	  }function nn() {
	    $e.apply(this), this.interval = null, this.centre = null, this.level = null;var t = arguments[0],
	        e = arguments[1];this.interval = t, this.level = e, this.centre = (t.getMin() + t.getMax()) / 2;
	  }function rn() {
	    $e.apply(this);
	  }function sn() {
	    this.root = null, this.minExtent = 1, this.root = new rn();
	  }function on() {
	    this.pts = null, this.start = null, this.end = null, this.env = null, this.context = null, this.id = null;var t = arguments[0],
	        e = arguments[1],
	        n = arguments[2],
	        i = arguments[3];this.pts = t, this.start = e, this.end = n, this.context = i;
	  }function an() {}function un() {}function ln() {
	    this.ring = null, this.tree = null, this.crossings = 0, this.interval = new tn();var t = arguments[0];this.ring = t, this.buildIndex();
	  }function hn() {
	    Ze.apply(this), this.mcp = null, this.p = null;var t = arguments[0],
	        e = arguments[1];this.mcp = t, this.p = e;
	  }function cn() {
	    this.mce = null, this.chainIndex = null;var t = arguments[0],
	        e = arguments[1];this.mce = t, this.chainIndex = e;
	  }function fn() {
	    if (this.label = null, this.xValue = null, this.eventType = null, this.insertEvent = null, this.deleteEventIndex = null, this.obj = null, 2 === arguments.length) {
	      var t = arguments[0],
	          e = arguments[1];this.eventType = fn.DELETE, this.xValue = t, this.insertEvent = e;
	    } else if (3 === arguments.length) {
	      var n = arguments[0],
	          i = arguments[1],
	          r = arguments[2];this.eventType = fn.INSERT, this.label = n, this.xValue = i, this.obj = r;
	    }
	  }function gn() {}function dn() {
	    this._hasIntersection = !1, this.hasProper = !1, this.hasProperInterior = !1, this.properIntersectionPoint = null, this.li = null, this.includeProper = null, this.recordIsolated = null, this.isSelfIntersection = null, this.numIntersections = 0, this.numTests = 0, this.bdyNodes = null, this._isDone = !1, this.isDoneWhenProperInt = !1;var t = arguments[0],
	        e = arguments[1],
	        n = arguments[2];this.li = t, this.includeProper = e, this.recordIsolated = n;
	  }function pn() {
	    gn.apply(this), this.events = new I(), this.nOverlaps = null;
	  }function mn() {
	    this.min = i.POSITIVE_INFINITY, this.max = i.NEGATIVE_INFINITY;
	  }function vn() {}function yn() {
	    mn.apply(this), this.item = null;var t = arguments[0],
	        e = arguments[1],
	        n = arguments[2];this.min = t, this.max = e, this.item = n;
	  }function In() {
	    mn.apply(this), this.node1 = null, this.node2 = null;var t = arguments[0],
	        e = arguments[1];this.node1 = t, this.node2 = e, this.buildExtent(this.node1, this.node2);
	  }function En() {
	    this.leaves = new I(), this.root = null, this.level = 0;
	  }function xn() {
	    this.index = null;var t = arguments[0];if (!_r(t, St)) throw new n("Argument must be Polygonal");this.index = new Cn(t);
	  }function Nn() {
	    this.counter = null;var t = arguments[0];this.counter = t;
	  }function Cn() {
	    this.index = new En();var t = arguments[0];this.init(t);
	  }function Sn() {
	    this.coord = null, this.segmentIndex = null, this.dist = null;var t = arguments[0],
	        e = arguments[1],
	        n = arguments[2];this.coord = new c(t), this.segmentIndex = e, this.dist = n;
	  }function Ln() {
	    this.nodeMap = new et(), this.edge = null;var t = arguments[0];this.edge = t;
	  }function Rn() {}function wn() {
	    this.e = null, this.pts = null, this.startIndex = null, this.env1 = new x(), this.env2 = new x();var t = arguments[0];this.e = t, this.pts = t.getCoordinates();var e = new Rn();this.startIndex = e.getChainStartIndices(this.pts);
	  }function Tn() {
	    this.depth = Array(2).fill().map(function () {
	      return Array(3);
	    });for (var t = 0; t < 2; t++) {
	      for (var e = 0; e < 3; e++) {
	        this.depth[t][e] = Tn.NULL_VALUE;
	      }
	    }
	  }function On() {
	    if (Xe.apply(this), this.pts = null, this.env = null, this.eiList = new Ln(this), this.name = null, this.mce = null, this._isIsolated = !0, this.depth = new Tn(), this.depthDelta = 0, 1 === arguments.length) {
	      var t = arguments[0];On.call(this, t, null);
	    } else if (2 === arguments.length) {
	      var e = arguments[0],
	          n = arguments[1];this.pts = e, this.label = n;
	    }
	  }function bn() {
	    if (Je.apply(this), this.parentGeom = null, this.lineEdgeMap = new Jt(), this.boundaryNodeRule = null, this.useBoundaryDeterminationRule = !0, this.argIndex = null, this.boundaryNodes = null, this._hasTooFewPoints = !1, this.invalidPoint = null, this.areaPtLocator = null, this.ptLocator = new Ce(), 2 === arguments.length) {
	      var t = arguments[0],
	          e = arguments[1];bn.call(this, t, e, B.OGC_SFS_BOUNDARY_RULE);
	    } else if (3 === arguments.length) {
	      var n = arguments[0],
	          i = arguments[1],
	          r = arguments[2];this.argIndex = n, this.parentGeom = i, this.boundaryNodeRule = r, null !== i && this.add(i);
	    }
	  }function Pn() {}function _n() {
	    if (this.edgeEnds = new I(), 1 === arguments.length) {
	      var t = arguments[0];_n.call(this, null, t);
	    } else if (2 === arguments.length) {
	      var e = (arguments[0], arguments[1]);je.call(this, e.getEdge(), e.getCoordinate(), e.getDirectedCoordinate(), new Ae(e.getLabel())), this.insert(e);
	    }
	  }function Mn() {
	    ze.apply(this);
	  }function An() {
	    var t = arguments[0],
	        e = arguments[1];ke.call(this, t, e);
	  }function Dn() {
	    Ve.apply(this);
	  }function Fn() {
	    this.nodes = new We(new Dn());
	  }function Gn() {
	    this.li = new ie(), this.geomGraph = null, this.nodeGraph = new Fn(), this.invalidPoint = null;var t = arguments[0];this.geomGraph = t;
	  }function Bn() {}function qn() {
	    this.bounds = null, this.item = null;var t = arguments[0],
	        e = arguments[1];this.bounds = t, this.item = e;
	  }function zn() {
	    this._size = null, this.items = null, this._size = 0, this.items = new I(), this.items.add(null);
	  }function Un() {
	    if (this.childBoundables = new I(), this.bounds = null, this.level = null, 0 === arguments.length) ;else if (1 === arguments.length) {
	      var t = arguments[0];this.level = t;
	    }
	  }function Yn() {
	    this.boundable1 = null, this.boundable2 = null, this._distance = null, this.itemDistance = null;var t = arguments[0],
	        e = arguments[1],
	        n = arguments[2];this.boundable1 = t, this.boundable2 = e, this.itemDistance = n, this._distance = this.distance();
	  }function Xn() {
	    if (this.root = null, this.built = !1, this.itemBoundables = new I(), this.nodeCapacity = null, 0 === arguments.length) Xn.call(this, Xn.DEFAULT_NODE_CAPACITY);else if (1 === arguments.length) {
	      var t = arguments[0];h.isTrue(t > 1, "Node capacity must be greater than 1"), this.nodeCapacity = t;
	    }
	  }function kn() {}function Vn() {}function Hn() {
	    if (0 === arguments.length) Hn.call(this, Hn.DEFAULT_NODE_CAPACITY);else if (1 === arguments.length) {
	      var t = arguments[0];Xn.call(this, t);
	    }
	  }function Wn() {
	    var t = arguments[0];Un.call(this, t);
	  }function jn() {
	    this.graph = null, this.rings = new I(), this.totalEnv = new x(), this.index = null, this.nestedPt = null;var t = arguments[0];this.graph = t;
	  }function Kn() {
	    if (this.errorType = null, this.pt = null, 1 === arguments.length) {
	      var t = arguments[0];Kn.call(this, t, null);
	    } else if (2 === arguments.length) {
	      var e = arguments[0],
	          n = arguments[1];this.errorType = e, null !== n && (this.pt = n.copy());
	    }
	  }function Jn() {
	    this.parentGeometry = null, this.isSelfTouchingRingFormingHoleValid = !1, this.validErr = null;var t = arguments[0];this.parentGeometry = t;
	  }function Qn() {
	    this.inputGeom = null, this.factory = null, this.pruneEmptyGeometry = !0, this.preserveGeometryCollectionType = !0, this.preserveCollections = !1, this.preserveType = !1;
	  }function Zn() {
	    if (this.snapTolerance = 0, this.srcPts = null, this.seg = new ae(), this.allowSnappingToSourceVertices = !1, this._isClosed = !1, arguments[0] instanceof xt && "number" == typeof arguments[1]) {
	      var t = arguments[0],
	          e = arguments[1];Zn.call(this, t.getCoordinates(), e);
	    } else if (arguments[0] instanceof Array && "number" == typeof arguments[1]) {
	      var n = arguments[0],
	          i = arguments[1];this.srcPts = n, this._isClosed = Zn.isClosed(n), this.snapTolerance = i;
	    }
	  }function $n() {
	    this.srcGeom = null;var t = arguments[0];this.srcGeom = t;
	  }function ti() {
	    if (Qn.apply(this), this.snapTolerance = null, this.snapPts = null, this.isSelfSnap = !1, 2 === arguments.length) {
	      var t = arguments[0],
	          e = arguments[1];this.snapTolerance = t, this.snapPts = e;
	    } else if (3 === arguments.length) {
	      var n = arguments[0],
	          i = arguments[1],
	          r = arguments[2];this.snapTolerance = n, this.snapPts = i, this.isSelfSnap = r;
	    }
	  }function ei() {
	    this.isFirst = !0, this.commonMantissaBitsCount = 53, this.commonBits = 0, this.commonSignExp = null;
	  }function ni() {
	    this.commonCoord = null, this.ccFilter = new ii();
	  }function ii() {
	    this.commonBitsX = new ei(), this.commonBitsY = new ei();
	  }function ri() {
	    this.trans = null;var t = arguments[0];this.trans = t;
	  }function si() {}function oi() {}function ai() {
	    this.pts = null, this.data = null;var t = arguments[0],
	        e = arguments[1];this.pts = t, this.data = e;
	  }function ui() {}function li() {
	    this.segString = null, this.coord = null, this.segmentIndex = null, this.segmentOctant = null, this._isInterior = null;var t = arguments[0],
	        e = arguments[1],
	        n = arguments[2],
	        i = arguments[3];this.segString = t, this.coord = new c(e), this.segmentIndex = n, this.segmentOctant = i, this._isInterior = !e.equals2D(t.getCoordinate(n));
	  }function hi() {
	    this.nodeMap = new et(), this.edge = null;var t = arguments[0];this.edge = t;
	  }function ci() {
	    this.nodeList = null, this.edge = null, this.nodeIt = null, this.currNode = null, this.nextNode = null, this.currSegIndex = 0;var t = arguments[0];this.nodeList = t, this.edge = t.getEdge(), this.nodeIt = t.iterator(), this.readNextNode();
	  }function fi() {}function gi() {
	    this.nodeList = new hi(this), this.pts = null, this.data = null;var t = arguments[0],
	        e = arguments[1];this.pts = t, this.data = e;
	  }function di() {
	    this.tempEnv1 = new x(), this.tempEnv2 = new x(), this.overlapSeg1 = new ae(), this.overlapSeg2 = new ae();
	  }function pi() {}function mi() {
	    if (this.segInt = null, 0 === arguments.length) ;else if (1 === arguments.length) {
	      var t = arguments[0];this.setSegmentIntersector(t);
	    }
	  }function vi() {
	    if (this.monoChains = new I(), this.index = new Hn(), this.idCounter = 0, this.nodedSegStrings = null, this.nOverlaps = 0, 0 === arguments.length) ;else if (1 === arguments.length) {
	      var t = arguments[0];mi.call(this, t);
	    }
	  }function yi() {
	    di.apply(this), this.si = null;var t = arguments[0];this.si = t;
	  }function Ii() {}function Ei() {
	    this.findAllIntersections = !1, this.isCheckEndSegmentsOnly = !1, this.li = null, this.interiorIntersection = null, this.intSegments = null, this.intersections = new I(), this.intersectionCount = 0, this.keepIntersections = !0;var t = arguments[0];this.li = t, this.interiorIntersection = null;
	  }function xi() {
	    this.li = new ie(), this.segStrings = null, this.findAllIntersections = !1, this.segInt = null, this._isValid = !0;var t = arguments[0];this.segStrings = t;
	  }function Ni() {
	    this.nv = null;var t = arguments[0];this.nv = new xi(Ni.toSegmentStrings(t));
	  }function Ci() {
	    this.geometryFactory = null, this.shellList = new I();var t = arguments[0];this.geometryFactory = t;
	  }function Si() {
	    this.op = null, this.geometryFactory = null, this.ptLocator = null, this.lineEdgesList = new I(), this.resultLineList = new I();var t = arguments[0],
	        e = arguments[1],
	        n = arguments[2];this.op = t, this.geometryFactory = e, this.ptLocator = n;
	  }function Li() {
	    this.op = null, this.geometryFactory = null, this.resultPointList = new I();var t = arguments[0],
	        e = arguments[1];arguments[2];this.op = t, this.geometryFactory = e;
	  }function Ri() {
	    if (this.li = new ie(), this.resultPrecisionModel = null, this.arg = null, 1 === arguments.length) {
	      var t = arguments[0];this.setComputationPrecision(t.getPrecisionModel()), this.arg = new Array(1).fill(null), this.arg[0] = new bn(0, t);
	    } else if (2 === arguments.length) {
	      var e = arguments[0],
	          n = arguments[1];Ri.call(this, e, n, B.OGC_SFS_BOUNDARY_RULE);
	    } else if (3 === arguments.length) {
	      var i = arguments[0],
	          r = arguments[1],
	          s = arguments[2];i.getPrecisionModel().compareTo(r.getPrecisionModel()) >= 0 ? this.setComputationPrecision(i.getPrecisionModel()) : this.setComputationPrecision(r.getPrecisionModel()), this.arg = new Array(2).fill(null), this.arg[0] = new bn(0, i, s), this.arg[1] = new bn(1, r, s);
	    }
	  }function wi() {
	    this.pts = null, this._orientation = null;var t = arguments[0];this.pts = t, this._orientation = wi.orientation(t);
	  }function Ti() {
	    this.edges = new I(), this.ocaMap = new et();
	  }function Oi() {
	    this.ptLocator = new Ce(), this.geomFact = null, this.resultGeom = null, this.graph = null, this.edgeList = new Ti(), this.resultPolyList = new I(), this.resultLineList = new I(), this.resultPointList = new I();var t = arguments[0],
	        e = arguments[1];Ri.call(this, t, e), this.graph = new Je(new He()), this.geomFact = t.getFactory();
	  }function bi() {
	    this.geom = new Array(2).fill(null), this.snapTolerance = null, this.cbr = null;var t = arguments[0],
	        e = arguments[1];this.geom[0] = t, this.geom[1] = e, this.computeSnapTolerance();
	  }function Pi() {
	    this.geom = new Array(2).fill(null);var t = arguments[0],
	        e = arguments[1];this.geom[0] = t, this.geom[1] = e;
	  }function _i() {
	    this.factory = null, this.interiorPoint = null, this.maxWidth = 0;var t = arguments[0];this.factory = t.getFactory(), this.add(t);
	  }function Mi() {
	    this.poly = null, this.centreY = null, this.hiY = i.MAX_VALUE, this.loY = -i.MAX_VALUE;var t = arguments[0];this.poly = t, this.hiY = t.getEnvelopeInternal().getMaxY(), this.loY = t.getEnvelopeInternal().getMinY(), this.centreY = _i.avg(this.loY, this.hiY);
	  }function Ai() {
	    this.geomFactory = null, this.skipEmpty = !1, this.inputGeoms = null;var t = arguments[0];this.geomFactory = Ai.extractFactory(t), this.inputGeoms = t;
	  }function Di() {
	    this.pointGeom = null, this.otherGeom = null, this.geomFact = null;var t = arguments[0],
	        e = arguments[1];this.pointGeom = t, this.otherGeom = e, this.geomFact = e.getFactory();
	  }function Fi() {
	    this.sortIndex = -1, this.comps = null;var t = arguments[0],
	        e = arguments[1];this.sortIndex = t, this.comps = e;
	  }function Gi() {
	    this.inputPolys = null, this.geomFactory = null;var t = arguments[0];this.inputPolys = t, null === this.inputPolys && (this.inputPolys = new I());
	  }function Bi() {
	    if (this.polygons = new I(), this.lines = new I(), this.points = new I(), this.geomFact = null, 1 === arguments.length) {
	      if (_r(arguments[0], d)) {
	        var t = arguments[0];this.extract(t);
	      } else if (arguments[0] instanceof F) {
	        var e = arguments[0];this.extract(e);
	      }
	    } else if (2 === arguments.length) {
	      var n = arguments[0],
	          i = arguments[1];this.geomFact = i, this.extract(n);
	    }
	  }function qi() {}function zi() {
	    this.centroid = null, this.minDistance = i.MAX_VALUE, this.interiorPoint = null;var t = arguments[0];this.centroid = t.getCentroid().getCoordinate(), this.addInterior(t), null === this.interiorPoint && this.addEndpoints(t);
	  }function Ui() {
	    if (this.inputGeom = null, this.isClosedEndpointsInInterior = !0, this.nonSimpleLocation = null, 1 === arguments.length) {
	      var t = arguments[0];this.inputGeom = t;
	    } else if (2 === arguments.length) {
	      var e = arguments[0],
	          n = arguments[1];this.inputGeom = e, this.isClosedEndpointsInInterior = !n.isInBoundary(2);
	    }
	  }function Yi() {
	    this.pt = null, this.isClosed = null, this.degree = null;var t = arguments[0];this.pt = t, this.isClosed = !1, this.degree = 0;
	  }function Xi() {
	    if (this.quadrantSegments = Xi.DEFAULT_QUADRANT_SEGMENTS, this.endCapStyle = Xi.CAP_ROUND, this.joinStyle = Xi.JOIN_ROUND, this.mitreLimit = Xi.DEFAULT_MITRE_LIMIT, this._isSingleSided = !1, this.simplifyFactor = Xi.DEFAULT_SIMPLIFY_FACTOR, 0 === arguments.length) ;else if (1 === arguments.length) {
	      var t = arguments[0];this.setQuadrantSegments(t);
	    } else if (2 === arguments.length) {
	      var e = arguments[0],
	          n = arguments[1];this.setQuadrantSegments(e), this.setEndCapStyle(n);
	    } else if (4 === arguments.length) {
	      var i = arguments[0],
	          r = arguments[1],
	          s = arguments[2],
	          o = arguments[3];this.setQuadrantSegments(i), this.setEndCapStyle(r), this.setJoinStyle(s), this.setMitreLimit(o);
	    }
	  }function ki(t) {
	    this.message = t || "";
	  }function Vi() {
	    this.array_ = [];
	  }function Hi() {
	    this.minIndex = -1, this.minCoord = null, this.minDe = null, this.orientedDe = null;
	  }function Wi() {
	    this.array_ = [];
	  }function ji() {
	    this.finder = null, this.dirEdgeList = new I(), this.nodes = new I(), this.rightMostCoord = null, this.env = null, this.finder = new Hi();
	  }function Ki() {
	    this.inputLine = null, this.distanceTol = null, this.isDeleted = null, this.angleOrientation = oe.COUNTERCLOCKWISE;var t = arguments[0];this.inputLine = t;
	  }function Ji() {
	    this.ptList = null, this.precisionModel = null, this.minimimVertexDistance = 0, this.ptList = new I();
	  }function Qi() {}function Zi() {
	    this.maxCurveSegmentError = 0, this.filletAngleQuantum = null, this.closingSegLengthFactor = 1, this.segList = null, this.distance = 0, this.precisionModel = null, this.bufParams = null, this.li = null, this.s0 = null, this.s1 = null, this.s2 = null, this.seg0 = new ae(), this.seg1 = new ae(), this.offset0 = new ae(), this.offset1 = new ae(), this.side = 0, this._hasNarrowConcaveAngle = !1;var t = arguments[0],
	        e = arguments[1],
	        n = arguments[2];this.precisionModel = t, this.bufParams = e, this.li = new ie(), this.filletAngleQuantum = Math.PI / 2 / e.getQuadrantSegments(), e.getQuadrantSegments() >= 8 && e.getJoinStyle() === Xi.JOIN_ROUND && (this.closingSegLengthFactor = Zi.MAX_CLOSING_SEG_LEN_FACTOR), this.init(n);
	  }function $i() {
	    this.distance = 0, this.precisionModel = null, this.bufParams = null;var t = arguments[0],
	        e = arguments[1];this.precisionModel = t, this.bufParams = e;
	  }function tr() {
	    this.subgraphs = null, this.seg = new ae(), this.cga = new oe();var t = arguments[0];this.subgraphs = t;
	  }function er() {
	    this.upwardSeg = null, this.leftDepth = null;var t = arguments[0],
	        e = arguments[1];this.upwardSeg = new ae(t), this.leftDepth = e;
	  }function nr() {
	    this.p0 = null, this.p1 = null, this.p2 = null;var t = arguments[0],
	        e = arguments[1],
	        n = arguments[2];this.p0 = t, this.p1 = e, this.p2 = n;
	  }function ir() {
	    this.inputGeom = null, this.distance = null, this.curveBuilder = null, this.curveList = new I();var t = arguments[0],
	        e = arguments[1],
	        n = arguments[2];this.inputGeom = t, this.distance = e, this.curveBuilder = n;
	  }function rr() {
	    this._hasIntersection = !1, this.hasProper = !1, this.hasProperInterior = !1, this.hasInterior = !1, this.properIntersectionPoint = null, this.li = null, this.isSelfIntersection = null, this.numIntersections = 0, this.numInteriorIntersections = 0, this.numProperIntersections = 0, this.numTests = 0;var t = arguments[0];this.li = t;
	  }function sr() {
	    this.bufParams = null, this.workingPrecisionModel = null, this.workingNoder = null, this.geomFact = null, this.graph = null, this.edgeList = new Ti();var t = arguments[0];this.bufParams = t;
	  }function or() {
	    if (this.noder = null, this.scaleFactor = null, this.offsetX = null, this.offsetY = null, this.isScaled = !1, 2 === arguments.length) {
	      var t = arguments[0],
	          e = arguments[1];or.call(this, t, e, 0, 0);
	    } else if (4 === arguments.length) {
	      var n = arguments[0],
	          i = arguments[1];arguments[2], arguments[3];this.noder = n, this.scaleFactor = i, this.isScaled = !this.isIntegerPrecision();
	    }
	  }function ar() {
	    this.li = new ie(), this.segStrings = null;var t = arguments[0];this.segStrings = t;
	  }function ur() {
	    this.li = null, this.pt = null, this.originalPt = null, this.ptScaled = null, this.p0Scaled = null, this.p1Scaled = null, this.scaleFactor = null, this.minx = null, this.maxx = null, this.miny = null, this.maxy = null, this.corner = new Array(4).fill(null), this.safeEnv = null;var t = arguments[0],
	        e = arguments[1],
	        i = arguments[2];if (this.originalPt = t, this.pt = t, this.scaleFactor = e, this.li = i, e <= 0) throw new n("Scale factor must be non-zero");1 !== e && (this.pt = new c(this.scale(t.x), this.scale(t.y)), this.p0Scaled = new c(), this.p1Scaled = new c()), this.initCorners(this.pt);
	  }function lr() {
	    this.index = null;var t = arguments[0];this.index = t;
	  }function hr() {
	    Ze.apply(this), this.hotPixel = null, this.parentEdge = null, this.hotPixelVertexIndex = null, this._isNodeAdded = !1;var t = arguments[0],
	        e = arguments[1],
	        n = arguments[2];this.hotPixel = t, this.parentEdge = e, this.hotPixelVertexIndex = n;
	  }function cr() {
	    this.li = null, this.interiorIntersections = null;var t = arguments[0];this.li = t, this.interiorIntersections = new I();
	  }function fr() {
	    this.pm = null, this.li = null, this.scaleFactor = null, this.noder = null, this.pointSnapper = null, this.nodedSegStrings = null;var t = arguments[0];this.pm = t, this.li = new ie(), this.li.setPrecisionModel(t), this.scaleFactor = t.getScale();
	  }function gr() {
	    if (this.argGeom = null, this.distance = null, this.bufParams = new Xi(), this.resultGeometry = null, this.saveException = null, 1 === arguments.length) {
	      var t = arguments[0];this.argGeom = t;
	    } else if (2 === arguments.length) {
	      var e = arguments[0],
	          n = arguments[1];this.argGeom = e, this.bufParams = n;
	    }
	  }function dr() {
	    this.treeSet = new rt(), this.list = new I();
	  }function pr() {
	    if (this.geomFactory = null, this.inputPts = null, 1 === arguments.length) {
	      var t = arguments[0];pr.call(this, pr.extractCoordinates(t), t.getFactory());
	    } else if (2 === arguments.length) {
	      var e = arguments[0],
	          n = arguments[1];this.inputPts = dr.filterCoordinates(e), this.geomFactory = n;
	    }
	  }function mr() {
	    this.origin = null;var t = arguments[0];this.origin = t;
	  }function vr() {
	    this.areaBasePt = null, this.triangleCent3 = new c(), this.areasum2 = 0, this.cg3 = new c(), this.lineCentSum = new c(), this.totalLength = 0, this.ptCount = 0, this.ptCentSum = new c();var t = arguments[0];this.areaBasePt = null, this.add(t);
	  }function yr() {
	    if (this.matrix = null, 0 === arguments.length) this.matrix = Array(3).fill().map(function () {
	      return Array(3);
	    }), this.setAll(ot.FALSE);else if (1 === arguments.length) if ("string" == typeof arguments[0]) {
	      var t = arguments[0];yr.call(this), this.set(t);
	    } else if (arguments[0] instanceof yr) {
	      var e = arguments[0];yr.call(this), this.matrix[S.INTERIOR][S.INTERIOR] = e.matrix[S.INTERIOR][S.INTERIOR], this.matrix[S.INTERIOR][S.BOUNDARY] = e.matrix[S.INTERIOR][S.BOUNDARY], this.matrix[S.INTERIOR][S.EXTERIOR] = e.matrix[S.INTERIOR][S.EXTERIOR], this.matrix[S.BOUNDARY][S.INTERIOR] = e.matrix[S.BOUNDARY][S.INTERIOR], this.matrix[S.BOUNDARY][S.BOUNDARY] = e.matrix[S.BOUNDARY][S.BOUNDARY], this.matrix[S.BOUNDARY][S.EXTERIOR] = e.matrix[S.BOUNDARY][S.EXTERIOR], this.matrix[S.EXTERIOR][S.INTERIOR] = e.matrix[S.EXTERIOR][S.INTERIOR], this.matrix[S.EXTERIOR][S.BOUNDARY] = e.matrix[S.EXTERIOR][S.BOUNDARY], this.matrix[S.EXTERIOR][S.EXTERIOR] = e.matrix[S.EXTERIOR][S.EXTERIOR];
	    }
	  }function Ir() {
	    this.li = new ie(), this.ptLocator = new Ce(), this.arg = null, this.nodes = new We(new Dn()), this.im = null, this.isolatedEdges = new I(), this.invalidPoint = null;var t = arguments[0];this.arg = t;
	  }function Er() {
	    this.rectEnv = null;var t = arguments[0];this.rectEnv = t.getEnvelopeInternal();
	  }function xr() {
	    this.li = new ie(), this.rectEnv = null, this.diagUp0 = null, this.diagUp1 = null, this.diagDown0 = null, this.diagDown1 = null;var t = arguments[0];this.rectEnv = t, this.diagUp0 = new c(t.getMinX(), t.getMinY()), this.diagUp1 = new c(t.getMaxX(), t.getMaxY()), this.diagDown0 = new c(t.getMinX(), t.getMaxY()), this.diagDown1 = new c(t.getMaxX(), t.getMinY());
	  }function Nr() {
	    this._isDone = !1;
	  }function Cr() {
	    this.rectangle = null, this.rectEnv = null;var t = arguments[0];this.rectangle = t, this.rectEnv = t.getEnvelopeInternal();
	  }function Sr() {
	    Nr.apply(this), this.rectEnv = null, this._intersects = !1;var t = arguments[0];this.rectEnv = t;
	  }function Lr() {
	    Nr.apply(this), this.rectSeq = null, this.rectEnv = null, this._containsPoint = !1;var t = arguments[0];this.rectSeq = t.getExteriorRing().getCoordinateSequence(), this.rectEnv = t.getEnvelopeInternal();
	  }function Rr() {
	    Nr.apply(this), this.rectEnv = null, this.rectIntersector = null, this.hasIntersection = !1, this.p0 = new c(), this.p1 = new c();var t = arguments[0];this.rectEnv = t.getEnvelopeInternal(), this.rectIntersector = new xr(this.rectEnv);
	  }function wr() {
	    if (this._relate = null, 2 === arguments.length) {
	      var t = arguments[0],
	          e = arguments[1];Ri.call(this, t, e), this._relate = new Ir(this.arg);
	    } else if (3 === arguments.length) {
	      var n = arguments[0],
	          i = arguments[1],
	          r = arguments[2];Ri.call(this, n, i, r), this._relate = new Ir(this.arg);
	    }
	  }function Tr() {
	    this.centroid = null, this.minDistance = i.MAX_VALUE, this.interiorPoint = null;var t = arguments[0];this.centroid = t.getCentroid().getCoordinate(), this.add(t);
	  }"fill" in Array.prototype || Object.defineProperty(Array.prototype, "fill", { configurable: !0, value: function value(t) {
	      if (void 0 === this || null === this) throw new TypeError(this + " is not an object");var e = Object(this),
	          n = Math.max(Math.min(e.length, 9007199254740991), 0) || 0,
	          i = 1 in arguments ? parseInt(Number(arguments[1]), 10) || 0 : 0;i = i < 0 ? Math.max(n + i, 0) : Math.min(i, n);var r = 2 in arguments && void 0 !== arguments[2] ? parseInt(Number(arguments[2]), 10) || 0 : n;for (r = r < 0 ? Math.max(n + arguments[2], 0) : Math.min(r, n); i < r;) {
	        e[i] = t, ++i;
	      }return e;
	    }, writable: !0 }), Number.isFinite = Number.isFinite || function (t) {
	    return "number" == typeof t && isFinite(t);
	  }, Number.isInteger = Number.isInteger || function (t) {
	    return "number" == typeof t && isFinite(t) && Math.floor(t) === t;
	  }, Number.parseFloat = Number.parseFloat || parseFloat, Number.isNaN = Number.isNaN || function (t) {
	    return t !== t;
	  }, Math.trunc = Math.trunc || function (t) {
	    return t < 0 ? Math.ceil(t) : Math.floor(t);
	  };var Or = function Or(t, e) {
	    for (var n in e) {
	      e.hasOwnProperty(n) && (t[n] = e[n]);
	    }
	  };Or(e.prototype, { interfaces_: function interfaces_() {
	      return [];
	    }, getClass: function getClass() {
	      return e;
	    } }), e.equalsWithTolerance = function (t, e, n) {
	    return Math.abs(t - e) <= n;
	  }, i.isNaN = function (t) {
	    return Number.isNaN(t);
	  }, i.doubleToLongBits = function (t) {
	    return t;
	  }, i.longBitsToDouble = function (t) {
	    return t;
	  }, i.isInfinite = function (t) {
	    return !Number.isFinite(t);
	  }, i.MAX_VALUE = Number.MAX_VALUE, u.prototype = Object.create(Error.prototype), u.prototype.constructor = Error;var br = function br(t, e) {
	    t.prototype = Object.create(e.prototype), t.prototype.constructor = t;
	  };br(l, u), Or(l.prototype, { interfaces_: function interfaces_() {
	      return [];
	    }, getClass: function getClass() {
	      return l;
	    } }), Or(h.prototype, { interfaces_: function interfaces_() {
	      return [];
	    }, getClass: function getClass() {
	      return h;
	    } }), h.shouldNeverReachHere = function () {
	    if (0 === arguments.length) h.shouldNeverReachHere(null);else if (1 === arguments.length) {
	      var t = arguments[0];throw new l("Should never reach here" + (null !== t ? ": " + t : ""));
	    }
	  }, h.isTrue = function () {
	    if (1 === arguments.length) {
	      var t = arguments[0];h.isTrue(t, null);
	    } else if (2 === arguments.length) {
	      var e = arguments[0],
	          n = arguments[1];if (!e) throw null === n ? new l() : new l(n);
	    }
	  }, h.equals = function () {
	    if (2 === arguments.length) {
	      var t = arguments[0],
	          e = arguments[1];h.equals(t, e, null);
	    } else if (3 === arguments.length) {
	      var n = arguments[0],
	          i = arguments[1],
	          r = arguments[2];if (!i.equals(n)) throw new l("Expected " + n + " but encountered " + i + (null !== r ? ": " + r : ""));
	    }
	  }, Or(c.prototype, { setOrdinate: function setOrdinate(t, e) {
	      switch (t) {case c.X:
	          this.x = e;break;case c.Y:
	          this.y = e;break;case c.Z:
	          this.z = e;break;default:
	          throw new n("Invalid ordinate index: " + t);}
	    }, equals2D: function equals2D() {
	      if (1 === arguments.length) {
	        var t = arguments[0];return this.x === t.x && this.y === t.y;
	      }if (2 === arguments.length) {
	        var n = arguments[0],
	            i = arguments[1];return !!e.equalsWithTolerance(this.x, n.x, i) && !!e.equalsWithTolerance(this.y, n.y, i);
	      }
	    }, getOrdinate: function getOrdinate(t) {
	      switch (t) {case c.X:
	          return this.x;case c.Y:
	          return this.y;case c.Z:
	          return this.z;}throw new n("Invalid ordinate index: " + t);
	    }, equals3D: function equals3D(t) {
	      return this.x === t.x && this.y === t.y && (this.z === t.z || i.isNaN(this.z) && i.isNaN(t.z));
	    }, equals: function equals(t) {
	      return t instanceof c && this.equals2D(t);
	    }, equalInZ: function equalInZ(t, n) {
	      return e.equalsWithTolerance(this.z, t.z, n);
	    }, compareTo: function compareTo(t) {
	      var e = t;return this.x < e.x ? -1 : this.x > e.x ? 1 : this.y < e.y ? -1 : this.y > e.y ? 1 : 0;
	    }, clone: function clone() {
	      try {
	        return null;
	      } catch (t) {
	        if (t instanceof CloneNotSupportedException) return h.shouldNeverReachHere("this shouldn't happen because this class is Cloneable"), null;throw t;
	      } finally {}
	    }, copy: function copy() {
	      return new c(this);
	    }, toString: function toString() {
	      return "(" + this.x + ", " + this.y + ", " + this.z + ")";
	    }, distance3D: function distance3D(t) {
	      var e = this.x - t.x,
	          n = this.y - t.y,
	          i = this.z - t.z;return Math.sqrt(e * e + n * n + i * i);
	    }, distance: function distance(t) {
	      var e = this.x - t.x,
	          n = this.y - t.y;return Math.sqrt(e * e + n * n);
	    }, hashCode: function hashCode() {
	      var t = 17;return t = 37 * t + c.hashCode(this.x), t = 37 * t + c.hashCode(this.y);
	    }, setCoordinate: function setCoordinate(t) {
	      this.x = t.x, this.y = t.y, this.z = t.z;
	    }, interfaces_: function interfaces_() {
	      return [r, s, a];
	    }, getClass: function getClass() {
	      return c;
	    } }), c.hashCode = function () {
	    if (1 === arguments.length) {
	      var t = arguments[0],
	          e = i.doubleToLongBits(t);return Math.trunc(e ^ e >>> 32);
	    }
	  }, Or(f.prototype, { compare: function compare(t, e) {
	      var n = t,
	          i = e,
	          r = f.compare(n.x, i.x);if (0 !== r) return r;var s = f.compare(n.y, i.y);return 0 !== s ? s : this.dimensionsToTest <= 2 ? 0 : f.compare(n.z, i.z);
	    }, interfaces_: function interfaces_() {
	      return [o];
	    }, getClass: function getClass() {
	      return f;
	    } }), f.compare = function (t, e) {
	    return t < e ? -1 : t > e ? 1 : i.isNaN(t) ? i.isNaN(e) ? 0 : -1 : i.isNaN(e) ? 1 : 0;
	  }, c.DimensionalComparator = f, c.serialVersionUID = 0x5cbf2c235c7e5800, c.NULL_ORDINATE = i.NaN, c.X = 0, c.Y = 1, c.Z = 2, g.prototype.hasNext = function () {}, g.prototype.next = function () {}, g.prototype.remove = function () {}, d.prototype.add = function () {}, d.prototype.addAll = function () {}, d.prototype.isEmpty = function () {}, d.prototype.iterator = function () {}, d.prototype.size = function () {}, d.prototype.toArray = function () {}, d.prototype.remove = function () {}, p.prototype = new Error(), p.prototype.name = "IndexOutOfBoundsException", m.prototype = Object.create(d.prototype), m.prototype.constructor = m, m.prototype.get = function () {}, m.prototype.set = function () {}, m.prototype.isEmpty = function () {}, v.prototype = new Error(), v.prototype.name = "NoSuchElementException", y.prototype = new Error(), y.prototype.name = "OperationNotSupported", I.prototype = Object.create(m.prototype), I.prototype.constructor = I, I.prototype.ensureCapacity = function () {}, I.prototype.interfaces_ = function () {
	    return [m, d];
	  }, I.prototype.add = function (t) {
	    return 1 === arguments.length ? this.array_.push(t) : this.array_.splice(arguments[0], arguments[1]), !0;
	  }, I.prototype.clear = function () {
	    this.array_ = [];
	  }, I.prototype.addAll = function (t) {
	    for (var e = t.iterator(); e.hasNext();) {
	      this.add(e.next());
	    }return !0;
	  }, I.prototype.set = function (t, e) {
	    var n = this.array_[t];return this.array_[t] = e, n;
	  }, I.prototype.iterator = function () {
	    return new Pr(this);
	  }, I.prototype.get = function (t) {
	    if (t < 0 || t >= this.size()) throw new p();return this.array_[t];
	  }, I.prototype.isEmpty = function () {
	    return 0 === this.array_.length;
	  }, I.prototype.size = function () {
	    return this.array_.length;
	  }, I.prototype.toArray = function () {
	    for (var t = [], e = 0, n = this.array_.length; e < n; e++) {
	      t.push(this.array_[e]);
	    }return t;
	  }, I.prototype.remove = function (t) {
	    for (var e = !1, n = 0, i = this.array_.length; n < i; n++) {
	      if (this.array_[n] === t) {
	        this.array_.splice(n, 1), e = !0;break;
	      }
	    }return e;
	  };var Pr = function Pr(t) {
	    this.arrayList_ = t, this.position_ = 0;
	  };Pr.prototype.next = function () {
	    if (this.position_ === this.arrayList_.size()) throw new v();return this.arrayList_.get(this.position_++);
	  }, Pr.prototype.hasNext = function () {
	    return this.position_ < this.arrayList_.size();
	  }, Pr.prototype.set = function (t) {
	    return this.arrayList_.set(this.position_ - 1, t);
	  }, Pr.prototype.remove = function () {
	    this.arrayList_.remove(this.arrayList_.get(this.position_));
	  }, br(E, I), Or(E.prototype, { getCoordinate: function getCoordinate(t) {
	      return this.get(t);
	    }, addAll: function addAll() {
	      if (2 === arguments.length) {
	        for (var t = arguments[0], e = arguments[1], n = !1, i = t.iterator(); i.hasNext();) {
	          this.add(i.next(), e), n = !0;
	        }return n;
	      }return I.prototype.addAll.apply(this, arguments);
	    }, clone: function clone() {
	      for (var t = I.prototype.clone.call(this), e = 0; e < this.size(); e++) {
	        t.add(e, this.get(e).copy());
	      }return t;
	    }, toCoordinateArray: function toCoordinateArray() {
	      return this.toArray(E.coordArrayType);
	    }, add: function add() {
	      if (1 === arguments.length) {
	        var t = arguments[0];I.prototype.add.call(this, t);
	      } else if (2 === arguments.length) {
	        if (arguments[0] instanceof Array && "boolean" == typeof arguments[1]) {
	          var e = arguments[0],
	              n = arguments[1];return this.add(e, n, !0), !0;
	        }if (arguments[0] instanceof c && "boolean" == typeof arguments[1]) {
	          var i = arguments[0],
	              r = arguments[1];if (!r && this.size() >= 1) {
	            var s = this.get(this.size() - 1);if (s.equals2D(i)) return null;
	          }I.prototype.add.call(this, i);
	        } else if (arguments[0] instanceof Object && "boolean" == typeof arguments[1]) {
	          var o = arguments[0],
	              a = arguments[1];return this.add(o, a), !0;
	        }
	      } else if (3 === arguments.length) {
	        if ("boolean" == typeof arguments[2] && arguments[0] instanceof Array && "boolean" == typeof arguments[1]) {
	          var u = arguments[0],
	              l = arguments[1],
	              h = arguments[2];if (h) for (var f = 0; f < u.length; f++) {
	            this.add(u[f], l);
	          } else for (var f = u.length - 1; f >= 0; f--) {
	            this.add(u[f], l);
	          }return !0;
	        }if ("boolean" == typeof arguments[2] && Number.isInteger(arguments[0]) && arguments[1] instanceof c) {
	          var g = arguments[0],
	              d = arguments[1],
	              p = arguments[2];if (!p) {
	            var m = this.size();if (m > 0) {
	              if (g > 0) {
	                var v = this.get(g - 1);if (v.equals2D(d)) return null;
	              }if (g < m) {
	                var y = this.get(g);if (y.equals2D(d)) return null;
	              }
	            }
	          }I.prototype.add.call(this, g, d);
	        }
	      } else if (4 === arguments.length) {
	        var E = arguments[0],
	            x = arguments[1],
	            N = arguments[2],
	            C = arguments[3],
	            S = 1;N > C && (S = -1);for (var f = N; f !== C; f += S) {
	          this.add(E[f], x);
	        }return !0;
	      }
	    }, closeRing: function closeRing() {
	      this.size() > 0 && this.add(new c(this.get(0)), !1);
	    }, interfaces_: function interfaces_() {
	      return [];
	    }, getClass: function getClass() {
	      return E;
	    } }), E.coordArrayType = new Array(0).fill(null), Or(x.prototype, { getArea: function getArea() {
	      return this.getWidth() * this.getHeight();
	    }, equals: function equals(t) {
	      if (!(t instanceof x)) return !1;var e = t;return this.isNull() ? e.isNull() : this.maxx === e.getMaxX() && this.maxy === e.getMaxY() && this.minx === e.getMinX() && this.miny === e.getMinY();
	    }, intersection: function intersection(t) {
	      if (this.isNull() || t.isNull() || !this.intersects(t)) return new x();var e = this.minx > t.minx ? this.minx : t.minx,
	          n = this.miny > t.miny ? this.miny : t.miny;return new x(e, this.maxx < t.maxx ? this.maxx : t.maxx, n, this.maxy < t.maxy ? this.maxy : t.maxy);
	    }, isNull: function isNull() {
	      return this.maxx < this.minx;
	    }, getMaxX: function getMaxX() {
	      return this.maxx;
	    }, covers: function covers() {
	      if (1 === arguments.length) {
	        if (arguments[0] instanceof c) {
	          var t = arguments[0];return this.covers(t.x, t.y);
	        }if (arguments[0] instanceof x) {
	          var e = arguments[0];return !this.isNull() && !e.isNull() && e.getMinX() >= this.minx && e.getMaxX() <= this.maxx && e.getMinY() >= this.miny && e.getMaxY() <= this.maxy;
	        }
	      } else if (2 === arguments.length) {
	        var n = arguments[0],
	            i = arguments[1];return !this.isNull() && n >= this.minx && n <= this.maxx && i >= this.miny && i <= this.maxy;
	      }
	    }, intersects: function intersects() {
	      if (1 === arguments.length) {
	        if (arguments[0] instanceof x) {
	          var t = arguments[0];return !this.isNull() && !t.isNull() && !(t.minx > this.maxx || t.maxx < this.minx || t.miny > this.maxy || t.maxy < this.miny);
	        }if (arguments[0] instanceof c) {
	          var e = arguments[0];return this.intersects(e.x, e.y);
	        }
	      } else if (2 === arguments.length) {
	        var n = arguments[0],
	            i = arguments[1];return !this.isNull() && !(n > this.maxx || n < this.minx || i > this.maxy || i < this.miny);
	      }
	    }, getMinY: function getMinY() {
	      return this.miny;
	    }, getMinX: function getMinX() {
	      return this.minx;
	    }, expandToInclude: function expandToInclude() {
	      if (1 === arguments.length) {
	        if (arguments[0] instanceof c) {
	          var t = arguments[0];this.expandToInclude(t.x, t.y);
	        } else if (arguments[0] instanceof x) {
	          var e = arguments[0];if (e.isNull()) return null;this.isNull() ? (this.minx = e.getMinX(), this.maxx = e.getMaxX(), this.miny = e.getMinY(), this.maxy = e.getMaxY()) : (e.minx < this.minx && (this.minx = e.minx), e.maxx > this.maxx && (this.maxx = e.maxx), e.miny < this.miny && (this.miny = e.miny), e.maxy > this.maxy && (this.maxy = e.maxy));
	        }
	      } else if (2 === arguments.length) {
	        var n = arguments[0],
	            i = arguments[1];this.isNull() ? (this.minx = n, this.maxx = n, this.miny = i, this.maxy = i) : (n < this.minx && (this.minx = n), n > this.maxx && (this.maxx = n), i < this.miny && (this.miny = i), i > this.maxy && (this.maxy = i));
	      }
	    }, minExtent: function minExtent() {
	      if (this.isNull()) return 0;var t = this.getWidth(),
	          e = this.getHeight();return t < e ? t : e;
	    }, getWidth: function getWidth() {
	      return this.isNull() ? 0 : this.maxx - this.minx;
	    }, compareTo: function compareTo(t) {
	      var e = t;return this.isNull() ? e.isNull() ? 0 : -1 : e.isNull() ? 1 : this.minx < e.minx ? -1 : this.minx > e.minx ? 1 : this.miny < e.miny ? -1 : this.miny > e.miny ? 1 : this.maxx < e.maxx ? -1 : this.maxx > e.maxx ? 1 : this.maxy < e.maxy ? -1 : this.maxy > e.maxy ? 1 : 0;
	    }, translate: function translate(t, e) {
	      if (this.isNull()) return null;this.init(this.getMinX() + t, this.getMaxX() + t, this.getMinY() + e, this.getMaxY() + e);
	    }, toString: function toString() {
	      return "Env[" + this.minx + " : " + this.maxx + ", " + this.miny + " : " + this.maxy + "]";
	    }, setToNull: function setToNull() {
	      this.minx = 0, this.maxx = -1, this.miny = 0, this.maxy = -1;
	    }, getHeight: function getHeight() {
	      return this.isNull() ? 0 : this.maxy - this.miny;
	    }, maxExtent: function maxExtent() {
	      if (this.isNull()) return 0;var t = this.getWidth(),
	          e = this.getHeight();return t > e ? t : e;
	    }, expandBy: function expandBy() {
	      if (1 === arguments.length) {
	        var t = arguments[0];this.expandBy(t, t);
	      } else if (2 === arguments.length) {
	        var e = arguments[0],
	            n = arguments[1];if (this.isNull()) return null;this.minx -= e, this.maxx += e, this.miny -= n, this.maxy += n, (this.minx > this.maxx || this.miny > this.maxy) && this.setToNull();
	      }
	    }, contains: function contains() {
	      if (1 === arguments.length) {
	        if (arguments[0] instanceof x) {
	          var t = arguments[0];return this.covers(t);
	        }if (arguments[0] instanceof c) {
	          var e = arguments[0];return this.covers(e);
	        }
	      } else if (2 === arguments.length) {
	        var n = arguments[0],
	            i = arguments[1];return this.covers(n, i);
	      }
	    }, centre: function centre() {
	      return this.isNull() ? null : new c((this.getMinX() + this.getMaxX()) / 2, (this.getMinY() + this.getMaxY()) / 2);
	    }, init: function init() {
	      if (0 === arguments.length) this.setToNull();else if (1 === arguments.length) {
	        if (arguments[0] instanceof c) {
	          var t = arguments[0];this.init(t.x, t.x, t.y, t.y);
	        } else if (arguments[0] instanceof x) {
	          var e = arguments[0];this.minx = e.minx, this.maxx = e.maxx, this.miny = e.miny, this.maxy = e.maxy;
	        }
	      } else if (2 === arguments.length) {
	        var n = arguments[0],
	            i = arguments[1];this.init(n.x, i.x, n.y, i.y);
	      } else if (4 === arguments.length) {
	        var r = arguments[0],
	            s = arguments[1],
	            o = arguments[2],
	            a = arguments[3];r < s ? (this.minx = r, this.maxx = s) : (this.minx = s, this.maxx = r), o < a ? (this.miny = o, this.maxy = a) : (this.miny = a, this.maxy = o);
	      }
	    }, getMaxY: function getMaxY() {
	      return this.maxy;
	    }, distance: function distance(t) {
	      if (this.intersects(t)) return 0;var e = 0;this.maxx < t.minx ? e = t.minx - this.maxx : this.minx > t.maxx && (e = this.minx - t.maxx);var n = 0;return this.maxy < t.miny ? n = t.miny - this.maxy : this.miny > t.maxy && (n = this.miny - t.maxy), 0 === e ? n : 0 === n ? e : Math.sqrt(e * e + n * n);
	    }, hashCode: function hashCode() {
	      var t = 17;return t = 37 * t + c.hashCode(this.minx), t = 37 * t + c.hashCode(this.maxx), t = 37 * t + c.hashCode(this.miny), t = 37 * t + c.hashCode(this.maxy);
	    }, interfaces_: function interfaces_() {
	      return [r, a];
	    }, getClass: function getClass() {
	      return x;
	    } }), x.intersects = function () {
	    if (3 === arguments.length) {
	      var t = arguments[0],
	          e = arguments[1],
	          n = arguments[2];return n.x >= (t.x < e.x ? t.x : e.x) && n.x <= (t.x > e.x ? t.x : e.x) && n.y >= (t.y < e.y ? t.y : e.y) && n.y <= (t.y > e.y ? t.y : e.y);
	    }if (4 === arguments.length) {
	      var i = arguments[0],
	          r = arguments[1],
	          s = arguments[2],
	          o = arguments[3],
	          a = Math.min(s.x, o.x),
	          u = Math.max(s.x, o.x),
	          l = Math.min(i.x, r.x),
	          h = Math.max(i.x, r.x);return !(l > u) && !(h < a) && (a = Math.min(s.y, o.y), u = Math.max(s.y, o.y), l = Math.min(i.y, r.y), h = Math.max(i.y, r.y), !(l > u) && !(h < a));
	    }
	  }, x.serialVersionUID = 0x51845cd552189800, br(C, N), Or(C.prototype, { interfaces_: function interfaces_() {
	      return [];
	    }, getClass: function getClass() {
	      return C;
	    } }), Or(S.prototype, { interfaces_: function interfaces_() {
	      return [];
	    }, getClass: function getClass() {
	      return S;
	    } }), S.toLocationSymbol = function (t) {
	    switch (t) {case S.EXTERIOR:
	        return "e";case S.BOUNDARY:
	        return "b";case S.INTERIOR:
	        return "i";case S.NONE:
	        return "-";}throw new n("Unknown location value: " + t);
	  }, S.INTERIOR = 0, S.BOUNDARY = 1, S.EXTERIOR = 2, S.NONE = -1;var _r = function _r(t, e) {
	    return t.interfaces_ && t.interfaces_().indexOf(e) > -1;
	  };Or(L.prototype, { interfaces_: function interfaces_() {
	      return [];
	    }, getClass: function getClass() {
	      return L;
	    } }), L.log10 = function (t) {
	    var e = Math.log(t);return i.isInfinite(e) ? e : i.isNaN(e) ? e : e / L.LOG_10;
	  }, L.min = function (t, e, n, i) {
	    var r = t;return e < r && (r = e), n < r && (r = n), i < r && (r = i), r;
	  }, L.clamp = function () {
	    if ("number" == typeof arguments[2] && "number" == typeof arguments[0] && "number" == typeof arguments[1]) {
	      var t = arguments[0],
	          e = arguments[1],
	          n = arguments[2];return t < e ? e : t > n ? n : t;
	    }if (Number.isInteger(arguments[2]) && Number.isInteger(arguments[0]) && Number.isInteger(arguments[1])) {
	      var i = arguments[0],
	          r = arguments[1],
	          s = arguments[2];return i < r ? r : i > s ? s : i;
	    }
	  }, L.wrap = function (t, e) {
	    return t < 0 ? e - -t % e : t % e;
	  }, L.max = function () {
	    if (3 === arguments.length) {
	      var t = arguments[0],
	          e = arguments[1],
	          n = arguments[2],
	          i = t;return e > i && (i = e), n > i && (i = n), i;
	    }if (4 === arguments.length) {
	      var r = arguments[0],
	          s = arguments[1],
	          o = arguments[2],
	          a = arguments[3],
	          i = r;return s > i && (i = s), o > i && (i = o), a > i && (i = a), i;
	    }
	  }, L.average = function (t, e) {
	    return (t + e) / 2;
	  }, L.LOG_10 = Math.log(10), R.prototype.append = function (t) {
	    this.str += t;
	  }, R.prototype.setCharAt = function (t, e) {
	    this.str = this.str.substr(0, t) + e + this.str.substr(t + 1);
	  }, R.prototype.toString = function (t) {
	    return this.str;
	  }, w.prototype.intValue = function () {
	    return this.value;
	  }, w.prototype.compareTo = function (t) {
	    return this.value < t ? -1 : this.value > t ? 1 : 0;
	  }, w.isNaN = function (t) {
	    return Number.isNaN(t);
	  }, T.isWhitespace = function (t) {
	    return t <= 32 && t >= 0 || 127 == t;
	  }, T.toUpperCase = function (t) {
	    return t.toUpperCase();
	  }, Or(O.prototype, { le: function le(t) {
	      return this.hi < t.hi || this.hi === t.hi && this.lo <= t.lo;
	    }, extractSignificantDigits: function extractSignificantDigits(t, e) {
	      var n = this.abs(),
	          i = O.magnitude(n.hi),
	          r = O.TEN.pow(i);n = n.divide(r), n.gt(O.TEN) ? (n = n.divide(O.TEN), i += 1) : n.lt(O.ONE) && (n = n.multiply(O.TEN), i -= 1);for (var s = i + 1, o = new R(), a = O.MAX_PRINT_DIGITS - 1, u = 0; u <= a; u++) {
	        t && u === s && o.append(".");var l = Math.trunc(n.hi);if (l < 0) break;var h = !1,
	            c = 0;l > 9 ? (h = !0, c = "9") : c = "0" + l, o.append(c), n = n.subtract(O.valueOf(l)).multiply(O.TEN), h && n.selfAdd(O.TEN);var f = !0,
	            g = O.magnitude(n.hi);if (g < 0 && Math.abs(g) >= a - u && (f = !1), !f) break;
	      }return e[0] = i, o.toString();
	    }, sqr: function sqr() {
	      return this.multiply(this);
	    }, doubleValue: function doubleValue() {
	      return this.hi + this.lo;
	    }, subtract: function subtract() {
	      if (arguments[0] instanceof O) {
	        var t = arguments[0];return this.add(t.negate());
	      }if ("number" == typeof arguments[0]) {
	        var e = arguments[0];return this.add(-e);
	      }
	    }, equals: function equals() {
	      if (1 === arguments.length) {
	        var t = arguments[0];return this.hi === t.hi && this.lo === t.lo;
	      }
	    }, isZero: function isZero() {
	      return 0 === this.hi && 0 === this.lo;
	    }, selfSubtract: function selfSubtract() {
	      if (arguments[0] instanceof O) {
	        var t = arguments[0];return this.isNaN() ? this : this.selfAdd(-t.hi, -t.lo);
	      }if ("number" == typeof arguments[0]) {
	        var e = arguments[0];return this.isNaN() ? this : this.selfAdd(-e, 0);
	      }
	    }, getSpecialNumberString: function getSpecialNumberString() {
	      return this.isZero() ? "0.0" : this.isNaN() ? "NaN " : null;
	    }, min: function min(t) {
	      return this.le(t) ? this : t;
	    }, selfDivide: function selfDivide() {
	      if (1 === arguments.length) {
	        if (arguments[0] instanceof O) {
	          var t = arguments[0];return this.selfDivide(t.hi, t.lo);
	        }if ("number" == typeof arguments[0]) {
	          var e = arguments[0];return this.selfDivide(e, 0);
	        }
	      } else if (2 === arguments.length) {
	        var n = arguments[0],
	            i = arguments[1],
	            r = null,
	            s = null,
	            o = null,
	            a = null,
	            u = null,
	            l = null,
	            h = null,
	            c = null;return u = this.hi / n, l = O.SPLIT * u, r = l - u, c = O.SPLIT * n, r = l - r, s = u - r, o = c - n, h = u * n, o = c - o, a = n - o, c = r * o - h + r * a + s * o + s * a, l = (this.hi - h - c + this.lo - u * i) / n, c = u + l, this.hi = c, this.lo = u - c + l, this;
	      }
	    }, dump: function dump() {
	      return "DD<" + this.hi + ", " + this.lo + ">";
	    }, divide: function divide() {
	      if (arguments[0] instanceof O) {
	        var t = arguments[0],
	            e = null,
	            n = null,
	            r = null,
	            s = null,
	            o = null,
	            a = null,
	            u = null,
	            l = null;o = this.hi / t.hi, a = O.SPLIT * o, e = a - o, l = O.SPLIT * t.hi, e = a - e, n = o - e, r = l - t.hi, u = o * t.hi, r = l - r, s = t.hi - r, l = e * r - u + e * s + n * r + n * s, a = (this.hi - u - l + this.lo - o * t.lo) / t.hi, l = o + a;return new O(l, o - l + a);
	      }if ("number" == typeof arguments[0]) {
	        var h = arguments[0];return i.isNaN(h) ? O.createNaN() : O.copy(this).selfDivide(h, 0);
	      }
	    }, ge: function ge(t) {
	      return this.hi > t.hi || this.hi === t.hi && this.lo >= t.lo;
	    }, pow: function pow(t) {
	      if (0 === t) return O.valueOf(1);var e = new O(this),
	          n = O.valueOf(1),
	          i = Math.abs(t);if (i > 1) for (; i > 0;) {
	        i % 2 == 1 && n.selfMultiply(e), (i /= 2) > 0 && (e = e.sqr());
	      } else n = e;return t < 0 ? n.reciprocal() : n;
	    }, ceil: function ceil() {
	      if (this.isNaN()) return O.NaN;var t = Math.ceil(this.hi),
	          e = 0;return t === this.hi && (e = Math.ceil(this.lo)), new O(t, e);
	    }, compareTo: function compareTo(t) {
	      var e = t;return this.hi < e.hi ? -1 : this.hi > e.hi ? 1 : this.lo < e.lo ? -1 : this.lo > e.lo ? 1 : 0;
	    }, rint: function rint() {
	      return this.isNaN() ? this : this.add(.5).floor();
	    }, setValue: function setValue() {
	      if (arguments[0] instanceof O) {
	        var t = arguments[0];return this.init(t), this;
	      }if ("number" == typeof arguments[0]) {
	        var e = arguments[0];return this.init(e), this;
	      }
	    }, max: function max(t) {
	      return this.ge(t) ? this : t;
	    }, sqrt: function sqrt() {
	      if (this.isZero()) return O.valueOf(0);if (this.isNegative()) return O.NaN;var t = 1 / Math.sqrt(this.hi),
	          e = this.hi * t,
	          n = O.valueOf(e),
	          i = this.subtract(n.sqr()),
	          r = i.hi * (.5 * t);return n.add(r);
	    }, selfAdd: function selfAdd() {
	      if (1 === arguments.length) {
	        if (arguments[0] instanceof O) {
	          var t = arguments[0];return this.selfAdd(t.hi, t.lo);
	        }if ("number" == typeof arguments[0]) {
	          var e = arguments[0],
	              n = null,
	              i = null,
	              r = null,
	              s = null,
	              o = null,
	              a = null;return r = this.hi + e, o = r - this.hi, s = r - o, s = e - o + (this.hi - s), a = s + this.lo, n = r + a, i = a + (r - n), this.hi = n + i, this.lo = i + (n - this.hi), this;
	        }
	      } else if (2 === arguments.length) {
	        var u = arguments[0],
	            l = arguments[1],
	            n = null,
	            i = null,
	            h = null,
	            c = null,
	            r = null,
	            s = null,
	            o = null,
	            a = null;r = this.hi + u, h = this.lo + l, o = r - this.hi, a = h - this.lo, s = r - o, c = h - a, s = u - o + (this.hi - s), c = l - a + (this.lo - c), o = s + h, n = r + o, i = o + (r - n), o = c + i;var f = n + o,
	            g = o + (n - f);return this.hi = f, this.lo = g, this;
	      }
	    }, selfMultiply: function selfMultiply() {
	      if (1 === arguments.length) {
	        if (arguments[0] instanceof O) {
	          var t = arguments[0];return this.selfMultiply(t.hi, t.lo);
	        }if ("number" == typeof arguments[0]) {
	          var e = arguments[0];return this.selfMultiply(e, 0);
	        }
	      } else if (2 === arguments.length) {
	        var n = arguments[0],
	            i = arguments[1],
	            r = null,
	            s = null,
	            o = null,
	            a = null,
	            u = null,
	            l = null;u = O.SPLIT * this.hi, r = u - this.hi, l = O.SPLIT * n, r = u - r, s = this.hi - r, o = l - n, u = this.hi * n, o = l - o, a = n - o, l = r * o - u + r * a + s * o + s * a + (this.hi * i + this.lo * n);var h = u + l;r = u - h;var c = l + r;return this.hi = h, this.lo = c, this;
	      }
	    }, selfSqr: function selfSqr() {
	      return this.selfMultiply(this);
	    }, floor: function floor() {
	      if (this.isNaN()) return O.NaN;var t = Math.floor(this.hi),
	          e = 0;return t === this.hi && (e = Math.floor(this.lo)), new O(t, e);
	    }, negate: function negate() {
	      return this.isNaN() ? this : new O(-this.hi, -this.lo);
	    }, clone: function clone() {
	      try {
	        return null;
	      } catch (t) {
	        if (t instanceof CloneNotSupportedException) return null;throw t;
	      } finally {}
	    }, multiply: function multiply() {
	      if (arguments[0] instanceof O) {
	        var t = arguments[0];return t.isNaN() ? O.createNaN() : O.copy(this).selfMultiply(t);
	      }if ("number" == typeof arguments[0]) {
	        var e = arguments[0];return i.isNaN(e) ? O.createNaN() : O.copy(this).selfMultiply(e, 0);
	      }
	    }, isNaN: function isNaN() {
	      return i.isNaN(this.hi);
	    }, intValue: function intValue() {
	      return Math.trunc(this.hi);
	    }, toString: function toString() {
	      var t = O.magnitude(this.hi);return t >= -3 && t <= 20 ? this.toStandardNotation() : this.toSciNotation();
	    }, toStandardNotation: function toStandardNotation() {
	      var t = this.getSpecialNumberString();if (null !== t) return t;var e = new Array(1).fill(null),
	          n = this.extractSignificantDigits(!0, e),
	          i = e[0] + 1,
	          r = n;if ("." === n.charAt(0)) r = "0" + n;else if (i < 0) r = "0." + O.stringOfChar("0", -i) + n;else if (n.indexOf(".") === -1) {
	        var s = i - n.length,
	            o = O.stringOfChar("0", s);r = n + o + ".0";
	      }return this.isNegative() ? "-" + r : r;
	    }, reciprocal: function reciprocal() {
	      var t = null,
	          e = null,
	          n = null,
	          i = null,
	          r = null,
	          s = null,
	          o = null,
	          a = null;r = 1 / this.hi, s = O.SPLIT * r, t = s - r, a = O.SPLIT * this.hi, t = s - t, e = r - t, n = a - this.hi, o = r * this.hi, n = a - n, i = this.hi - n, a = t * n - o + t * i + e * n + e * i, s = (1 - o - a - r * this.lo) / this.hi;var u = r + s;return new O(u, r - u + s);
	    }, toSciNotation: function toSciNotation() {
	      if (this.isZero()) return O.SCI_NOT_ZERO;var t = this.getSpecialNumberString();if (null !== t) return t;var e = new Array(1).fill(null),
	          n = this.extractSignificantDigits(!1, e),
	          i = O.SCI_NOT_EXPONENT_CHAR + e[0];if ("0" === n.charAt(0)) throw new IllegalStateException("Found leading zero: " + n);var r = "";n.length > 1 && (r = n.substring(1));var s = n.charAt(0) + "." + r;return this.isNegative() ? "-" + s + i : s + i;
	    }, abs: function abs() {
	      return this.isNaN() ? O.NaN : this.isNegative() ? this.negate() : new O(this);
	    }, isPositive: function isPositive() {
	      return this.hi > 0 || 0 === this.hi && this.lo > 0;
	    }, lt: function lt(t) {
	      return this.hi < t.hi || this.hi === t.hi && this.lo < t.lo;
	    }, add: function add() {
	      if (arguments[0] instanceof O) {
	        var t = arguments[0];return O.copy(this).selfAdd(t);
	      }if ("number" == typeof arguments[0]) {
	        var e = arguments[0];return O.copy(this).selfAdd(e);
	      }
	    }, init: function init() {
	      if (1 === arguments.length) {
	        if ("number" == typeof arguments[0]) {
	          var t = arguments[0];this.hi = t, this.lo = 0;
	        } else if (arguments[0] instanceof O) {
	          var e = arguments[0];this.hi = e.hi, this.lo = e.lo;
	        }
	      } else if (2 === arguments.length) {
	        var n = arguments[0],
	            i = arguments[1];this.hi = n, this.lo = i;
	      }
	    }, gt: function gt(t) {
	      return this.hi > t.hi || this.hi === t.hi && this.lo > t.lo;
	    }, isNegative: function isNegative() {
	      return this.hi < 0 || 0 === this.hi && this.lo < 0;
	    }, trunc: function trunc() {
	      return this.isNaN() ? O.NaN : this.isPositive() ? this.floor() : this.ceil();
	    }, signum: function signum() {
	      return this.hi > 0 ? 1 : this.hi < 0 ? -1 : this.lo > 0 ? 1 : this.lo < 0 ? -1 : 0;
	    }, interfaces_: function interfaces_() {
	      return [a, r, s];
	    }, getClass: function getClass() {
	      return O;
	    } }), O.sqr = function (t) {
	    return O.valueOf(t).selfMultiply(t);
	  }, O.valueOf = function () {
	    if ("string" == typeof arguments[0]) {
	      var t = arguments[0];return O.parse(t);
	    }if ("number" == typeof arguments[0]) {
	      return new O(arguments[0]);
	    }
	  }, O.sqrt = function (t) {
	    return O.valueOf(t).sqrt();
	  }, O.parse = function (t) {
	    for (var e = 0, n = t.length; T.isWhitespace(t.charAt(e));) {
	      e++;
	    }var i = !1;if (e < n) {
	      var r = t.charAt(e);"-" !== r && "+" !== r || (e++, "-" === r && (i = !0));
	    }for (var s = new O(), o = 0, a = 0, u = 0;;) {
	      if (e >= n) break;var l = t.charAt(e);if (e++, T.isDigit(l)) {
	        var h = l - "0";s.selfMultiply(O.TEN), s.selfAdd(h), o++;
	      } else {
	        if ("." !== l) {
	          if ("e" === l || "E" === l) {
	            var c = t.substring(e);try {
	              u = w.parseInt(c);
	            } catch (e) {
	              throw e instanceof NumberFormatException ? new NumberFormatException("Invalid exponent " + c + " in string " + t) : e;
	            } finally {}break;
	          }throw new NumberFormatException("Unexpected character '" + l + "' at position " + e + " in string " + t);
	        }a = o;
	      }
	    }var f = s,
	        g = o - a - u;if (0 === g) f = s;else if (g > 0) {
	      var d = O.TEN.pow(g);f = s.divide(d);
	    } else if (g < 0) {
	      var d = O.TEN.pow(-g);f = s.multiply(d);
	    }return i ? f.negate() : f;
	  }, O.createNaN = function () {
	    return new O(i.NaN, i.NaN);
	  }, O.copy = function (t) {
	    return new O(t);
	  }, O.magnitude = function (t) {
	    var e = Math.abs(t),
	        n = Math.log(e) / Math.log(10),
	        i = Math.trunc(Math.floor(n));return 10 * Math.pow(10, i) <= e && (i += 1), i;
	  }, O.stringOfChar = function (t, e) {
	    for (var n = new R(), i = 0; i < e; i++) {
	      n.append(t);
	    }return n.toString();
	  }, O.PI = new O(3.141592653589793, 1.2246467991473532e-16), O.TWO_PI = new O(6.283185307179586, 2.4492935982947064e-16), O.PI_2 = new O(1.5707963267948966, 6.123233995736766e-17), O.E = new O(2.718281828459045, 1.4456468917292502e-16), O.NaN = new O(i.NaN, i.NaN), O.EPS = 1.23259516440783e-32, O.SPLIT = 134217729, O.MAX_PRINT_DIGITS = 32, O.TEN = O.valueOf(10), O.ONE = O.valueOf(1), O.SCI_NOT_EXPONENT_CHAR = "E", O.SCI_NOT_ZERO = "0.0E0", Or(b.prototype, { interfaces_: function interfaces_() {
	      return [];
	    }, getClass: function getClass() {
	      return b;
	    } }), b.orientationIndex = function (t, e, n) {
	    var i = b.orientationIndexFilter(t, e, n);if (i <= 1) return i;var r = O.valueOf(e.x).selfAdd(-t.x),
	        s = O.valueOf(e.y).selfAdd(-t.y),
	        o = O.valueOf(n.x).selfAdd(-e.x),
	        a = O.valueOf(n.y).selfAdd(-e.y);return r.selfMultiply(a).selfSubtract(s.selfMultiply(o)).signum();
	  }, b.signOfDet2x2 = function (t, e, n, i) {
	    return t.multiply(i).selfSubtract(e.multiply(n)).signum();
	  }, b.intersection = function (t, e, n, i) {
	    var r = O.valueOf(i.y).selfSubtract(n.y).selfMultiply(O.valueOf(e.x).selfSubtract(t.x)),
	        s = O.valueOf(i.x).selfSubtract(n.x).selfMultiply(O.valueOf(e.y).selfSubtract(t.y)),
	        o = r.subtract(s),
	        a = O.valueOf(i.x).selfSubtract(n.x).selfMultiply(O.valueOf(t.y).selfSubtract(n.y)),
	        u = O.valueOf(i.y).selfSubtract(n.y).selfMultiply(O.valueOf(t.x).selfSubtract(n.x)),
	        l = a.subtract(u),
	        h = l.selfDivide(o).doubleValue(),
	        f = O.valueOf(t.x).selfAdd(O.valueOf(e.x).selfSubtract(t.x).selfMultiply(h)).doubleValue(),
	        g = O.valueOf(e.x).selfSubtract(t.x).selfMultiply(O.valueOf(t.y).selfSubtract(n.y)),
	        d = O.valueOf(e.y).selfSubtract(t.y).selfMultiply(O.valueOf(t.x).selfSubtract(n.x)),
	        p = g.subtract(d),
	        m = p.selfDivide(o).doubleValue();return new c(f, O.valueOf(n.y).selfAdd(O.valueOf(i.y).selfSubtract(n.y).selfMultiply(m)).doubleValue());
	  }, b.orientationIndexFilter = function (t, e, n) {
	    var i = null,
	        r = (t.x - n.x) * (e.y - n.y),
	        s = (t.y - n.y) * (e.x - n.x),
	        o = r - s;if (r > 0) {
	      if (s <= 0) return b.signum(o);i = r + s;
	    } else {
	      if (!(r < 0)) return b.signum(o);if (s >= 0) return b.signum(o);i = -r - s;
	    }var a = b.DP_SAFE_EPSILON * i;return o >= a || -o >= a ? b.signum(o) : 2;
	  }, b.signum = function (t) {
	    return t > 0 ? 1 : t < 0 ? -1 : 0;
	  }, b.DP_SAFE_EPSILON = 1e-15, Or(P.prototype, { setOrdinate: function setOrdinate(t, e, n) {}, size: function size() {}, getOrdinate: function getOrdinate(t, e) {}, getCoordinate: function getCoordinate() {
	      if (1 === arguments.length) {
	        arguments[0];
	      } else if (2 === arguments.length) {
	        arguments[0], arguments[1];
	      }
	    }, getCoordinateCopy: function getCoordinateCopy(t) {}, getDimension: function getDimension() {}, getX: function getX(t) {}, clone: function clone() {}, expandEnvelope: function expandEnvelope(t) {}, copy: function copy() {}, getY: function getY(t) {}, toCoordinateArray: function toCoordinateArray() {}, interfaces_: function interfaces_() {
	      return [s];
	    }, getClass: function getClass() {
	      return P;
	    } }), P.X = 0, P.Y = 1, P.Z = 2, P.M = 3, _.arraycopy = function (t, e, n, i, r) {
	    for (var s = 0, o = e; o < e + r; o++) {
	      n[i + s] = t[o], s++;
	    }
	  }, _.getProperty = function (t) {
	    return { "line.separator": "\n" }[t];
	  }, Or(M.prototype, { getY: function getY() {
	      var t = this.y / this.w;if (i.isNaN(t) || i.isInfinite(t)) throw new C();return t;
	    }, getX: function getX() {
	      var t = this.x / this.w;if (i.isNaN(t) || i.isInfinite(t)) throw new C();return t;
	    }, getCoordinate: function getCoordinate() {
	      var t = new c();return t.x = this.getX(), t.y = this.getY(), t;
	    }, interfaces_: function interfaces_() {
	      return [];
	    }, getClass: function getClass() {
	      return M;
	    } }), M.intersection = function (t, e, n, r) {
	    var s = t.y - e.y,
	        o = e.x - t.x,
	        a = t.x * e.y - e.x * t.y,
	        u = n.y - r.y,
	        l = r.x - n.x,
	        h = n.x * r.y - r.x * n.y,
	        f = o * h - l * a,
	        g = u * a - s * h,
	        d = s * l - u * o,
	        p = f / d,
	        m = g / d;if (i.isNaN(p) || i.isInfinite(p) || i.isNaN(m) || i.isInfinite(m)) throw new C();return new c(p, m);
	  }, Or(A.prototype, { create: function create() {
	      if (1 === arguments.length) {
	        if (arguments[0] instanceof Array) {
	          arguments[0];
	        } else if (_r(arguments[0], P)) {
	          arguments[0];
	        }
	      } else if (2 === arguments.length) {
	        arguments[0], arguments[1];
	      }
	    }, interfaces_: function interfaces_() {
	      return [];
	    }, getClass: function getClass() {
	      return A;
	    } }), Or(D.prototype, { filter: function filter(t) {}, interfaces_: function interfaces_() {
	      return [];
	    }, getClass: function getClass() {
	      return D;
	    } }), Or(F.prototype, { isGeometryCollection: function isGeometryCollection() {
	      return this.getSortIndex() === F.SORTINDEX_GEOMETRYCOLLECTION;
	    }, getFactory: function getFactory() {
	      return this.factory;
	    }, getGeometryN: function getGeometryN(t) {
	      return this;
	    }, getArea: function getArea() {
	      return 0;
	    }, isRectangle: function isRectangle() {
	      return !1;
	    }, equals: function equals() {
	      if (1 === arguments.length) {
	        if (arguments[0] instanceof F) {
	          var t = arguments[0];return null !== t && this.equalsTopo(t);
	        }if (arguments[0] instanceof Object) {
	          var e = arguments[0];if (!(e instanceof F)) return !1;var n = e;return this.equalsExact(n);
	        }
	      }
	    }, equalsExact: function equalsExact(t) {
	      return this === t || this.equalsExact(t, 0);
	    }, geometryChanged: function geometryChanged() {
	      this.apply(F.geometryChangedFilter);
	    }, geometryChangedAction: function geometryChangedAction() {
	      this.envelope = null;
	    }, equalsNorm: function equalsNorm(t) {
	      return null !== t && this.norm().equalsExact(t.norm());
	    }, getLength: function getLength() {
	      return 0;
	    }, getNumGeometries: function getNumGeometries() {
	      return 1;
	    }, compareTo: function compareTo() {
	      if (1 === arguments.length) {
	        var t = arguments[0],
	            e = t;return this.getSortIndex() !== e.getSortIndex() ? this.getSortIndex() - e.getSortIndex() : this.isEmpty() && e.isEmpty() ? 0 : this.isEmpty() ? -1 : e.isEmpty() ? 1 : this.compareToSameClass(t);
	      }if (2 === arguments.length) {
	        var n = arguments[0],
	            i = arguments[1],
	            e = n;return this.getSortIndex() !== e.getSortIndex() ? this.getSortIndex() - e.getSortIndex() : this.isEmpty() && e.isEmpty() ? 0 : this.isEmpty() ? -1 : e.isEmpty() ? 1 : this.compareToSameClass(n, i);
	      }
	    }, getUserData: function getUserData() {
	      return this.userData;
	    }, getSRID: function getSRID() {
	      return this.SRID;
	    }, getEnvelope: function getEnvelope() {
	      return this.getFactory().toGeometry(this.getEnvelopeInternal());
	    }, checkNotGeometryCollection: function checkNotGeometryCollection(t) {
	      if (t.getSortIndex() === F.SORTINDEX_GEOMETRYCOLLECTION) throw new n("This method does not support GeometryCollection arguments");
	    }, equal: function equal(t, e, n) {
	      return 0 === n ? t.equals(e) : t.distance(e) <= n;
	    }, norm: function norm() {
	      var t = this.copy();return t.normalize(), t;
	    }, getPrecisionModel: function getPrecisionModel() {
	      return this.factory.getPrecisionModel();
	    }, getEnvelopeInternal: function getEnvelopeInternal() {
	      return null === this.envelope && (this.envelope = this.computeEnvelopeInternal()), new x(this.envelope);
	    }, setSRID: function setSRID(t) {
	      this.SRID = t;
	    }, setUserData: function setUserData(t) {
	      this.userData = t;
	    }, compare: function compare(t, e) {
	      for (var n = t.iterator(), i = e.iterator(); n.hasNext() && i.hasNext();) {
	        var r = n.next(),
	            s = i.next(),
	            o = r.compareTo(s);if (0 !== o) return o;
	      }return n.hasNext() ? 1 : i.hasNext() ? -1 : 0;
	    }, hashCode: function hashCode() {
	      return this.getEnvelopeInternal().hashCode();
	    }, isGeometryCollectionOrDerived: function isGeometryCollectionOrDerived() {
	      return this.getSortIndex() === F.SORTINDEX_GEOMETRYCOLLECTION || this.getSortIndex() === F.SORTINDEX_MULTIPOINT || this.getSortIndex() === F.SORTINDEX_MULTILINESTRING || this.getSortIndex() === F.SORTINDEX_MULTIPOLYGON;
	    }, interfaces_: function interfaces_() {
	      return [s, r, a];
	    }, getClass: function getClass() {
	      return F;
	    } }), F.hasNonEmptyElements = function (t) {
	    for (var e = 0; e < t.length; e++) {
	      if (!t[e].isEmpty()) return !0;
	    }return !1;
	  }, F.hasNullElements = function (t) {
	    for (var e = 0; e < t.length; e++) {
	      if (null === t[e]) return !0;
	    }return !1;
	  }, F.serialVersionUID = 0x799ea46522854c00, F.SORTINDEX_POINT = 0, F.SORTINDEX_MULTIPOINT = 1, F.SORTINDEX_LINESTRING = 2, F.SORTINDEX_LINEARRING = 3, F.SORTINDEX_MULTILINESTRING = 4, F.SORTINDEX_POLYGON = 5, F.SORTINDEX_MULTIPOLYGON = 6, F.SORTINDEX_GEOMETRYCOLLECTION = 7, F.geometryChangedFilter = { interfaces_: function interfaces_() {
	      return [D];
	    }, filter: function filter(t) {
	      t.geometryChangedAction();
	    } }, Or(G.prototype, { filter: function filter(t) {}, interfaces_: function interfaces_() {
	      return [];
	    }, getClass: function getClass() {
	      return G;
	    } }), Or(B.prototype, { isInBoundary: function isInBoundary(t) {}, interfaces_: function interfaces_() {
	      return [];
	    }, getClass: function getClass() {
	      return B;
	    } }), Or(q.prototype, { isInBoundary: function isInBoundary(t) {
	      return t % 2 == 1;
	    }, interfaces_: function interfaces_() {
	      return [B];
	    }, getClass: function getClass() {
	      return q;
	    } }), Or(z.prototype, { isInBoundary: function isInBoundary(t) {
	      return t > 0;
	    }, interfaces_: function interfaces_() {
	      return [B];
	    }, getClass: function getClass() {
	      return z;
	    } }), Or(U.prototype, { isInBoundary: function isInBoundary(t) {
	      return t > 1;
	    }, interfaces_: function interfaces_() {
	      return [B];
	    }, getClass: function getClass() {
	      return U;
	    } }), Or(Y.prototype, { isInBoundary: function isInBoundary(t) {
	      return 1 === t;
	    }, interfaces_: function interfaces_() {
	      return [B];
	    }, getClass: function getClass() {
	      return Y;
	    } }), B.Mod2BoundaryNodeRule = q, B.EndPointBoundaryNodeRule = z, B.MultiValentEndPointBoundaryNodeRule = U, B.MonoValentEndPointBoundaryNodeRule = Y, B.MOD2_BOUNDARY_RULE = new q(), B.ENDPOINT_BOUNDARY_RULE = new z(), B.MULTIVALENT_ENDPOINT_BOUNDARY_RULE = new U(), B.MONOVALENT_ENDPOINT_BOUNDARY_RULE = new Y(), B.OGC_SFS_BOUNDARY_RULE = B.MOD2_BOUNDARY_RULE, Or(X.prototype, { interfaces_: function interfaces_() {
	      return [];
	    }, getClass: function getClass() {
	      return X;
	    } }), X.isRing = function (t) {
	    return !(t.length < 4) && !!t[0].equals2D(t[t.length - 1]);
	  }, X.ptNotInList = function (t, e) {
	    for (var n = 0; n < t.length; n++) {
	      var i = t[n];if (X.indexOf(i, e) < 0) return i;
	    }return null;
	  }, X.scroll = function (t, e) {
	    var n = X.indexOf(e, t);if (n < 0) return null;var i = new Array(t.length).fill(null);_.arraycopy(t, n, i, 0, t.length - n), _.arraycopy(t, 0, i, t.length - n, n), _.arraycopy(i, 0, t, 0, t.length);
	  }, X.equals = function () {
	    if (2 === arguments.length) {
	      var t = arguments[0],
	          e = arguments[1];if (t === e) return !0;if (null === t || null === e) return !1;if (t.length !== e.length) return !1;for (var n = 0; n < t.length; n++) {
	        if (!t[n].equals(e[n])) return !1;
	      }return !0;
	    }if (3 === arguments.length) {
	      var i = arguments[0],
	          r = arguments[1],
	          s = arguments[2];if (i === r) return !0;if (null === i || null === r) return !1;if (i.length !== r.length) return !1;for (var n = 0; n < i.length; n++) {
	        if (0 !== s.compare(i[n], r[n])) return !1;
	      }return !0;
	    }
	  }, X.intersection = function (t, e) {
	    for (var n = new E(), i = 0; i < t.length; i++) {
	      e.intersects(t[i]) && n.add(t[i], !0);
	    }return n.toCoordinateArray();
	  }, X.hasRepeatedPoints = function (t) {
	    for (var e = 1; e < t.length; e++) {
	      if (t[e - 1].equals(t[e])) return !0;
	    }return !1;
	  }, X.removeRepeatedPoints = function (t) {
	    return X.hasRepeatedPoints(t) ? new E(t, !1).toCoordinateArray() : t;
	  }, X.reverse = function (t) {
	    for (var e = t.length - 1, n = Math.trunc(e / 2), i = 0; i <= n; i++) {
	      var r = t[i];t[i] = t[e - i], t[e - i] = r;
	    }
	  }, X.removeNull = function (t) {
	    for (var e = 0, n = 0; n < t.length; n++) {
	      null !== t[n] && e++;
	    }var i = new Array(e).fill(null);if (0 === e) return i;for (var r = 0, n = 0; n < t.length; n++) {
	      null !== t[n] && (i[r++] = t[n]);
	    }return i;
	  }, X.copyDeep = function () {
	    if (1 === arguments.length) {
	      for (var t = arguments[0], e = new Array(t.length).fill(null), n = 0; n < t.length; n++) {
	        e[n] = new c(t[n]);
	      }return e;
	    }if (5 === arguments.length) for (var i = arguments[0], r = arguments[1], s = arguments[2], o = arguments[3], a = arguments[4], n = 0; n < a; n++) {
	      s[o + n] = new c(i[r + n]);
	    }
	  }, X.isEqualReversed = function (t, e) {
	    for (var n = 0; n < t.length; n++) {
	      var i = t[n],
	          r = e[t.length - n - 1];if (0 !== i.compareTo(r)) return !1;
	    }return !0;
	  }, X.envelope = function (t) {
	    for (var e = new x(), n = 0; n < t.length; n++) {
	      e.expandToInclude(t[n]);
	    }return e;
	  }, X.toCoordinateArray = function (t) {
	    return t.toArray(X.coordArrayType);
	  }, X.atLeastNCoordinatesOrNothing = function (t, e) {
	    return e.length >= t ? e : [];
	  }, X.indexOf = function (t, e) {
	    for (var n = 0; n < e.length; n++) {
	      if (t.equals(e[n])) return n;
	    }return -1;
	  }, X.increasingDirection = function (t) {
	    for (var e = 0; e < Math.trunc(t.length / 2); e++) {
	      var n = t.length - 1 - e,
	          i = t[e].compareTo(t[n]);if (0 !== i) return i;
	    }return 1;
	  }, X.compare = function (t, e) {
	    for (var n = 0; n < t.length && n < e.length;) {
	      var i = t[n].compareTo(e[n]);if (0 !== i) return i;n++;
	    }return n < e.length ? -1 : n < t.length ? 1 : 0;
	  }, X.minCoordinate = function (t) {
	    for (var e = null, n = 0; n < t.length; n++) {
	      (null === e || e.compareTo(t[n]) > 0) && (e = t[n]);
	    }return e;
	  }, X.extract = function (t, e, n) {
	    e = L.clamp(e, 0, t.length), n = L.clamp(n, -1, t.length);var i = n - e + 1;n < 0 && (i = 0), e >= t.length && (i = 0), n < e && (i = 0);var r = new Array(i).fill(null);if (0 === i) return r;for (var s = 0, o = e; o <= n; o++) {
	      r[s++] = t[o];
	    }return r;
	  }, Or(k.prototype, { compare: function compare(t, e) {
	      var n = t,
	          i = e;return X.compare(n, i);
	    }, interfaces_: function interfaces_() {
	      return [o];
	    }, getClass: function getClass() {
	      return k;
	    } }), Or(V.prototype, { compare: function compare(t, e) {
	      var n = t,
	          i = e;if (n.length < i.length) return -1;if (n.length > i.length) return 1;if (0 === n.length) return 0;var r = X.compare(n, i);return X.isEqualReversed(n, i) ? 0 : r;
	    }, OLDcompare: function OLDcompare(t, e) {
	      var n = t,
	          i = e;if (n.length < i.length) return -1;if (n.length > i.length) return 1;if (0 === n.length) return 0;for (var r = X.increasingDirection(n), s = X.increasingDirection(i), o = r > 0 ? 0 : n.length - 1, a = s > 0 ? 0 : n.length - 1, u = 0; u < n.length; u++) {
	        var l = n[o].compareTo(i[a]);if (0 !== l) return l;o += r, a += s;
	      }return 0;
	    }, interfaces_: function interfaces_() {
	      return [o];
	    }, getClass: function getClass() {
	      return V;
	    } }), X.ForwardComparator = k, X.BidirectionalComparator = V, X.coordArrayType = new Array(0).fill(null), H.prototype.get = function () {}, H.prototype.put = function () {}, H.prototype.size = function () {}, H.prototype.values = function () {}, H.prototype.entrySet = function () {}, W.prototype = new H(), j.prototype = new d(), j.prototype.contains = function () {}, K.prototype = new j(), K.prototype.contains = function (t) {
	    for (var e = 0, n = this.array_.length; e < n; e++) {
	      if (this.array_[e] === t) return !0;
	    }return !1;
	  }, K.prototype.add = function (t) {
	    return !this.contains(t) && (this.array_.push(t), !0);
	  }, K.prototype.addAll = function (t) {
	    for (var e = t.iterator(); e.hasNext();) {
	      this.add(e.next());
	    }return !0;
	  }, K.prototype.remove = function (t) {
	    throw new javascript.util.OperationNotSupported();
	  }, K.prototype.size = function () {
	    return this.array_.length;
	  }, K.prototype.isEmpty = function () {
	    return 0 === this.array_.length;
	  }, K.prototype.toArray = function () {
	    for (var t = [], e = 0, n = this.array_.length; e < n; e++) {
	      t.push(this.array_[e]);
	    }return t;
	  }, K.prototype.iterator = function () {
	    return new Mr(this);
	  };var Mr = function Mr(t) {
	    this.hashSet_ = t, this.position_ = 0;
	  };Mr.prototype.next = function () {
	    if (this.position_ === this.hashSet_.size()) throw new v();return this.hashSet_.array_[this.position_++];
	  }, Mr.prototype.hasNext = function () {
	    return this.position_ < this.hashSet_.size();
	  }, Mr.prototype.remove = function () {
	    throw new y();
	  };var Ar = 0;et.prototype = new W(), et.prototype.get = function (t) {
	    for (var e = this.root_; null !== e;) {
	      var n = t.compareTo(e.key);if (n < 0) e = e.left;else {
	        if (!(n > 0)) return e.value;e = e.right;
	      }
	    }return null;
	  }, et.prototype.put = function (t, e) {
	    if (null === this.root_) return this.root_ = { key: t, value: e, left: null, right: null, parent: null, color: Ar, getValue: function getValue() {
	        return this.value;
	      }, getKey: function getKey() {
	        return this.key;
	      } }, this.size_ = 1, null;var n,
	        i,
	        r = this.root_;do {
	      if (n = r, (i = t.compareTo(r.key)) < 0) r = r.left;else {
	        if (!(i > 0)) {
	          var s = r.value;return r.value = e, s;
	        }r = r.right;
	      }
	    } while (null !== r);var o = { key: t, left: null, right: null, value: e, parent: n, color: Ar, getValue: function getValue() {
	        return this.value;
	      }, getKey: function getKey() {
	        return this.key;
	      } };return i < 0 ? n.left = o : n.right = o, this.fixAfterInsertion(o), this.size_++, null;
	  }, et.prototype.fixAfterInsertion = function (t) {
	    for (t.color = 1; null != t && t != this.root_ && 1 == t.parent.color;) {
	      if (Q(t) == $(Q(Q(t)))) {
	        var e = tt(Q(Q(t)));1 == J(e) ? (Z(Q(t), Ar), Z(e, Ar), Z(Q(Q(t)), 1), t = Q(Q(t))) : (t == tt(Q(t)) && (t = Q(t), this.rotateLeft(t)), Z(Q(t), Ar), Z(Q(Q(t)), 1), this.rotateRight(Q(Q(t))));
	      } else {
	        var e = $(Q(Q(t)));1 == J(e) ? (Z(Q(t), Ar), Z(e, Ar), Z(Q(Q(t)), 1), t = Q(Q(t))) : (t == $(Q(t)) && (t = Q(t), this.rotateRight(t)), Z(Q(t), Ar), Z(Q(Q(t)), 1), this.rotateLeft(Q(Q(t))));
	      }
	    }this.root_.color = Ar;
	  }, et.prototype.values = function () {
	    var t = new I(),
	        e = this.getFirstEntry();if (null !== e) for (t.add(e.value); null !== (e = et.successor(e));) {
	      t.add(e.value);
	    }return t;
	  }, et.prototype.entrySet = function () {
	    var t = new K(),
	        e = this.getFirstEntry();if (null !== e) for (t.add(e); null !== (e = et.successor(e));) {
	      t.add(e);
	    }return t;
	  }, et.prototype.rotateLeft = function (t) {
	    if (null != t) {
	      var e = t.right;t.right = e.left, null != e.left && (e.left.parent = t), e.parent = t.parent, null == t.parent ? this.root_ = e : t.parent.left == t ? t.parent.left = e : t.parent.right = e, e.left = t, t.parent = e;
	    }
	  }, et.prototype.rotateRight = function (t) {
	    if (null != t) {
	      var e = t.left;t.left = e.right, null != e.right && (e.right.parent = t), e.parent = t.parent, null == t.parent ? this.root_ = e : t.parent.right == t ? t.parent.right = e : t.parent.left = e, e.right = t, t.parent = e;
	    }
	  }, et.prototype.getFirstEntry = function () {
	    var t = this.root_;if (null != t) for (; null != t.left;) {
	      t = t.left;
	    }return t;
	  }, et.successor = function (t) {
	    if (null === t) return null;if (null !== t.right) {
	      for (var e = t.right; null !== e.left;) {
	        e = e.left;
	      }return e;
	    }for (var e = t.parent, n = t; null !== e && n === e.right;) {
	      n = e, e = e.parent;
	    }return e;
	  }, et.prototype.size = function () {
	    return this.size_;
	  }, Or(nt.prototype, { interfaces_: function interfaces_() {
	      return [];
	    }, getClass: function getClass() {
	      return nt;
	    } }), it.prototype = new j(), rt.prototype = new it(), rt.prototype.contains = function (t) {
	    for (var e = 0, n = this.array_.length; e < n; e++) {
	      if (0 === this.array_[e].compareTo(t)) return !0;
	    }return !1;
	  }, rt.prototype.add = function (t) {
	    if (this.contains(t)) return !1;for (var e = 0, n = this.array_.length; e < n; e++) {
	      if (1 === this.array_[e].compareTo(t)) return this.array_.splice(e, 0, t), !0;
	    }return this.array_.push(t), !0;
	  }, rt.prototype.addAll = function (t) {
	    for (var e = t.iterator(); e.hasNext();) {
	      this.add(e.next());
	    }return !0;
	  }, rt.prototype.remove = function (t) {
	    throw new y();
	  }, rt.prototype.size = function () {
	    return this.array_.length;
	  }, rt.prototype.isEmpty = function () {
	    return 0 === this.array_.length;
	  }, rt.prototype.toArray = function () {
	    for (var t = [], e = 0, n = this.array_.length; e < n; e++) {
	      t.push(this.array_[e]);
	    }return t;
	  }, rt.prototype.iterator = function () {
	    return new Dr(this);
	  };var Dr = function Dr(t) {
	    this.treeSet_ = t, this.position_ = 0;
	  };Dr.prototype.next = function () {
	    if (this.position_ === this.treeSet_.size()) throw new v();return this.treeSet_.array_[this.position_++];
	  }, Dr.prototype.hasNext = function () {
	    return this.position_ < this.treeSet_.size();
	  }, Dr.prototype.remove = function () {
	    throw new y();
	  }, st.sort = function () {
	    var t,
	        e,
	        n,
	        i,
	        r = arguments[0];if (1 === arguments.length) return i = function i(t, e) {
	      return t.compareTo(e);
	    }, void r.sort(i);if (2 === arguments.length) n = arguments[1], i = function i(t, e) {
	      return n.compare(t, e);
	    }, r.sort(i);else {
	      if (3 === arguments.length) {
	        e = r.slice(arguments[1], arguments[2]), e.sort();var s = r.slice(0, arguments[1]).concat(e, r.slice(arguments[2], r.length));for (r.splice(0, r.length), t = 0; t < s.length; t++) {
	          r.push(s[t]);
	        }return;
	      }if (4 === arguments.length) {
	        for (e = r.slice(arguments[1], arguments[2]), n = arguments[3], i = function i(t, e) {
	          return n.compare(t, e);
	        }, e.sort(i), s = r.slice(0, arguments[1]).concat(e, r.slice(arguments[2], r.length)), r.splice(0, r.length), t = 0; t < s.length; t++) {
	          r.push(s[t]);
	        }return;
	      }
	    }
	  }, st.asList = function (t) {
	    for (var e = new I(), n = 0, i = t.length; n < i; n++) {
	      e.add(t[n]);
	    }return e;
	  }, Or(ot.prototype, { interfaces_: function interfaces_() {
	      return [];
	    }, getClass: function getClass() {
	      return ot;
	    } }), ot.toDimensionSymbol = function (t) {
	    switch (t) {case ot.FALSE:
	        return ot.SYM_FALSE;case ot.TRUE:
	        return ot.SYM_TRUE;case ot.DONTCARE:
	        return ot.SYM_DONTCARE;case ot.P:
	        return ot.SYM_P;case ot.L:
	        return ot.SYM_L;case ot.A:
	        return ot.SYM_A;}throw new n("Unknown dimension value: " + t);
	  }, ot.toDimensionValue = function (t) {
	    switch (T.toUpperCase(t)) {case ot.SYM_FALSE:
	        return ot.FALSE;case ot.SYM_TRUE:
	        return ot.TRUE;case ot.SYM_DONTCARE:
	        return ot.DONTCARE;case ot.SYM_P:
	        return ot.P;case ot.SYM_L:
	        return ot.L;case ot.SYM_A:
	        return ot.A;}throw new n("Unknown dimension symbol: " + t);
	  }, ot.P = 0, ot.L = 1, ot.A = 2, ot.FALSE = -1, ot.TRUE = -2, ot.DONTCARE = -3, ot.SYM_FALSE = "F", ot.SYM_TRUE = "T", ot.SYM_DONTCARE = "*", ot.SYM_P = "0", ot.SYM_L = "1", ot.SYM_A = "2", Or(at.prototype, { filter: function filter(t) {}, interfaces_: function interfaces_() {
	      return [];
	    }, getClass: function getClass() {
	      return at;
	    } }), Or(ut.prototype, { filter: function filter(t, e) {}, isDone: function isDone() {}, isGeometryChanged: function isGeometryChanged() {}, interfaces_: function interfaces_() {
	      return [];
	    }, getClass: function getClass() {
	      return ut;
	    } }), br(lt, F), Or(lt.prototype, { computeEnvelopeInternal: function computeEnvelopeInternal() {
	      for (var t = new x(), e = 0; e < this.geometries.length; e++) {
	        t.expandToInclude(this.geometries[e].getEnvelopeInternal());
	      }return t;
	    }, getGeometryN: function getGeometryN(t) {
	      return this.geometries[t];
	    }, getSortIndex: function getSortIndex() {
	      return F.SORTINDEX_GEOMETRYCOLLECTION;
	    }, getCoordinates: function getCoordinates() {
	      for (var t = new Array(this.getNumPoints()).fill(null), e = -1, n = 0; n < this.geometries.length; n++) {
	        for (var i = this.geometries[n].getCoordinates(), r = 0; r < i.length; r++) {
	          e++, t[e] = i[r];
	        }
	      }return t;
	    }, getArea: function getArea() {
	      for (var t = 0, e = 0; e < this.geometries.length; e++) {
	        t += this.geometries[e].getArea();
	      }return t;
	    }, equalsExact: function equalsExact() {
	      if (2 === arguments.length) {
	        var t = arguments[0],
	            e = arguments[1];if (!this.isEquivalentClass(t)) return !1;var n = t;if (this.geometries.length !== n.geometries.length) return !1;for (var i = 0; i < this.geometries.length; i++) {
	          if (!this.geometries[i].equalsExact(n.geometries[i], e)) return !1;
	        }return !0;
	      }return F.prototype.equalsExact.apply(this, arguments);
	    }, normalize: function normalize() {
	      for (var t = 0; t < this.geometries.length; t++) {
	        this.geometries[t].normalize();
	      }st.sort(this.geometries);
	    }, getCoordinate: function getCoordinate() {
	      return this.isEmpty() ? null : this.geometries[0].getCoordinate();
	    }, getBoundaryDimension: function getBoundaryDimension() {
	      for (var t = ot.FALSE, e = 0; e < this.geometries.length; e++) {
	        t = Math.max(t, this.geometries[e].getBoundaryDimension());
	      }return t;
	    }, getDimension: function getDimension() {
	      for (var t = ot.FALSE, e = 0; e < this.geometries.length; e++) {
	        t = Math.max(t, this.geometries[e].getDimension());
	      }return t;
	    }, getLength: function getLength() {
	      for (var t = 0, e = 0; e < this.geometries.length; e++) {
	        t += this.geometries[e].getLength();
	      }return t;
	    }, getNumPoints: function getNumPoints() {
	      for (var t = 0, e = 0; e < this.geometries.length; e++) {
	        t += this.geometries[e].getNumPoints();
	      }return t;
	    }, getNumGeometries: function getNumGeometries() {
	      return this.geometries.length;
	    }, reverse: function reverse() {
	      for (var t = this.geometries.length, e = new Array(t).fill(null), n = 0; n < this.geometries.length; n++) {
	        e[n] = this.geometries[n].reverse();
	      }return this.getFactory().createGeometryCollection(e);
	    }, compareToSameClass: function compareToSameClass() {
	      if (1 === arguments.length) {
	        var t = arguments[0],
	            e = new rt(st.asList(this.geometries)),
	            n = new rt(st.asList(t.geometries));return this.compare(e, n);
	      }if (2 === arguments.length) {
	        for (var i = arguments[0], r = arguments[1], s = i, o = this.getNumGeometries(), a = s.getNumGeometries(), u = 0; u < o && u < a;) {
	          var l = this.getGeometryN(u),
	              h = s.getGeometryN(u),
	              c = l.compareToSameClass(h, r);if (0 !== c) return c;u++;
	        }return u < o ? 1 : u < a ? -1 : 0;
	      }
	    }, apply: function apply() {
	      if (_r(arguments[0], G)) for (var t = arguments[0], e = 0; e < this.geometries.length; e++) {
	        this.geometries[e].apply(t);
	      } else if (_r(arguments[0], ut)) {
	        var n = arguments[0];if (0 === this.geometries.length) return null;for (var e = 0; e < this.geometries.length && (this.geometries[e].apply(n), !n.isDone()); e++) {}n.isGeometryChanged() && this.geometryChanged();
	      } else if (_r(arguments[0], at)) {
	        var i = arguments[0];i.filter(this);for (var e = 0; e < this.geometries.length; e++) {
	          this.geometries[e].apply(i);
	        }
	      } else if (_r(arguments[0], D)) {
	        var r = arguments[0];r.filter(this);for (var e = 0; e < this.geometries.length; e++) {
	          this.geometries[e].apply(r);
	        }
	      }
	    }, getBoundary: function getBoundary() {
	      return this.checkNotGeometryCollection(this), h.shouldNeverReachHere(), null;
	    }, clone: function clone() {
	      var t = F.prototype.clone.call(this);t.geometries = new Array(this.geometries.length).fill(null);for (var e = 0; e < this.geometries.length; e++) {
	        t.geometries[e] = this.geometries[e].clone();
	      }return t;
	    }, getGeometryType: function getGeometryType() {
	      return "GeometryCollection";
	    }, copy: function copy() {
	      for (var t = new Array(this.geometries.length).fill(null), e = 0; e < t.length; e++) {
	        t[e] = this.geometries[e].copy();
	      }return new lt(t, this.factory);
	    }, isEmpty: function isEmpty() {
	      for (var t = 0; t < this.geometries.length; t++) {
	        if (!this.geometries[t].isEmpty()) return !1;
	      }return !0;
	    }, interfaces_: function interfaces_() {
	      return [];
	    }, getClass: function getClass() {
	      return lt;
	    } }), lt.serialVersionUID = -0x4f07bcb1f857d800, br(ht, lt), Or(ht.prototype, { getSortIndex: function getSortIndex() {
	      return F.SORTINDEX_MULTILINESTRING;
	    }, equalsExact: function equalsExact() {
	      if (2 === arguments.length) {
	        var t = arguments[0],
	            e = arguments[1];return !!this.isEquivalentClass(t) && lt.prototype.equalsExact.call(this, t, e);
	      }return lt.prototype.equalsExact.apply(this, arguments);
	    }, getBoundaryDimension: function getBoundaryDimension() {
	      return this.isClosed() ? ot.FALSE : 0;
	    }, isClosed: function isClosed() {
	      if (this.isEmpty()) return !1;for (var t = 0; t < this.geometries.length; t++) {
	        if (!this.geometries[t].isClosed()) return !1;
	      }return !0;
	    }, getDimension: function getDimension() {
	      return 1;
	    }, reverse: function reverse() {
	      for (var t = this.geometries.length, e = new Array(t).fill(null), n = 0; n < this.geometries.length; n++) {
	        e[t - 1 - n] = this.geometries[n].reverse();
	      }return this.getFactory().createMultiLineString(e);
	    }, getBoundary: function getBoundary() {
	      return new ct(this).getBoundary();
	    }, getGeometryType: function getGeometryType() {
	      return "MultiLineString";
	    }, copy: function copy() {
	      for (var t = new Array(this.geometries.length).fill(null), e = 0; e < t.length; e++) {
	        t[e] = this.geometries[e].copy();
	      }return new ht(t, this.factory);
	    }, interfaces_: function interfaces_() {
	      return [nt];
	    }, getClass: function getClass() {
	      return ht;
	    } }), ht.serialVersionUID = 0x7155d2ab4afa8000, Or(ct.prototype, { boundaryMultiLineString: function boundaryMultiLineString(t) {
	      if (this.geom.isEmpty()) return this.getEmptyMultiPoint();var e = this.computeBoundaryCoordinates(t);return 1 === e.length ? this.geomFact.createPoint(e[0]) : this.geomFact.createMultiPointFromCoords(e);
	    }, getBoundary: function getBoundary() {
	      return this.geom instanceof xt ? this.boundaryLineString(this.geom) : this.geom instanceof ht ? this.boundaryMultiLineString(this.geom) : this.geom.getBoundary();
	    }, boundaryLineString: function boundaryLineString(t) {
	      if (this.geom.isEmpty()) return this.getEmptyMultiPoint();if (t.isClosed()) {
	        return this.bnRule.isInBoundary(2) ? t.getStartPoint() : this.geomFact.createMultiPoint();
	      }return this.geomFact.createMultiPoint([t.getStartPoint(), t.getEndPoint()]);
	    }, getEmptyMultiPoint: function getEmptyMultiPoint() {
	      return this.geomFact.createMultiPoint();
	    }, computeBoundaryCoordinates: function computeBoundaryCoordinates(t) {
	      var e = new I();this.endpointMap = new et();for (var n = 0; n < t.getNumGeometries(); n++) {
	        var i = t.getGeometryN(n);0 !== i.getNumPoints() && (this.addEndpoint(i.getCoordinateN(0)), this.addEndpoint(i.getCoordinateN(i.getNumPoints() - 1)));
	      }for (var r = this.endpointMap.entrySet().iterator(); r.hasNext();) {
	        var s = r.next(),
	            o = s.getValue(),
	            a = o.count;this.bnRule.isInBoundary(a) && e.add(s.getKey());
	      }return X.toCoordinateArray(e);
	    }, addEndpoint: function addEndpoint(t) {
	      var e = this.endpointMap.get(t);null === e && (e = new ft(), this.endpointMap.put(t, e)), e.count++;
	    }, interfaces_: function interfaces_() {
	      return [];
	    }, getClass: function getClass() {
	      return ct;
	    } }), ct.getBoundary = function () {
	    if (1 === arguments.length) {
	      var t = arguments[0],
	          e = new ct(t);return e.getBoundary();
	    }if (2 === arguments.length) {
	      var n = arguments[0],
	          i = arguments[1],
	          e = new ct(n, i);return e.getBoundary();
	    }
	  }, Or(ft.prototype, { interfaces_: function interfaces_() {
	      return [];
	    }, getClass: function getClass() {
	      return ft;
	    } }), Or(It.prototype, { interfaces_: function interfaces_() {
	      return [];
	    }, getClass: function getClass() {
	      return It;
	    } }), It.chars = function (t, e) {
	    for (var n = new Array(e).fill(null), i = 0; i < e; i++) {
	      n[i] = t;
	    }return new String(n);
	  }, It.getStackTrace = function () {
	    if (1 === arguments.length) {
	      var t = arguments[0],
	          e = new mt(),
	          n = new gt(e);return t.printStackTrace(n), e.toString();
	    }if (2 === arguments.length) {
	      for (var i = arguments[0], r = arguments[1], s = "", o = new dt(It.getStackTrace(i)), a = new yt(o), u = 0; u < r; u++) {
	        try {
	          s += a.readLine() + It.NEWLINE;
	        } catch (t) {
	          if (!(t instanceof vt)) throw t;h.shouldNeverReachHere();
	        } finally {}
	      }return s;
	    }
	  }, It.split = function (t, e) {
	    for (var n = e.length, i = new I(), r = "" + t, s = r.indexOf(e); s >= 0;) {
	      var o = r.substring(0, s);i.add(o), r = r.substring(s + n), s = r.indexOf(e);
	    }r.length > 0 && i.add(r);for (var a = new Array(i.size()).fill(null), u = 0; u < a.length; u++) {
	      a[u] = i.get(u);
	    }return a;
	  }, It.toString = function () {
	    if (1 === arguments.length) {
	      var t = arguments[0];return It.SIMPLE_ORDINATE_FORMAT.format(t);
	    }
	  }, It.spaces = function (t) {
	    return It.chars(" ", t);
	  }, It.NEWLINE = _.getProperty("line.separator"), It.SIMPLE_ORDINATE_FORMAT = new pt("0.#"), Or(Et.prototype, { interfaces_: function interfaces_() {
	      return [];
	    }, getClass: function getClass() {
	      return Et;
	    } }), Et.copyCoord = function (t, e, n, i) {
	    for (var r = Math.min(t.getDimension(), n.getDimension()), s = 0; s < r; s++) {
	      n.setOrdinate(i, s, t.getOrdinate(e, s));
	    }
	  }, Et.isRing = function (t) {
	    var e = t.size();return 0 === e || !(e <= 3) && t.getOrdinate(0, P.X) === t.getOrdinate(e - 1, P.X) && t.getOrdinate(0, P.Y) === t.getOrdinate(e - 1, P.Y);
	  }, Et.isEqual = function (t, e) {
	    var n = t.size();if (n !== e.size()) return !1;for (var r = Math.min(t.getDimension(), e.getDimension()), s = 0; s < n; s++) {
	      for (var o = 0; o < r; o++) {
	        var a = t.getOrdinate(s, o),
	            u = e.getOrdinate(s, o);if (t.getOrdinate(s, o) !== e.getOrdinate(s, o) && (!i.isNaN(a) || !i.isNaN(u))) return !1;
	      }
	    }return !0;
	  }, Et.extend = function (t, e, n) {
	    var i = t.create(n, e.getDimension()),
	        r = e.size();if (Et.copy(e, 0, i, 0, r), r > 0) for (var s = r; s < n; s++) {
	      Et.copy(e, r - 1, i, s, 1);
	    }return i;
	  }, Et.reverse = function (t) {
	    for (var e = t.size() - 1, n = Math.trunc(e / 2), i = 0; i <= n; i++) {
	      Et.swap(t, i, e - i);
	    }
	  }, Et.swap = function (t, e, n) {
	    if (e === n) return null;for (var i = 0; i < t.getDimension(); i++) {
	      var r = t.getOrdinate(e, i);t.setOrdinate(e, i, t.getOrdinate(n, i)), t.setOrdinate(n, i, r);
	    }
	  }, Et.copy = function (t, e, n, i, r) {
	    for (var s = 0; s < r; s++) {
	      Et.copyCoord(t, e + s, n, i + s);
	    }
	  }, Et.toString = function () {
	    if (1 === arguments.length) {
	      var t = arguments[0],
	          e = t.size();if (0 === e) return "()";var n = t.getDimension(),
	          i = new R();i.append("(");for (var r = 0; r < e; r++) {
	        r > 0 && i.append(" ");for (var s = 0; s < n; s++) {
	          s > 0 && i.append(","), i.append(It.toString(t.getOrdinate(r, s)));
	        }
	      }return i.append(")"), i.toString();
	    }
	  }, Et.ensureValidRing = function (t, e) {
	    var n = e.size();return 0 === n ? e : n <= 3 ? Et.createClosedRing(t, e, 4) : e.getOrdinate(0, P.X) === e.getOrdinate(n - 1, P.X) && e.getOrdinate(0, P.Y) === e.getOrdinate(n - 1, P.Y) ? e : Et.createClosedRing(t, e, n + 1);
	  }, Et.createClosedRing = function (t, e, n) {
	    var i = t.create(n, e.getDimension()),
	        r = e.size();Et.copy(e, 0, i, 0, r);for (var s = r; s < n; s++) {
	      Et.copy(e, 0, i, s, 1);
	    }return i;
	  }, br(xt, F), Or(xt.prototype, { computeEnvelopeInternal: function computeEnvelopeInternal() {
	      return this.isEmpty() ? new x() : this.points.expandEnvelope(new x());
	    }, isRing: function isRing() {
	      return this.isClosed() && this.isSimple();
	    }, getSortIndex: function getSortIndex() {
	      return F.SORTINDEX_LINESTRING;
	    }, getCoordinates: function getCoordinates() {
	      return this.points.toCoordinateArray();
	    }, equalsExact: function equalsExact() {
	      if (2 === arguments.length) {
	        var t = arguments[0],
	            e = arguments[1];if (!this.isEquivalentClass(t)) return !1;var n = t;if (this.points.size() !== n.points.size()) return !1;for (var i = 0; i < this.points.size(); i++) {
	          if (!this.equal(this.points.getCoordinate(i), n.points.getCoordinate(i), e)) return !1;
	        }return !0;
	      }return F.prototype.equalsExact.apply(this, arguments);
	    }, normalize: function normalize() {
	      for (var t = 0; t < Math.trunc(this.points.size() / 2); t++) {
	        var e = this.points.size() - 1 - t;if (!this.points.getCoordinate(t).equals(this.points.getCoordinate(e))) return this.points.getCoordinate(t).compareTo(this.points.getCoordinate(e)) > 0 && Et.reverse(this.points), null;
	      }
	    }, getCoordinate: function getCoordinate() {
	      return this.isEmpty() ? null : this.points.getCoordinate(0);
	    }, getBoundaryDimension: function getBoundaryDimension() {
	      return this.isClosed() ? ot.FALSE : 0;
	    }, isClosed: function isClosed() {
	      return !this.isEmpty() && this.getCoordinateN(0).equals2D(this.getCoordinateN(this.getNumPoints() - 1));
	    }, getEndPoint: function getEndPoint() {
	      return this.isEmpty() ? null : this.getPointN(this.getNumPoints() - 1);
	    }, getDimension: function getDimension() {
	      return 1;
	    }, getLength: function getLength() {
	      return oe.computeLength(this.points);
	    }, getNumPoints: function getNumPoints() {
	      return this.points.size();
	    }, reverse: function reverse() {
	      var t = this.points.copy();return Et.reverse(t), this.getFactory().createLineString(t);
	    }, compareToSameClass: function compareToSameClass() {
	      if (1 === arguments.length) {
	        for (var t = arguments[0], e = t, n = 0, i = 0; n < this.points.size() && i < e.points.size();) {
	          var r = this.points.getCoordinate(n).compareTo(e.points.getCoordinate(i));if (0 !== r) return r;n++, i++;
	        }return n < this.points.size() ? 1 : i < e.points.size() ? -1 : 0;
	      }if (2 === arguments.length) {
	        var s = arguments[0],
	            o = arguments[1],
	            e = s;return o.compare(this.points, e.points);
	      }
	    }, apply: function apply() {
	      if (_r(arguments[0], G)) for (var t = arguments[0], e = 0; e < this.points.size(); e++) {
	        t.filter(this.points.getCoordinate(e));
	      } else if (_r(arguments[0], ut)) {
	        var n = arguments[0];if (0 === this.points.size()) return null;for (var e = 0; e < this.points.size() && (n.filter(this.points, e), !n.isDone()); e++) {}n.isGeometryChanged() && this.geometryChanged();
	      } else if (_r(arguments[0], at)) {
	        var i = arguments[0];i.filter(this);
	      } else if (_r(arguments[0], D)) {
	        var r = arguments[0];r.filter(this);
	      }
	    }, getBoundary: function getBoundary() {
	      return new ct(this).getBoundary();
	    }, isEquivalentClass: function isEquivalentClass(t) {
	      return t instanceof xt;
	    }, clone: function clone() {
	      var t = F.prototype.clone.call(this);return t.points = this.points.clone(), t;
	    }, getCoordinateN: function getCoordinateN(t) {
	      return this.points.getCoordinate(t);
	    }, getGeometryType: function getGeometryType() {
	      return "LineString";
	    }, copy: function copy() {
	      return new xt(this.points.copy(), this.factory);
	    }, getCoordinateSequence: function getCoordinateSequence() {
	      return this.points;
	    }, isEmpty: function isEmpty() {
	      return 0 === this.points.size();
	    }, init: function init(t) {
	      if (null === t && (t = this.getFactory().getCoordinateSequenceFactory().create([])), 1 === t.size()) throw new n("Invalid number of points in LineString (found " + t.size() + " - must be 0 or >= 2)");this.points = t;
	    }, isCoordinate: function isCoordinate(t) {
	      for (var e = 0; e < this.points.size(); e++) {
	        if (this.points.getCoordinate(e).equals(t)) return !0;
	      }return !1;
	    }, getStartPoint: function getStartPoint() {
	      return this.isEmpty() ? null : this.getPointN(0);
	    }, getPointN: function getPointN(t) {
	      return this.getFactory().createPoint(this.points.getCoordinate(t));
	    }, interfaces_: function interfaces_() {
	      return [nt];
	    }, getClass: function getClass() {
	      return xt;
	    } }), xt.serialVersionUID = 0x2b2b51ba435c8e00, Or(Nt.prototype, { interfaces_: function interfaces_() {
	      return [];
	    }, getClass: function getClass() {
	      return Nt;
	    } }), br(Ct, F), Or(Ct.prototype, { computeEnvelopeInternal: function computeEnvelopeInternal() {
	      if (this.isEmpty()) return new x();var t = new x();return t.expandToInclude(this.coordinates.getX(0), this.coordinates.getY(0)), t;
	    }, getSortIndex: function getSortIndex() {
	      return F.SORTINDEX_POINT;
	    }, getCoordinates: function getCoordinates() {
	      return this.isEmpty() ? [] : [this.getCoordinate()];
	    }, equalsExact: function equalsExact() {
	      if (2 === arguments.length) {
	        var t = arguments[0],
	            e = arguments[1];return !!this.isEquivalentClass(t) && (!(!this.isEmpty() || !t.isEmpty()) || this.isEmpty() === t.isEmpty() && this.equal(t.getCoordinate(), this.getCoordinate(), e));
	      }return F.prototype.equalsExact.apply(this, arguments);
	    }, normalize: function normalize() {}, getCoordinate: function getCoordinate() {
	      return 0 !== this.coordinates.size() ? this.coordinates.getCoordinate(0) : null;
	    }, getBoundaryDimension: function getBoundaryDimension() {
	      return ot.FALSE;
	    }, getDimension: function getDimension() {
	      return 0;
	    }, getNumPoints: function getNumPoints() {
	      return this.isEmpty() ? 0 : 1;
	    }, reverse: function reverse() {
	      return this.copy();
	    }, getX: function getX() {
	      if (null === this.getCoordinate()) throw new IllegalStateException("getX called on empty Point");return this.getCoordinate().x;
	    }, compareToSameClass: function compareToSameClass() {
	      if (1 === arguments.length) {
	        var t = arguments[0],
	            e = t;return this.getCoordinate().compareTo(e.getCoordinate());
	      }if (2 === arguments.length) {
	        var n = arguments[0],
	            i = arguments[1],
	            e = n;return i.compare(this.coordinates, e.coordinates);
	      }
	    }, apply: function apply() {
	      if (_r(arguments[0], G)) {
	        var t = arguments[0];if (this.isEmpty()) return null;t.filter(this.getCoordinate());
	      } else if (_r(arguments[0], ut)) {
	        var e = arguments[0];if (this.isEmpty()) return null;e.filter(this.coordinates, 0), e.isGeometryChanged() && this.geometryChanged();
	      } else if (_r(arguments[0], at)) {
	        var n = arguments[0];n.filter(this);
	      } else if (_r(arguments[0], D)) {
	        var i = arguments[0];i.filter(this);
	      }
	    }, getBoundary: function getBoundary() {
	      return this.getFactory().createGeometryCollection(null);
	    }, clone: function clone() {
	      var t = F.prototype.clone.call(this);return t.coordinates = this.coordinates.clone(), t;
	    }, getGeometryType: function getGeometryType() {
	      return "Point";
	    }, copy: function copy() {
	      return new Ct(this.coordinates.copy(), this.factory);
	    }, getCoordinateSequence: function getCoordinateSequence() {
	      return this.coordinates;
	    }, getY: function getY() {
	      if (null === this.getCoordinate()) throw new IllegalStateException("getY called on empty Point");return this.getCoordinate().y;
	    }, isEmpty: function isEmpty() {
	      return 0 === this.coordinates.size();
	    }, init: function init(t) {
	      null === t && (t = this.getFactory().getCoordinateSequenceFactory().create([])), h.isTrue(t.size() <= 1), this.coordinates = t;
	    }, isSimple: function isSimple() {
	      return !0;
	    }, interfaces_: function interfaces_() {
	      return [Nt];
	    }, getClass: function getClass() {
	      return Ct;
	    } }), Ct.serialVersionUID = 0x44077bad161cbc00, Or(St.prototype, { interfaces_: function interfaces_() {
	      return [];
	    }, getClass: function getClass() {
	      return St;
	    } }), br(Lt, F), Or(Lt.prototype, { computeEnvelopeInternal: function computeEnvelopeInternal() {
	      return this.shell.getEnvelopeInternal();
	    }, getSortIndex: function getSortIndex() {
	      return F.SORTINDEX_POLYGON;
	    }, getCoordinates: function getCoordinates() {
	      if (this.isEmpty()) return [];for (var t = new Array(this.getNumPoints()).fill(null), e = -1, n = this.shell.getCoordinates(), i = 0; i < n.length; i++) {
	        e++, t[e] = n[i];
	      }for (var r = 0; r < this.holes.length; r++) {
	        for (var s = this.holes[r].getCoordinates(), o = 0; o < s.length; o++) {
	          e++, t[e] = s[o];
	        }
	      }return t;
	    }, getArea: function getArea() {
	      var t = 0;t += Math.abs(oe.signedArea(this.shell.getCoordinateSequence()));for (var e = 0; e < this.holes.length; e++) {
	        t -= Math.abs(oe.signedArea(this.holes[e].getCoordinateSequence()));
	      }return t;
	    }, isRectangle: function isRectangle() {
	      if (0 !== this.getNumInteriorRing()) return !1;if (null === this.shell) return !1;if (5 !== this.shell.getNumPoints()) return !1;for (var t = this.shell.getCoordinateSequence(), e = this.getEnvelopeInternal(), n = 0; n < 5; n++) {
	        var i = t.getX(n);if (i !== e.getMinX() && i !== e.getMaxX()) return !1;var r = t.getY(n);if (r !== e.getMinY() && r !== e.getMaxY()) return !1;
	      }for (var s = t.getX(0), o = t.getY(0), n = 1; n <= 4; n++) {
	        var i = t.getX(n),
	            r = t.getY(n);if (i !== s === (r !== o)) return !1;s = i, o = r;
	      }return !0;
	    }, equalsExact: function equalsExact() {
	      if (2 === arguments.length) {
	        var t = arguments[0],
	            e = arguments[1];if (!this.isEquivalentClass(t)) return !1;var n = t,
	            i = this.shell,
	            r = n.shell;if (!i.equalsExact(r, e)) return !1;if (this.holes.length !== n.holes.length) return !1;for (var s = 0; s < this.holes.length; s++) {
	          if (!this.holes[s].equalsExact(n.holes[s], e)) return !1;
	        }return !0;
	      }return F.prototype.equalsExact.apply(this, arguments);
	    }, normalize: function normalize() {
	      if (0 === arguments.length) {
	        this.normalize(this.shell, !0);for (var t = 0; t < this.holes.length; t++) {
	          this.normalize(this.holes[t], !1);
	        }st.sort(this.holes);
	      } else if (2 === arguments.length) {
	        var e = arguments[0],
	            n = arguments[1];if (e.isEmpty()) return null;var i = new Array(e.getCoordinates().length - 1).fill(null);_.arraycopy(e.getCoordinates(), 0, i, 0, i.length);var r = X.minCoordinate(e.getCoordinates());X.scroll(i, r), _.arraycopy(i, 0, e.getCoordinates(), 0, i.length), e.getCoordinates()[i.length] = i[0], oe.isCCW(e.getCoordinates()) === n && X.reverse(e.getCoordinates());
	      }
	    }, getCoordinate: function getCoordinate() {
	      return this.shell.getCoordinate();
	    }, getNumInteriorRing: function getNumInteriorRing() {
	      return this.holes.length;
	    }, getBoundaryDimension: function getBoundaryDimension() {
	      return 1;
	    }, getDimension: function getDimension() {
	      return 2;
	    }, getLength: function getLength() {
	      var t = 0;t += this.shell.getLength();for (var e = 0; e < this.holes.length; e++) {
	        t += this.holes[e].getLength();
	      }return t;
	    }, getNumPoints: function getNumPoints() {
	      for (var t = this.shell.getNumPoints(), e = 0; e < this.holes.length; e++) {
	        t += this.holes[e].getNumPoints();
	      }return t;
	    }, reverse: function reverse() {
	      var t = this.copy();t.shell = this.shell.copy().reverse(), t.holes = new Array(this.holes.length).fill(null);for (var e = 0; e < this.holes.length; e++) {
	        t.holes[e] = this.holes[e].copy().reverse();
	      }return t;
	    }, convexHull: function convexHull() {
	      return this.getExteriorRing().convexHull();
	    }, compareToSameClass: function compareToSameClass() {
	      if (1 === arguments.length) {
	        var t = arguments[0],
	            e = this.shell,
	            n = t.shell;return e.compareToSameClass(n);
	      }if (2 === arguments.length) {
	        var i = arguments[0],
	            r = arguments[1],
	            s = i,
	            e = this.shell,
	            n = s.shell,
	            o = e.compareToSameClass(n, r);if (0 !== o) return o;for (var a = this.getNumInteriorRing(), u = s.getNumInteriorRing(), l = 0; l < a && l < u;) {
	          var h = this.getInteriorRingN(l),
	              c = s.getInteriorRingN(l),
	              f = h.compareToSameClass(c, r);if (0 !== f) return f;l++;
	        }return l < a ? 1 : l < u ? -1 : 0;
	      }
	    }, apply: function apply() {
	      if (_r(arguments[0], G)) {
	        var t = arguments[0];this.shell.apply(t);for (var e = 0; e < this.holes.length; e++) {
	          this.holes[e].apply(t);
	        }
	      } else if (_r(arguments[0], ut)) {
	        var n = arguments[0];if (this.shell.apply(n), !n.isDone()) for (var e = 0; e < this.holes.length && (this.holes[e].apply(n), !n.isDone()); e++) {}n.isGeometryChanged() && this.geometryChanged();
	      } else if (_r(arguments[0], at)) {
	        var i = arguments[0];i.filter(this);
	      } else if (_r(arguments[0], D)) {
	        var r = arguments[0];r.filter(this), this.shell.apply(r);for (var e = 0; e < this.holes.length; e++) {
	          this.holes[e].apply(r);
	        }
	      }
	    }, getBoundary: function getBoundary() {
	      if (this.isEmpty()) return this.getFactory().createMultiLineString();var t = new Array(this.holes.length + 1).fill(null);t[0] = this.shell;for (var e = 0; e < this.holes.length; e++) {
	        t[e + 1] = this.holes[e];
	      }return t.length <= 1 ? this.getFactory().createLinearRing(t[0].getCoordinateSequence()) : this.getFactory().createMultiLineString(t);
	    }, clone: function clone() {
	      var t = F.prototype.clone.call(this);t.shell = this.shell.clone(), t.holes = new Array(this.holes.length).fill(null);for (var e = 0; e < this.holes.length; e++) {
	        t.holes[e] = this.holes[e].clone();
	      }return t;
	    }, getGeometryType: function getGeometryType() {
	      return "Polygon";
	    }, copy: function copy() {
	      for (var t = this.shell.copy(), e = new Array(this.holes.length).fill(null), n = 0; n < e.length; n++) {
	        e[n] = this.holes[n].copy();
	      }return new Lt(t, e, this.factory);
	    }, getExteriorRing: function getExteriorRing() {
	      return this.shell;
	    }, isEmpty: function isEmpty() {
	      return this.shell.isEmpty();
	    }, getInteriorRingN: function getInteriorRingN(t) {
	      return this.holes[t];
	    }, interfaces_: function interfaces_() {
	      return [St];
	    }, getClass: function getClass() {
	      return Lt;
	    } }), Lt.serialVersionUID = -0x307ffefd8dc97200, br(Rt, lt), Or(Rt.prototype, { getSortIndex: function getSortIndex() {
	      return F.SORTINDEX_MULTIPOINT;
	    }, isValid: function isValid() {
	      return !0;
	    }, equalsExact: function equalsExact() {
	      if (2 === arguments.length) {
	        var t = arguments[0],
	            e = arguments[1];return !!this.isEquivalentClass(t) && lt.prototype.equalsExact.call(this, t, e);
	      }return lt.prototype.equalsExact.apply(this, arguments);
	    }, getCoordinate: function getCoordinate() {
	      if (1 === arguments.length) {
	        var t = arguments[0];return this.geometries[t].getCoordinate();
	      }return lt.prototype.getCoordinate.apply(this, arguments);
	    }, getBoundaryDimension: function getBoundaryDimension() {
	      return ot.FALSE;
	    }, getDimension: function getDimension() {
	      return 0;
	    }, getBoundary: function getBoundary() {
	      return this.getFactory().createGeometryCollection(null);
	    }, getGeometryType: function getGeometryType() {
	      return "MultiPoint";
	    }, copy: function copy() {
	      for (var t = new Array(this.geometries.length).fill(null), e = 0; e < t.length; e++) {
	        t[e] = this.geometries[e].copy();
	      }return new Rt(t, this.factory);
	    }, interfaces_: function interfaces_() {
	      return [Nt];
	    }, getClass: function getClass() {
	      return Rt;
	    } }), Rt.serialVersionUID = -0x6fb1ed4162e0fc00, br(wt, xt), Or(wt.prototype, { getSortIndex: function getSortIndex() {
	      return F.SORTINDEX_LINEARRING;
	    }, getBoundaryDimension: function getBoundaryDimension() {
	      return ot.FALSE;
	    }, isClosed: function isClosed() {
	      return !!this.isEmpty() || xt.prototype.isClosed.call(this);
	    }, reverse: function reverse() {
	      var t = this.points.copy();return Et.reverse(t), this.getFactory().createLinearRing(t);
	    }, validateConstruction: function validateConstruction() {
	      if (!this.isEmpty() && !xt.prototype.isClosed.call(this)) throw new n("Points of LinearRing do not form a closed linestring");if (this.getCoordinateSequence().size() >= 1 && this.getCoordinateSequence().size() < wt.MINIMUM_VALID_SIZE) throw new n("Invalid number of points in LinearRing (found " + this.getCoordinateSequence().size() + " - must be 0 or >= 4)");
	    }, getGeometryType: function getGeometryType() {
	      return "LinearRing";
	    }, copy: function copy() {
	      return new wt(this.points.copy(), this.factory);
	    }, interfaces_: function interfaces_() {
	      return [];
	    }, getClass: function getClass() {
	      return wt;
	    } }), wt.MINIMUM_VALID_SIZE = 4, wt.serialVersionUID = -0x3b229e262367a600, br(Tt, lt), Or(Tt.prototype, { getSortIndex: function getSortIndex() {
	      return F.SORTINDEX_MULTIPOLYGON;
	    }, equalsExact: function equalsExact() {
	      if (2 === arguments.length) {
	        var t = arguments[0],
	            e = arguments[1];return !!this.isEquivalentClass(t) && lt.prototype.equalsExact.call(this, t, e);
	      }return lt.prototype.equalsExact.apply(this, arguments);
	    }, getBoundaryDimension: function getBoundaryDimension() {
	      return 1;
	    }, getDimension: function getDimension() {
	      return 2;
	    }, reverse: function reverse() {
	      for (var t = this.geometries.length, e = new Array(t).fill(null), n = 0; n < this.geometries.length; n++) {
	        e[n] = this.geometries[n].reverse();
	      }return this.getFactory().createMultiPolygon(e);
	    }, getBoundary: function getBoundary() {
	      if (this.isEmpty()) return this.getFactory().createMultiLineString();for (var t = new I(), e = 0; e < this.geometries.length; e++) {
	        for (var n = this.geometries[e], i = n.getBoundary(), r = 0; r < i.getNumGeometries(); r++) {
	          t.add(i.getGeometryN(r));
	        }
	      }var s = new Array(t.size()).fill(null);return this.getFactory().createMultiLineString(t.toArray(s));
	    }, getGeometryType: function getGeometryType() {
	      return "MultiPolygon";
	    }, copy: function copy() {
	      for (var t = new Array(this.geometries.length).fill(null), e = 0; e < t.length; e++) {
	        t[e] = this.geometries[e].copy();
	      }return new Tt(t, this.factory);
	    }, interfaces_: function interfaces_() {
	      return [St];
	    }, getClass: function getClass() {
	      return Tt;
	    } }), Tt.serialVersionUID = -0x7a5aa1369171980, Or(Ot.prototype, { setCopyUserData: function setCopyUserData(t) {
	      this.isUserDataCopied = t;
	    }, edit: function edit(t, e) {
	      if (null === t) return null;var n = this.editInternal(t, e);return this.isUserDataCopied && n.setUserData(t.getUserData()), n;
	    }, editInternal: function editInternal(t, e) {
	      return null === this.factory && (this.factory = t.getFactory()), t instanceof lt ? this.editGeometryCollection(t, e) : t instanceof Lt ? this.editPolygon(t, e) : t instanceof Ct ? e.edit(t, this.factory) : t instanceof xt ? e.edit(t, this.factory) : (h.shouldNeverReachHere("Unsupported Geometry class: " + t.getClass().getName()), null);
	    }, editGeometryCollection: function editGeometryCollection(t, e) {
	      for (var n = e.edit(t, this.factory), i = new I(), r = 0; r < n.getNumGeometries(); r++) {
	        var s = this.edit(n.getGeometryN(r), e);null === s || s.isEmpty() || i.add(s);
	      }return n.getClass() === Rt ? this.factory.createMultiPoint(i.toArray([])) : n.getClass() === ht ? this.factory.createMultiLineString(i.toArray([])) : n.getClass() === Tt ? this.factory.createMultiPolygon(i.toArray([])) : this.factory.createGeometryCollection(i.toArray([]));
	    }, editPolygon: function editPolygon(t, e) {
	      var n = e.edit(t, this.factory);if (null === n && (n = this.factory.createPolygon(null)), n.isEmpty()) return n;var i = this.edit(n.getExteriorRing(), e);if (null === i || i.isEmpty()) return this.factory.createPolygon();for (var r = new I(), s = 0; s < n.getNumInteriorRing(); s++) {
	        var o = this.edit(n.getInteriorRingN(s), e);null === o || o.isEmpty() || r.add(o);
	      }return this.factory.createPolygon(i, r.toArray([]));
	    }, interfaces_: function interfaces_() {
	      return [];
	    }, getClass: function getClass() {
	      return Ot;
	    } }), Ot.GeometryEditorOperation = bt, Or(Pt.prototype, { edit: function edit(t, e) {
	      return t;
	    }, interfaces_: function interfaces_() {
	      return [bt];
	    }, getClass: function getClass() {
	      return Pt;
	    } }), Or(_t.prototype, { edit: function edit(t, e) {
	      var n = this.editCoordinates(t.getCoordinates(), t);return null === n ? t : t instanceof wt ? e.createLinearRing(n) : t instanceof xt ? e.createLineString(n) : t instanceof Ct ? n.length > 0 ? e.createPoint(n[0]) : e.createPoint() : t;
	    }, interfaces_: function interfaces_() {
	      return [bt];
	    }, getClass: function getClass() {
	      return _t;
	    } }), Or(Mt.prototype, { edit: function edit(t, e) {
	      return t instanceof wt ? e.createLinearRing(this.edit(t.getCoordinateSequence(), t)) : t instanceof xt ? e.createLineString(this.edit(t.getCoordinateSequence(), t)) : t instanceof Ct ? e.createPoint(this.edit(t.getCoordinateSequence(), t)) : t;
	    }, interfaces_: function interfaces_() {
	      return [bt];
	    }, getClass: function getClass() {
	      return Mt;
	    } }), Ot.NoOpGeometryOperation = Pt, Ot.CoordinateOperation = _t, Ot.CoordinateSequenceOperation = Mt, Or(At.prototype, { setOrdinate: function setOrdinate(t, e, i) {
	      switch (e) {case P.X:
	          this.coordinates[t].x = i;break;case P.Y:
	          this.coordinates[t].y = i;break;case P.Z:
	          this.coordinates[t].z = i;break;default:
	          throw new n("invalid ordinateIndex");}
	    }, size: function size() {
	      return this.coordinates.length;
	    }, getOrdinate: function getOrdinate(t, e) {
	      switch (e) {case P.X:
	          return this.coordinates[t].x;case P.Y:
	          return this.coordinates[t].y;case P.Z:
	          return this.coordinates[t].z;}return i.NaN;
	    }, getCoordinate: function getCoordinate() {
	      if (1 === arguments.length) {
	        var t = arguments[0];return this.coordinates[t];
	      }if (2 === arguments.length) {
	        var e = arguments[0],
	            n = arguments[1];n.x = this.coordinates[e].x, n.y = this.coordinates[e].y, n.z = this.coordinates[e].z;
	      }
	    }, getCoordinateCopy: function getCoordinateCopy(t) {
	      return new c(this.coordinates[t]);
	    }, getDimension: function getDimension() {
	      return this.dimension;
	    }, getX: function getX(t) {
	      return this.coordinates[t].x;
	    }, clone: function clone() {
	      for (var t = new Array(this.size()).fill(null), e = 0; e < this.coordinates.length; e++) {
	        t[e] = this.coordinates[e].clone();
	      }return new At(t, this.dimension);
	    }, expandEnvelope: function expandEnvelope(t) {
	      for (var e = 0; e < this.coordinates.length; e++) {
	        t.expandToInclude(this.coordinates[e]);
	      }return t;
	    }, copy: function copy() {
	      for (var t = new Array(this.size()).fill(null), e = 0; e < this.coordinates.length; e++) {
	        t[e] = this.coordinates[e].copy();
	      }return new At(t, this.dimension);
	    }, toString: function toString() {
	      if (this.coordinates.length > 0) {
	        var t = new R(17 * this.coordinates.length);t.append("("), t.append(this.coordinates[0]);for (var e = 1; e < this.coordinates.length; e++) {
	          t.append(", "), t.append(this.coordinates[e]);
	        }return t.append(")"), t.toString();
	      }return "()";
	    }, getY: function getY(t) {
	      return this.coordinates[t].y;
	    }, toCoordinateArray: function toCoordinateArray() {
	      return this.coordinates;
	    }, interfaces_: function interfaces_() {
	      return [P, a];
	    }, getClass: function getClass() {
	      return At;
	    } }), At.serialVersionUID = -0xcb44a778db18e00, Or(Dt.prototype, { readResolve: function readResolve() {
	      return Dt.instance();
	    }, create: function create() {
	      if (1 === arguments.length) {
	        if (arguments[0] instanceof Array) {
	          return new At(arguments[0]);
	        }if (_r(arguments[0], P)) {
	          return new At(arguments[0]);
	        }
	      } else if (2 === arguments.length) {
	        var t = arguments[0],
	            e = arguments[1];return e > 3 && (e = 3), e < 2 ? new At(t) : new At(t, e);
	      }
	    }, interfaces_: function interfaces_() {
	      return [A, a];
	    }, getClass: function getClass() {
	      return Dt;
	    } }), Dt.instance = function () {
	    return Dt.instanceObject;
	  }, Dt.serialVersionUID = -0x38e49fa6cf6f2e00, Dt.instanceObject = new Dt();var Fr,
	      Gr = Object.defineProperty,
	      Br = function (t, e) {
	    function n(t) {
	      if (!this || this.constructor !== n) return new n(t);this._keys = [], this._values = [], this._itp = [], this.objectOnly = e, t && Gt.call(this, t);
	    }return e || Gr(t, "size", { get: jt }), t.constructor = n, n.prototype = t, n;
	  }({ delete: Bt, has: Ut, get: qt, set: Yt, keys: kt, values: Vt, entries: Ht, forEach: Kt, clear: Xt }),
	      qr = "undefined" != typeof Map && Map.prototype.values ? Map : Br;Jt.prototype = new H(), Jt.prototype.get = function (t) {
	    return this.map_.get(t) || null;
	  }, Jt.prototype.put = function (t, e) {
	    return this.map_.set(t, e), e;
	  }, Jt.prototype.values = function () {
	    for (var t = new I(), e = this.map_.values(), n = e.next(); !n.done;) {
	      t.add(n.value), n = e.next();
	    }return t;
	  }, Jt.prototype.entrySet = function () {
	    var t = new K();return this.map_.entries().forEach(function (e) {
	      return t.add(e);
	    }), t;
	  }, Jt.prototype.size = function () {
	    return this.map_.size();
	  }, Or(Qt.prototype, { equals: function equals(t) {
	      if (!(t instanceof Qt)) return !1;var e = t;return this.modelType === e.modelType && this.scale === e.scale;
	    }, compareTo: function compareTo(t) {
	      var e = t,
	          n = this.getMaximumSignificantDigits(),
	          i = e.getMaximumSignificantDigits();return new w(n).compareTo(new w(i));
	    }, getScale: function getScale() {
	      return this.scale;
	    }, isFloating: function isFloating() {
	      return this.modelType === Qt.FLOATING || this.modelType === Qt.FLOATING_SINGLE;
	    }, getType: function getType() {
	      return this.modelType;
	    }, toString: function toString() {
	      var t = "UNKNOWN";return this.modelType === Qt.FLOATING ? t = "Floating" : this.modelType === Qt.FLOATING_SINGLE ? t = "Floating-Single" : this.modelType === Qt.FIXED && (t = "Fixed (Scale=" + this.getScale() + ")"), t;
	    }, makePrecise: function makePrecise() {
	      if ("number" == typeof arguments[0]) {
	        var t = arguments[0];if (i.isNaN(t)) return t;if (this.modelType === Qt.FLOATING_SINGLE) {
	          return t;
	        }return this.modelType === Qt.FIXED ? Math.round(t * this.scale) / this.scale : t;
	      }if (arguments[0] instanceof c) {
	        var e = arguments[0];if (this.modelType === Qt.FLOATING) return null;e.x = this.makePrecise(e.x), e.y = this.makePrecise(e.y);
	      }
	    }, getMaximumSignificantDigits: function getMaximumSignificantDigits() {
	      var t = 16;return this.modelType === Qt.FLOATING ? t = 16 : this.modelType === Qt.FLOATING_SINGLE ? t = 6 : this.modelType === Qt.FIXED && (t = 1 + Math.trunc(Math.ceil(Math.log(this.getScale()) / Math.log(10)))), t;
	    }, setScale: function setScale(t) {
	      this.scale = Math.abs(t);
	    }, interfaces_: function interfaces_() {
	      return [a, r];
	    }, getClass: function getClass() {
	      return Qt;
	    } }), Qt.mostPrecise = function (t, e) {
	    return t.compareTo(e) >= 0 ? t : e;
	  }, Or(Zt.prototype, { readResolve: function readResolve() {
	      return Zt.nameToTypeMap.get(this.name);
	    }, toString: function toString() {
	      return this.name;
	    }, interfaces_: function interfaces_() {
	      return [a];
	    }, getClass: function getClass() {
	      return Zt;
	    } }), Zt.serialVersionUID = -552860263173159e4, Zt.nameToTypeMap = new Jt(), Qt.Type = Zt, Qt.serialVersionUID = 0x6bee6404e9a25c00, Qt.FIXED = new Zt("FIXED"), Qt.FLOATING = new Zt("FLOATING"), Qt.FLOATING_SINGLE = new Zt("FLOATING SINGLE"), Qt.maximumPreciseValue = 9007199254740992, Or($t.prototype, { toGeometry: function toGeometry(t) {
	      return t.isNull() ? this.createPoint(null) : t.getMinX() === t.getMaxX() && t.getMinY() === t.getMaxY() ? this.createPoint(new c(t.getMinX(), t.getMinY())) : t.getMinX() === t.getMaxX() || t.getMinY() === t.getMaxY() ? this.createLineString([new c(t.getMinX(), t.getMinY()), new c(t.getMaxX(), t.getMaxY())]) : this.createPolygon(this.createLinearRing([new c(t.getMinX(), t.getMinY()), new c(t.getMinX(), t.getMaxY()), new c(t.getMaxX(), t.getMaxY()), new c(t.getMaxX(), t.getMinY()), new c(t.getMinX(), t.getMinY())]), null);
	    }, createLineString: function createLineString() {
	      if (0 === arguments.length) return this.createLineString(this.getCoordinateSequenceFactory().create([]));if (1 === arguments.length) {
	        if (arguments[0] instanceof Array) {
	          var t = arguments[0];return this.createLineString(null !== t ? this.getCoordinateSequenceFactory().create(t) : null);
	        }if (_r(arguments[0], P)) {
	          return new xt(arguments[0], this);
	        }
	      }
	    }, createMultiLineString: function createMultiLineString() {
	      if (0 === arguments.length) return new ht(null, this);if (1 === arguments.length) {
	        return new ht(arguments[0], this);
	      }
	    }, buildGeometry: function buildGeometry(t) {
	      for (var e = null, n = !1, i = !1, r = t.iterator(); r.hasNext();) {
	        var s = r.next(),
	            o = s.getClass();null === e && (e = o), o !== e && (n = !0), s.isGeometryCollectionOrDerived() && (i = !0);
	      }if (null === e) return this.createGeometryCollection();if (n || i) return this.createGeometryCollection($t.toGeometryArray(t));var a = t.iterator().next();if (t.size() > 1) {
	        if (a instanceof Lt) return this.createMultiPolygon($t.toPolygonArray(t));if (a instanceof xt) return this.createMultiLineString($t.toLineStringArray(t));if (a instanceof Ct) return this.createMultiPoint($t.toPointArray(t));h.shouldNeverReachHere("Unhandled class: " + a.getClass().getName());
	      }return a;
	    }, createMultiPointFromCoords: function createMultiPointFromCoords(t) {
	      return this.createMultiPoint(null !== t ? this.getCoordinateSequenceFactory().create(t) : null);
	    }, createPoint: function createPoint() {
	      if (0 === arguments.length) return this.createPoint(this.getCoordinateSequenceFactory().create([]));if (1 === arguments.length) {
	        if (arguments[0] instanceof c) {
	          var t = arguments[0];return this.createPoint(null !== t ? this.getCoordinateSequenceFactory().create([t]) : null);
	        }if (_r(arguments[0], P)) {
	          return new Ct(arguments[0], this);
	        }
	      }
	    }, getCoordinateSequenceFactory: function getCoordinateSequenceFactory() {
	      return this.coordinateSequenceFactory;
	    }, createPolygon: function createPolygon() {
	      if (0 === arguments.length) return new Lt(null, null, this);if (1 === arguments.length) {
	        if (_r(arguments[0], P)) {
	          var t = arguments[0];return this.createPolygon(this.createLinearRing(t));
	        }if (arguments[0] instanceof Array) {
	          var e = arguments[0];return this.createPolygon(this.createLinearRing(e));
	        }if (arguments[0] instanceof wt) {
	          var n = arguments[0];return this.createPolygon(n, null);
	        }
	      } else if (2 === arguments.length) {
	        var i = arguments[0],
	            r = arguments[1];return new Lt(i, r, this);
	      }
	    }, getSRID: function getSRID() {
	      return this.SRID;
	    }, createGeometryCollection: function createGeometryCollection() {
	      if (0 === arguments.length) return new lt(null, this);if (1 === arguments.length) {
	        return new lt(arguments[0], this);
	      }
	    }, createGeometry: function createGeometry(t) {
	      return new Ot(this).edit(t, { edit: function edit() {
	          if (2 === arguments.length) {
	            var t = arguments[0];return arguments[1], this.coordinateSequenceFactory.create(t);
	          }
	        } });
	    }, getPrecisionModel: function getPrecisionModel() {
	      return this.precisionModel;
	    }, createLinearRing: function createLinearRing() {
	      if (0 === arguments.length) return this.createLinearRing(this.getCoordinateSequenceFactory().create([]));if (1 === arguments.length) {
	        if (arguments[0] instanceof Array) {
	          var t = arguments[0];return this.createLinearRing(null !== t ? this.getCoordinateSequenceFactory().create(t) : null);
	        }if (_r(arguments[0], P)) {
	          return new wt(arguments[0], this);
	        }
	      }
	    }, createMultiPolygon: function createMultiPolygon() {
	      if (0 === arguments.length) return new Tt(null, this);if (1 === arguments.length) {
	        return new Tt(arguments[0], this);
	      }
	    }, createMultiPoint: function createMultiPoint() {
	      if (0 === arguments.length) return new Rt(null, this);if (1 === arguments.length) {
	        if (arguments[0] instanceof Array) {
	          return new Rt(arguments[0], this);
	        }if (arguments[0] instanceof Array) {
	          var t = arguments[0];return this.createMultiPoint(null !== t ? this.getCoordinateSequenceFactory().create(t) : null);
	        }if (_r(arguments[0], P)) {
	          var e = arguments[0];if (null === e) return this.createMultiPoint(new Array(0).fill(null));for (var n = new Array(e.size()).fill(null), i = 0; i < e.size(); i++) {
	            var r = this.getCoordinateSequenceFactory().create(1, e.getDimension());Et.copy(e, i, r, 0, 1), n[i] = this.createPoint(r);
	          }return this.createMultiPoint(n);
	        }
	      }
	    }, interfaces_: function interfaces_() {
	      return [a];
	    }, getClass: function getClass() {
	      return $t;
	    } }), $t.toMultiPolygonArray = function (t) {
	    var e = new Array(t.size()).fill(null);return t.toArray(e);
	  }, $t.toGeometryArray = function (t) {
	    if (null === t) return null;var e = new Array(t.size()).fill(null);return t.toArray(e);
	  }, $t.getDefaultCoordinateSequenceFactory = function () {
	    return Dt.instance();
	  }, $t.toMultiLineStringArray = function (t) {
	    var e = new Array(t.size()).fill(null);return t.toArray(e);
	  }, $t.toLineStringArray = function (t) {
	    var e = new Array(t.size()).fill(null);return t.toArray(e);
	  }, $t.toMultiPointArray = function (t) {
	    var e = new Array(t.size()).fill(null);return t.toArray(e);
	  }, $t.toLinearRingArray = function (t) {
	    var e = new Array(t.size()).fill(null);return t.toArray(e);
	  }, $t.toPointArray = function (t) {
	    var e = new Array(t.size()).fill(null);return t.toArray(e);
	  }, $t.toPolygonArray = function (t) {
	    var e = new Array(t.size()).fill(null);return t.toArray(e);
	  }, $t.createPointFromInternalCoord = function (t, e) {
	    return e.getPrecisionModel().makePrecise(t), e.getFactory().createPoint(t);
	  }, $t.serialVersionUID = -0x5ea75f2051eeb400;var zr = { typeStr: /^\s*(\w+)\s*\(\s*(.*)\s*\)\s*$/, emptyTypeStr: /^\s*(\w+)\s*EMPTY\s*$/, spaces: /\s+/, parenComma: /\)\s*,\s*\(/, doubleParenComma: /\)\s*\)\s*,\s*\(\s*\(/, trimParens: /^\s*\(?(.*?)\)?\s*$/ };Or(te.prototype, { read: function read(t) {
	      var e, n, i;t = t.replace(/[\n\r]/g, " ");var r = zr.typeStr.exec(t);if (t.search("EMPTY") !== -1 && (r = zr.emptyTypeStr.exec(t), r[2] = void 0), r && (n = r[1].toLowerCase(), i = r[2], Yr[n] && (e = Yr[n].apply(this, [i]))), void 0 === e) throw new Error("Could not parse WKT " + t);return e;
	    }, write: function write(t) {
	      return this.extractGeometry(t);
	    }, extractGeometry: function extractGeometry(t) {
	      var e = t.getGeometryType().toLowerCase();if (!Ur[e]) return null;var n = e.toUpperCase();return t.isEmpty() ? n + " EMPTY" : n + "(" + Ur[e].apply(this, [t]) + ")";
	    } });var Ur = { coordinate: function coordinate(t) {
	      return t.x + " " + t.y;
	    }, point: function point(t) {
	      return Ur.coordinate.call(this, t.coordinates.coordinates[0]);
	    }, multipoint: function multipoint(t) {
	      for (var e = [], n = 0, i = t.geometries.length; n < i; ++n) {
	        e.push("(" + Ur.point.apply(this, [t.geometries[n]]) + ")");
	      }return e.join(",");
	    }, linestring: function linestring(t) {
	      for (var e = [], n = 0, i = t.points.coordinates.length; n < i; ++n) {
	        e.push(Ur.coordinate.apply(this, [t.points.coordinates[n]]));
	      }return e.join(",");
	    }, linearring: function linearring(t) {
	      for (var e = [], n = 0, i = t.points.coordinates.length; n < i; ++n) {
	        e.push(Ur.coordinate.apply(this, [t.points.coordinates[n]]));
	      }return e.join(",");
	    }, multilinestring: function multilinestring(t) {
	      for (var e = [], n = 0, i = t.geometries.length; n < i; ++n) {
	        e.push("(" + Ur.linestring.apply(this, [t.geometries[n]]) + ")");
	      }return e.join(",");
	    }, polygon: function polygon(t) {
	      var e = [];e.push("(" + Ur.linestring.apply(this, [t.shell]) + ")");for (var n = 0, i = t.holes.length; n < i; ++n) {
	        e.push("(" + Ur.linestring.apply(this, [t.holes[n]]) + ")");
	      }return e.join(",");
	    }, multipolygon: function multipolygon(t) {
	      for (var e = [], n = 0, i = t.geometries.length; n < i; ++n) {
	        e.push("(" + Ur.polygon.apply(this, [t.geometries[n]]) + ")");
	      }return e.join(",");
	    }, geometrycollection: function geometrycollection(t) {
	      for (var e = [], n = 0, i = t.geometries.length; n < i; ++n) {
	        e.push(this.extractGeometry(t.geometries[n]));
	      }return e.join(",");
	    } },
	      Yr = { point: function point(t) {
	      if (void 0 === t) return this.geometryFactory.createPoint();var e = t.trim().split(zr.spaces);return this.geometryFactory.createPoint(new c(Number.parseFloat(e[0]), Number.parseFloat(e[1])));
	    }, multipoint: function multipoint(t) {
	      if (void 0 === t) return this.geometryFactory.createMultiPoint();for (var e, n = t.trim().split(","), i = [], r = 0, s = n.length; r < s; ++r) {
	        e = n[r].replace(zr.trimParens, "$1"), i.push(Yr.point.apply(this, [e]));
	      }return this.geometryFactory.createMultiPoint(i);
	    }, linestring: function linestring(t) {
	      if (void 0 === t) return this.geometryFactory.createLineString();for (var e, n = t.trim().split(","), i = [], r = 0, s = n.length; r < s; ++r) {
	        e = n[r].trim().split(zr.spaces), i.push(new c(Number.parseFloat(e[0]), Number.parseFloat(e[1])));
	      }return this.geometryFactory.createLineString(i);
	    }, linearring: function linearring(t) {
	      if (void 0 === t) return this.geometryFactory.createLinearRing();for (var e, n = t.trim().split(","), i = [], r = 0, s = n.length; r < s; ++r) {
	        e = n[r].trim().split(zr.spaces), i.push(new c(Number.parseFloat(e[0]), Number.parseFloat(e[1])));
	      }return this.geometryFactory.createLinearRing(i);
	    }, multilinestring: function multilinestring(t) {
	      if (void 0 === t) return this.geometryFactory.createMultiLineString();for (var e, n = t.trim().split(zr.parenComma), i = [], r = 0, s = n.length; r < s; ++r) {
	        e = n[r].replace(zr.trimParens, "$1"), i.push(Yr.linestring.apply(this, [e]));
	      }return this.geometryFactory.createMultiLineString(i);
	    }, polygon: function polygon(t) {
	      if (void 0 === t) return this.geometryFactory.createPolygon();for (var e, n, i, r, s = t.trim().split(zr.parenComma), o = [], a = 0, u = s.length; a < u; ++a) {
	        e = s[a].replace(zr.trimParens, "$1"), n = Yr.linestring.apply(this, [e]), i = this.geometryFactory.createLinearRing(n.points), 0 === a ? r = i : o.push(i);
	      }return this.geometryFactory.createPolygon(r, o);
	    }, multipolygon: function multipolygon(t) {
	      if (void 0 === t) return this.geometryFactory.createMultiPolygon();for (var e, n = t.trim().split(zr.doubleParenComma), i = [], r = 0, s = n.length; r < s; ++r) {
	        e = n[r].replace(zr.trimParens, "$1"), i.push(Yr.polygon.apply(this, [e]));
	      }return this.geometryFactory.createMultiPolygon(i);
	    }, geometrycollection: function geometrycollection(t) {
	      if (void 0 === t) return this.geometryFactory.createGeometryCollection();t = t.replace(/,\s*([A-Za-z])/g, "|$1");for (var e = t.trim().split("|"), n = [], i = 0, r = e.length; i < r; ++i) {
	        n.push(this.read(e[i]));
	      }return this.geometryFactory.createGeometryCollection(n);
	    } };Or(ee.prototype, { write: function write(t) {
	      return this.parser.write(t);
	    } }), Or(ee, { toLineString: function toLineString(t, e) {
	      if (2 !== arguments.length) throw new Error("Not implemented");return "LINESTRING ( " + t.x + " " + t.y + ", " + e.x + " " + e.y + " )";
	    } }), Or(ne.prototype, { getIndexAlongSegment: function getIndexAlongSegment(t, e) {
	      return this.computeIntLineIndex(), this.intLineIndex[t][e];
	    }, getTopologySummary: function getTopologySummary() {
	      var t = new R();return this.isEndPoint() && t.append(" endpoint"), this._isProper && t.append(" proper"), this.isCollinear() && t.append(" collinear"), t.toString();
	    }, computeIntersection: function computeIntersection(t, e, n, i) {
	      this.inputLines[0][0] = t, this.inputLines[0][1] = e, this.inputLines[1][0] = n, this.inputLines[1][1] = i, this.result = this.computeIntersect(t, e, n, i);
	    }, getIntersectionNum: function getIntersectionNum() {
	      return this.result;
	    }, computeIntLineIndex: function computeIntLineIndex() {
	      if (0 === arguments.length) null === this.intLineIndex && (this.intLineIndex = Array(2).fill().map(function () {
	        return Array(2);
	      }), this.computeIntLineIndex(0), this.computeIntLineIndex(1));else if (1 === arguments.length) {
	        var t = arguments[0],
	            e = this.getEdgeDistance(t, 0),
	            n = this.getEdgeDistance(t, 1);e > n ? (this.intLineIndex[t][0] = 0, this.intLineIndex[t][1] = 1) : (this.intLineIndex[t][0] = 1, this.intLineIndex[t][1] = 0);
	      }
	    }, isProper: function isProper() {
	      return this.hasIntersection() && this._isProper;
	    }, setPrecisionModel: function setPrecisionModel(t) {
	      this.precisionModel = t;
	    }, isInteriorIntersection: function isInteriorIntersection() {
	      if (0 === arguments.length) return !!this.isInteriorIntersection(0) || !!this.isInteriorIntersection(1);if (1 === arguments.length) {
	        for (var t = arguments[0], e = 0; e < this.result; e++) {
	          if (!this.intPt[e].equals2D(this.inputLines[t][0]) && !this.intPt[e].equals2D(this.inputLines[t][1])) return !0;
	        }return !1;
	      }
	    }, getIntersection: function getIntersection(t) {
	      return this.intPt[t];
	    }, isEndPoint: function isEndPoint() {
	      return this.hasIntersection() && !this._isProper;
	    }, hasIntersection: function hasIntersection() {
	      return this.result !== ne.NO_INTERSECTION;
	    }, getEdgeDistance: function getEdgeDistance(t, e) {
	      return ne.computeEdgeDistance(this.intPt[e], this.inputLines[t][0], this.inputLines[t][1]);
	    }, isCollinear: function isCollinear() {
	      return this.result === ne.COLLINEAR_INTERSECTION;
	    }, toString: function toString() {
	      return ee.toLineString(this.inputLines[0][0], this.inputLines[0][1]) + " - " + ee.toLineString(this.inputLines[1][0], this.inputLines[1][1]) + this.getTopologySummary();
	    }, getEndpoint: function getEndpoint(t, e) {
	      return this.inputLines[t][e];
	    }, isIntersection: function isIntersection(t) {
	      for (var e = 0; e < this.result; e++) {
	        if (this.intPt[e].equals2D(t)) return !0;
	      }return !1;
	    }, getIntersectionAlongSegment: function getIntersectionAlongSegment(t, e) {
	      return this.computeIntLineIndex(), this.intPt[this.intLineIndex[t][e]];
	    }, interfaces_: function interfaces_() {
	      return [];
	    }, getClass: function getClass() {
	      return ne;
	    } }), ne.computeEdgeDistance = function (t, e, n) {
	    var i = Math.abs(n.x - e.x),
	        r = Math.abs(n.y - e.y),
	        s = -1;if (t.equals(e)) s = 0;else if (t.equals(n)) s = i > r ? i : r;else {
	      var o = Math.abs(t.x - e.x),
	          a = Math.abs(t.y - e.y);s = i > r ? o : a, 0 !== s || t.equals(e) || (s = Math.max(o, a));
	    }return h.isTrue(!(0 === s && !t.equals(e)), "Bad distance calculation"), s;
	  }, ne.nonRobustComputeEdgeDistance = function (t, e, n) {
	    var i = t.x - e.x,
	        r = t.y - e.y,
	        s = Math.sqrt(i * i + r * r);return h.isTrue(!(0 === s && !t.equals(e)), "Invalid distance calculation"), s;
	  }, ne.DONT_INTERSECT = 0, ne.DO_INTERSECT = 1, ne.COLLINEAR = 2, ne.NO_INTERSECTION = 0, ne.POINT_INTERSECTION = 1, ne.COLLINEAR_INTERSECTION = 2, br(ie, ne), Or(ie.prototype, { isInSegmentEnvelopes: function isInSegmentEnvelopes(t) {
	      var e = new x(this.inputLines[0][0], this.inputLines[0][1]),
	          n = new x(this.inputLines[1][0], this.inputLines[1][1]);return e.contains(t) && n.contains(t);
	    }, computeIntersection: function computeIntersection() {
	      if (3 !== arguments.length) return ne.prototype.computeIntersection.apply(this, arguments);var t = arguments[0],
	          e = arguments[1],
	          n = arguments[2];if (this._isProper = !1, x.intersects(e, n, t) && 0 === oe.orientationIndex(e, n, t) && 0 === oe.orientationIndex(n, e, t)) return this._isProper = !0, (t.equals(e) || t.equals(n)) && (this._isProper = !1), this.result = ne.POINT_INTERSECTION, null;this.result = ne.NO_INTERSECTION;
	    }, normalizeToMinimum: function normalizeToMinimum(t, e, n, i, r) {
	      r.x = this.smallestInAbsValue(t.x, e.x, n.x, i.x), r.y = this.smallestInAbsValue(t.y, e.y, n.y, i.y), t.x -= r.x, t.y -= r.y, e.x -= r.x, e.y -= r.y, n.x -= r.x, n.y -= r.y, i.x -= r.x, i.y -= r.y;
	    }, safeHCoordinateIntersection: function safeHCoordinateIntersection(t, e, n, i) {
	      var r = null;try {
	        r = M.intersection(t, e, n, i);
	      } catch (s) {
	        if (!(s instanceof C)) throw s;r = ie.nearestEndpoint(t, e, n, i);
	      } finally {}return r;
	    }, intersection: function intersection(t, e, n, i) {
	      var r = this.intersectionWithNormalization(t, e, n, i);return this.isInSegmentEnvelopes(r) || (r = new c(ie.nearestEndpoint(t, e, n, i))), null !== this.precisionModel && this.precisionModel.makePrecise(r), r;
	    }, smallestInAbsValue: function smallestInAbsValue(t, e, n, i) {
	      var r = t,
	          s = Math.abs(r);return Math.abs(e) < s && (r = e, s = Math.abs(e)), Math.abs(n) < s && (r = n, s = Math.abs(n)), Math.abs(i) < s && (r = i), r;
	    }, checkDD: function checkDD(t, e, n, i, r) {
	      var s = b.intersection(t, e, n, i),
	          o = this.isInSegmentEnvelopes(s);_.out.println("DD in env = " + o + "  --------------------- " + s), r.distance(s) > 1e-4 && _.out.println("Distance = " + r.distance(s));
	    }, intersectionWithNormalization: function intersectionWithNormalization(t, e, n, i) {
	      var r = new c(t),
	          s = new c(e),
	          o = new c(n),
	          a = new c(i),
	          u = new c();this.normalizeToEnvCentre(r, s, o, a, u);var l = this.safeHCoordinateIntersection(r, s, o, a);return l.x += u.x, l.y += u.y, l;
	    }, computeCollinearIntersection: function computeCollinearIntersection(t, e, n, i) {
	      var r = x.intersects(t, e, n),
	          s = x.intersects(t, e, i),
	          o = x.intersects(n, i, t),
	          a = x.intersects(n, i, e);return r && s ? (this.intPt[0] = n, this.intPt[1] = i, ne.COLLINEAR_INTERSECTION) : o && a ? (this.intPt[0] = t, this.intPt[1] = e, ne.COLLINEAR_INTERSECTION) : r && o ? (this.intPt[0] = n, this.intPt[1] = t, !n.equals(t) || s || a ? ne.COLLINEAR_INTERSECTION : ne.POINT_INTERSECTION) : r && a ? (this.intPt[0] = n, this.intPt[1] = e, !n.equals(e) || s || o ? ne.COLLINEAR_INTERSECTION : ne.POINT_INTERSECTION) : s && o ? (this.intPt[0] = i, this.intPt[1] = t, !i.equals(t) || r || a ? ne.COLLINEAR_INTERSECTION : ne.POINT_INTERSECTION) : s && a ? (this.intPt[0] = i, this.intPt[1] = e, !i.equals(e) || r || o ? ne.COLLINEAR_INTERSECTION : ne.POINT_INTERSECTION) : ne.NO_INTERSECTION;
	    }, normalizeToEnvCentre: function normalizeToEnvCentre(t, e, n, i, r) {
	      var s = t.x < e.x ? t.x : e.x,
	          o = t.y < e.y ? t.y : e.y,
	          a = t.x > e.x ? t.x : e.x,
	          u = t.y > e.y ? t.y : e.y,
	          l = n.x < i.x ? n.x : i.x,
	          h = n.y < i.y ? n.y : i.y,
	          c = n.x > i.x ? n.x : i.x,
	          f = n.y > i.y ? n.y : i.y,
	          g = s > l ? s : l,
	          d = a < c ? a : c,
	          p = o > h ? o : h,
	          m = u < f ? u : f,
	          v = (g + d) / 2,
	          y = (p + m) / 2;r.x = v, r.y = y, t.x -= r.x, t.y -= r.y, e.x -= r.x, e.y -= r.y, n.x -= r.x, n.y -= r.y, i.x -= r.x, i.y -= r.y;
	    },
	    computeIntersect: function computeIntersect(t, e, n, i) {
	      if (this._isProper = !1, !x.intersects(t, e, n, i)) return ne.NO_INTERSECTION;var r = oe.orientationIndex(t, e, n),
	          s = oe.orientationIndex(t, e, i);if (r > 0 && s > 0 || r < 0 && s < 0) return ne.NO_INTERSECTION;var o = oe.orientationIndex(n, i, t),
	          a = oe.orientationIndex(n, i, e);return o > 0 && a > 0 || o < 0 && a < 0 ? ne.NO_INTERSECTION : 0 === r && 0 === s && 0 === o && 0 === a ? this.computeCollinearIntersection(t, e, n, i) : (0 === r || 0 === s || 0 === o || 0 === a ? (this._isProper = !1, t.equals2D(n) || t.equals2D(i) ? this.intPt[0] = t : e.equals2D(n) || e.equals2D(i) ? this.intPt[0] = e : 0 === r ? this.intPt[0] = new c(n) : 0 === s ? this.intPt[0] = new c(i) : 0 === o ? this.intPt[0] = new c(t) : 0 === a && (this.intPt[0] = new c(e))) : (this._isProper = !0, this.intPt[0] = this.intersection(t, e, n, i)), ne.POINT_INTERSECTION);
	    }, interfaces_: function interfaces_() {
	      return [];
	    }, getClass: function getClass() {
	      return ie;
	    } }), ie.nearestEndpoint = function (t, e, n, i) {
	    var r = t,
	        s = oe.distancePointLine(t, n, i),
	        o = oe.distancePointLine(e, n, i);return o < s && (s = o, r = e), o = oe.distancePointLine(n, t, e), o < s && (s = o, r = n), o = oe.distancePointLine(i, t, e), o < s && (s = o, r = i), r;
	  }, Or(re.prototype, { interfaces_: function interfaces_() {
	      return [];
	    }, getClass: function getClass() {
	      return re;
	    } }), re.orientationIndex = function (t, e, n) {
	    var i = e.x - t.x,
	        r = e.y - t.y,
	        s = n.x - e.x,
	        o = n.y - e.y;return re.signOfDet2x2(i, r, s, o);
	  }, re.signOfDet2x2 = function (t, e, n, i) {
	    var r = null,
	        s = null,
	        o = null,
	        a = 0;if (r = 1, 0 === t || 0 === i) return 0 === e || 0 === n ? 0 : e > 0 ? n > 0 ? -r : r : n > 0 ? r : -r;if (0 === e || 0 === n) return i > 0 ? t > 0 ? r : -r : t > 0 ? -r : r;if (0 < e ? 0 < i ? e <= i || (r = -r, s = t, t = n, n = s, s = e, e = i, i = s) : e <= -i ? (r = -r, n = -n, i = -i) : (s = t, t = -n, n = s, s = e, e = -i, i = s) : 0 < i ? -e <= i ? (r = -r, t = -t, e = -e) : (s = -t, t = n, n = s, s = -e, e = i, i = s) : e >= i ? (t = -t, e = -e, n = -n, i = -i) : (r = -r, s = -t, t = -n, n = s, s = -e, e = -i, i = s), 0 < t) {
	      if (!(0 < n)) return r;if (!(t <= n)) return r;
	    } else {
	      if (0 < n) return -r;if (!(t >= n)) return -r;r = -r, t = -t, n = -n;
	    }for (;;) {
	      if (a += 1, o = Math.floor(n / t), n -= o * t, (i -= o * e) < 0) return -r;if (i > e) return r;if (t > n + n) {
	        if (e < i + i) return r;
	      } else {
	        if (e > i + i) return -r;n = t - n, i = e - i, r = -r;
	      }if (0 === i) return 0 === n ? 0 : -r;if (0 === n) return r;if (o = Math.floor(t / n), t -= o * n, (e -= o * i) < 0) return r;if (e > i) return -r;if (n > t + t) {
	        if (i < e + e) return -r;
	      } else {
	        if (i > e + e) return r;t = n - t, e = i - e, r = -r;
	      }if (0 === e) return 0 === t ? 0 : r;if (0 === t) return -r;
	    }
	  }, Or(se.prototype, { countSegment: function countSegment(t, e) {
	      if (t.x < this.p.x && e.x < this.p.x) return null;if (this.p.x === e.x && this.p.y === e.y) return this.isPointOnSegment = !0, null;if (t.y === this.p.y && e.y === this.p.y) {
	        var n = t.x,
	            i = e.x;return n > i && (n = e.x, i = t.x), this.p.x >= n && this.p.x <= i && (this.isPointOnSegment = !0), null;
	      }if (t.y > this.p.y && e.y <= this.p.y || e.y > this.p.y && t.y <= this.p.y) {
	        var r = t.x - this.p.x,
	            s = t.y - this.p.y,
	            o = e.x - this.p.x,
	            a = e.y - this.p.y,
	            u = re.signOfDet2x2(r, s, o, a);if (0 === u) return this.isPointOnSegment = !0, null;a < s && (u = -u), u > 0 && this.crossingCount++;
	      }
	    }, isPointInPolygon: function isPointInPolygon() {
	      return this.getLocation() !== S.EXTERIOR;
	    }, getLocation: function getLocation() {
	      return this.isPointOnSegment ? S.BOUNDARY : this.crossingCount % 2 == 1 ? S.INTERIOR : S.EXTERIOR;
	    }, isOnSegment: function isOnSegment() {
	      return this.isPointOnSegment;
	    }, interfaces_: function interfaces_() {
	      return [];
	    }, getClass: function getClass() {
	      return se;
	    } }), se.locatePointInRing = function () {
	    if (arguments[0] instanceof c && _r(arguments[1], P)) {
	      for (var t = arguments[0], e = arguments[1], n = new se(t), i = new c(), r = new c(), s = 1; s < e.size(); s++) {
	        if (e.getCoordinate(s, i), e.getCoordinate(s - 1, r), n.countSegment(i, r), n.isOnSegment()) return n.getLocation();
	      }return n.getLocation();
	    }if (arguments[0] instanceof c && arguments[1] instanceof Array) {
	      for (var o = arguments[0], a = arguments[1], n = new se(o), s = 1; s < a.length; s++) {
	        var i = a[s],
	            r = a[s - 1];if (n.countSegment(i, r), n.isOnSegment()) return n.getLocation();
	      }return n.getLocation();
	    }
	  }, Or(oe.prototype, { interfaces_: function interfaces_() {
	      return [];
	    }, getClass: function getClass() {
	      return oe;
	    } }), oe.orientationIndex = function (t, e, n) {
	    return b.orientationIndex(t, e, n);
	  }, oe.signedArea = function () {
	    if (arguments[0] instanceof Array) {
	      var t = arguments[0];if (t.length < 3) return 0;for (var e = 0, n = t[0].x, i = 1; i < t.length - 1; i++) {
	        var r = t[i].x - n,
	            s = t[i + 1].y;e += r * (t[i - 1].y - s);
	      }return e / 2;
	    }if (_r(arguments[0], P)) {
	      var o = arguments[0],
	          a = o.size();if (a < 3) return 0;var u = new c(),
	          l = new c(),
	          h = new c();o.getCoordinate(0, l), o.getCoordinate(1, h);var n = l.x;h.x -= n;for (var e = 0, i = 1; i < a - 1; i++) {
	        u.y = l.y, l.x = h.x, l.y = h.y, o.getCoordinate(i + 1, h), h.x -= n, e += l.x * (u.y - h.y);
	      }return e / 2;
	    }
	  }, oe.distanceLineLine = function (t, e, n, i) {
	    if (t.equals(e)) return oe.distancePointLine(t, n, i);if (n.equals(i)) return oe.distancePointLine(i, t, e);var r = !1;if (x.intersects(t, e, n, i)) {
	      var s = (e.x - t.x) * (i.y - n.y) - (e.y - t.y) * (i.x - n.x);if (0 === s) r = !0;else {
	        var o = (t.y - n.y) * (i.x - n.x) - (t.x - n.x) * (i.y - n.y),
	            a = (t.y - n.y) * (e.x - t.x) - (t.x - n.x) * (e.y - t.y),
	            u = a / s,
	            l = o / s;(l < 0 || l > 1 || u < 0 || u > 1) && (r = !0);
	      }
	    } else r = !0;return r ? L.min(oe.distancePointLine(t, n, i), oe.distancePointLine(e, n, i), oe.distancePointLine(n, t, e), oe.distancePointLine(i, t, e)) : 0;
	  }, oe.isPointInRing = function (t, e) {
	    return oe.locatePointInRing(t, e) !== S.EXTERIOR;
	  }, oe.computeLength = function (t) {
	    var e = t.size();if (e <= 1) return 0;var n = 0,
	        i = new c();t.getCoordinate(0, i);for (var r = i.x, s = i.y, o = 1; o < e; o++) {
	      t.getCoordinate(o, i);var a = i.x,
	          u = i.y,
	          l = a - r,
	          h = u - s;n += Math.sqrt(l * l + h * h), r = a, s = u;
	    }return n;
	  }, oe.isCCW = function (t) {
	    var e = t.length - 1;if (e < 3) throw new n("Ring has fewer than 4 points, so orientation cannot be determined");for (var i = t[0], r = 0, s = 1; s <= e; s++) {
	      var o = t[s];o.y > i.y && (i = o, r = s);
	    }var a = r;do {
	      (a -= 1) < 0 && (a = e);
	    } while (t[a].equals2D(i) && a !== r);var u = r;do {
	      u = (u + 1) % e;
	    } while (t[u].equals2D(i) && u !== r);var l = t[a],
	        h = t[u];if (l.equals2D(i) || h.equals2D(i) || l.equals2D(h)) return !1;var c = oe.computeOrientation(l, i, h);return 0 === c ? l.x > h.x : c > 0;
	  }, oe.locatePointInRing = function (t, e) {
	    return se.locatePointInRing(t, e);
	  }, oe.distancePointLinePerpendicular = function (t, e, n) {
	    var i = (n.x - e.x) * (n.x - e.x) + (n.y - e.y) * (n.y - e.y),
	        r = ((e.y - t.y) * (n.x - e.x) - (e.x - t.x) * (n.y - e.y)) / i;return Math.abs(r) * Math.sqrt(i);
	  }, oe.computeOrientation = function (t, e, n) {
	    return oe.orientationIndex(t, e, n);
	  }, oe.distancePointLine = function () {
	    if (2 === arguments.length) {
	      var t = arguments[0],
	          e = arguments[1];if (0 === e.length) throw new n("Line array must contain at least one vertex");for (var i = t.distance(e[0]), r = 0; r < e.length - 1; r++) {
	        var s = oe.distancePointLine(t, e[r], e[r + 1]);s < i && (i = s);
	      }return i;
	    }if (3 === arguments.length) {
	      var o = arguments[0],
	          a = arguments[1],
	          u = arguments[2];if (a.x === u.x && a.y === u.y) return o.distance(a);var l = (u.x - a.x) * (u.x - a.x) + (u.y - a.y) * (u.y - a.y),
	          h = ((o.x - a.x) * (u.x - a.x) + (o.y - a.y) * (u.y - a.y)) / l;if (h <= 0) return o.distance(a);if (h >= 1) return o.distance(u);var c = ((a.y - o.y) * (u.x - a.x) - (a.x - o.x) * (u.y - a.y)) / l;return Math.abs(c) * Math.sqrt(l);
	    }
	  }, oe.isOnLine = function (t, e) {
	    for (var n = new ie(), i = 1; i < e.length; i++) {
	      var r = e[i - 1],
	          s = e[i];if (n.computeIntersection(t, r, s), n.hasIntersection()) return !0;
	    }return !1;
	  }, oe.CLOCKWISE = -1, oe.RIGHT = oe.CLOCKWISE, oe.COUNTERCLOCKWISE = 1, oe.LEFT = oe.COUNTERCLOCKWISE, oe.COLLINEAR = 0, oe.STRAIGHT = oe.COLLINEAR, Or(ae.prototype, { minX: function minX() {
	      return Math.min(this.p0.x, this.p1.x);
	    }, orientationIndex: function orientationIndex() {
	      if (arguments[0] instanceof ae) {
	        var t = arguments[0],
	            e = oe.orientationIndex(this.p0, this.p1, t.p0),
	            n = oe.orientationIndex(this.p0, this.p1, t.p1);return e >= 0 && n >= 0 ? Math.max(e, n) : e <= 0 && n <= 0 ? Math.max(e, n) : 0;
	      }if (arguments[0] instanceof c) {
	        var i = arguments[0];return oe.orientationIndex(this.p0, this.p1, i);
	      }
	    }, toGeometry: function toGeometry(t) {
	      return t.createLineString([this.p0, this.p1]);
	    }, isVertical: function isVertical() {
	      return this.p0.x === this.p1.x;
	    }, equals: function equals(t) {
	      if (!(t instanceof ae)) return !1;var e = t;return this.p0.equals(e.p0) && this.p1.equals(e.p1);
	    }, intersection: function intersection(t) {
	      var e = new ie();return e.computeIntersection(this.p0, this.p1, t.p0, t.p1), e.hasIntersection() ? e.getIntersection(0) : null;
	    }, project: function project() {
	      if (arguments[0] instanceof c) {
	        var t = arguments[0];if (t.equals(this.p0) || t.equals(this.p1)) return new c(t);var e = this.projectionFactor(t),
	            n = new c();return n.x = this.p0.x + e * (this.p1.x - this.p0.x), n.y = this.p0.y + e * (this.p1.y - this.p0.y), n;
	      }if (arguments[0] instanceof ae) {
	        var i = arguments[0],
	            r = this.projectionFactor(i.p0),
	            s = this.projectionFactor(i.p1);if (r >= 1 && s >= 1) return null;if (r <= 0 && s <= 0) return null;var o = this.project(i.p0);r < 0 && (o = this.p0), r > 1 && (o = this.p1);var a = this.project(i.p1);return s < 0 && (a = this.p0), s > 1 && (a = this.p1), new ae(o, a);
	      }
	    }, normalize: function normalize() {
	      this.p1.compareTo(this.p0) < 0 && this.reverse();
	    }, angle: function angle() {
	      return Math.atan2(this.p1.y - this.p0.y, this.p1.x - this.p0.x);
	    }, getCoordinate: function getCoordinate(t) {
	      return 0 === t ? this.p0 : this.p1;
	    }, distancePerpendicular: function distancePerpendicular(t) {
	      return oe.distancePointLinePerpendicular(t, this.p0, this.p1);
	    }, minY: function minY() {
	      return Math.min(this.p0.y, this.p1.y);
	    }, midPoint: function midPoint() {
	      return ae.midPoint(this.p0, this.p1);
	    }, projectionFactor: function projectionFactor(t) {
	      if (t.equals(this.p0)) return 0;if (t.equals(this.p1)) return 1;var e = this.p1.x - this.p0.x,
	          n = this.p1.y - this.p0.y,
	          r = e * e + n * n;return r <= 0 ? i.NaN : ((t.x - this.p0.x) * e + (t.y - this.p0.y) * n) / r;
	    }, closestPoints: function closestPoints(t) {
	      var e = this.intersection(t);if (null !== e) return [e, e];var n = new Array(2).fill(null),
	          r = i.MAX_VALUE,
	          s = null,
	          o = this.closestPoint(t.p0);r = o.distance(t.p0), n[0] = o, n[1] = t.p0;var a = this.closestPoint(t.p1);(s = a.distance(t.p1)) < r && (r = s, n[0] = a, n[1] = t.p1);var u = t.closestPoint(this.p0);(s = u.distance(this.p0)) < r && (r = s, n[0] = this.p0, n[1] = u);var l = t.closestPoint(this.p1);return s = l.distance(this.p1), s < r && (r = s, n[0] = this.p1, n[1] = l), n;
	    }, closestPoint: function closestPoint(t) {
	      var e = this.projectionFactor(t);return e > 0 && e < 1 ? this.project(t) : this.p0.distance(t) < this.p1.distance(t) ? this.p0 : this.p1;
	    }, maxX: function maxX() {
	      return Math.max(this.p0.x, this.p1.x);
	    }, getLength: function getLength() {
	      return this.p0.distance(this.p1);
	    }, compareTo: function compareTo(t) {
	      var e = t,
	          n = this.p0.compareTo(e.p0);return 0 !== n ? n : this.p1.compareTo(e.p1);
	    }, reverse: function reverse() {
	      var t = this.p0;this.p0 = this.p1, this.p1 = t;
	    }, equalsTopo: function equalsTopo(t) {
	      return this.p0.equals(t.p0) && this.p1.equals(t.p1) || this.p0.equals(t.p1) && this.p1.equals(t.p0);
	    }, lineIntersection: function lineIntersection(t) {
	      try {
	        return M.intersection(this.p0, this.p1, t.p0, t.p1);
	      } catch (t) {
	        if (!(t instanceof C)) throw t;
	      } finally {}return null;
	    }, maxY: function maxY() {
	      return Math.max(this.p0.y, this.p1.y);
	    }, pointAlongOffset: function pointAlongOffset(t, e) {
	      var n = this.p0.x + t * (this.p1.x - this.p0.x),
	          i = this.p0.y + t * (this.p1.y - this.p0.y),
	          r = this.p1.x - this.p0.x,
	          s = this.p1.y - this.p0.y,
	          o = Math.sqrt(r * r + s * s),
	          a = 0,
	          u = 0;if (0 !== e) {
	        if (o <= 0) throw new IllegalStateException("Cannot compute offset from zero-length line segment");a = e * r / o, u = e * s / o;
	      }return new c(n - u, i + a);
	    }, setCoordinates: function setCoordinates() {
	      if (1 === arguments.length) {
	        var t = arguments[0];this.setCoordinates(t.p0, t.p1);
	      } else if (2 === arguments.length) {
	        var e = arguments[0],
	            n = arguments[1];this.p0.x = e.x, this.p0.y = e.y, this.p1.x = n.x, this.p1.y = n.y;
	      }
	    }, segmentFraction: function segmentFraction(t) {
	      var e = this.projectionFactor(t);return e < 0 ? e = 0 : (e > 1 || i.isNaN(e)) && (e = 1), e;
	    }, toString: function toString() {
	      return "LINESTRING( " + this.p0.x + " " + this.p0.y + ", " + this.p1.x + " " + this.p1.y + ")";
	    }, isHorizontal: function isHorizontal() {
	      return this.p0.y === this.p1.y;
	    }, distance: function distance() {
	      if (arguments[0] instanceof ae) {
	        var t = arguments[0];return oe.distanceLineLine(this.p0, this.p1, t.p0, t.p1);
	      }if (arguments[0] instanceof c) {
	        var e = arguments[0];return oe.distancePointLine(e, this.p0, this.p1);
	      }
	    }, pointAlong: function pointAlong(t) {
	      var e = new c();return e.x = this.p0.x + t * (this.p1.x - this.p0.x), e.y = this.p0.y + t * (this.p1.y - this.p0.y), e;
	    }, hashCode: function hashCode() {
	      var t = java.lang.Double.doubleToLongBits(this.p0.x);t ^= 31 * java.lang.Double.doubleToLongBits(this.p0.y);var e = Math.trunc(t) ^ Math.trunc(t >> 32),
	          n = java.lang.Double.doubleToLongBits(this.p1.x);return n ^= 31 * java.lang.Double.doubleToLongBits(this.p1.y), e ^ Math.trunc(n) ^ Math.trunc(n >> 32);
	    }, interfaces_: function interfaces_() {
	      return [r, a];
	    }, getClass: function getClass() {
	      return ae;
	    } }), ae.midPoint = function (t, e) {
	    return new c((t.x + e.x) / 2, (t.y + e.y) / 2);
	  }, ae.serialVersionUID = 0x2d2172135f411c00;var Xr = Object.freeze({ Coordinate: c, CoordinateList: E, Envelope: x, LineSegment: ae, GeometryFactory: $t, Geometry: F, Point: Ct, LineString: xt, LinearRing: wt, Polygon: Lt, GeometryCollection: lt, MultiPoint: Rt, MultiLineString: ht, MultiPolygon: Tt });Or(ue.prototype, { hasChildren: function hasChildren() {
	      for (var t = 0; t < 4; t++) {
	        if (null !== this.subnode[t]) return !0;
	      }return !1;
	    }, isPrunable: function isPrunable() {
	      return !(this.hasChildren() || this.hasItems());
	    }, addAllItems: function addAllItems(t) {
	      t.addAll(this.items);for (var e = 0; e < 4; e++) {
	        null !== this.subnode[e] && this.subnode[e].addAllItems(t);
	      }return t;
	    }, getNodeCount: function getNodeCount() {
	      for (var t = 0, e = 0; e < 4; e++) {
	        null !== this.subnode[e] && (t += this.subnode[e].size());
	      }return t + 1;
	    }, size: function size() {
	      for (var t = 0, e = 0; e < 4; e++) {
	        null !== this.subnode[e] && (t += this.subnode[e].size());
	      }return t + this.items.size();
	    }, addAllItemsFromOverlapping: function addAllItemsFromOverlapping(t, e) {
	      if (!this.isSearchMatch(t)) return null;e.addAll(this.items);for (var n = 0; n < 4; n++) {
	        null !== this.subnode[n] && this.subnode[n].addAllItemsFromOverlapping(t, e);
	      }
	    }, visitItems: function visitItems(t, e) {
	      for (var n = this.items.iterator(); n.hasNext();) {
	        e.visitItem(n.next());
	      }
	    }, hasItems: function hasItems() {
	      return !this.items.isEmpty();
	    }, remove: function remove(t, e) {
	      if (!this.isSearchMatch(t)) return !1;for (var n = !1, i = 0; i < 4; i++) {
	        if (null !== this.subnode[i] && (n = this.subnode[i].remove(t, e))) {
	          this.subnode[i].isPrunable() && (this.subnode[i] = null);break;
	        }
	      }return n || (n = this.items.remove(e));
	    }, visit: function visit(t, e) {
	      if (!this.isSearchMatch(t)) return null;this.visitItems(t, e);for (var n = 0; n < 4; n++) {
	        null !== this.subnode[n] && this.subnode[n].visit(t, e);
	      }
	    }, getItems: function getItems() {
	      return this.items;
	    }, depth: function depth() {
	      for (var t = 0, e = 0; e < 4; e++) {
	        if (null !== this.subnode[e]) {
	          var n = this.subnode[e].depth();n > t && (t = n);
	        }
	      }return t + 1;
	    }, isEmpty: function isEmpty() {
	      var t = !0;this.items.isEmpty() || (t = !1);for (var e = 0; e < 4; e++) {
	        null !== this.subnode[e] && (this.subnode[e].isEmpty() || (t = !1));
	      }return t;
	    }, add: function add(t) {
	      this.items.add(t);
	    }, interfaces_: function interfaces_() {
	      return [a];
	    }, getClass: function getClass() {
	      return ue;
	    } }), ue.getSubnodeIndex = function (t, e, n) {
	    var i = -1;return t.getMinX() >= e && (t.getMinY() >= n && (i = 3), t.getMaxY() <= n && (i = 1)), t.getMaxX() <= e && (t.getMinY() >= n && (i = 2), t.getMaxY() <= n && (i = 0)), i;
	  }, le.exponent = function (t) {
	    return he(64, t) - 1023;
	  }, le.powerOf2 = function (t) {
	    return Math.pow(2, t);
	  }, Or(ce.prototype, { getLevel: function getLevel() {
	      return this.level;
	    }, computeKey: function computeKey() {
	      if (1 === arguments.length) {
	        var t = arguments[0];for (this.level = ce.computeQuadLevel(t), this.env = new x(), this.computeKey(this.level, t); !this.env.contains(t);) {
	          this.level += 1, this.computeKey(this.level, t);
	        }
	      } else if (2 === arguments.length) {
	        var e = arguments[0],
	            n = arguments[1],
	            i = le.powerOf2(e);this.pt.x = Math.floor(n.getMinX() / i) * i, this.pt.y = Math.floor(n.getMinY() / i) * i, this.env.init(this.pt.x, this.pt.x + i, this.pt.y, this.pt.y + i);
	      }
	    }, getEnvelope: function getEnvelope() {
	      return this.env;
	    }, getCentre: function getCentre() {
	      return new c((this.env.getMinX() + this.env.getMaxX()) / 2, (this.env.getMinY() + this.env.getMaxY()) / 2);
	    }, getPoint: function getPoint() {
	      return this.pt;
	    }, interfaces_: function interfaces_() {
	      return [];
	    }, getClass: function getClass() {
	      return ce;
	    } }), ce.computeQuadLevel = function (t) {
	    var e = t.getWidth(),
	        n = t.getHeight(),
	        i = e > n ? e : n;return le.exponent(i) + 1;
	  }, br(fe, ue), Or(fe.prototype, { find: function find(t) {
	      var e = ue.getSubnodeIndex(t, this.centrex, this.centrey);if (e === -1) return this;if (null !== this.subnode[e]) {
	        return this.subnode[e].find(t);
	      }return this;
	    }, isSearchMatch: function isSearchMatch(t) {
	      return this.env.intersects(t);
	    }, getSubnode: function getSubnode(t) {
	      return null === this.subnode[t] && (this.subnode[t] = this.createSubnode(t)), this.subnode[t];
	    }, getEnvelope: function getEnvelope() {
	      return this.env;
	    }, getNode: function getNode(t) {
	      var e = ue.getSubnodeIndex(t, this.centrex, this.centrey);if (e !== -1) {
	        return this.getSubnode(e).getNode(t);
	      }return this;
	    }, createSubnode: function createSubnode(t) {
	      var e = 0,
	          n = 0,
	          i = 0,
	          r = 0;switch (t) {case 0:
	          e = this.env.getMinX(), n = this.centrex, i = this.env.getMinY(), r = this.centrey;break;case 1:
	          e = this.centrex, n = this.env.getMaxX(), i = this.env.getMinY(), r = this.centrey;break;case 2:
	          e = this.env.getMinX(), n = this.centrex, i = this.centrey, r = this.env.getMaxY();break;case 3:
	          e = this.centrex, n = this.env.getMaxX(), i = this.centrey, r = this.env.getMaxY();}return new fe(new x(e, n, i, r), this.level - 1);
	    }, insertNode: function insertNode(t) {
	      h.isTrue(null === this.env || this.env.contains(t.env));var e = ue.getSubnodeIndex(t.env, this.centrex, this.centrey);if (t.level === this.level - 1) this.subnode[e] = t;else {
	        var n = this.createSubnode(e);n.insertNode(t), this.subnode[e] = n;
	      }
	    }, interfaces_: function interfaces_() {
	      return [];
	    }, getClass: function getClass() {
	      return fe;
	    } }), fe.createNode = function (t) {
	    var e = new ce(t);return new fe(e.getEnvelope(), e.getLevel());
	  }, fe.createExpanded = function (t, e) {
	    var n = new x(e);null !== t && n.expandToInclude(t.env);var i = fe.createNode(n);return null !== t && i.insertNode(t), i;
	  }, Or(ge.prototype, { interfaces_: function interfaces_() {
	      return [];
	    }, getClass: function getClass() {
	      return ge;
	    } }), ge.isZeroWidth = function (t, e) {
	    var n = e - t;if (0 === n) return !0;var i = Math.max(Math.abs(t), Math.abs(e)),
	        r = n / i;return le.exponent(r) <= ge.MIN_BINARY_EXPONENT;
	  }, ge.MIN_BINARY_EXPONENT = -50, br(de, ue), Or(de.prototype, { insert: function insert(t, e) {
	      var n = ue.getSubnodeIndex(t, de.origin.x, de.origin.y);if (n === -1) return this.add(e), null;var i = this.subnode[n];if (null === i || !i.getEnvelope().contains(t)) {
	        var r = fe.createExpanded(i, t);this.subnode[n] = r;
	      }this.insertContained(this.subnode[n], t, e);
	    }, isSearchMatch: function isSearchMatch(t) {
	      return !0;
	    }, insertContained: function insertContained(t, e, n) {
	      h.isTrue(t.getEnvelope().contains(e));var i = ge.isZeroWidth(e.getMinX(), e.getMaxX()),
	          r = ge.isZeroWidth(e.getMinY(), e.getMaxY()),
	          s = null;s = i || r ? t.find(e) : t.getNode(e), s.add(n);
	    }, interfaces_: function interfaces_() {
	      return [];
	    }, getClass: function getClass() {
	      return de;
	    } }), de.origin = new c(0, 0), Or(pe.prototype, { insert: function insert(t, e) {}, remove: function remove(t, e) {}, query: function query() {
	      if (1 === arguments.length) {
	        arguments[0];
	      } else if (2 === arguments.length) {
	        arguments[0], arguments[1];
	      }
	    }, interfaces_: function interfaces_() {
	      return [];
	    }, getClass: function getClass() {
	      return pe;
	    } }), Or(me.prototype, { visitItem: function visitItem(t) {}, interfaces_: function interfaces_() {
	      return [];
	    }, getClass: function getClass() {
	      return me;
	    } }), Or(ve.prototype, { visitItem: function visitItem(t) {
	      this.items.add(t);
	    }, getItems: function getItems() {
	      return this.items;
	    }, interfaces_: function interfaces_() {
	      return [me];
	    }, getClass: function getClass() {
	      return ve;
	    } }), Or(ye.prototype, { size: function size() {
	      return null !== this.root ? this.root.size() : 0;
	    }, insert: function insert(t, e) {
	      this.collectStats(t);var n = ye.ensureExtent(t, this.minExtent);this.root.insert(n, e);
	    }, query: function query() {
	      if (1 === arguments.length) {
	        var t = arguments[0],
	            e = new ve();return this.query(t, e), e.getItems();
	      }if (2 === arguments.length) {
	        var n = arguments[0],
	            i = arguments[1];this.root.visit(n, i);
	      }
	    }, queryAll: function queryAll() {
	      var t = new I();return this.root.addAllItems(t), t;
	    }, remove: function remove(t, e) {
	      var n = ye.ensureExtent(t, this.minExtent);return this.root.remove(n, e);
	    }, collectStats: function collectStats(t) {
	      var e = t.getWidth();e < this.minExtent && e > 0 && (this.minExtent = e);var n = t.getHeight();n < this.minExtent && n > 0 && (this.minExtent = n);
	    }, depth: function depth() {
	      return null !== this.root ? this.root.depth() : 0;
	    }, isEmpty: function isEmpty() {
	      return null === this.root;
	    }, interfaces_: function interfaces_() {
	      return [pe, a];
	    }, getClass: function getClass() {
	      return ye;
	    } }), ye.ensureExtent = function (t, e) {
	    var n = t.getMinX(),
	        i = t.getMaxX(),
	        r = t.getMinY(),
	        s = t.getMaxY();return n !== i && r !== s ? t : (n === i && (n -= e / 2, i = n + e / 2), r === s && (r -= e / 2, s = r + e / 2), new x(n, i, r, s));
	  }, ye.serialVersionUID = -0x678b60c967a25400;var kr = Object.freeze({ Quadtree: ye }),
	      Vr = Object.freeze({ quadtree: kr }),
	      Hr = ["Point", "MultiPoint", "LineString", "MultiLineString", "Polygon", "MultiPolygon"];Or(Ie.prototype, { read: function read(t) {
	      var e = void 0;e = "string" == typeof t ? JSON.parse(t) : t;var n = e.type;if (!Wr[n]) throw new Error("Unknown GeoJSON type: " + e.type);return Hr.indexOf(n) !== -1 ? Wr[n].apply(this, [e.coordinates]) : "GeometryCollection" === n ? Wr[n].apply(this, [e.geometries]) : Wr[n].apply(this, [e]);
	    }, write: function write(t) {
	      var e = t.getGeometryType();if (!jr[e]) throw new Error("Geometry is not supported");return jr[e].apply(this, [t]);
	    } });var Wr = { Feature: function Feature(t) {
	      var e = {};for (var n in t) {
	        e[n] = t[n];
	      }if (t.geometry) {
	        var i = t.geometry.type;if (!Wr[i]) throw new Error("Unknown GeoJSON type: " + t.type);e.geometry = this.read(t.geometry);
	      }return t.bbox && (e.bbox = Wr.bbox.apply(this, [t.bbox])), e;
	    }, FeatureCollection: function FeatureCollection(t) {
	      var e = {};if (t.features) {
	        e.features = [];for (var n = 0; n < t.features.length; ++n) {
	          e.features.push(this.read(t.features[n]));
	        }
	      }return t.bbox && (e.bbox = this.parse.bbox.apply(this, [t.bbox])), e;
	    }, coordinates: function coordinates(t) {
	      for (var e = [], n = 0; n < t.length; ++n) {
	        var i = t[n];e.push(new c(i[0], i[1]));
	      }return e;
	    }, bbox: function bbox(t) {
	      return this.geometryFactory.createLinearRing([new c(t[0], t[1]), new c(t[2], t[1]), new c(t[2], t[3]), new c(t[0], t[3]), new c(t[0], t[1])]);
	    }, Point: function Point(t) {
	      var e = new c(t[0], t[1]);return this.geometryFactory.createPoint(e);
	    }, MultiPoint: function MultiPoint(t) {
	      for (var e = [], n = 0; n < t.length; ++n) {
	        e.push(Wr.Point.apply(this, [t[n]]));
	      }return this.geometryFactory.createMultiPoint(e);
	    }, LineString: function LineString(t) {
	      var e = Wr.coordinates.apply(this, [t]);return this.geometryFactory.createLineString(e);
	    }, MultiLineString: function MultiLineString(t) {
	      for (var e = [], n = 0; n < t.length; ++n) {
	        e.push(Wr.LineString.apply(this, [t[n]]));
	      }return this.geometryFactory.createMultiLineString(e);
	    }, Polygon: function Polygon(t) {
	      for (var e = Wr.coordinates.apply(this, [t[0]]), n = this.geometryFactory.createLinearRing(e), i = [], r = 1; r < t.length; ++r) {
	        var s = t[r],
	            o = Wr.coordinates.apply(this, [s]),
	            a = this.geometryFactory.createLinearRing(o);i.push(a);
	      }return this.geometryFactory.createPolygon(n, i);
	    }, MultiPolygon: function MultiPolygon(t) {
	      for (var e = [], n = 0; n < t.length; ++n) {
	        var i = t[n];e.push(Wr.Polygon.apply(this, [i]));
	      }return this.geometryFactory.createMultiPolygon(e);
	    }, GeometryCollection: function GeometryCollection(t) {
	      for (var e = [], n = 0; n < t.length; ++n) {
	        var i = t[n];e.push(this.read(i));
	      }return this.geometryFactory.createGeometryCollection(e);
	    } },
	      jr = { coordinate: function coordinate(t) {
	      return [t.x, t.y];
	    }, Point: function Point(t) {
	      return { type: "Point", coordinates: jr.coordinate.apply(this, [t.getCoordinate()]) };
	    }, MultiPoint: function MultiPoint(t) {
	      for (var e = [], n = 0; n < t.geometries.length; ++n) {
	        var i = t.geometries[n],
	            r = jr.Point.apply(this, [i]);e.push(r.coordinates);
	      }return { type: "MultiPoint", coordinates: e };
	    }, LineString: function LineString(t) {
	      for (var e = [], n = t.getCoordinates(), i = 0; i < n.length; ++i) {
	        var r = n[i];e.push(jr.coordinate.apply(this, [r]));
	      }return { type: "LineString", coordinates: e };
	    }, MultiLineString: function MultiLineString(t) {
	      for (var e = [], n = 0; n < t.geometries.length; ++n) {
	        var i = t.geometries[n],
	            r = jr.LineString.apply(this, [i]);e.push(r.coordinates);
	      }return { type: "MultiLineString", coordinates: e };
	    }, Polygon: function Polygon(t) {
	      var e = [],
	          n = jr.LineString.apply(this, [t.shell]);e.push(n.coordinates);for (var i = 0; i < t.holes.length; ++i) {
	        var r = t.holes[i],
	            s = jr.LineString.apply(this, [r]);e.push(s.coordinates);
	      }return { type: "Polygon", coordinates: e };
	    }, MultiPolygon: function MultiPolygon(t) {
	      for (var e = [], n = 0; n < t.geometries.length; ++n) {
	        var i = t.geometries[n],
	            r = jr.Polygon.apply(this, [i]);e.push(r.coordinates);
	      }return { type: "MultiPolygon", coordinates: e };
	    }, GeometryCollection: function GeometryCollection(t) {
	      for (var e = [], n = 0; n < t.geometries.length; ++n) {
	        var i = t.geometries[n],
	            r = i.getGeometryType();e.push(jr[r].apply(this, [i]));
	      }return { type: "GeometryCollection", geometries: e };
	    } };Or(Ee.prototype, { read: function read(t) {
	      var e = this.parser.read(t);return this.precisionModel.getType() === Qt.FIXED && this.reducePrecision(e), e;
	    }, reducePrecision: function reducePrecision(t) {
	      var e, n;if (t.coordinate) this.precisionModel.makePrecise(t.coordinate);else if (t.points) for (e = 0, n = t.points.length; e < n; e++) {
	        this.precisionModel.makePrecise(t.points[e]);
	      } else if (t.geometries) for (e = 0, n = t.geometries.length; e < n; e++) {
	        this.reducePrecision(t.geometries[e]);
	      }
	    } }), Or(xe.prototype, { write: function write(t) {
	      return this.parser.write(t);
	    } });var Kr = Object.freeze({ GeoJSONReader: Ee, GeoJSONWriter: xe });Or(Ne.prototype, { next: function next() {
	      if (this.atStart) return this.atStart = !1, Ne.isAtomic(this.parent) && this.index++, this.parent;if (null !== this.subcollectionIterator) {
	        if (this.subcollectionIterator.hasNext()) return this.subcollectionIterator.next();this.subcollectionIterator = null;
	      }if (this.index >= this.max) throw new v();var t = this.parent.getGeometryN(this.index++);return t instanceof lt ? (this.subcollectionIterator = new Ne(t), this.subcollectionIterator.next()) : t;
	    }, remove: function remove() {
	      throw new UnsupportedOperationException(this.getClass().getName());
	    }, hasNext: function hasNext() {
	      if (this.atStart) return !0;if (null !== this.subcollectionIterator) {
	        if (this.subcollectionIterator.hasNext()) return !0;this.subcollectionIterator = null;
	      }return !(this.index >= this.max);
	    }, interfaces_: function interfaces_() {
	      return [g];
	    }, getClass: function getClass() {
	      return Ne;
	    } }), Ne.isAtomic = function (t) {
	    return !(t instanceof lt);
	  }, Or(Ce.prototype, { locateInternal: function locateInternal() {
	      if (arguments[0] instanceof c && arguments[1] instanceof Lt) {
	        var t = arguments[0],
	            e = arguments[1];if (e.isEmpty()) return S.EXTERIOR;var n = e.getExteriorRing(),
	            i = this.locateInPolygonRing(t, n);if (i === S.EXTERIOR) return S.EXTERIOR;if (i === S.BOUNDARY) return S.BOUNDARY;for (var r = 0; r < e.getNumInteriorRing(); r++) {
	          var s = e.getInteriorRingN(r),
	              o = this.locateInPolygonRing(t, s);if (o === S.INTERIOR) return S.EXTERIOR;if (o === S.BOUNDARY) return S.BOUNDARY;
	        }return S.INTERIOR;
	      }if (arguments[0] instanceof c && arguments[1] instanceof xt) {
	        var a = arguments[0],
	            u = arguments[1];if (!u.getEnvelopeInternal().intersects(a)) return S.EXTERIOR;var l = u.getCoordinates();return u.isClosed() || !a.equals(l[0]) && !a.equals(l[l.length - 1]) ? oe.isOnLine(a, l) ? S.INTERIOR : S.EXTERIOR : S.BOUNDARY;
	      }if (arguments[0] instanceof c && arguments[1] instanceof Ct) {
	        var h = arguments[0];return arguments[1].getCoordinate().equals2D(h) ? S.INTERIOR : S.EXTERIOR;
	      }
	    }, locateInPolygonRing: function locateInPolygonRing(t, e) {
	      return e.getEnvelopeInternal().intersects(t) ? oe.locatePointInRing(t, e.getCoordinates()) : S.EXTERIOR;
	    }, intersects: function intersects(t, e) {
	      return this.locate(t, e) !== S.EXTERIOR;
	    }, updateLocationInfo: function updateLocationInfo(t) {
	      t === S.INTERIOR && (this.isIn = !0), t === S.BOUNDARY && this.numBoundaries++;
	    }, computeLocation: function computeLocation(t, e) {
	      if (e instanceof Ct && this.updateLocationInfo(this.locateInternal(t, e)), e instanceof xt) this.updateLocationInfo(this.locateInternal(t, e));else if (e instanceof Lt) this.updateLocationInfo(this.locateInternal(t, e));else if (e instanceof ht) for (var n = e, i = 0; i < n.getNumGeometries(); i++) {
	        var r = n.getGeometryN(i);this.updateLocationInfo(this.locateInternal(t, r));
	      } else if (e instanceof Tt) for (var s = e, i = 0; i < s.getNumGeometries(); i++) {
	        var o = s.getGeometryN(i);this.updateLocationInfo(this.locateInternal(t, o));
	      } else if (e instanceof lt) for (var a = new Ne(e); a.hasNext();) {
	        var u = a.next();u !== e && this.computeLocation(t, u);
	      }
	    }, locate: function locate(t, e) {
	      return e.isEmpty() ? S.EXTERIOR : e instanceof xt ? this.locateInternal(t, e) : e instanceof Lt ? this.locateInternal(t, e) : (this.isIn = !1, this.numBoundaries = 0, this.computeLocation(t, e), this.boundaryRule.isInBoundary(this.numBoundaries) ? S.BOUNDARY : this.numBoundaries > 0 || this.isIn ? S.INTERIOR : S.EXTERIOR);
	    }, interfaces_: function interfaces_() {
	      return [];
	    }, getClass: function getClass() {
	      return Ce;
	    } }), Or(Se.prototype, { filter: function filter(t) {
	      t instanceof Lt && this.comps.add(t);
	    }, interfaces_: function interfaces_() {
	      return [at];
	    }, getClass: function getClass() {
	      return Se;
	    } }), Se.getPolygons = function () {
	    if (1 === arguments.length) {
	      var t = arguments[0];return Se.getPolygons(t, new I());
	    }if (2 === arguments.length) {
	      var e = arguments[0],
	          n = arguments[1];return e instanceof Lt ? n.add(e) : e instanceof lt && e.apply(new Se(n)), n;
	    }
	  }, Or(Le.prototype, { isInsideArea: function isInsideArea() {
	      return this.segIndex === Le.INSIDE_AREA;
	    }, getCoordinate: function getCoordinate() {
	      return this.pt;
	    }, getGeometryComponent: function getGeometryComponent() {
	      return this.component;
	    }, getSegmentIndex: function getSegmentIndex() {
	      return this.segIndex;
	    }, interfaces_: function interfaces_() {
	      return [];
	    }, getClass: function getClass() {
	      return Le;
	    } }), Le.INSIDE_AREA = -1;var Jr = { reverseOrder: function reverseOrder() {
	      return { compare: function compare(t, e) {
	          return e.compareTo(t);
	        } };
	    }, min: function min(t) {
	      return Jr.sort(t), t.get(0);
	    }, sort: function sort(t, e) {
	      var n = t.toArray();e ? st.sort(n, e) : st.sort(n);for (var i = t.iterator(), r = 0, s = n.length; r < s; r++) {
	        i.next(), i.set(n[r]);
	      }
	    }, singletonList: function singletonList(t) {
	      var e = new I();return e.add(t), e;
	    } };Or(Re.prototype, { filter: function filter(t) {
	      t instanceof Ct && this.pts.add(t);
	    }, interfaces_: function interfaces_() {
	      return [at];
	    }, getClass: function getClass() {
	      return Re;
	    } }), Re.getPoints = function () {
	    if (1 === arguments.length) {
	      var t = arguments[0];return t instanceof Ct ? Jr.singletonList(t) : Re.getPoints(t, new I());
	    }if (2 === arguments.length) {
	      var e = arguments[0],
	          n = arguments[1];return e instanceof Ct ? n.add(e) : e instanceof lt && e.apply(new Re(n)), n;
	    }
	  }, Or(we.prototype, { filter: function filter(t) {
	      (t instanceof Ct || t instanceof xt || t instanceof Lt) && this.locations.add(new Le(t, 0, t.getCoordinate()));
	    }, interfaces_: function interfaces_() {
	      return [at];
	    }, getClass: function getClass() {
	      return we;
	    } }), we.getLocations = function (t) {
	    var e = new I();return t.apply(new we(e)), e;
	  }, Or(Te.prototype, { filter: function filter(t) {
	      if (this.isForcedToLineString && t instanceof wt) {
	        var e = t.getFactory().createLineString(t.getCoordinateSequence());return this.lines.add(e), null;
	      }t instanceof xt && this.lines.add(t);
	    }, setForceToLineString: function setForceToLineString(t) {
	      this.isForcedToLineString = t;
	    }, interfaces_: function interfaces_() {
	      return [D];
	    }, getClass: function getClass() {
	      return Te;
	    } }), Te.getGeometry = function () {
	    if (1 === arguments.length) {
	      var t = arguments[0];return t.getFactory().buildGeometry(Te.getLines(t));
	    }if (2 === arguments.length) {
	      var e = arguments[0],
	          n = arguments[1];return e.getFactory().buildGeometry(Te.getLines(e, n));
	    }
	  }, Te.getLines = function () {
	    if (1 === arguments.length) {
	      var t = arguments[0];return Te.getLines(t, !1);
	    }if (2 === arguments.length) {
	      if (_r(arguments[0], d) && _r(arguments[1], d)) {
	        for (var e = arguments[0], n = arguments[1], i = e.iterator(); i.hasNext();) {
	          var r = i.next();Te.getLines(r, n);
	        }return n;
	      }if (arguments[0] instanceof F && "boolean" == typeof arguments[1]) {
	        var s = arguments[0],
	            o = arguments[1],
	            a = new I();return s.apply(new Te(a, o)), a;
	      }if (arguments[0] instanceof F && _r(arguments[1], d)) {
	        var u = arguments[0],
	            l = arguments[1];return u instanceof xt ? l.add(u) : u.apply(new Te(l)), l;
	      }
	    } else if (3 === arguments.length) {
	      if ("boolean" == typeof arguments[2] && _r(arguments[0], d) && _r(arguments[1], d)) {
	        for (var h = arguments[0], c = arguments[1], f = arguments[2], i = h.iterator(); i.hasNext();) {
	          var r = i.next();Te.getLines(r, c, f);
	        }return c;
	      }if ("boolean" == typeof arguments[2] && arguments[0] instanceof F && _r(arguments[1], d)) {
	        var g = arguments[0],
	            p = arguments[1],
	            m = arguments[2];return g.apply(new Te(p, m)), p;
	      }
	    }
	  }, Or(Oe.prototype, { computeContainmentDistance: function computeContainmentDistance() {
	      if (0 === arguments.length) {
	        var t = new Array(2).fill(null);if (this.computeContainmentDistance(0, t), this.minDistance <= this.terminateDistance) return null;this.computeContainmentDistance(1, t);
	      } else if (2 === arguments.length) {
	        var e = arguments[0],
	            n = arguments[1],
	            i = 1 - e,
	            r = Se.getPolygons(this.geom[e]);if (r.size() > 0) {
	          var s = we.getLocations(this.geom[i]);if (this.computeContainmentDistance(s, r, n), this.minDistance <= this.terminateDistance) return this.minDistanceLocation[i] = n[0], this.minDistanceLocation[e] = n[1], null;
	        }
	      } else if (3 === arguments.length) if (arguments[2] instanceof Array && _r(arguments[0], m) && _r(arguments[1], m)) {
	        for (var o = arguments[0], a = arguments[1], u = arguments[2], l = 0; l < o.size(); l++) {
	          for (var h = o.get(l), c = 0; c < a.size(); c++) {
	            if (this.computeContainmentDistance(h, a.get(c), u), this.minDistance <= this.terminateDistance) return null;
	          }
	        }
	      } else if (arguments[2] instanceof Array && arguments[0] instanceof Le && arguments[1] instanceof Lt) {
	        var f = arguments[0],
	            g = arguments[1],
	            d = arguments[2],
	            p = f.getCoordinate();if (S.EXTERIOR !== this.ptLocator.locate(p, g)) return this.minDistance = 0, d[0] = f, d[1] = new Le(g, p), null;
	      }
	    }, computeMinDistanceLinesPoints: function computeMinDistanceLinesPoints(t, e, n) {
	      for (var i = 0; i < t.size(); i++) {
	        for (var r = t.get(i), s = 0; s < e.size(); s++) {
	          var o = e.get(s);if (this.computeMinDistance(r, o, n), this.minDistance <= this.terminateDistance) return null;
	        }
	      }
	    }, computeFacetDistance: function computeFacetDistance() {
	      var t = new Array(2).fill(null),
	          e = Te.getLines(this.geom[0]),
	          n = Te.getLines(this.geom[1]),
	          i = Re.getPoints(this.geom[0]),
	          r = Re.getPoints(this.geom[1]);return this.computeMinDistanceLines(e, n, t), this.updateMinDistance(t, !1), this.minDistance <= this.terminateDistance ? null : (t[0] = null, t[1] = null, this.computeMinDistanceLinesPoints(e, r, t), this.updateMinDistance(t, !1), this.minDistance <= this.terminateDistance ? null : (t[0] = null, t[1] = null, this.computeMinDistanceLinesPoints(n, i, t), this.updateMinDistance(t, !0), this.minDistance <= this.terminateDistance ? null : (t[0] = null, t[1] = null, this.computeMinDistancePoints(i, r, t), void this.updateMinDistance(t, !1))));
	    }, nearestLocations: function nearestLocations() {
	      return this.computeMinDistance(), this.minDistanceLocation;
	    }, updateMinDistance: function updateMinDistance(t, e) {
	      if (null === t[0]) return null;e ? (this.minDistanceLocation[0] = t[1], this.minDistanceLocation[1] = t[0]) : (this.minDistanceLocation[0] = t[0], this.minDistanceLocation[1] = t[1]);
	    }, nearestPoints: function nearestPoints() {
	      return this.computeMinDistance(), [this.minDistanceLocation[0].getCoordinate(), this.minDistanceLocation[1].getCoordinate()];
	    }, computeMinDistance: function computeMinDistance() {
	      if (0 === arguments.length) {
	        if (null !== this.minDistanceLocation) return null;if (this.minDistanceLocation = new Array(2).fill(null), this.computeContainmentDistance(), this.minDistance <= this.terminateDistance) return null;this.computeFacetDistance();
	      } else if (3 === arguments.length) if (arguments[2] instanceof Array && arguments[0] instanceof xt && arguments[1] instanceof Ct) {
	        var t = arguments[0],
	            e = arguments[1],
	            n = arguments[2];if (t.getEnvelopeInternal().distance(e.getEnvelopeInternal()) > this.minDistance) return null;for (var i = t.getCoordinates(), r = e.getCoordinate(), s = 0; s < i.length - 1; s++) {
	          var o = oe.distancePointLine(r, i[s], i[s + 1]);if (o < this.minDistance) {
	            this.minDistance = o;var a = new ae(i[s], i[s + 1]),
	                u = a.closestPoint(r);n[0] = new Le(t, s, u), n[1] = new Le(e, 0, r);
	          }if (this.minDistance <= this.terminateDistance) return null;
	        }
	      } else if (arguments[2] instanceof Array && arguments[0] instanceof xt && arguments[1] instanceof xt) {
	        var l = arguments[0],
	            h = arguments[1],
	            c = arguments[2];if (l.getEnvelopeInternal().distance(h.getEnvelopeInternal()) > this.minDistance) return null;for (var i = l.getCoordinates(), f = h.getCoordinates(), s = 0; s < i.length - 1; s++) {
	          for (var g = 0; g < f.length - 1; g++) {
	            var o = oe.distanceLineLine(i[s], i[s + 1], f[g], f[g + 1]);if (o < this.minDistance) {
	              this.minDistance = o;var d = new ae(i[s], i[s + 1]),
	                  p = new ae(f[g], f[g + 1]),
	                  m = d.closestPoints(p);c[0] = new Le(l, s, m[0]), c[1] = new Le(h, g, m[1]);
	            }if (this.minDistance <= this.terminateDistance) return null;
	          }
	        }
	      }
	    }, computeMinDistancePoints: function computeMinDistancePoints(t, e, n) {
	      for (var i = 0; i < t.size(); i++) {
	        for (var r = t.get(i), s = 0; s < e.size(); s++) {
	          var o = e.get(s),
	              a = r.getCoordinate().distance(o.getCoordinate());if (a < this.minDistance && (this.minDistance = a, n[0] = new Le(r, 0, r.getCoordinate()), n[1] = new Le(o, 0, o.getCoordinate())), this.minDistance <= this.terminateDistance) return null;
	        }
	      }
	    }, distance: function distance() {
	      if (null === this.geom[0] || null === this.geom[1]) throw new n("null geometries are not supported");return this.geom[0].isEmpty() || this.geom[1].isEmpty() ? 0 : (this.computeMinDistance(), this.minDistance);
	    }, computeMinDistanceLines: function computeMinDistanceLines(t, e, n) {
	      for (var i = 0; i < t.size(); i++) {
	        for (var r = t.get(i), s = 0; s < e.size(); s++) {
	          var o = e.get(s);if (this.computeMinDistance(r, o, n), this.minDistance <= this.terminateDistance) return null;
	        }
	      }
	    }, interfaces_: function interfaces_() {
	      return [];
	    }, getClass: function getClass() {
	      return Oe;
	    } }), Oe.distance = function (t, e) {
	    return new Oe(t, e).distance();
	  }, Oe.isWithinDistance = function (t, e, n) {
	    return new Oe(t, e, n).distance() <= n;
	  }, Oe.nearestPoints = function (t, e) {
	    return new Oe(t, e).nearestPoints();
	  };var Qr = Object.freeze({ DistanceOp: Oe }),
	      Zr = Object.freeze({ distance: Qr });Or(be.prototype, { map: function map(t) {
	      for (var e = new I(), n = 0; n < t.getNumGeometries(); n++) {
	        var i = this.mapOp.map(t.getGeometryN(n));i.isEmpty() || e.add(i);
	      }return t.getFactory().createGeometryCollection($t.toGeometryArray(e));
	    }, interfaces_: function interfaces_() {
	      return [];
	    }, getClass: function getClass() {
	      return be;
	    } }), be.map = function (t, e) {
	    return new be(e).map(t);
	  }, Or(Pe.prototype, { interfaces_: function interfaces_() {
	      return [];
	    }, getClass: function getClass() {
	      return Pe;
	    } }), Pe.opposite = function (t) {
	    return t === Pe.LEFT ? Pe.RIGHT : t === Pe.RIGHT ? Pe.LEFT : t;
	  }, Pe.ON = 0, Pe.LEFT = 1, Pe.RIGHT = 2, br(_e, u), Or(_e.prototype, { getCoordinate: function getCoordinate() {
	      return this.pt;
	    }, interfaces_: function interfaces_() {
	      return [];
	    }, getClass: function getClass() {
	      return _e;
	    } }), _e.msgWithCoord = function (t, e) {
	    return null !== e ? t + " [ " + e + " ]" : t;
	  }, Or(Me.prototype, { setAllLocations: function setAllLocations(t) {
	      for (var e = 0; e < this.location.length; e++) {
	        this.location[e] = t;
	      }
	    }, isNull: function isNull() {
	      for (var t = 0; t < this.location.length; t++) {
	        if (this.location[t] !== S.NONE) return !1;
	      }return !0;
	    }, setAllLocationsIfNull: function setAllLocationsIfNull(t) {
	      for (var e = 0; e < this.location.length; e++) {
	        this.location[e] === S.NONE && (this.location[e] = t);
	      }
	    }, isLine: function isLine() {
	      return 1 === this.location.length;
	    }, merge: function merge(t) {
	      if (t.location.length > this.location.length) {
	        var e = new Array(3).fill(null);e[Pe.ON] = this.location[Pe.ON], e[Pe.LEFT] = S.NONE, e[Pe.RIGHT] = S.NONE, this.location = e;
	      }for (var n = 0; n < this.location.length; n++) {
	        this.location[n] === S.NONE && n < t.location.length && (this.location[n] = t.location[n]);
	      }
	    }, getLocations: function getLocations() {
	      return this.location;
	    }, flip: function flip() {
	      if (this.location.length <= 1) return null;var t = this.location[Pe.LEFT];this.location[Pe.LEFT] = this.location[Pe.RIGHT], this.location[Pe.RIGHT] = t;
	    }, toString: function toString() {
	      var t = new R();return this.location.length > 1 && t.append(S.toLocationSymbol(this.location[Pe.LEFT])), t.append(S.toLocationSymbol(this.location[Pe.ON])), this.location.length > 1 && t.append(S.toLocationSymbol(this.location[Pe.RIGHT])), t.toString();
	    }, setLocations: function setLocations(t, e, n) {
	      this.location[Pe.ON] = t, this.location[Pe.LEFT] = e, this.location[Pe.RIGHT] = n;
	    }, get: function get(t) {
	      return t < this.location.length ? this.location[t] : S.NONE;
	    }, isArea: function isArea() {
	      return this.location.length > 1;
	    }, isAnyNull: function isAnyNull() {
	      for (var t = 0; t < this.location.length; t++) {
	        if (this.location[t] === S.NONE) return !0;
	      }return !1;
	    }, setLocation: function setLocation() {
	      if (1 === arguments.length) {
	        var t = arguments[0];this.setLocation(Pe.ON, t);
	      } else if (2 === arguments.length) {
	        var e = arguments[0],
	            n = arguments[1];this.location[e] = n;
	      }
	    }, init: function init(t) {
	      this.location = new Array(t).fill(null), this.setAllLocations(S.NONE);
	    }, isEqualOnSide: function isEqualOnSide(t, e) {
	      return this.location[e] === t.location[e];
	    }, allPositionsEqual: function allPositionsEqual(t) {
	      for (var e = 0; e < this.location.length; e++) {
	        if (this.location[e] !== t) return !1;
	      }return !0;
	    }, interfaces_: function interfaces_() {
	      return [];
	    }, getClass: function getClass() {
	      return Me;
	    } }), Or(Ae.prototype, { getGeometryCount: function getGeometryCount() {
	      var t = 0;return this.elt[0].isNull() || t++, this.elt[1].isNull() || t++, t;
	    }, setAllLocations: function setAllLocations(t, e) {
	      this.elt[t].setAllLocations(e);
	    }, isNull: function isNull(t) {
	      return this.elt[t].isNull();
	    }, setAllLocationsIfNull: function setAllLocationsIfNull() {
	      if (1 === arguments.length) {
	        var t = arguments[0];this.setAllLocationsIfNull(0, t), this.setAllLocationsIfNull(1, t);
	      } else if (2 === arguments.length) {
	        var e = arguments[0],
	            n = arguments[1];this.elt[e].setAllLocationsIfNull(n);
	      }
	    }, isLine: function isLine(t) {
	      return this.elt[t].isLine();
	    }, merge: function merge(t) {
	      for (var e = 0; e < 2; e++) {
	        null === this.elt[e] && null !== t.elt[e] ? this.elt[e] = new Me(t.elt[e]) : this.elt[e].merge(t.elt[e]);
	      }
	    }, flip: function flip() {
	      this.elt[0].flip(), this.elt[1].flip();
	    }, getLocation: function getLocation() {
	      if (1 === arguments.length) {
	        var t = arguments[0];return this.elt[t].get(Pe.ON);
	      }if (2 === arguments.length) {
	        var e = arguments[0],
	            n = arguments[1];return this.elt[e].get(n);
	      }
	    }, toString: function toString() {
	      var t = new R();return null !== this.elt[0] && (t.append("A:"), t.append(this.elt[0].toString())), null !== this.elt[1] && (t.append(" B:"), t.append(this.elt[1].toString())), t.toString();
	    }, isArea: function isArea() {
	      if (0 === arguments.length) return this.elt[0].isArea() || this.elt[1].isArea();if (1 === arguments.length) {
	        var t = arguments[0];return this.elt[t].isArea();
	      }
	    }, isAnyNull: function isAnyNull(t) {
	      return this.elt[t].isAnyNull();
	    }, setLocation: function setLocation() {
	      if (2 === arguments.length) {
	        var t = arguments[0],
	            e = arguments[1];this.elt[t].setLocation(Pe.ON, e);
	      } else if (3 === arguments.length) {
	        var n = arguments[0],
	            i = arguments[1],
	            r = arguments[2];this.elt[n].setLocation(i, r);
	      }
	    }, isEqualOnSide: function isEqualOnSide(t, e) {
	      return this.elt[0].isEqualOnSide(t.elt[0], e) && this.elt[1].isEqualOnSide(t.elt[1], e);
	    }, allPositionsEqual: function allPositionsEqual(t, e) {
	      return this.elt[t].allPositionsEqual(e);
	    }, toLine: function toLine(t) {
	      this.elt[t].isArea() && (this.elt[t] = new Me(this.elt[t].location[0]));
	    }, interfaces_: function interfaces_() {
	      return [];
	    }, getClass: function getClass() {
	      return Ae;
	    } }), Ae.toLineLabel = function (t) {
	    for (var e = new Ae(S.NONE), n = 0; n < 2; n++) {
	      e.setLocation(n, t.getLocation(n));
	    }return e;
	  }, Or(De.prototype, { computeRing: function computeRing() {
	      if (null !== this.ring) return null;for (var t = new Array(this.pts.size()).fill(null), e = 0; e < this.pts.size(); e++) {
	        t[e] = this.pts.get(e);
	      }this.ring = this.geometryFactory.createLinearRing(t), this._isHole = oe.isCCW(this.ring.getCoordinates());
	    }, isIsolated: function isIsolated() {
	      return 1 === this.label.getGeometryCount();
	    }, computePoints: function computePoints(t) {
	      this.startDe = t;var e = t,
	          n = !0;do {
	        if (null === e) throw new _e("Found null DirectedEdge");if (e.getEdgeRing() === this) throw new _e("Directed Edge visited twice during ring-building at " + e.getCoordinate());this.edges.add(e);var i = e.getLabel();h.isTrue(i.isArea()), this.mergeLabel(i), this.addPoints(e.getEdge(), e.isForward(), n), n = !1, this.setEdgeRing(e, this), e = this.getNext(e);
	      } while (e !== this.startDe);
	    }, getLinearRing: function getLinearRing() {
	      return this.ring;
	    }, getCoordinate: function getCoordinate(t) {
	      return this.pts.get(t);
	    }, computeMaxNodeDegree: function computeMaxNodeDegree() {
	      this.maxNodeDegree = 0;var t = this.startDe;do {
	        var e = t.getNode(),
	            n = e.getEdges().getOutgoingDegree(this);n > this.maxNodeDegree && (this.maxNodeDegree = n), t = this.getNext(t);
	      } while (t !== this.startDe);this.maxNodeDegree *= 2;
	    }, addPoints: function addPoints(t, e, n) {
	      var i = t.getCoordinates();if (e) {
	        var r = 1;n && (r = 0);for (var s = r; s < i.length; s++) {
	          this.pts.add(i[s]);
	        }
	      } else {
	        var r = i.length - 2;n && (r = i.length - 1);for (var s = r; s >= 0; s--) {
	          this.pts.add(i[s]);
	        }
	      }
	    }, isHole: function isHole() {
	      return this._isHole;
	    }, setInResult: function setInResult() {
	      var t = this.startDe;do {
	        t.getEdge().setInResult(!0), t = t.getNext();
	      } while (t !== this.startDe);
	    }, containsPoint: function containsPoint(t) {
	      var e = this.getLinearRing();if (!e.getEnvelopeInternal().contains(t)) return !1;if (!oe.isPointInRing(t, e.getCoordinates())) return !1;for (var n = this.holes.iterator(); n.hasNext();) {
	        if (n.next().containsPoint(t)) return !1;
	      }return !0;
	    }, addHole: function addHole(t) {
	      this.holes.add(t);
	    }, isShell: function isShell() {
	      return null === this.shell;
	    }, getLabel: function getLabel() {
	      return this.label;
	    }, getEdges: function getEdges() {
	      return this.edges;
	    }, getMaxNodeDegree: function getMaxNodeDegree() {
	      return this.maxNodeDegree < 0 && this.computeMaxNodeDegree(), this.maxNodeDegree;
	    }, getShell: function getShell() {
	      return this.shell;
	    }, mergeLabel: function mergeLabel() {
	      if (1 === arguments.length) {
	        var t = arguments[0];this.mergeLabel(t, 0), this.mergeLabel(t, 1);
	      } else if (2 === arguments.length) {
	        var e = arguments[0],
	            n = arguments[1],
	            i = e.getLocation(n, Pe.RIGHT);if (i === S.NONE) return null;if (this.label.getLocation(n) === S.NONE) return this.label.setLocation(n, i), null;
	      }
	    }, setShell: function setShell(t) {
	      this.shell = t, null !== t && t.addHole(this);
	    }, toPolygon: function toPolygon(t) {
	      for (var e = new Array(this.holes.size()).fill(null), n = 0; n < this.holes.size(); n++) {
	        e[n] = this.holes.get(n).getLinearRing();
	      }return t.createPolygon(this.getLinearRing(), e);
	    }, interfaces_: function interfaces_() {
	      return [];
	    }, getClass: function getClass() {
	      return De;
	    } }), br(Fe, De), Or(Fe.prototype, { setEdgeRing: function setEdgeRing(t, e) {
	      t.setMinEdgeRing(e);
	    }, getNext: function getNext(t) {
	      return t.getNextMin();
	    }, interfaces_: function interfaces_() {
	      return [];
	    }, getClass: function getClass() {
	      return Fe;
	    } }), br(Ge, De), Or(Ge.prototype, { buildMinimalRings: function buildMinimalRings() {
	      var t = new I(),
	          e = this.startDe;do {
	        if (null === e.getMinEdgeRing()) {
	          var n = new Fe(e, this.geometryFactory);t.add(n);
	        }e = e.getNext();
	      } while (e !== this.startDe);return t;
	    }, setEdgeRing: function setEdgeRing(t, e) {
	      t.setEdgeRing(e);
	    }, linkDirectedEdgesForMinimalEdgeRings: function linkDirectedEdgesForMinimalEdgeRings() {
	      var t = this.startDe;do {
	        t.getNode().getEdges().linkMinimalDirectedEdges(this), t = t.getNext();
	      } while (t !== this.startDe);
	    }, getNext: function getNext(t) {
	      return t.getNext();
	    }, interfaces_: function interfaces_() {
	      return [];
	    }, getClass: function getClass() {
	      return Ge;
	    } }), Or(Be.prototype, { locate: function locate(t) {}, interfaces_: function interfaces_() {
	      return [];
	    }, getClass: function getClass() {
	      return Be;
	    } }), Or(qe.prototype, { locate: function locate(t) {
	      return qe.locate(t, this.geom);
	    }, interfaces_: function interfaces_() {
	      return [Be];
	    }, getClass: function getClass() {
	      return qe;
	    } }), qe.isPointInRing = function (t, e) {
	    return !!e.getEnvelopeInternal().intersects(t) && oe.isPointInRing(t, e.getCoordinates());
	  }, qe.containsPointInPolygon = function (t, e) {
	    if (e.isEmpty()) return !1;var n = e.getExteriorRing();if (!qe.isPointInRing(t, n)) return !1;for (var i = 0; i < e.getNumInteriorRing(); i++) {
	      var r = e.getInteriorRingN(i);if (qe.isPointInRing(t, r)) return !1;
	    }return !0;
	  }, qe.containsPoint = function (t, e) {
	    if (e instanceof Lt) return qe.containsPointInPolygon(t, e);if (e instanceof lt) for (var n = new Ne(e); n.hasNext();) {
	      var i = n.next();if (i !== e && qe.containsPoint(t, i)) return !0;
	    }return !1;
	  }, qe.locate = function (t, e) {
	    return e.isEmpty() ? S.EXTERIOR : qe.containsPoint(t, e) ? S.INTERIOR : S.EXTERIOR;
	  }, Or(ze.prototype, { getNextCW: function getNextCW(t) {
	      this.getEdges();var e = this.edgeList.indexOf(t),
	          n = e - 1;return 0 === e && (n = this.edgeList.size() - 1), this.edgeList.get(n);
	    }, propagateSideLabels: function propagateSideLabels(t) {
	      for (var e = S.NONE, n = this.iterator(); n.hasNext();) {
	        var i = n.next(),
	            r = i.getLabel();r.isArea(t) && r.getLocation(t, Pe.LEFT) !== S.NONE && (e = r.getLocation(t, Pe.LEFT));
	      }if (e === S.NONE) return null;for (var s = e, n = this.iterator(); n.hasNext();) {
	        var i = n.next(),
	            r = i.getLabel();if (r.getLocation(t, Pe.ON) === S.NONE && r.setLocation(t, Pe.ON, s), r.isArea(t)) {
	          var o = r.getLocation(t, Pe.LEFT),
	              a = r.getLocation(t, Pe.RIGHT);if (a !== S.NONE) {
	            if (a !== s) throw new _e("side location conflict", i.getCoordinate());o === S.NONE && h.shouldNeverReachHere("found single null side (at " + i.getCoordinate() + ")"), s = o;
	          } else h.isTrue(r.getLocation(t, Pe.LEFT) === S.NONE, "found single null side"), r.setLocation(t, Pe.RIGHT, s), r.setLocation(t, Pe.LEFT, s);
	        }
	      }
	    }, getCoordinate: function getCoordinate() {
	      var t = this.iterator();return t.hasNext() ? t.next().getCoordinate() : null;
	    }, print: function print(t) {
	      _.out.println("EdgeEndStar:   " + this.getCoordinate());for (var e = this.iterator(); e.hasNext();) {
	        e.next().print(t);
	      }
	    }, isAreaLabelsConsistent: function isAreaLabelsConsistent(t) {
	      return this.computeEdgeEndLabels(t.getBoundaryNodeRule()), this.checkAreaLabelsConsistent(0);
	    }, checkAreaLabelsConsistent: function checkAreaLabelsConsistent(t) {
	      var e = this.getEdges();if (e.size() <= 0) return !0;var n = e.size() - 1,
	          i = e.get(n).getLabel(),
	          r = i.getLocation(t, Pe.LEFT);h.isTrue(r !== S.NONE, "Found unlabelled area edge");for (var s = r, o = this.iterator(); o.hasNext();) {
	        var a = o.next(),
	            u = a.getLabel();h.isTrue(u.isArea(t), "Found non-area edge");var l = u.getLocation(t, Pe.LEFT),
	            c = u.getLocation(t, Pe.RIGHT);if (l === c) return !1;if (c !== s) return !1;s = l;
	      }return !0;
	    }, findIndex: function findIndex(t) {
	      this.iterator();for (var e = 0; e < this.edgeList.size(); e++) {
	        if (this.edgeList.get(e) === t) return e;
	      }return -1;
	    }, iterator: function iterator() {
	      return this.getEdges().iterator();
	    }, getEdges: function getEdges() {
	      return null === this.edgeList && (this.edgeList = new I(this.edgeMap.values())), this.edgeList;
	    }, getLocation: function getLocation(t, e, n) {
	      return this.ptInAreaLocation[t] === S.NONE && (this.ptInAreaLocation[t] = qe.locate(e, n[t].getGeometry())), this.ptInAreaLocation[t];
	    }, toString: function toString() {
	      var t = new R();t.append("EdgeEndStar:   " + this.getCoordinate()), t.append("\n");for (var e = this.iterator(); e.hasNext();) {
	        var n = e.next();t.append(n), t.append("\n");
	      }return t.toString();
	    }, computeEdgeEndLabels: function computeEdgeEndLabels(t) {
	      for (var e = this.iterator(); e.hasNext();) {
	        e.next().computeLabel(t);
	      }
	    }, computeLabelling: function computeLabelling(t) {
	      this.computeEdgeEndLabels(t[0].getBoundaryNodeRule()), this.propagateSideLabels(0), this.propagateSideLabels(1);for (var e = [!1, !1], n = this.iterator(); n.hasNext();) {
	        for (var i = n.next(), r = i.getLabel(), s = 0; s < 2; s++) {
	          r.isLine(s) && r.getLocation(s) === S.BOUNDARY && (e[s] = !0);
	        }
	      }for (var n = this.iterator(); n.hasNext();) {
	        for (var i = n.next(), r = i.getLabel(), s = 0; s < 2; s++) {
	          if (r.isAnyNull(s)) {
	            var o = S.NONE;if (e[s]) o = S.EXTERIOR;else {
	              var a = i.getCoordinate();o = this.getLocation(s, a, t);
	            }r.setAllLocationsIfNull(s, o);
	          }
	        }
	      }
	    }, getDegree: function getDegree() {
	      return this.edgeMap.size();
	    }, insertEdgeEnd: function insertEdgeEnd(t, e) {
	      this.edgeMap.put(t, e), this.edgeList = null;
	    }, interfaces_: function interfaces_() {
	      return [];
	    }, getClass: function getClass() {
	      return ze;
	    } }), Or(Ue.prototype, { interfaces_: function interfaces_() {
	      return [];
	    }, getClass: function getClass() {
	      return Ue;
	    } }), Ue.isNorthern = function (t) {
	    return t === Ue.NE || t === Ue.NW;
	  }, Ue.isOpposite = function (t, e) {
	    return t !== e && 2 == (t - e + 4) % 4;
	  }, Ue.commonHalfPlane = function (t, e) {
	    if (t === e) return t;if (2 == (t - e + 4) % 4) return -1;var n = t < e ? t : e,
	        i = t > e ? t : e;return 0 === n && 3 === i ? 3 : n;
	  }, Ue.isInHalfPlane = function (t, e) {
	    return e === Ue.SE ? t === Ue.SE || t === Ue.SW : t === e || t === e + 1;
	  }, Ue.quadrant = function () {
	    if ("number" == typeof arguments[0] && "number" == typeof arguments[1]) {
	      var t = arguments[0],
	          e = arguments[1];if (0 === t && 0 === e) throw new n("Cannot compute the quadrant for point ( " + t + ", " + e + " )");return t >= 0 ? e >= 0 ? Ue.NE : Ue.SE : e >= 0 ? Ue.NW : Ue.SW;
	    }if (arguments[0] instanceof c && arguments[1] instanceof c) {
	      var i = arguments[0],
	          r = arguments[1];if (r.x === i.x && r.y === i.y) throw new n("Cannot compute the quadrant for two identical points " + i);return r.x >= i.x ? r.y >= i.y ? Ue.NE : Ue.SE : r.y >= i.y ? Ue.NW : Ue.SW;
	    }
	  }, Ue.NE = 0, Ue.NW = 1, Ue.SW = 2, Ue.SE = 3, br(Ye, ze), Or(Ye.prototype, { linkResultDirectedEdges: function linkResultDirectedEdges() {
	      this.getResultAreaEdges();for (var t = null, e = null, n = this.SCANNING_FOR_INCOMING, i = 0; i < this.resultAreaEdgeList.size(); i++) {
	        var r = this.resultAreaEdgeList.get(i),
	            s = r.getSym();if (r.getLabel().isArea()) switch (null === t && r.isInResult() && (t = r), n) {case this.SCANNING_FOR_INCOMING:
	            if (!s.isInResult()) continue;e = s, n = this.LINKING_TO_OUTGOING;break;case this.LINKING_TO_OUTGOING:
	            if (!r.isInResult()) continue;e.setNext(r), n = this.SCANNING_FOR_INCOMING;}
	      }if (n === this.LINKING_TO_OUTGOING) {
	        if (null === t) throw new _e("no outgoing dirEdge found", this.getCoordinate());h.isTrue(t.isInResult(), "unable to link last incoming dirEdge"), e.setNext(t);
	      }
	    }, insert: function insert(t) {
	      var e = t;this.insertEdgeEnd(e, e);
	    }, getRightmostEdge: function getRightmostEdge() {
	      var t = this.getEdges(),
	          e = t.size();if (e < 1) return null;var n = t.get(0);if (1 === e) return n;var i = t.get(e - 1),
	          r = n.getQuadrant(),
	          s = i.getQuadrant();if (Ue.isNorthern(r) && Ue.isNorthern(s)) return n;if (!Ue.isNorthern(r) && !Ue.isNorthern(s)) return i;return 0 !== n.getDy() ? n : 0 !== i.getDy() ? i : (h.shouldNeverReachHere("found two horizontal edges incident on node"), null);
	    }, print: function print(t) {
	      _.out.println("DirectedEdgeStar: " + this.getCoordinate());for (var e = this.iterator(); e.hasNext();) {
	        var n = e.next();t.print("out "), n.print(t), t.println(), t.print("in "), n.getSym().print(t), t.println();
	      }
	    }, getResultAreaEdges: function getResultAreaEdges() {
	      if (null !== this.resultAreaEdgeList) return this.resultAreaEdgeList;this.resultAreaEdgeList = new I();for (var t = this.iterator(); t.hasNext();) {
	        var e = t.next();(e.isInResult() || e.getSym().isInResult()) && this.resultAreaEdgeList.add(e);
	      }return this.resultAreaEdgeList;
	    }, updateLabelling: function updateLabelling(t) {
	      for (var e = this.iterator(); e.hasNext();) {
	        var n = e.next(),
	            i = n.getLabel();i.setAllLocationsIfNull(0, t.getLocation(0)), i.setAllLocationsIfNull(1, t.getLocation(1));
	      }
	    }, linkAllDirectedEdges: function linkAllDirectedEdges() {
	      this.getEdges();for (var t = null, e = null, n = this.edgeList.size() - 1; n >= 0; n--) {
	        var i = this.edgeList.get(n),
	            r = i.getSym();null === e && (e = r), null !== t && r.setNext(t), t = i;
	      }e.setNext(t);
	    }, computeDepths: function computeDepths() {
	      if (1 === arguments.length) {
	        var t = arguments[0],
	            e = this.findIndex(t),
	            n = (t.getLabel(), t.getDepth(Pe.LEFT)),
	            i = t.getDepth(Pe.RIGHT),
	            r = this.computeDepths(e + 1, this.edgeList.size(), n);if (this.computeDepths(0, e, r) !== i) throw new _e("depth mismatch at " + t.getCoordinate());
	      } else if (3 === arguments.length) {
	        for (var s = arguments[0], o = arguments[1], a = arguments[2], u = a, l = s; l < o; l++) {
	          var h = this.edgeList.get(l);h.getLabel();h.setEdgeDepths(Pe.RIGHT, u), u = h.getDepth(Pe.LEFT);
	        }return u;
	      }
	    }, mergeSymLabels: function mergeSymLabels() {
	      for (var t = this.iterator(); t.hasNext();) {
	        var e = t.next();e.getLabel().merge(e.getSym().getLabel());
	      }
	    }, linkMinimalDirectedEdges: function linkMinimalDirectedEdges(t) {
	      for (var e = null, n = null, i = this.SCANNING_FOR_INCOMING, r = this.resultAreaEdgeList.size() - 1; r >= 0; r--) {
	        var s = this.resultAreaEdgeList.get(r),
	            o = s.getSym();switch (null === e && s.getEdgeRing() === t && (e = s), i) {case this.SCANNING_FOR_INCOMING:
	            if (o.getEdgeRing() !== t) continue;n = o, i = this.LINKING_TO_OUTGOING;break;case this.LINKING_TO_OUTGOING:
	            if (s.getEdgeRing() !== t) continue;n.setNextMin(s), i = this.SCANNING_FOR_INCOMING;}
	      }i === this.LINKING_TO_OUTGOING && (h.isTrue(null !== e, "found null for first outgoing dirEdge"), h.isTrue(e.getEdgeRing() === t, "unable to link last incoming dirEdge"), n.setNextMin(e));
	    }, getOutgoingDegree: function getOutgoingDegree() {
	      if (0 === arguments.length) {
	        for (var t = 0, e = this.iterator(); e.hasNext();) {
	          var n = e.next();n.isInResult() && t++;
	        }return t;
	      }if (1 === arguments.length) {
	        for (var i = arguments[0], t = 0, e = this.iterator(); e.hasNext();) {
	          var n = e.next();n.getEdgeRing() === i && t++;
	        }return t;
	      }
	    }, getLabel: function getLabel() {
	      return this.label;
	    }, findCoveredLineEdges: function findCoveredLineEdges() {
	      for (var t = S.NONE, e = this.iterator(); e.hasNext();) {
	        var n = e.next(),
	            i = n.getSym();if (!n.isLineEdge()) {
	          if (n.isInResult()) {
	            t = S.INTERIOR;break;
	          }if (i.isInResult()) {
	            t = S.EXTERIOR;break;
	          }
	        }
	      }if (t === S.NONE) return null;for (var r = t, e = this.iterator(); e.hasNext();) {
	        var n = e.next(),
	            i = n.getSym();n.isLineEdge() ? n.getEdge().setCovered(r === S.INTERIOR) : (n.isInResult() && (r = S.EXTERIOR), i.isInResult() && (r = S.INTERIOR));
	      }
	    }, computeLabelling: function computeLabelling(t) {
	      ze.prototype.computeLabelling.call(this, t), this.label = new Ae(S.NONE);for (var e = this.iterator(); e.hasNext();) {
	        for (var n = e.next(), i = n.getEdge(), r = i.getLabel(), s = 0; s < 2; s++) {
	          var o = r.getLocation(s);o !== S.INTERIOR && o !== S.BOUNDARY || this.label.setLocation(s, S.INTERIOR);
	        }
	      }
	    }, interfaces_: function interfaces_() {
	      return [];
	    }, getClass: function getClass() {
	      return Ye;
	    } }), Or(Xe.prototype, { setVisited: function setVisited(t) {
	      this._isVisited = t;
	    }, setInResult: function setInResult(t) {
	      this._isInResult = t;
	    }, isCovered: function isCovered() {
	      return this._isCovered;
	    }, isCoveredSet: function isCoveredSet() {
	      return this._isCoveredSet;
	    }, setLabel: function setLabel(t) {
	      this.label = t;
	    }, getLabel: function getLabel() {
	      return this.label;
	    }, setCovered: function setCovered(t) {
	      this._isCovered = t, this._isCoveredSet = !0;
	    }, updateIM: function updateIM(t) {
	      h.isTrue(this.label.getGeometryCount() >= 2, "found partial label"), this.computeIM(t);
	    }, isInResult: function isInResult() {
	      return this._isInResult;
	    }, isVisited: function isVisited() {
	      return this._isVisited;
	    }, interfaces_: function interfaces_() {
	      return [];
	    }, getClass: function getClass() {
	      return Xe;
	    } }), br(ke, Xe), Or(ke.prototype, { isIncidentEdgeInResult: function isIncidentEdgeInResult() {
	      for (var t = this.getEdges().getEdges().iterator(); t.hasNext();) {
	        if (t.next().getEdge().isInResult()) return !0;
	      }return !1;
	    }, isIsolated: function isIsolated() {
	      return 1 === this.label.getGeometryCount();
	    }, getCoordinate: function getCoordinate() {
	      return this.coord;
	    }, print: function print(t) {
	      t.println("node " + this.coord + " lbl: " + this.label);
	    }, computeIM: function computeIM(t) {}, computeMergedLocation: function computeMergedLocation(t, e) {
	      var n = S.NONE;if (n = this.label.getLocation(e), !t.isNull(e)) {
	        var i = t.getLocation(e);n !== S.BOUNDARY && (n = i);
	      }return n;
	    }, setLabel: function setLabel() {
	      if (2 !== arguments.length) return Xe.prototype.setLabel.apply(this, arguments);var t = arguments[0],
	          e = arguments[1];null === this.label ? this.label = new Ae(t, e) : this.label.setLocation(t, e);
	    }, getEdges: function getEdges() {
	      return this.edges;
	    }, mergeLabel: function mergeLabel() {
	      if (arguments[0] instanceof ke) {
	        var t = arguments[0];this.mergeLabel(t.label);
	      } else if (arguments[0] instanceof Ae) for (var e = arguments[0], n = 0; n < 2; n++) {
	        var i = this.computeMergedLocation(e, n),
	            r = this.label.getLocation(n);r === S.NONE && this.label.setLocation(n, i);
	      }
	    }, add: function add(t) {
	      this.edges.insert(t), t.setNode(this);
	    }, setLabelBoundary: function setLabelBoundary(t) {
	      if (null === this.label) return null;var e = S.NONE;null !== this.label && (e = this.label.getLocation(t));var n = null;switch (e) {case S.BOUNDARY:
	          n = S.INTERIOR;break;case S.INTERIOR:default:
	          n = S.BOUNDARY;}this.label.setLocation(t, n);
	    }, interfaces_: function interfaces_() {
	      return [];
	    }, getClass: function getClass() {
	      return ke;
	    } }), Or(Ve.prototype, { createNode: function createNode(t) {
	      return new ke(t, null);
	    }, interfaces_: function interfaces_() {
	      return [];
	    }, getClass: function getClass() {
	      return Ve;
	    } }), br(He, Ve), Or(He.prototype, { createNode: function createNode(t) {
	      return new ke(t, new Ye());
	    }, interfaces_: function interfaces_() {
	      return [];
	    }, getClass: function getClass() {
	      return He;
	    } }), Or(We.prototype, { find: function find(t) {
	      return this.nodeMap.get(t);
	    }, addNode: function addNode() {
	      if (arguments[0] instanceof c) {
	        var t = arguments[0],
	            e = this.nodeMap.get(t);return null === e && (e = this.nodeFact.createNode(t), this.nodeMap.put(t, e)), e;
	      }if (arguments[0] instanceof ke) {
	        var n = arguments[0],
	            e = this.nodeMap.get(n.getCoordinate());return null === e ? (this.nodeMap.put(n.getCoordinate(), n), n) : (e.mergeLabel(n), e);
	      }
	    }, print: function print(t) {
	      for (var e = this.iterator(); e.hasNext();) {
	        e.next().print(t);
	      }
	    }, iterator: function iterator() {
	      return this.nodeMap.values().iterator();
	    }, values: function values() {
	      return this.nodeMap.values();
	    }, getBoundaryNodes: function getBoundaryNodes(t) {
	      for (var e = new I(), n = this.iterator(); n.hasNext();) {
	        var i = n.next();i.getLabel().getLocation(t) === S.BOUNDARY && e.add(i);
	      }return e;
	    }, add: function add(t) {
	      var e = t.getCoordinate();this.addNode(e).add(t);
	    }, interfaces_: function interfaces_() {
	      return [];
	    }, getClass: function getClass() {
	      return We;
	    } }), Or(je.prototype, { compareDirection: function compareDirection(t) {
	      return this.dx === t.dx && this.dy === t.dy ? 0 : this.quadrant > t.quadrant ? 1 : this.quadrant < t.quadrant ? -1 : oe.computeOrientation(t.p0, t.p1, this.p1);
	    }, getDy: function getDy() {
	      return this.dy;
	    }, getCoordinate: function getCoordinate() {
	      return this.p0;
	    }, setNode: function setNode(t) {
	      this.node = t;
	    }, print: function print(t) {
	      var e = Math.atan2(this.dy, this.dx),
	          n = this.getClass().getName(),
	          i = n.lastIndexOf("."),
	          r = n.substring(i + 1);t.print("  " + r + ": " + this.p0 + " - " + this.p1 + " " + this.quadrant + ":" + e + "   " + this.label);
	    }, compareTo: function compareTo(t) {
	      var e = t;return this.compareDirection(e);
	    }, getDirectedCoordinate: function getDirectedCoordinate() {
	      return this.p1;
	    }, getDx: function getDx() {
	      return this.dx;
	    }, getLabel: function getLabel() {
	      return this.label;
	    }, getEdge: function getEdge() {
	      return this.edge;
	    }, getQuadrant: function getQuadrant() {
	      return this.quadrant;
	    }, getNode: function getNode() {
	      return this.node;
	    }, toString: function toString() {
	      var t = Math.atan2(this.dy, this.dx),
	          e = this.getClass().getName(),
	          n = e.lastIndexOf(".");return "  " + e.substring(n + 1) + ": " + this.p0 + " - " + this.p1 + " " + this.quadrant + ":" + t + "   " + this.label;
	    }, computeLabel: function computeLabel(t) {}, init: function init(t, e) {
	      this.p0 = t, this.p1 = e, this.dx = e.x - t.x, this.dy = e.y - t.y, this.quadrant = Ue.quadrant(this.dx, this.dy), h.isTrue(!(0 === this.dx && 0 === this.dy), "EdgeEnd with identical endpoints found");
	    }, interfaces_: function interfaces_() {
	      return [r];
	    }, getClass: function getClass() {
	      return je;
	    } }), br(Ke, je), Or(Ke.prototype, { getNextMin: function getNextMin() {
	      return this.nextMin;
	    }, getDepth: function getDepth(t) {
	      return this.depth[t];
	    }, setVisited: function setVisited(t) {
	      this._isVisited = t;
	    }, computeDirectedLabel: function computeDirectedLabel() {
	      this.label = new Ae(this.edge.getLabel()), this._isForward || this.label.flip();
	    }, getNext: function getNext() {
	      return this.next;
	    }, setDepth: function setDepth(t, e) {
	      if (this.depth[t] !== -999 && this.depth[t] !== e) throw new _e("assigned depths do not match", this.getCoordinate());this.depth[t] = e;
	    }, isInteriorAreaEdge: function isInteriorAreaEdge() {
	      for (var t = !0, e = 0; e < 2; e++) {
	        this.label.isArea(e) && this.label.getLocation(e, Pe.LEFT) === S.INTERIOR && this.label.getLocation(e, Pe.RIGHT) === S.INTERIOR || (t = !1);
	      }return t;
	    }, setNextMin: function setNextMin(t) {
	      this.nextMin = t;
	    }, print: function print(t) {
	      je.prototype.print.call(this, t), t.print(" " + this.depth[Pe.LEFT] + "/" + this.depth[Pe.RIGHT]), t.print(" (" + this.getDepthDelta() + ")"), this._isInResult && t.print(" inResult");
	    }, setMinEdgeRing: function setMinEdgeRing(t) {
	      this.minEdgeRing = t;
	    }, isLineEdge: function isLineEdge() {
	      var t = this.label.isLine(0) || this.label.isLine(1),
	          e = !this.label.isArea(0) || this.label.allPositionsEqual(0, S.EXTERIOR),
	          n = !this.label.isArea(1) || this.label.allPositionsEqual(1, S.EXTERIOR);return t && e && n;
	    }, setEdgeRing: function setEdgeRing(t) {
	      this.edgeRing = t;
	    }, getMinEdgeRing: function getMinEdgeRing() {
	      return this.minEdgeRing;
	    }, getDepthDelta: function getDepthDelta() {
	      var t = this.edge.getDepthDelta();return this._isForward || (t = -t), t;
	    }, setInResult: function setInResult(t) {
	      this._isInResult = t;
	    }, getSym: function getSym() {
	      return this.sym;
	    }, isForward: function isForward() {
	      return this._isForward;
	    }, getEdge: function getEdge() {
	      return this.edge;
	    }, printEdge: function printEdge(t) {
	      this.print(t), t.print(" "), this._isForward ? this.edge.print(t) : this.edge.printReverse(t);
	    }, setSym: function setSym(t) {
	      this.sym = t;
	    }, setVisitedEdge: function setVisitedEdge(t) {
	      this.setVisited(t), this.sym.setVisited(t);
	    }, setEdgeDepths: function setEdgeDepths(t, e) {
	      var n = this.getEdge().getDepthDelta();this._isForward || (n = -n);var i = 1;t === Pe.LEFT && (i = -1);var r = Pe.opposite(t),
	          s = n * i,
	          o = e + s;this.setDepth(t, e), this.setDepth(r, o);
	    }, getEdgeRing: function getEdgeRing() {
	      return this.edgeRing;
	    }, isInResult: function isInResult() {
	      return this._isInResult;
	    }, setNext: function setNext(t) {
	      this.next = t;
	    }, isVisited: function isVisited() {
	      return this._isVisited;
	    }, interfaces_: function interfaces_() {
	      return [];
	    }, getClass: function getClass() {
	      return Ke;
	    } }), Ke.depthFactor = function (t, e) {
	    return t === S.EXTERIOR && e === S.INTERIOR ? 1 : t === S.INTERIOR && e === S.EXTERIOR ? -1 : 0;
	  }, Or(Je.prototype, { printEdges: function printEdges(t) {
	      t.println("Edges:");for (var e = 0; e < this.edges.size(); e++) {
	        t.println("edge " + e + ":");var n = this.edges.get(e);n.print(t), n.eiList.print(t);
	      }
	    }, find: function find(t) {
	      return this.nodes.find(t);
	    }, addNode: function addNode() {
	      if (arguments[0] instanceof ke) {
	        var t = arguments[0];return this.nodes.addNode(t);
	      }if (arguments[0] instanceof c) {
	        var e = arguments[0];return this.nodes.addNode(e);
	      }
	    }, getNodeIterator: function getNodeIterator() {
	      return this.nodes.iterator();
	    }, linkResultDirectedEdges: function linkResultDirectedEdges() {
	      for (var t = this.nodes.iterator(); t.hasNext();) {
	        t.next().getEdges().linkResultDirectedEdges();
	      }
	    }, debugPrintln: function debugPrintln(t) {
	      _.out.println(t);
	    }, isBoundaryNode: function isBoundaryNode(t, e) {
	      var n = this.nodes.find(e);if (null === n) return !1;var i = n.getLabel();return null !== i && i.getLocation(t) === S.BOUNDARY;
	    }, linkAllDirectedEdges: function linkAllDirectedEdges() {
	      for (var t = this.nodes.iterator(); t.hasNext();) {
	        t.next().getEdges().linkAllDirectedEdges();
	      }
	    }, matchInSameDirection: function matchInSameDirection(t, e, n, i) {
	      return !!t.equals(n) && oe.computeOrientation(t, e, i) === oe.COLLINEAR && Ue.quadrant(t, e) === Ue.quadrant(n, i);
	    }, getEdgeEnds: function getEdgeEnds() {
	      return this.edgeEndList;
	    }, debugPrint: function debugPrint(t) {
	      _.out.print(t);
	    }, getEdgeIterator: function getEdgeIterator() {
	      return this.edges.iterator();
	    }, findEdgeInSameDirection: function findEdgeInSameDirection(t, e) {
	      for (var n = 0; n < this.edges.size(); n++) {
	        var i = this.edges.get(n),
	            r = i.getCoordinates();if (this.matchInSameDirection(t, e, r[0], r[1])) return i;if (this.matchInSameDirection(t, e, r[r.length - 1], r[r.length - 2])) return i;
	      }return null;
	    }, insertEdge: function insertEdge(t) {
	      this.edges.add(t);
	    }, findEdgeEnd: function findEdgeEnd(t) {
	      for (var e = this.getEdgeEnds().iterator(); e.hasNext();) {
	        var n = e.next();if (n.getEdge() === t) return n;
	      }return null;
	    }, addEdges: function addEdges(t) {
	      for (var e = t.iterator(); e.hasNext();) {
	        var n = e.next();this.edges.add(n);var i = new Ke(n, !0),
	            r = new Ke(n, !1);i.setSym(r), r.setSym(i), this.add(i), this.add(r);
	      }
	    }, add: function add(t) {
	      this.nodes.add(t), this.edgeEndList.add(t);
	    }, getNodes: function getNodes() {
	      return this.nodes.values();
	    }, findEdge: function findEdge(t, e) {
	      for (var n = 0; n < this.edges.size(); n++) {
	        var i = this.edges.get(n),
	            r = i.getCoordinates();if (t.equals(r[0]) && e.equals(r[1])) return i;
	      }return null;
	    }, interfaces_: function interfaces_() {
	      return [];
	    }, getClass: function getClass() {
	      return Je;
	    } }), Je.linkResultDirectedEdges = function (t) {
	    for (var e = t.iterator(); e.hasNext();) {
	      e.next().getEdges().linkResultDirectedEdges();
	    }
	  }, Or(Qe.prototype, { visitInteriorRing: function visitInteriorRing(t, e) {
	      var n = t.getCoordinates(),
	          i = n[0],
	          r = Qe.findDifferentPoint(n, i),
	          s = e.findEdgeInSameDirection(i, r),
	          o = e.findEdgeEnd(s),
	          a = null;o.getLabel().getLocation(0, Pe.RIGHT) === S.INTERIOR ? a = o : o.getSym().getLabel().getLocation(0, Pe.RIGHT) === S.INTERIOR && (a = o.getSym()), h.isTrue(null !== a, "unable to find dirEdge with Interior on RHS"), this.visitLinkedDirectedEdges(a);
	    }, visitShellInteriors: function visitShellInteriors(t, e) {
	      if (t instanceof Lt) {
	        var n = t;this.visitInteriorRing(n.getExteriorRing(), e);
	      }if (t instanceof Tt) for (var i = t, r = 0; r < i.getNumGeometries(); r++) {
	        var n = i.getGeometryN(r);this.visitInteriorRing(n.getExteriorRing(), e);
	      }
	    }, getCoordinate: function getCoordinate() {
	      return this.disconnectedRingcoord;
	    }, setInteriorEdgesInResult: function setInteriorEdgesInResult(t) {
	      for (var e = t.getEdgeEnds().iterator(); e.hasNext();) {
	        var n = e.next();n.getLabel().getLocation(0, Pe.RIGHT) === S.INTERIOR && n.setInResult(!0);
	      }
	    }, visitLinkedDirectedEdges: function visitLinkedDirectedEdges(t) {
	      var e = t,
	          n = t;do {
	        h.isTrue(null !== n, "found null Directed Edge"), n.setVisited(!0), n = n.getNext();
	      } while (n !== e);
	    }, buildEdgeRings: function buildEdgeRings(t) {
	      for (var e = new I(), n = t.iterator(); n.hasNext();) {
	        var i = n.next();if (i.isInResult() && null === i.getEdgeRing()) {
	          var r = new Ge(i, this.geometryFactory);r.linkDirectedEdgesForMinimalEdgeRings();var s = r.buildMinimalRings();e.addAll(s);
	        }
	      }return e;
	    }, hasUnvisitedShellEdge: function hasUnvisitedShellEdge(t) {
	      for (var e = 0; e < t.size(); e++) {
	        var n = t.get(e);if (!n.isHole()) {
	          var i = n.getEdges(),
	              r = i.get(0);if (r.getLabel().getLocation(0, Pe.RIGHT) === S.INTERIOR) for (var s = 0; s < i.size(); s++) {
	            if (r = i.get(s), !r.isVisited()) return this.disconnectedRingcoord = r.getCoordinate(), !0;
	          }
	        }
	      }return !1;
	    }, isInteriorsConnected: function isInteriorsConnected() {
	      var t = new I();this.geomGraph.computeSplitEdges(t);var e = new Je(new He());e.addEdges(t), this.setInteriorEdgesInResult(e), e.linkResultDirectedEdges();var n = this.buildEdgeRings(e.getEdgeEnds());return this.visitShellInteriors(this.geomGraph.getGeometry(), e), !this.hasUnvisitedShellEdge(n);
	    }, interfaces_: function interfaces_() {
	      return [];
	    }, getClass: function getClass() {
	      return Qe;
	    } }), Qe.findDifferentPoint = function (t, e) {
	    for (var n = 0; n < t.length; n++) {
	      if (!t[n].equals(e)) return t[n];
	    }return null;
	  }, Or(Ze.prototype, { select: function select() {
	      if (1 === arguments.length) {
	        arguments[0];
	      } else if (2 === arguments.length) {
	        var t = arguments[0],
	            e = arguments[1];t.getLineSegment(e, this.selectedSegment), this.select(this.selectedSegment);
	      }
	    }, interfaces_: function interfaces_() {
	      return [];
	    }, getClass: function getClass() {
	      return Ze;
	    } }), Or($e.prototype, { hasChildren: function hasChildren() {
	      for (var t = 0; t < 2; t++) {
	        if (null !== this.subnode[t]) return !0;
	      }return !1;
	    }, isPrunable: function isPrunable() {
	      return !(this.hasChildren() || this.hasItems());
	    }, addAllItems: function addAllItems(t) {
	      t.addAll(this.items);for (var e = 0; e < 2; e++) {
	        null !== this.subnode[e] && this.subnode[e].addAllItems(t);
	      }return t;
	    }, size: function size() {
	      for (var t = 0, e = 0; e < 2; e++) {
	        null !== this.subnode[e] && (t += this.subnode[e].size());
	      }return t + this.items.size();
	    }, addAllItemsFromOverlapping: function addAllItemsFromOverlapping(t, e) {
	      if (null !== t && !this.isSearchMatch(t)) return null;e.addAll(this.items), null !== this.subnode[0] && this.subnode[0].addAllItemsFromOverlapping(t, e), null !== this.subnode[1] && this.subnode[1].addAllItemsFromOverlapping(t, e);
	    }, hasItems: function hasItems() {
	      return !this.items.isEmpty();
	    }, remove: function remove(t, e) {
	      if (!this.isSearchMatch(t)) return !1;for (var n = !1, i = 0; i < 2; i++) {
	        if (null !== this.subnode[i] && (n = this.subnode[i].remove(t, e))) {
	          this.subnode[i].isPrunable() && (this.subnode[i] = null);break;
	        }
	      }return n || (n = this.items.remove(e));
	    }, getItems: function getItems() {
	      return this.items;
	    }, depth: function depth() {
	      for (var t = 0, e = 0; e < 2; e++) {
	        if (null !== this.subnode[e]) {
	          var n = this.subnode[e].depth();n > t && (t = n);
	        }
	      }return t + 1;
	    }, nodeSize: function nodeSize() {
	      for (var t = 0, e = 0; e < 2; e++) {
	        null !== this.subnode[e] && (t += this.subnode[e].nodeSize());
	      }return t + 1;
	    }, add: function add(t) {
	      this.items.add(t);
	    }, interfaces_: function interfaces_() {
	      return [];
	    }, getClass: function getClass() {
	      return $e;
	    } }), $e.getSubnodeIndex = function (t, e) {
	    var n = -1;return t.min >= e && (n = 1), t.max <= e && (n = 0), n;
	  }, Or(tn.prototype, { expandToInclude: function expandToInclude(t) {
	      t.max > this.max && (this.max = t.max), t.min < this.min && (this.min = t.min);
	    }, getWidth: function getWidth() {
	      return this.max - this.min;
	    }, overlaps: function overlaps() {
	      if (1 === arguments.length) {
	        var t = arguments[0];return this.overlaps(t.min, t.max);
	      }if (2 === arguments.length) {
	        var e = arguments[0],
	            n = arguments[1];return !(this.min > n || this.max < e);
	      }
	    }, getMin: function getMin() {
	      return this.min;
	    },
	    toString: function toString() {
	      return "[" + this.min + ", " + this.max + "]";
	    }, contains: function contains() {
	      if (1 === arguments.length) {
	        if (arguments[0] instanceof tn) {
	          var t = arguments[0];return this.contains(t.min, t.max);
	        }if ("number" == typeof arguments[0]) {
	          var e = arguments[0];return e >= this.min && e <= this.max;
	        }
	      } else if (2 === arguments.length) {
	        var n = arguments[0],
	            i = arguments[1];return n >= this.min && i <= this.max;
	      }
	    }, init: function init(t, e) {
	      this.min = t, this.max = e, t > e && (this.min = e, this.max = t);
	    }, getMax: function getMax() {
	      return this.max;
	    }, interfaces_: function interfaces_() {
	      return [];
	    }, getClass: function getClass() {
	      return tn;
	    } }), Or(en.prototype, { getInterval: function getInterval() {
	      return this.interval;
	    }, getLevel: function getLevel() {
	      return this.level;
	    }, computeKey: function computeKey(t) {
	      for (this.level = en.computeLevel(t), this.interval = new tn(), this.computeInterval(this.level, t); !this.interval.contains(t);) {
	        this.level += 1, this.computeInterval(this.level, t);
	      }
	    }, computeInterval: function computeInterval(t, e) {
	      var n = le.powerOf2(t);this.pt = Math.floor(e.getMin() / n) * n, this.interval.init(this.pt, this.pt + n);
	    }, getPoint: function getPoint() {
	      return this.pt;
	    }, interfaces_: function interfaces_() {
	      return [];
	    }, getClass: function getClass() {
	      return en;
	    } }), en.computeLevel = function (t) {
	    var e = t.getWidth();return le.exponent(e) + 1;
	  }, br(nn, $e), Or(nn.prototype, { getInterval: function getInterval() {
	      return this.interval;
	    }, find: function find(t) {
	      var e = $e.getSubnodeIndex(t, this.centre);if (e === -1) return this;if (null !== this.subnode[e]) {
	        return this.subnode[e].find(t);
	      }return this;
	    }, insert: function insert(t) {
	      h.isTrue(null === this.interval || this.interval.contains(t.interval));var e = $e.getSubnodeIndex(t.interval, this.centre);if (t.level === this.level - 1) this.subnode[e] = t;else {
	        var n = this.createSubnode(e);n.insert(t), this.subnode[e] = n;
	      }
	    }, isSearchMatch: function isSearchMatch(t) {
	      return t.overlaps(this.interval);
	    }, getSubnode: function getSubnode(t) {
	      return null === this.subnode[t] && (this.subnode[t] = this.createSubnode(t)), this.subnode[t];
	    }, getNode: function getNode(t) {
	      var e = $e.getSubnodeIndex(t, this.centre);if (e !== -1) {
	        return this.getSubnode(e).getNode(t);
	      }return this;
	    }, createSubnode: function createSubnode(t) {
	      var e = 0,
	          n = 0;switch (t) {case 0:
	          e = this.interval.getMin(), n = this.centre;break;case 1:
	          e = this.centre, n = this.interval.getMax();}return new nn(new tn(e, n), this.level - 1);
	    }, interfaces_: function interfaces_() {
	      return [];
	    }, getClass: function getClass() {
	      return nn;
	    } }), nn.createNode = function (t) {
	    var e = new en(t);return new nn(e.getInterval(), e.getLevel());
	  }, nn.createExpanded = function (t, e) {
	    var n = new tn(e);null !== t && n.expandToInclude(t.interval);var i = nn.createNode(n);return null !== t && i.insert(t), i;
	  }, br(rn, $e), Or(rn.prototype, { insert: function insert(t, e) {
	      var n = $e.getSubnodeIndex(t, rn.origin);if (n === -1) return this.add(e), null;var i = this.subnode[n];if (null === i || !i.getInterval().contains(t)) {
	        var r = nn.createExpanded(i, t);this.subnode[n] = r;
	      }this.insertContained(this.subnode[n], t, e);
	    }, isSearchMatch: function isSearchMatch(t) {
	      return !0;
	    }, insertContained: function insertContained(t, e, n) {
	      h.isTrue(t.getInterval().contains(e));var i = ge.isZeroWidth(e.getMin(), e.getMax()),
	          r = null;r = i ? t.find(e) : t.getNode(e), r.add(n);
	    }, interfaces_: function interfaces_() {
	      return [];
	    }, getClass: function getClass() {
	      return rn;
	    } }), rn.origin = 0, Or(sn.prototype, { size: function size() {
	      return null !== this.root ? this.root.size() : 0;
	    }, insert: function insert(t, e) {
	      this.collectStats(t);var n = sn.ensureExtent(t, this.minExtent);this.root.insert(n, e);
	    }, query: function query() {
	      if (1 === arguments.length) {
	        if ("number" == typeof arguments[0]) {
	          var t = arguments[0];return this.query(new tn(t, t));
	        }if (arguments[0] instanceof tn) {
	          var e = arguments[0],
	              n = new I();return this.query(e, n), n;
	        }
	      } else if (2 === arguments.length) {
	        var i = arguments[0],
	            r = arguments[1];this.root.addAllItemsFromOverlapping(i, r);
	      }
	    }, iterator: function iterator() {
	      var t = new I();return this.root.addAllItems(t), t.iterator();
	    }, remove: function remove(t, e) {
	      var n = sn.ensureExtent(t, this.minExtent);return this.root.remove(n, e);
	    }, collectStats: function collectStats(t) {
	      var e = t.getWidth();e < this.minExtent && e > 0 && (this.minExtent = e);
	    }, depth: function depth() {
	      return null !== this.root ? this.root.depth() : 0;
	    }, nodeSize: function nodeSize() {
	      return null !== this.root ? this.root.nodeSize() : 0;
	    }, interfaces_: function interfaces_() {
	      return [];
	    }, getClass: function getClass() {
	      return sn;
	    } }), sn.ensureExtent = function (t, e) {
	    var n = t.getMin(),
	        i = t.getMax();return n !== i ? t : (n === i && (n -= e / 2, i = n + e / 2), new tn(n, i));
	  }, Or(on.prototype, { getLineSegment: function getLineSegment(t, e) {
	      e.p0 = this.pts[t], e.p1 = this.pts[t + 1];
	    }, computeSelect: function computeSelect(t, e, n, i) {
	      var r = this.pts[e],
	          s = this.pts[n];if (i.tempEnv1.init(r, s), n - e == 1) return i.select(this, e), null;if (!t.intersects(i.tempEnv1)) return null;var o = Math.trunc((e + n) / 2);e < o && this.computeSelect(t, e, o, i), o < n && this.computeSelect(t, o, n, i);
	    }, getCoordinates: function getCoordinates() {
	      for (var t = new Array(this.end - this.start + 1).fill(null), e = 0, n = this.start; n <= this.end; n++) {
	        t[e++] = this.pts[n];
	      }return t;
	    }, computeOverlaps: function computeOverlaps(t, e) {
	      this.computeOverlapsInternal(this.start, this.end, t, t.start, t.end, e);
	    }, setId: function setId(t) {
	      this.id = t;
	    }, select: function select(t, e) {
	      this.computeSelect(t, this.start, this.end, e);
	    }, getEnvelope: function getEnvelope() {
	      if (null === this.env) {
	        var t = this.pts[this.start],
	            e = this.pts[this.end];this.env = new x(t, e);
	      }return this.env;
	    }, getEndIndex: function getEndIndex() {
	      return this.end;
	    }, getStartIndex: function getStartIndex() {
	      return this.start;
	    }, getContext: function getContext() {
	      return this.context;
	    }, getId: function getId() {
	      return this.id;
	    }, computeOverlapsInternal: function computeOverlapsInternal(t, e, n, i, r, s) {
	      var o = this.pts[t],
	          a = this.pts[e],
	          u = n.pts[i],
	          l = n.pts[r];if (e - t == 1 && r - i == 1) return s.overlap(this, t, n, i), null;if (s.tempEnv1.init(o, a), s.tempEnv2.init(u, l), !s.tempEnv1.intersects(s.tempEnv2)) return null;var h = Math.trunc((t + e) / 2),
	          c = Math.trunc((i + r) / 2);t < h && (i < c && this.computeOverlapsInternal(t, h, n, i, c, s), c < r && this.computeOverlapsInternal(t, h, n, c, r, s)), h < e && (i < c && this.computeOverlapsInternal(h, e, n, i, c, s), c < r && this.computeOverlapsInternal(h, e, n, c, r, s));
	    }, interfaces_: function interfaces_() {
	      return [];
	    }, getClass: function getClass() {
	      return on;
	    } }), Or(an.prototype, { interfaces_: function interfaces_() {
	      return [];
	    }, getClass: function getClass() {
	      return an;
	    } }), an.getChainStartIndices = function (t) {
	    var e = 0,
	        n = new I();n.add(new w(e));do {
	      var i = an.findChainEnd(t, e);n.add(new w(i)), e = i;
	    } while (e < t.length - 1);return an.toIntArray(n);
	  }, an.findChainEnd = function (t, e) {
	    for (var n = e; n < t.length - 1 && t[n].equals2D(t[n + 1]);) {
	      n++;
	    }if (n >= t.length - 1) return t.length - 1;for (var i = Ue.quadrant(t[n], t[n + 1]), r = e + 1; r < t.length;) {
	      if (!t[r - 1].equals2D(t[r])) {
	        if (Ue.quadrant(t[r - 1], t[r]) !== i) break;
	      }r++;
	    }return r - 1;
	  }, an.getChains = function () {
	    if (1 === arguments.length) {
	      var t = arguments[0];return an.getChains(t, null);
	    }if (2 === arguments.length) {
	      for (var e = arguments[0], n = arguments[1], i = new I(), r = an.getChainStartIndices(e), s = 0; s < r.length - 1; s++) {
	        var o = new on(e, r[s], r[s + 1], n);i.add(o);
	      }return i;
	    }
	  }, an.toIntArray = function (t) {
	    for (var e = new Array(t.size()).fill(null), n = 0; n < e.length; n++) {
	      e[n] = t.get(n).intValue();
	    }return e;
	  }, Or(un.prototype, { isInside: function isInside(t) {}, interfaces_: function interfaces_() {
	      return [];
	    }, getClass: function getClass() {
	      return un;
	    } }), Or(ln.prototype, { testLineSegment: function testLineSegment(t, e) {
	      var n = null,
	          i = null,
	          r = null,
	          s = null,
	          o = e.p0,
	          a = e.p1;n = o.x - t.x, i = o.y - t.y, r = a.x - t.x, s = a.y - t.y, (i > 0 && s <= 0 || s > 0 && i <= 0) && 0 < re.signOfDet2x2(n, i, r, s) / (s - i) && this.crossings++;
	    }, buildIndex: function buildIndex() {
	      this.tree = new sn();for (var t = X.removeRepeatedPoints(this.ring.getCoordinates()), e = an.getChains(t), n = 0; n < e.size(); n++) {
	        var i = e.get(n),
	            r = i.getEnvelope();this.interval.min = r.getMinY(), this.interval.max = r.getMaxY(), this.tree.insert(this.interval, i);
	      }
	    }, testMonotoneChain: function testMonotoneChain(t, e, n) {
	      n.select(t, e);
	    }, isInside: function isInside(t) {
	      this.crossings = 0;var e = new x(i.NEGATIVE_INFINITY, i.POSITIVE_INFINITY, t.y, t.y);this.interval.min = t.y, this.interval.max = t.y;for (var n = this.tree.query(this.interval), r = new hn(this, t), s = n.iterator(); s.hasNext();) {
	        var o = s.next();this.testMonotoneChain(e, r, o);
	      }return this.crossings % 2 == 1;
	    }, interfaces_: function interfaces_() {
	      return [un];
	    }, getClass: function getClass() {
	      return ln;
	    } }), br(hn, Ze), Or(hn.prototype, { select: function select() {
	      if (1 !== arguments.length) return Ze.prototype.select.apply(this, arguments);var t = arguments[0];this.mcp.testLineSegment(this.p, t);
	    }, interfaces_: function interfaces_() {
	      return [];
	    }, getClass: function getClass() {
	      return hn;
	    } }), ln.MCSelecter = hn, Or(cn.prototype, { computeIntersections: function computeIntersections(t, e) {
	      this.mce.computeIntersectsForChain(this.chainIndex, t.mce, t.chainIndex, e);
	    }, interfaces_: function interfaces_() {
	      return [];
	    }, getClass: function getClass() {
	      return cn;
	    } }), Or(fn.prototype, { isDelete: function isDelete() {
	      return this.eventType === fn.DELETE;
	    }, setDeleteEventIndex: function setDeleteEventIndex(t) {
	      this.deleteEventIndex = t;
	    }, getObject: function getObject() {
	      return this.obj;
	    }, compareTo: function compareTo(t) {
	      var e = t;return this.xValue < e.xValue ? -1 : this.xValue > e.xValue ? 1 : this.eventType < e.eventType ? -1 : this.eventType > e.eventType ? 1 : 0;
	    }, getInsertEvent: function getInsertEvent() {
	      return this.insertEvent;
	    }, isInsert: function isInsert() {
	      return this.eventType === fn.INSERT;
	    }, isSameLabel: function isSameLabel(t) {
	      return null !== this.label && this.label === t.label;
	    }, getDeleteEventIndex: function getDeleteEventIndex() {
	      return this.deleteEventIndex;
	    }, interfaces_: function interfaces_() {
	      return [r];
	    }, getClass: function getClass() {
	      return fn;
	    } }), fn.INSERT = 1, fn.DELETE = 2, Or(gn.prototype, { interfaces_: function interfaces_() {
	      return [];
	    }, getClass: function getClass() {
	      return gn;
	    } }), Or(dn.prototype, { isTrivialIntersection: function isTrivialIntersection(t, e, n, i) {
	      if (t === n && 1 === this.li.getIntersectionNum()) {
	        if (dn.isAdjacentSegments(e, i)) return !0;if (t.isClosed()) {
	          var r = t.getNumPoints() - 1;if (0 === e && i === r || 0 === i && e === r) return !0;
	        }
	      }return !1;
	    }, getProperIntersectionPoint: function getProperIntersectionPoint() {
	      return this.properIntersectionPoint;
	    }, setIsDoneIfProperInt: function setIsDoneIfProperInt(t) {
	      this.isDoneWhenProperInt = t;
	    }, hasProperInteriorIntersection: function hasProperInteriorIntersection() {
	      return this.hasProperInterior;
	    }, isBoundaryPointInternal: function isBoundaryPointInternal(t, e) {
	      for (var n = e.iterator(); n.hasNext();) {
	        var i = n.next(),
	            r = i.getCoordinate();if (t.isIntersection(r)) return !0;
	      }return !1;
	    }, hasProperIntersection: function hasProperIntersection() {
	      return this.hasProper;
	    }, hasIntersection: function hasIntersection() {
	      return this._hasIntersection;
	    }, isDone: function isDone() {
	      return this._isDone;
	    }, isBoundaryPoint: function isBoundaryPoint(t, e) {
	      return null !== e && (!!this.isBoundaryPointInternal(t, e[0]) || !!this.isBoundaryPointInternal(t, e[1]));
	    }, setBoundaryNodes: function setBoundaryNodes(t, e) {
	      this.bdyNodes = new Array(2).fill(null), this.bdyNodes[0] = t, this.bdyNodes[1] = e;
	    }, addIntersections: function addIntersections(t, e, n, i) {
	      if (t === n && e === i) return null;this.numTests++;var r = t.getCoordinates()[e],
	          s = t.getCoordinates()[e + 1],
	          o = n.getCoordinates()[i],
	          a = n.getCoordinates()[i + 1];this.li.computeIntersection(r, s, o, a), this.li.hasIntersection() && (this.recordIsolated && (t.setIsolated(!1), n.setIsolated(!1)), this.numIntersections++, this.isTrivialIntersection(t, e, n, i) || (this._hasIntersection = !0, !this.includeProper && this.li.isProper() || (t.addIntersections(this.li, e, 0), n.addIntersections(this.li, i, 1)), this.li.isProper() && (this.properIntersectionPoint = this.li.getIntersection(0).copy(), this.hasProper = !0, this.isDoneWhenProperInt && (this._isDone = !0), this.isBoundaryPoint(this.li, this.bdyNodes) || (this.hasProperInterior = !0))));
	    }, interfaces_: function interfaces_() {
	      return [];
	    }, getClass: function getClass() {
	      return dn;
	    } }), dn.isAdjacentSegments = function (t, e) {
	    return 1 === Math.abs(t - e);
	  }, br(pn, gn), Or(pn.prototype, { prepareEvents: function prepareEvents() {
	      Jr.sort(this.events);for (var t = 0; t < this.events.size(); t++) {
	        var e = this.events.get(t);e.isDelete() && e.getInsertEvent().setDeleteEventIndex(t);
	      }
	    }, computeIntersections: function computeIntersections() {
	      if (1 === arguments.length) {
	        var t = arguments[0];this.nOverlaps = 0, this.prepareEvents();for (var e = 0; e < this.events.size(); e++) {
	          var n = this.events.get(e);if (n.isInsert() && this.processOverlaps(e, n.getDeleteEventIndex(), n, t), t.isDone()) break;
	        }
	      } else if (3 === arguments.length) if (arguments[2] instanceof dn && _r(arguments[0], m) && _r(arguments[1], m)) {
	        var i = arguments[0],
	            r = arguments[1],
	            s = arguments[2];this.addEdges(i, i), this.addEdges(r, r), this.computeIntersections(s);
	      } else if ("boolean" == typeof arguments[2] && _r(arguments[0], m) && arguments[1] instanceof dn) {
	        var o = arguments[0],
	            a = arguments[1],
	            u = arguments[2];u ? this.addEdges(o, null) : this.addEdges(o), this.computeIntersections(a);
	      }
	    }, addEdge: function addEdge(t, e) {
	      for (var n = t.getMonotoneChainEdge(), i = n.getStartIndexes(), r = 0; r < i.length - 1; r++) {
	        var s = new cn(n, r),
	            o = new fn(e, n.getMinX(r), s);this.events.add(o), this.events.add(new fn(n.getMaxX(r), o));
	      }
	    }, processOverlaps: function processOverlaps(t, e, n, i) {
	      for (var r = n.getObject(), s = t; s < e; s++) {
	        var o = this.events.get(s);if (o.isInsert()) {
	          var a = o.getObject();n.isSameLabel(o) || (r.computeIntersections(a, i), this.nOverlaps++);
	        }
	      }
	    }, addEdges: function addEdges() {
	      if (1 === arguments.length) for (var t = arguments[0], e = t.iterator(); e.hasNext();) {
	        var n = e.next();this.addEdge(n, n);
	      } else if (2 === arguments.length) for (var i = arguments[0], r = arguments[1], e = i.iterator(); e.hasNext();) {
	        var n = e.next();this.addEdge(n, r);
	      }
	    }, interfaces_: function interfaces_() {
	      return [];
	    }, getClass: function getClass() {
	      return pn;
	    } }), Or(mn.prototype, { getMin: function getMin() {
	      return this.min;
	    }, intersects: function intersects(t, e) {
	      return !(this.min > e || this.max < t);
	    }, getMax: function getMax() {
	      return this.max;
	    }, toString: function toString() {
	      return ee.toLineString(new c(this.min, 0), new c(this.max, 0));
	    }, interfaces_: function interfaces_() {
	      return [];
	    }, getClass: function getClass() {
	      return mn;
	    } }), Or(vn.prototype, { compare: function compare(t, e) {
	      var n = t,
	          i = e,
	          r = (n.min + n.max) / 2,
	          s = (i.min + i.max) / 2;return r < s ? -1 : r > s ? 1 : 0;
	    }, interfaces_: function interfaces_() {
	      return [o];
	    }, getClass: function getClass() {
	      return vn;
	    } }), mn.NodeComparator = vn, br(yn, mn), Or(yn.prototype, { query: function query(t, e, n) {
	      if (!this.intersects(t, e)) return null;n.visitItem(this.item);
	    }, interfaces_: function interfaces_() {
	      return [];
	    }, getClass: function getClass() {
	      return yn;
	    } }), br(In, mn), Or(In.prototype, { buildExtent: function buildExtent(t, e) {
	      this.min = Math.min(t.min, e.min), this.max = Math.max(t.max, e.max);
	    }, query: function query(t, e, n) {
	      if (!this.intersects(t, e)) return null;null !== this.node1 && this.node1.query(t, e, n), null !== this.node2 && this.node2.query(t, e, n);
	    }, interfaces_: function interfaces_() {
	      return [];
	    }, getClass: function getClass() {
	      return In;
	    } }), Or(En.prototype, { buildTree: function buildTree() {
	      Jr.sort(this.leaves, new IntervalRTreeNode.NodeComparator());for (var t = this.leaves, e = null, n = new I();;) {
	        if (this.buildLevel(t, n), 1 === n.size()) return n.get(0);e = t, t = n, n = e;
	      }
	    }, insert: function insert(t, e, n) {
	      if (null !== this.root) throw new IllegalStateException("Index cannot be added to once it has been queried");this.leaves.add(new yn(t, e, n));
	    }, query: function query(t, e, n) {
	      this.init(), this.root.query(t, e, n);
	    }, buildRoot: function buildRoot() {
	      if (null !== this.root) return null;this.root = this.buildTree();
	    }, printNode: function printNode(t) {
	      _.out.println(ee.toLineString(new c(t.min, this.level), new c(t.max, this.level)));
	    }, init: function init() {
	      if (null !== this.root) return null;this.buildRoot();
	    }, buildLevel: function buildLevel(t, e) {
	      this.level++, e.clear();for (var n = 0; n < t.size(); n += 2) {
	        var i = t.get(n);if (null === (n + 1 < t.size() ? t.get(n) : null)) e.add(i);else {
	          var r = new In(t.get(n), t.get(n + 1));e.add(r);
	        }
	      }
	    }, interfaces_: function interfaces_() {
	      return [];
	    }, getClass: function getClass() {
	      return En;
	    } }), Or(xn.prototype, { locate: function locate(t) {
	      var e = new se(t),
	          n = new Nn(e);return this.index.query(t.y, t.y, n), e.getLocation();
	    }, interfaces_: function interfaces_() {
	      return [Be];
	    }, getClass: function getClass() {
	      return xn;
	    } }), Or(Nn.prototype, { visitItem: function visitItem(t) {
	      var e = t;this.counter.countSegment(e.getCoordinate(0), e.getCoordinate(1));
	    }, interfaces_: function interfaces_() {
	      return [me];
	    }, getClass: function getClass() {
	      return Nn;
	    } }), Or(Cn.prototype, { init: function init(t) {
	      for (var e = Te.getLines(t), n = e.iterator(); n.hasNext();) {
	        var i = n.next(),
	            r = i.getCoordinates();this.addLine(r);
	      }
	    }, addLine: function addLine(t) {
	      for (var e = 1; e < t.length; e++) {
	        var n = new ae(t[e - 1], t[e]),
	            i = Math.min(n.p0.y, n.p1.y),
	            r = Math.max(n.p0.y, n.p1.y);this.index.insert(i, r, n);
	      }
	    }, query: function query() {
	      if (2 === arguments.length) {
	        var t = arguments[0],
	            e = arguments[1],
	            n = new ve();return this.index.query(t, e, n), n.getItems();
	      }if (3 === arguments.length) {
	        var i = arguments[0],
	            r = arguments[1],
	            s = arguments[2];this.index.query(i, r, s);
	      }
	    }, interfaces_: function interfaces_() {
	      return [];
	    }, getClass: function getClass() {
	      return Cn;
	    } }), xn.SegmentVisitor = Nn, xn.IntervalIndexedGeometry = Cn, Or(Sn.prototype, { getSegmentIndex: function getSegmentIndex() {
	      return this.segmentIndex;
	    }, getCoordinate: function getCoordinate() {
	      return this.coord;
	    }, print: function print(t) {
	      t.print(this.coord), t.print(" seg # = " + this.segmentIndex), t.println(" dist = " + this.dist);
	    }, compareTo: function compareTo(t) {
	      var e = t;return this.compare(e.segmentIndex, e.dist);
	    }, isEndPoint: function isEndPoint(t) {
	      return 0 === this.segmentIndex && 0 === this.dist || this.segmentIndex === t;
	    }, toString: function toString() {
	      return this.coord + " seg # = " + this.segmentIndex + " dist = " + this.dist;
	    }, getDistance: function getDistance() {
	      return this.dist;
	    }, compare: function compare(t, e) {
	      return this.segmentIndex < t ? -1 : this.segmentIndex > t ? 1 : this.dist < e ? -1 : this.dist > e ? 1 : 0;
	    }, interfaces_: function interfaces_() {
	      return [r];
	    }, getClass: function getClass() {
	      return Sn;
	    } }), Or(Ln.prototype, { print: function print(t) {
	      t.println("Intersections:");for (var e = this.iterator(); e.hasNext();) {
	        e.next().print(t);
	      }
	    }, iterator: function iterator() {
	      return this.nodeMap.values().iterator();
	    }, addSplitEdges: function addSplitEdges(t) {
	      this.addEndpoints();for (var e = this.iterator(), n = e.next(); e.hasNext();) {
	        var i = e.next(),
	            r = this.createSplitEdge(n, i);t.add(r), n = i;
	      }
	    }, addEndpoints: function addEndpoints() {
	      var t = this.edge.pts.length - 1;this.add(this.edge.pts[0], 0, 0), this.add(this.edge.pts[t], t, 0);
	    }, createSplitEdge: function createSplitEdge(t, e) {
	      var n = e.segmentIndex - t.segmentIndex + 2,
	          i = this.edge.pts[e.segmentIndex],
	          r = e.dist > 0 || !e.coord.equals2D(i);r || n--;var s = new Array(n).fill(null),
	          o = 0;s[o++] = new c(t.coord);for (var a = t.segmentIndex + 1; a <= e.segmentIndex; a++) {
	        s[o++] = this.edge.pts[a];
	      }return r && (s[o] = e.coord), new On(s, new Ae(this.edge.label));
	    }, add: function add(t, e, n) {
	      var i = new Sn(t, e, n),
	          r = this.nodeMap.get(i);return null !== r ? r : (this.nodeMap.put(i, i), i);
	    }, isIntersection: function isIntersection(t) {
	      for (var e = this.iterator(); e.hasNext();) {
	        if (e.next().coord.equals(t)) return !0;
	      }return !1;
	    }, interfaces_: function interfaces_() {
	      return [];
	    }, getClass: function getClass() {
	      return Ln;
	    } }), Or(Rn.prototype, { getChainStartIndices: function getChainStartIndices(t) {
	      var e = 0,
	          n = new I();n.add(new w(e));do {
	        var i = this.findChainEnd(t, e);n.add(new w(i)), e = i;
	      } while (e < t.length - 1);return Rn.toIntArray(n);
	    }, findChainEnd: function findChainEnd(t, e) {
	      for (var n = Ue.quadrant(t[e], t[e + 1]), i = e + 1; i < t.length;) {
	        if (Ue.quadrant(t[i - 1], t[i]) !== n) break;i++;
	      }return i - 1;
	    }, interfaces_: function interfaces_() {
	      return [];
	    }, getClass: function getClass() {
	      return Rn;
	    } }), Rn.toIntArray = function (t) {
	    for (var e = new Array(t.size()).fill(null), n = 0; n < e.length; n++) {
	      e[n] = t.get(n).intValue();
	    }return e;
	  }, Or(wn.prototype, { getCoordinates: function getCoordinates() {
	      return this.pts;
	    }, getMaxX: function getMaxX(t) {
	      var e = this.pts[this.startIndex[t]].x,
	          n = this.pts[this.startIndex[t + 1]].x;return e > n ? e : n;
	    }, getMinX: function getMinX(t) {
	      var e = this.pts[this.startIndex[t]].x,
	          n = this.pts[this.startIndex[t + 1]].x;return e < n ? e : n;
	    }, computeIntersectsForChain: function computeIntersectsForChain() {
	      if (4 === arguments.length) {
	        var t = arguments[0],
	            e = arguments[1],
	            n = arguments[2],
	            i = arguments[3];this.computeIntersectsForChain(this.startIndex[t], this.startIndex[t + 1], e, e.startIndex[n], e.startIndex[n + 1], i);
	      } else if (6 === arguments.length) {
	        var r = arguments[0],
	            s = arguments[1],
	            o = arguments[2],
	            a = arguments[3],
	            u = arguments[4],
	            l = arguments[5],
	            h = this.pts[r],
	            c = this.pts[s],
	            f = o.pts[a],
	            g = o.pts[u];if (s - r == 1 && u - a == 1) return l.addIntersections(this.e, r, o.e, a), null;if (this.env1.init(h, c), this.env2.init(f, g), !this.env1.intersects(this.env2)) return null;var d = Math.trunc((r + s) / 2),
	            p = Math.trunc((a + u) / 2);r < d && (a < p && this.computeIntersectsForChain(r, d, o, a, p, l), p < u && this.computeIntersectsForChain(r, d, o, p, u, l)), d < s && (a < p && this.computeIntersectsForChain(d, s, o, a, p, l), p < u && this.computeIntersectsForChain(d, s, o, p, u, l));
	      }
	    }, getStartIndexes: function getStartIndexes() {
	      return this.startIndex;
	    }, computeIntersects: function computeIntersects(t, e) {
	      for (var n = 0; n < this.startIndex.length - 1; n++) {
	        for (var i = 0; i < t.startIndex.length - 1; i++) {
	          this.computeIntersectsForChain(n, t, i, e);
	        }
	      }
	    }, interfaces_: function interfaces_() {
	      return [];
	    }, getClass: function getClass() {
	      return wn;
	    } }), Or(Tn.prototype, { getDepth: function getDepth(t, e) {
	      return this.depth[t][e];
	    }, setDepth: function setDepth(t, e, n) {
	      this.depth[t][e] = n;
	    }, isNull: function isNull() {
	      if (0 === arguments.length) {
	        for (var t = 0; t < 2; t++) {
	          for (var e = 0; e < 3; e++) {
	            if (this.depth[t][e] !== Tn.NULL_VALUE) return !1;
	          }
	        }return !0;
	      }if (1 === arguments.length) {
	        var n = arguments[0];return this.depth[n][1] === Tn.NULL_VALUE;
	      }if (2 === arguments.length) {
	        var i = arguments[0],
	            r = arguments[1];return this.depth[i][r] === Tn.NULL_VALUE;
	      }
	    }, normalize: function normalize() {
	      for (var t = 0; t < 2; t++) {
	        if (!this.isNull(t)) {
	          var e = this.depth[t][1];this.depth[t][2] < e && (e = this.depth[t][2]), e < 0 && (e = 0);for (var n = 1; n < 3; n++) {
	            var i = 0;this.depth[t][n] > e && (i = 1), this.depth[t][n] = i;
	          }
	        }
	      }
	    }, getDelta: function getDelta(t) {
	      return this.depth[t][Pe.RIGHT] - this.depth[t][Pe.LEFT];
	    }, getLocation: function getLocation(t, e) {
	      return this.depth[t][e] <= 0 ? S.EXTERIOR : S.INTERIOR;
	    }, toString: function toString() {
	      return "A: " + this.depth[0][1] + "," + this.depth[0][2] + " B: " + this.depth[1][1] + "," + this.depth[1][2];
	    }, add: function add() {
	      if (1 === arguments.length) for (var t = arguments[0], e = 0; e < 2; e++) {
	        for (var n = 1; n < 3; n++) {
	          var i = t.getLocation(e, n);i !== S.EXTERIOR && i !== S.INTERIOR || (this.isNull(e, n) ? this.depth[e][n] = Tn.depthAtLocation(i) : this.depth[e][n] += Tn.depthAtLocation(i));
	        }
	      } else if (3 === arguments.length) {
	        var r = arguments[0],
	            s = arguments[1],
	            o = arguments[2];o === S.INTERIOR && this.depth[r][s]++;
	      }
	    }, interfaces_: function interfaces_() {
	      return [];
	    }, getClass: function getClass() {
	      return Tn;
	    } }), Tn.depthAtLocation = function (t) {
	    return t === S.EXTERIOR ? 0 : t === S.INTERIOR ? 1 : Tn.NULL_VALUE;
	  }, Tn.NULL_VALUE = -1, br(On, Xe), Or(On.prototype, { getDepth: function getDepth() {
	      return this.depth;
	    }, getCollapsedEdge: function getCollapsedEdge() {
	      var t = new Array(2).fill(null);return t[0] = this.pts[0], t[1] = this.pts[1], new On(t, Ae.toLineLabel(this.label));
	    }, isIsolated: function isIsolated() {
	      return this._isIsolated;
	    }, getCoordinates: function getCoordinates() {
	      return this.pts;
	    }, setIsolated: function setIsolated(t) {
	      this._isIsolated = t;
	    }, setName: function setName(t) {
	      this.name = t;
	    }, equals: function equals(t) {
	      if (!(t instanceof On)) return !1;var e = t;if (this.pts.length !== e.pts.length) return !1;for (var n = !0, i = !0, r = this.pts.length, s = 0; s < this.pts.length; s++) {
	        if (this.pts[s].equals2D(e.pts[s]) || (n = !1), this.pts[s].equals2D(e.pts[--r]) || (i = !1), !n && !i) return !1;
	      }return !0;
	    }, getCoordinate: function getCoordinate() {
	      if (0 === arguments.length) return this.pts.length > 0 ? this.pts[0] : null;if (1 === arguments.length) {
	        var t = arguments[0];return this.pts[t];
	      }
	    }, print: function print(t) {
	      t.print("edge " + this.name + ": "), t.print("LINESTRING (");for (var e = 0; e < this.pts.length; e++) {
	        e > 0 && t.print(","), t.print(this.pts[e].x + " " + this.pts[e].y);
	      }t.print(")  " + this.label + " " + this.depthDelta);
	    }, computeIM: function computeIM(t) {
	      On.updateIM(this.label, t);
	    }, isCollapsed: function isCollapsed() {
	      return !!this.label.isArea() && 3 === this.pts.length && !!this.pts[0].equals(this.pts[2]);
	    }, isClosed: function isClosed() {
	      return this.pts[0].equals(this.pts[this.pts.length - 1]);
	    }, getMaximumSegmentIndex: function getMaximumSegmentIndex() {
	      return this.pts.length - 1;
	    }, getDepthDelta: function getDepthDelta() {
	      return this.depthDelta;
	    }, getNumPoints: function getNumPoints() {
	      return this.pts.length;
	    }, printReverse: function printReverse(t) {
	      t.print("edge " + this.name + ": ");for (var e = this.pts.length - 1; e >= 0; e--) {
	        t.print(this.pts[e] + " ");
	      }t.println("");
	    }, getMonotoneChainEdge: function getMonotoneChainEdge() {
	      return null === this.mce && (this.mce = new wn(this)), this.mce;
	    }, getEnvelope: function getEnvelope() {
	      if (null === this.env) {
	        this.env = new x();for (var t = 0; t < this.pts.length; t++) {
	          this.env.expandToInclude(this.pts[t]);
	        }
	      }return this.env;
	    }, addIntersection: function addIntersection(t, e, n, i) {
	      var r = new c(t.getIntersection(i)),
	          s = e,
	          o = t.getEdgeDistance(n, i),
	          a = s + 1;if (a < this.pts.length) {
	        var u = this.pts[a];r.equals2D(u) && (s = a, o = 0);
	      }this.eiList.add(r, s, o);
	    }, toString: function toString() {
	      var t = new R();t.append("edge " + this.name + ": "), t.append("LINESTRING (");for (var e = 0; e < this.pts.length; e++) {
	        e > 0 && t.append(","), t.append(this.pts[e].x + " " + this.pts[e].y);
	      }return t.append(")  " + this.label + " " + this.depthDelta), t.toString();
	    }, isPointwiseEqual: function isPointwiseEqual(t) {
	      if (this.pts.length !== t.pts.length) return !1;for (var e = 0; e < this.pts.length; e++) {
	        if (!this.pts[e].equals2D(t.pts[e])) return !1;
	      }return !0;
	    }, setDepthDelta: function setDepthDelta(t) {
	      this.depthDelta = t;
	    }, getEdgeIntersectionList: function getEdgeIntersectionList() {
	      return this.eiList;
	    }, addIntersections: function addIntersections(t, e, n) {
	      for (var i = 0; i < t.getIntersectionNum(); i++) {
	        this.addIntersection(t, e, n, i);
	      }
	    }, interfaces_: function interfaces_() {
	      return [];
	    }, getClass: function getClass() {
	      return On;
	    } }), On.updateIM = function () {
	    if (2 !== arguments.length) return Xe.prototype.updateIM.apply(this, arguments);var t = arguments[0],
	        e = arguments[1];e.setAtLeastIfValid(t.getLocation(0, Pe.ON), t.getLocation(1, Pe.ON), 1), t.isArea() && (e.setAtLeastIfValid(t.getLocation(0, Pe.LEFT), t.getLocation(1, Pe.LEFT), 2), e.setAtLeastIfValid(t.getLocation(0, Pe.RIGHT), t.getLocation(1, Pe.RIGHT), 2));
	  }, br(bn, Je), Or(bn.prototype, { insertBoundaryPoint: function insertBoundaryPoint(t, e) {
	      var n = this.nodes.addNode(e),
	          i = n.getLabel(),
	          r = 1,
	          s = S.NONE;(s = i.getLocation(t, Pe.ON)) === S.BOUNDARY && r++;var o = bn.determineBoundary(this.boundaryNodeRule, r);i.setLocation(t, o);
	    }, computeSelfNodes: function computeSelfNodes() {
	      if (2 === arguments.length) {
	        var t = arguments[0],
	            e = arguments[1];return this.computeSelfNodes(t, e, !1);
	      }if (3 === arguments.length) {
	        var n = arguments[0],
	            i = arguments[1],
	            r = arguments[2],
	            s = new dn(n, !0, !1);s.setIsDoneIfProperInt(r);var o = this.createEdgeSetIntersector(),
	            a = this.parentGeom instanceof wt || this.parentGeom instanceof Lt || this.parentGeom instanceof Tt,
	            u = i || !a;return o.computeIntersections(this.edges, s, u), this.addSelfIntersectionNodes(this.argIndex), s;
	      }
	    }, computeSplitEdges: function computeSplitEdges(t) {
	      for (var e = this.edges.iterator(); e.hasNext();) {
	        e.next().eiList.addSplitEdges(t);
	      }
	    }, computeEdgeIntersections: function computeEdgeIntersections(t, e, n) {
	      var i = new dn(e, n, !0);return i.setBoundaryNodes(this.getBoundaryNodes(), t.getBoundaryNodes()), this.createEdgeSetIntersector().computeIntersections(this.edges, t.edges, i), i;
	    }, getGeometry: function getGeometry() {
	      return this.parentGeom;
	    }, getBoundaryNodeRule: function getBoundaryNodeRule() {
	      return this.boundaryNodeRule;
	    }, hasTooFewPoints: function hasTooFewPoints() {
	      return this._hasTooFewPoints;
	    }, addPoint: function addPoint() {
	      if (arguments[0] instanceof Ct) {
	        var t = arguments[0],
	            e = t.getCoordinate();this.insertPoint(this.argIndex, e, S.INTERIOR);
	      } else if (arguments[0] instanceof c) {
	        var n = arguments[0];this.insertPoint(this.argIndex, n, S.INTERIOR);
	      }
	    }, addPolygon: function addPolygon(t) {
	      this.addPolygonRing(t.getExteriorRing(), S.EXTERIOR, S.INTERIOR);for (var e = 0; e < t.getNumInteriorRing(); e++) {
	        var n = t.getInteriorRingN(e);this.addPolygonRing(n, S.INTERIOR, S.EXTERIOR);
	      }
	    }, addEdge: function addEdge(t) {
	      this.insertEdge(t);var e = t.getCoordinates();this.insertPoint(this.argIndex, e[0], S.BOUNDARY), this.insertPoint(this.argIndex, e[e.length - 1], S.BOUNDARY);
	    }, addLineString: function addLineString(t) {
	      var e = X.removeRepeatedPoints(t.getCoordinates());if (e.length < 2) return this._hasTooFewPoints = !0, this.invalidPoint = e[0], null;var n = new On(e, new Ae(this.argIndex, S.INTERIOR));this.lineEdgeMap.put(t, n), this.insertEdge(n), h.isTrue(e.length >= 2, "found LineString with single point"), this.insertBoundaryPoint(this.argIndex, e[0]), this.insertBoundaryPoint(this.argIndex, e[e.length - 1]);
	    }, getInvalidPoint: function getInvalidPoint() {
	      return this.invalidPoint;
	    }, getBoundaryPoints: function getBoundaryPoints() {
	      for (var t = this.getBoundaryNodes(), e = new Array(t.size()).fill(null), n = 0, i = t.iterator(); i.hasNext();) {
	        var r = i.next();e[n++] = r.getCoordinate().copy();
	      }return e;
	    }, getBoundaryNodes: function getBoundaryNodes() {
	      return null === this.boundaryNodes && (this.boundaryNodes = this.nodes.getBoundaryNodes(this.argIndex)), this.boundaryNodes;
	    }, addSelfIntersectionNode: function addSelfIntersectionNode(t, e, n) {
	      if (this.isBoundaryNode(t, e)) return null;n === S.BOUNDARY && this.useBoundaryDeterminationRule ? this.insertBoundaryPoint(t, e) : this.insertPoint(t, e, n);
	    }, addPolygonRing: function addPolygonRing(t, e, n) {
	      if (t.isEmpty()) return null;var i = X.removeRepeatedPoints(t.getCoordinates());if (i.length < 4) return this._hasTooFewPoints = !0, this.invalidPoint = i[0], null;var r = e,
	          s = n;oe.isCCW(i) && (r = n, s = e);var o = new On(i, new Ae(this.argIndex, S.BOUNDARY, r, s));this.lineEdgeMap.put(t, o), this.insertEdge(o), this.insertPoint(this.argIndex, i[0], S.BOUNDARY);
	    }, insertPoint: function insertPoint(t, e, n) {
	      var i = this.nodes.addNode(e),
	          r = i.getLabel();null === r ? i.label = new Ae(t, n) : r.setLocation(t, n);
	    }, createEdgeSetIntersector: function createEdgeSetIntersector() {
	      return new pn();
	    }, addSelfIntersectionNodes: function addSelfIntersectionNodes(t) {
	      for (var e = this.edges.iterator(); e.hasNext();) {
	        for (var n = e.next(), i = n.getLabel().getLocation(t), r = n.eiList.iterator(); r.hasNext();) {
	          var s = r.next();this.addSelfIntersectionNode(t, s.coord, i);
	        }
	      }
	    }, add: function add() {
	      if (1 !== arguments.length) return Je.prototype.add.apply(this, arguments);var t = arguments[0];if (t.isEmpty()) return null;if (t instanceof Tt && (this.useBoundaryDeterminationRule = !1), t instanceof Lt) this.addPolygon(t);else if (t instanceof xt) this.addLineString(t);else if (t instanceof Ct) this.addPoint(t);else if (t instanceof Rt) this.addCollection(t);else if (t instanceof ht) this.addCollection(t);else if (t instanceof Tt) this.addCollection(t);else {
	        if (!(t instanceof lt)) throw new UnsupportedOperationException(t.getClass().getName());this.addCollection(t);
	      }
	    }, addCollection: function addCollection(t) {
	      for (var e = 0; e < t.getNumGeometries(); e++) {
	        var n = t.getGeometryN(e);this.add(n);
	      }
	    }, locate: function locate(t) {
	      return _r(this.parentGeom, St) && this.parentGeom.getNumGeometries() > 50 ? (null === this.areaPtLocator && (this.areaPtLocator = new xn(this.parentGeom)), this.areaPtLocator.locate(t)) : this.ptLocator.locate(t, this.parentGeom);
	    }, findEdge: function findEdge() {
	      if (1 === arguments.length) {
	        var t = arguments[0];return this.lineEdgeMap.get(t);
	      }return Je.prototype.findEdge.apply(this, arguments);
	    }, interfaces_: function interfaces_() {
	      return [];
	    }, getClass: function getClass() {
	      return bn;
	    } }), bn.determineBoundary = function (t, e) {
	    return t.isInBoundary(e) ? S.BOUNDARY : S.INTERIOR;
	  }, Or(Pn.prototype, { createEdgeEndForNext: function createEdgeEndForNext(t, e, n, i) {
	      var r = n.segmentIndex + 1;if (r >= t.getNumPoints() && null === i) return null;var s = t.getCoordinate(r);null !== i && i.segmentIndex === n.segmentIndex && (s = i.coord);var o = new je(t, n.coord, s, new Ae(t.getLabel()));e.add(o);
	    }, createEdgeEndForPrev: function createEdgeEndForPrev(t, e, n, i) {
	      var r = n.segmentIndex;if (0 === n.dist) {
	        if (0 === r) return null;r--;
	      }var s = t.getCoordinate(r);null !== i && i.segmentIndex >= r && (s = i.coord);var o = new Ae(t.getLabel());o.flip();var a = new je(t, n.coord, s, o);e.add(a);
	    }, computeEdgeEnds: function computeEdgeEnds() {
	      if (1 === arguments.length) {
	        for (var t = arguments[0], e = new I(), n = t; n.hasNext();) {
	          var i = n.next();this.computeEdgeEnds(i, e);
	        }return e;
	      }if (2 === arguments.length) {
	        var r = arguments[0],
	            s = arguments[1],
	            o = r.getEdgeIntersectionList();o.addEndpoints();var a = o.iterator(),
	            u = null,
	            l = null;if (!a.hasNext()) return null;var h = a.next();do {
	          u = l, l = h, h = null, a.hasNext() && (h = a.next()), null !== l && (this.createEdgeEndForPrev(r, s, l, u), this.createEdgeEndForNext(r, s, l, h));
	        } while (null !== l);
	      }
	    }, interfaces_: function interfaces_() {
	      return [];
	    }, getClass: function getClass() {
	      return Pn;
	    } }), br(_n, je), Or(_n.prototype, { insert: function insert(t) {
	      this.edgeEnds.add(t);
	    }, print: function print(t) {
	      t.println("EdgeEndBundle--> Label: " + this.label);for (var e = this.iterator(); e.hasNext();) {
	        e.next().print(t), t.println();
	      }
	    }, iterator: function iterator() {
	      return this.edgeEnds.iterator();
	    }, getEdgeEnds: function getEdgeEnds() {
	      return this.edgeEnds;
	    }, computeLabelOn: function computeLabelOn(t, e) {
	      for (var n = 0, i = !1, r = this.iterator(); r.hasNext();) {
	        var s = r.next(),
	            o = s.getLabel().getLocation(t);o === S.BOUNDARY && n++, o === S.INTERIOR && (i = !0);
	      }var o = S.NONE;i && (o = S.INTERIOR), n > 0 && (o = bn.determineBoundary(e, n)), this.label.setLocation(t, o);
	    }, computeLabelSide: function computeLabelSide(t, e) {
	      for (var n = this.iterator(); n.hasNext();) {
	        var i = n.next();if (i.getLabel().isArea()) {
	          var r = i.getLabel().getLocation(t, e);if (r === S.INTERIOR) return this.label.setLocation(t, e, S.INTERIOR), null;r === S.EXTERIOR && this.label.setLocation(t, e, S.EXTERIOR);
	        }
	      }
	    }, getLabel: function getLabel() {
	      return this.label;
	    }, computeLabelSides: function computeLabelSides(t) {
	      this.computeLabelSide(t, Pe.LEFT), this.computeLabelSide(t, Pe.RIGHT);
	    }, updateIM: function updateIM(t) {
	      On.updateIM(this.label, t);
	    }, computeLabel: function computeLabel(t) {
	      for (var e = !1, n = this.iterator(); n.hasNext();) {
	        n.next().getLabel().isArea() && (e = !0);
	      }this.label = e ? new Ae(S.NONE, S.NONE, S.NONE) : new Ae(S.NONE);for (var i = 0; i < 2; i++) {
	        this.computeLabelOn(i, t), e && this.computeLabelSides(i);
	      }
	    }, interfaces_: function interfaces_() {
	      return [];
	    }, getClass: function getClass() {
	      return _n;
	    } }), br(Mn, ze), Or(Mn.prototype, { updateIM: function updateIM(t) {
	      for (var e = this.iterator(); e.hasNext();) {
	        e.next().updateIM(t);
	      }
	    }, insert: function insert(t) {
	      var e = this.edgeMap.get(t);null === e ? (e = new _n(t), this.insertEdgeEnd(t, e)) : e.insert(t);
	    }, interfaces_: function interfaces_() {
	      return [];
	    }, getClass: function getClass() {
	      return Mn;
	    } }), br(An, ke), Or(An.prototype, { updateIMFromEdges: function updateIMFromEdges(t) {
	      this.edges.updateIM(t);
	    }, computeIM: function computeIM(t) {
	      t.setAtLeastIfValid(this.label.getLocation(0), this.label.getLocation(1), 0);
	    }, interfaces_: function interfaces_() {
	      return [];
	    }, getClass: function getClass() {
	      return An;
	    } }), br(Dn, Ve), Or(Dn.prototype, { createNode: function createNode(t) {
	      return new An(t, new Mn());
	    }, interfaces_: function interfaces_() {
	      return [];
	    }, getClass: function getClass() {
	      return Dn;
	    } }), Or(Fn.prototype, { insertEdgeEnds: function insertEdgeEnds(t) {
	      for (var e = t.iterator(); e.hasNext();) {
	        var n = e.next();this.nodes.add(n);
	      }
	    }, getNodeIterator: function getNodeIterator() {
	      return this.nodes.iterator();
	    }, copyNodesAndLabels: function copyNodesAndLabels(t, e) {
	      for (var n = t.getNodeIterator(); n.hasNext();) {
	        var i = n.next();this.nodes.addNode(i.getCoordinate()).setLabel(e, i.getLabel().getLocation(e));
	      }
	    }, build: function build(t) {
	      this.computeIntersectionNodes(t, 0), this.copyNodesAndLabels(t, 0);var e = new Pn(),
	          n = e.computeEdgeEnds(t.getEdgeIterator());this.insertEdgeEnds(n);
	    }, computeIntersectionNodes: function computeIntersectionNodes(t, e) {
	      for (var n = t.getEdgeIterator(); n.hasNext();) {
	        for (var i = n.next(), r = i.getLabel().getLocation(e), s = i.getEdgeIntersectionList().iterator(); s.hasNext();) {
	          var o = s.next(),
	              a = this.nodes.addNode(o.coord);r === S.BOUNDARY ? a.setLabelBoundary(e) : a.getLabel().isNull(e) && a.setLabel(e, S.INTERIOR);
	        }
	      }
	    }, interfaces_: function interfaces_() {
	      return [];
	    }, getClass: function getClass() {
	      return Fn;
	    } }), Or(Gn.prototype, { isNodeEdgeAreaLabelsConsistent: function isNodeEdgeAreaLabelsConsistent() {
	      for (var t = this.nodeGraph.getNodeIterator(); t.hasNext();) {
	        var e = t.next();if (!e.getEdges().isAreaLabelsConsistent(this.geomGraph)) return this.invalidPoint = e.getCoordinate().copy(), !1;
	      }return !0;
	    }, getInvalidPoint: function getInvalidPoint() {
	      return this.invalidPoint;
	    }, hasDuplicateRings: function hasDuplicateRings() {
	      for (var t = this.nodeGraph.getNodeIterator(); t.hasNext();) {
	        for (var e = t.next(), n = e.getEdges().iterator(); n.hasNext();) {
	          var i = n.next();if (i.getEdgeEnds().size() > 1) return this.invalidPoint = i.getEdge().getCoordinate(0), !0;
	        }
	      }return !1;
	    }, isNodeConsistentArea: function isNodeConsistentArea() {
	      var t = this.geomGraph.computeSelfNodes(this.li, !0, !0);return t.hasProperIntersection() ? (this.invalidPoint = t.getProperIntersectionPoint(), !1) : (this.nodeGraph.build(this.geomGraph), this.isNodeEdgeAreaLabelsConsistent());
	    }, interfaces_: function interfaces_() {
	      return [];
	    }, getClass: function getClass() {
	      return Gn;
	    } }), Or(Bn.prototype, { getBounds: function getBounds() {}, interfaces_: function interfaces_() {
	      return [];
	    }, getClass: function getClass() {
	      return Bn;
	    } }), Or(qn.prototype, { getItem: function getItem() {
	      return this.item;
	    }, getBounds: function getBounds() {
	      return this.bounds;
	    }, interfaces_: function interfaces_() {
	      return [Bn, a];
	    }, getClass: function getClass() {
	      return qn;
	    } }), Or(zn.prototype, { poll: function poll() {
	      if (this.isEmpty()) return null;var t = this.items.get(1);return this.items.set(1, this.items.get(this._size)), this._size -= 1, this.reorder(1), t;
	    }, size: function size() {
	      return this._size;
	    }, reorder: function reorder(t) {
	      for (var e = null, n = this.items.get(t); 2 * t <= this._size && (e = 2 * t, e !== this._size && this.items.get(e + 1).compareTo(this.items.get(e)) < 0 && e++, this.items.get(e).compareTo(n) < 0); t = e) {
	        this.items.set(t, this.items.get(e));
	      }this.items.set(t, n);
	    }, clear: function clear() {
	      this._size = 0, this.items.clear();
	    }, isEmpty: function isEmpty() {
	      return 0 === this._size;
	    }, add: function add(t) {
	      this.items.add(null), this._size += 1;var e = this._size;for (this.items.set(0, t); t.compareTo(this.items.get(Math.trunc(e / 2))) < 0; e /= 2) {
	        this.items.set(e, this.items.get(Math.trunc(e / 2)));
	      }this.items.set(e, t);
	    }, interfaces_: function interfaces_() {
	      return [];
	    }, getClass: function getClass() {
	      return zn;
	    } }), Or(Un.prototype, { getLevel: function getLevel() {
	      return this.level;
	    }, size: function size() {
	      return this.childBoundables.size();
	    }, getChildBoundables: function getChildBoundables() {
	      return this.childBoundables;
	    }, addChildBoundable: function addChildBoundable(t) {
	      h.isTrue(null === this.bounds), this.childBoundables.add(t);
	    }, isEmpty: function isEmpty() {
	      return this.childBoundables.isEmpty();
	    }, getBounds: function getBounds() {
	      return null === this.bounds && (this.bounds = this.computeBounds()), this.bounds;
	    }, interfaces_: function interfaces_() {
	      return [Bn, a];
	    }, getClass: function getClass() {
	      return Un;
	    } }), Un.serialVersionUID = 0x5a1e55ec41369800, Or(Yn.prototype, { expandToQueue: function expandToQueue(t, e) {
	      var i = Yn.isComposite(this.boundable1),
	          r = Yn.isComposite(this.boundable2);if (i && r) return Yn.area(this.boundable1) > Yn.area(this.boundable2) ? (this.expand(this.boundable1, this.boundable2, t, e), null) : (this.expand(this.boundable2, this.boundable1, t, e), null);if (i) return this.expand(this.boundable1, this.boundable2, t, e), null;if (r) return this.expand(this.boundable2, this.boundable1, t, e), null;throw new n("neither boundable is composite");
	    }, isLeaves: function isLeaves() {
	      return !(Yn.isComposite(this.boundable1) || Yn.isComposite(this.boundable2));
	    }, compareTo: function compareTo(t) {
	      var e = t;return this._distance < e._distance ? -1 : this._distance > e._distance ? 1 : 0;
	    }, expand: function expand(t, e, n, i) {
	      for (var r = t.getChildBoundables(), s = r.iterator(); s.hasNext();) {
	        var o = s.next(),
	            a = new Yn(o, e, this.itemDistance);a.getDistance() < i && n.add(a);
	      }
	    }, getBoundable: function getBoundable(t) {
	      return 0 === t ? this.boundable1 : this.boundable2;
	    }, getDistance: function getDistance() {
	      return this._distance;
	    }, distance: function distance() {
	      return this.isLeaves() ? this.itemDistance.distance(this.boundable1, this.boundable2) : this.boundable1.getBounds().distance(this.boundable2.getBounds());
	    }, interfaces_: function interfaces_() {
	      return [r];
	    }, getClass: function getClass() {
	      return Yn;
	    } }), Yn.area = function (t) {
	    return t.getBounds().getArea();
	  }, Yn.isComposite = function (t) {
	    return t instanceof Un;
	  }, Or(Xn.prototype, { getNodeCapacity: function getNodeCapacity() {
	      return this.nodeCapacity;
	    }, lastNode: function lastNode(t) {
	      return t.get(t.size() - 1);
	    }, size: function size() {
	      if (0 === arguments.length) return this.isEmpty() ? 0 : (this.build(), this.size(this.root));if (1 === arguments.length) {
	        for (var t = arguments[0], e = 0, n = t.getChildBoundables().iterator(); n.hasNext();) {
	          var i = n.next();i instanceof Un ? e += this.size(i) : i instanceof qn && (e += 1);
	        }return e;
	      }
	    }, removeItem: function removeItem(t, e) {
	      for (var n = null, i = t.getChildBoundables().iterator(); i.hasNext();) {
	        var r = i.next();r instanceof qn && r.getItem() === e && (n = r);
	      }return null !== n && (t.getChildBoundables().remove(n), !0);
	    }, itemsTree: function itemsTree() {
	      if (0 === arguments.length) {
	        this.build();var t = this.itemsTree(this.root);return null === t ? new I() : t;
	      }if (1 === arguments.length) {
	        for (var e = arguments[0], n = new I(), i = e.getChildBoundables().iterator(); i.hasNext();) {
	          var r = i.next();if (r instanceof Un) {
	            var s = this.itemsTree(r);null !== s && n.add(s);
	          } else r instanceof qn ? n.add(r.getItem()) : h.shouldNeverReachHere();
	        }return n.size() <= 0 ? null : n;
	      }
	    }, insert: function insert(t, e) {
	      h.isTrue(!this.built, "Cannot insert items into an STR packed R-tree after it has been built."), this.itemBoundables.add(new qn(t, e));
	    }, boundablesAtLevel: function boundablesAtLevel() {
	      if (1 === arguments.length) {
	        var t = arguments[0],
	            e = new I();return this.boundablesAtLevel(t, this.root, e), e;
	      }if (3 === arguments.length) {
	        var n = arguments[0],
	            i = arguments[1],
	            r = arguments[2];if (h.isTrue(n > -2), i.getLevel() === n) return r.add(i), null;for (var s = i.getChildBoundables().iterator(); s.hasNext();) {
	          var o = s.next();o instanceof Un ? this.boundablesAtLevel(n, o, r) : (h.isTrue(o instanceof qn), n === -1 && r.add(o));
	        }return null;
	      }
	    }, query: function query() {
	      if (1 === arguments.length) {
	        var t = arguments[0];this.build();var e = new I();return this.isEmpty() ? e : (this.getIntersectsOp().intersects(this.root.getBounds(), t) && this.query(t, this.root, e), e);
	      }if (2 === arguments.length) {
	        var n = arguments[0],
	            i = arguments[1];if (this.build(), this.isEmpty()) return null;this.getIntersectsOp().intersects(this.root.getBounds(), n) && this.query(n, this.root, i);
	      } else if (3 === arguments.length) if (_r(arguments[2], me) && arguments[0] instanceof Object && arguments[1] instanceof Un) for (var r = arguments[0], s = arguments[1], o = arguments[2], a = s.getChildBoundables(), u = 0; u < a.size(); u++) {
	        var l = a.get(u);this.getIntersectsOp().intersects(l.getBounds(), r) && (l instanceof Un ? this.query(r, l, o) : l instanceof qn ? o.visitItem(l.getItem()) : h.shouldNeverReachHere());
	      } else if (_r(arguments[2], m) && arguments[0] instanceof Object && arguments[1] instanceof Un) for (var c = arguments[0], f = arguments[1], g = arguments[2], a = f.getChildBoundables(), u = 0; u < a.size(); u++) {
	        var l = a.get(u);this.getIntersectsOp().intersects(l.getBounds(), c) && (l instanceof Un ? this.query(c, l, g) : l instanceof qn ? g.add(l.getItem()) : h.shouldNeverReachHere());
	      }
	    }, build: function build() {
	      if (this.built) return null;this.root = this.itemBoundables.isEmpty() ? this.createNode(0) : this.createHigherLevels(this.itemBoundables, -1), this.itemBoundables = null, this.built = !0;
	    }, getRoot: function getRoot() {
	      return this.build(), this.root;
	    }, remove: function remove() {
	      if (2 === arguments.length) {
	        var t = arguments[0],
	            e = arguments[1];return this.build(), !!this.getIntersectsOp().intersects(this.root.getBounds(), t) && this.remove(t, this.root, e);
	      }if (3 === arguments.length) {
	        var n = arguments[0],
	            i = arguments[1],
	            r = arguments[2],
	            s = this.removeItem(i, r);if (s) return !0;for (var o = null, a = i.getChildBoundables().iterator(); a.hasNext();) {
	          var u = a.next();if (this.getIntersectsOp().intersects(u.getBounds(), n) && u instanceof Un && (s = this.remove(n, u, r))) {
	            o = u;break;
	          }
	        }return null !== o && o.getChildBoundables().isEmpty() && i.getChildBoundables().remove(o), s;
	      }
	    }, createHigherLevels: function createHigherLevels(t, e) {
	      h.isTrue(!t.isEmpty());var n = this.createParentBoundables(t, e + 1);return 1 === n.size() ? n.get(0) : this.createHigherLevels(n, e + 1);
	    }, depth: function depth() {
	      if (0 === arguments.length) return this.isEmpty() ? 0 : (this.build(), this.depth(this.root));if (1 === arguments.length) {
	        for (var t = arguments[0], e = 0, n = t.getChildBoundables().iterator(); n.hasNext();) {
	          var i = n.next();if (i instanceof Un) {
	            var r = this.depth(i);r > e && (e = r);
	          }
	        }return e + 1;
	      }
	    }, createParentBoundables: function createParentBoundables(t, e) {
	      h.isTrue(!t.isEmpty());var n = new I();n.add(this.createNode(e));var i = new I(t);Jr.sort(i, this.getComparator());for (var r = i.iterator(); r.hasNext();) {
	        var s = r.next();this.lastNode(n).getChildBoundables().size() === this.getNodeCapacity() && n.add(this.createNode(e)), this.lastNode(n).addChildBoundable(s);
	      }return n;
	    }, isEmpty: function isEmpty() {
	      return this.built ? this.root.isEmpty() : this.itemBoundables.isEmpty();
	    }, interfaces_: function interfaces_() {
	      return [a];
	    }, getClass: function getClass() {
	      return Xn;
	    } }), Xn.compareDoubles = function (t, e) {
	    return t > e ? 1 : t < e ? -1 : 0;
	  }, Xn.IntersectsOp = kn, Xn.serialVersionUID = -0x35ef64c82d4c5400, Xn.DEFAULT_NODE_CAPACITY = 10, Or(Vn.prototype, { distance: function distance(t, e) {}, interfaces_: function interfaces_() {
	      return [];
	    }, getClass: function getClass() {
	      return Vn;
	    } }), br(Hn, Xn), Or(Hn.prototype, { createParentBoundablesFromVerticalSlices: function createParentBoundablesFromVerticalSlices(t, e) {
	      h.isTrue(t.length > 0);for (var n = new I(), i = 0; i < t.length; i++) {
	        n.addAll(this.createParentBoundablesFromVerticalSlice(t[i], e));
	      }return n;
	    }, createNode: function createNode(t) {
	      return new Wn(t);
	    }, size: function size() {
	      return 0 === arguments.length ? Xn.prototype.size.call(this) : Xn.prototype.size.apply(this, arguments);
	    }, insert: function insert() {
	      if (2 !== arguments.length) return Xn.prototype.insert.apply(this, arguments);var t = arguments[0],
	          e = arguments[1];if (t.isNull()) return null;Xn.prototype.insert.call(this, t, e);
	    }, getIntersectsOp: function getIntersectsOp() {
	      return Hn.intersectsOp;
	    }, verticalSlices: function verticalSlices(t, e) {
	      for (var n = Math.trunc(Math.ceil(t.size() / e)), i = new Array(e).fill(null), r = t.iterator(), s = 0; s < e; s++) {
	        i[s] = new I();for (var o = 0; r.hasNext() && o < n;) {
	          var a = r.next();i[s].add(a), o++;
	        }
	      }return i;
	    }, query: function query() {
	      if (1 === arguments.length) {
	        var t = arguments[0];return Xn.prototype.query.call(this, t);
	      }if (2 === arguments.length) {
	        var e = arguments[0],
	            n = arguments[1];Xn.prototype.query.call(this, e, n);
	      } else if (3 === arguments.length) if (_r(arguments[2], me) && arguments[0] instanceof Object && arguments[1] instanceof Un) {
	        var i = arguments[0],
	            r = arguments[1],
	            s = arguments[2];Xn.prototype.query.call(this, i, r, s);
	      } else if (_r(arguments[2], m) && arguments[0] instanceof Object && arguments[1] instanceof Un) {
	        var o = arguments[0],
	            a = arguments[1],
	            u = arguments[2];Xn.prototype.query.call(this, o, a, u);
	      }
	    }, getComparator: function getComparator() {
	      return Hn.yComparator;
	    }, createParentBoundablesFromVerticalSlice: function createParentBoundablesFromVerticalSlice(t, e) {
	      return Xn.prototype.createParentBoundables.call(this, t, e);
	    }, remove: function remove() {
	      if (2 === arguments.length) {
	        var t = arguments[0],
	            e = arguments[1];return Xn.prototype.remove.call(this, t, e);
	      }return Xn.prototype.remove.apply(this, arguments);
	    }, depth: function depth() {
	      return 0 === arguments.length ? Xn.prototype.depth.call(this) : Xn.prototype.depth.apply(this, arguments);
	    }, createParentBoundables: function createParentBoundables(t, e) {
	      h.isTrue(!t.isEmpty());var n = Math.trunc(Math.ceil(t.size() / this.getNodeCapacity())),
	          i = new I(t);Jr.sort(i, Hn.xComparator);var r = this.verticalSlices(i, Math.trunc(Math.ceil(Math.sqrt(n))));return this.createParentBoundablesFromVerticalSlices(r, e);
	    }, nearestNeighbour: function nearestNeighbour() {
	      if (1 === arguments.length) {
	        if (_r(arguments[0], Vn)) {
	          var t = arguments[0],
	              e = new Yn(this.getRoot(), this.getRoot(), t);return this.nearestNeighbour(e);
	        }if (arguments[0] instanceof Yn) {
	          var n = arguments[0];return this.nearestNeighbour(n, i.POSITIVE_INFINITY);
	        }
	      } else if (2 === arguments.length) {
	        if (arguments[0] instanceof Hn && _r(arguments[1], Vn)) {
	          var r = arguments[0],
	              s = arguments[1],
	              e = new Yn(this.getRoot(), r.getRoot(), s);return this.nearestNeighbour(e);
	        }if (arguments[0] instanceof Yn && "number" == typeof arguments[1]) {
	          var o = arguments[0],
	              a = arguments[1],
	              u = a,
	              l = null,
	              h = new zn();for (h.add(o); !h.isEmpty() && u > 0;) {
	            var c = h.poll(),
	                f = c.getDistance();if (f >= u) break;c.isLeaves() ? (u = f, l = c) : c.expandToQueue(h, u);
	          }return [l.getBoundable(0).getItem(), l.getBoundable(1).getItem()];
	        }
	      } else if (3 === arguments.length) {
	        var g = arguments[0],
	            d = arguments[1],
	            p = arguments[2],
	            m = new qn(g, d),
	            e = new Yn(this.getRoot(), m, p);return this.nearestNeighbour(e)[0];
	      }
	    }, interfaces_: function interfaces_() {
	      return [pe, a];
	    }, getClass: function getClass() {
	      return Hn;
	    } }), Hn.centreX = function (t) {
	    return Hn.avg(t.getMinX(), t.getMaxX());
	  }, Hn.avg = function (t, e) {
	    return (t + e) / 2;
	  }, Hn.centreY = function (t) {
	    return Hn.avg(t.getMinY(), t.getMaxY());
	  }, br(Wn, Un), Or(Wn.prototype, { computeBounds: function computeBounds() {
	      for (var t = null, e = this.getChildBoundables().iterator(); e.hasNext();) {
	        var n = e.next();null === t ? t = new x(n.getBounds()) : t.expandToInclude(n.getBounds());
	      }return t;
	    }, interfaces_: function interfaces_() {
	      return [];
	    }, getClass: function getClass() {
	      return Wn;
	    } }), Hn.STRtreeNode = Wn, Hn.serialVersionUID = 0x39920f7d5f261e0, Hn.xComparator = { interfaces_: function interfaces_() {
	      return [o];
	    }, compare: function compare(t, e) {
	      return Xn.compareDoubles(Hn.centreX(t.getBounds()), Hn.centreX(e.getBounds()));
	    } }, Hn.yComparator = { interfaces_: function interfaces_() {
	      return [o];
	    }, compare: function compare(t, e) {
	      return Xn.compareDoubles(Hn.centreY(t.getBounds()), Hn.centreY(e.getBounds()));
	    } }, Hn.intersectsOp = { interfaces_: function interfaces_() {
	      return [IntersectsOp];
	    }, intersects: function intersects(t, e) {
	      return t.intersects(e);
	    } }, Hn.DEFAULT_NODE_CAPACITY = 10, Or(jn.prototype, { buildIndex: function buildIndex() {
	      this.index = new Hn();for (var t = 0; t < this.rings.size(); t++) {
	        var e = this.rings.get(t),
	            n = e.getEnvelopeInternal();this.index.insert(n, e);
	      }
	    }, getNestedPoint: function getNestedPoint() {
	      return this.nestedPt;
	    }, isNonNested: function isNonNested() {
	      this.buildIndex();for (var t = 0; t < this.rings.size(); t++) {
	        for (var e = this.rings.get(t), n = e.getCoordinates(), i = this.index.query(e.getEnvelopeInternal()), r = 0; r < i.size(); r++) {
	          var s = i.get(r),
	              o = s.getCoordinates();if (e !== s && e.getEnvelopeInternal().intersects(s.getEnvelopeInternal())) {
	            var a = Jn.findPtNotNode(n, s, this.graph);if (null !== a) {
	              var u = oe.isPointInRing(a, o);if (u) return this.nestedPt = a, !1;
	            }
	          }
	        }
	      }return !0;
	    }, add: function add(t) {
	      this.rings.add(t), this.totalEnv.expandToInclude(t.getEnvelopeInternal());
	    }, interfaces_: function interfaces_() {
	      return [];
	    }, getClass: function getClass() {
	      return jn;
	    } }), Or(Kn.prototype, { getErrorType: function getErrorType() {
	      return this.errorType;
	    }, getMessage: function getMessage() {
	      return Kn.errMsg[this.errorType];
	    }, getCoordinate: function getCoordinate() {
	      return this.pt;
	    }, toString: function toString() {
	      var t = "";return null !== this.pt && (t = " at or near point " + this.pt), this.getMessage() + t;
	    }, interfaces_: function interfaces_() {
	      return [];
	    }, getClass: function getClass() {
	      return Kn;
	    } }), Kn.ERROR = 0, Kn.REPEATED_POINT = 1, Kn.HOLE_OUTSIDE_SHELL = 2, Kn.NESTED_HOLES = 3, Kn.DISCONNECTED_INTERIOR = 4, Kn.SELF_INTERSECTION = 5, Kn.RING_SELF_INTERSECTION = 6, Kn.NESTED_SHELLS = 7, Kn.DUPLICATE_RINGS = 8, Kn.TOO_FEW_POINTS = 9, Kn.INVALID_COORDINATE = 10, Kn.RING_NOT_CLOSED = 11, Kn.errMsg = ["Topology Validation Error", "Repeated Point", "Hole lies outside shell", "Holes are nested", "Interior is disconnected", "Self-intersection", "Ring Self-intersection", "Nested shells", "Duplicate Rings", "Too few distinct points in geometry component", "Invalid Coordinate", "Ring is not closed"], Or(Jn.prototype, { checkInvalidCoordinates: function checkInvalidCoordinates() {
	      if (arguments[0] instanceof Array) {
	        for (var t = arguments[0], e = 0; e < t.length; e++) {
	          if (!Jn.isValid(t[e])) return this.validErr = new Kn(Kn.INVALID_COORDINATE, t[e]), null;
	        }
	      } else if (arguments[0] instanceof Lt) {
	        var n = arguments[0];if (this.checkInvalidCoordinates(n.getExteriorRing().getCoordinates()), null !== this.validErr) return null;for (var e = 0; e < n.getNumInteriorRing(); e++) {
	          if (this.checkInvalidCoordinates(n.getInteriorRingN(e).getCoordinates()), null !== this.validErr) return null;
	        }
	      }
	    }, checkHolesNotNested: function checkHolesNotNested(t, e) {
	      for (var n = new jn(e), i = 0; i < t.getNumInteriorRing(); i++) {
	        var r = t.getInteriorRingN(i);n.add(r);
	      }n.isNonNested() || (this.validErr = new Kn(Kn.NESTED_HOLES, n.getNestedPoint()));
	    }, checkConsistentArea: function checkConsistentArea(t) {
	      var e = new Gn(t);if (!e.isNodeConsistentArea()) return this.validErr = new Kn(Kn.SELF_INTERSECTION, e.getInvalidPoint()), null;e.hasDuplicateRings() && (this.validErr = new Kn(Kn.DUPLICATE_RINGS, e.getInvalidPoint()));
	    }, isValid: function isValid() {
	      return this.checkValid(this.parentGeometry), null === this.validErr;
	    }, checkShellInsideHole: function checkShellInsideHole(t, e, n) {
	      var i = t.getCoordinates(),
	          r = e.getCoordinates(),
	          s = Jn.findPtNotNode(i, e, n);if (null !== s) {
	        if (!oe.isPointInRing(s, r)) return s;
	      }var o = Jn.findPtNotNode(r, t, n);if (null !== o) {
	        return oe.isPointInRing(o, i) ? o : null;
	      }return h.shouldNeverReachHere("points in shell and hole appear to be equal"), null;
	    }, checkNoSelfIntersectingRings: function checkNoSelfIntersectingRings(t) {
	      for (var e = t.getEdgeIterator(); e.hasNext();) {
	        var n = e.next();if (this.checkNoSelfIntersectingRing(n.getEdgeIntersectionList()), null !== this.validErr) return null;
	      }
	    }, checkConnectedInteriors: function checkConnectedInteriors(t) {
	      var e = new Qe(t);e.isInteriorsConnected() || (this.validErr = new Kn(Kn.DISCONNECTED_INTERIOR, e.getCoordinate()));
	    }, checkNoSelfIntersectingRing: function checkNoSelfIntersectingRing(t) {
	      for (var e = new rt(), n = !0, i = t.iterator(); i.hasNext();) {
	        var r = i.next();if (n) n = !1;else {
	          if (e.contains(r.coord)) return this.validErr = new Kn(Kn.RING_SELF_INTERSECTION, r.coord), null;e.add(r.coord);
	        }
	      }
	    }, checkHolesInShell: function checkHolesInShell(t, e) {
	      for (var n = t.getExteriorRing(), i = new ln(n), r = 0; r < t.getNumInteriorRing(); r++) {
	        var s = t.getInteriorRingN(r),
	            o = Jn.findPtNotNode(s.getCoordinates(), n, e);if (null === o) return null;if (!i.isInside(o)) return this.validErr = new Kn(Kn.HOLE_OUTSIDE_SHELL, o), null;
	      }
	    }, checkTooFewPoints: function checkTooFewPoints(t) {
	      if (t.hasTooFewPoints()) return this.validErr = new Kn(Kn.TOO_FEW_POINTS, t.getInvalidPoint()), null;
	    }, getValidationError: function getValidationError() {
	      return this.checkValid(this.parentGeometry), this.validErr;
	    }, checkValid: function checkValid() {
	      if (arguments[0] instanceof Ct) {
	        var t = arguments[0];this.checkInvalidCoordinates(t.getCoordinates());
	      } else if (arguments[0] instanceof Rt) {
	        var e = arguments[0];this.checkInvalidCoordinates(e.getCoordinates());
	      } else if (arguments[0] instanceof wt) {
	        var n = arguments[0];if (this.checkInvalidCoordinates(n.getCoordinates()), null !== this.validErr) return null;if (this.checkClosedRing(n), null !== this.validErr) return null;var i = new bn(0, n);if (this.checkTooFewPoints(i), null !== this.validErr) return null;var r = new ie();i.computeSelfNodes(r, !0, !0), this.checkNoSelfIntersectingRings(i);
	      } else if (arguments[0] instanceof xt) {
	        var s = arguments[0];if (this.checkInvalidCoordinates(s.getCoordinates()), null !== this.validErr) return null;var i = new bn(0, s);this.checkTooFewPoints(i);
	      } else if (arguments[0] instanceof Lt) {
	        var o = arguments[0];if (this.checkInvalidCoordinates(o), null !== this.validErr) return null;if (this.checkClosedRings(o), null !== this.validErr) return null;var i = new bn(0, o);if (this.checkTooFewPoints(i), null !== this.validErr) return null;if (this.checkConsistentArea(i), null !== this.validErr) return null;if (!this.isSelfTouchingRingFormingHoleValid && (this.checkNoSelfIntersectingRings(i), null !== this.validErr)) return null;if (this.checkHolesInShell(o, i), null !== this.validErr) return null;if (this.checkHolesNotNested(o, i), null !== this.validErr) return null;this.checkConnectedInteriors(i);
	      } else if (arguments[0] instanceof Tt) {
	        for (var a = arguments[0], u = 0; u < a.getNumGeometries(); u++) {
	          var l = a.getGeometryN(u);if (this.checkInvalidCoordinates(l), null !== this.validErr) return null;if (this.checkClosedRings(l), null !== this.validErr) return null;
	        }var i = new bn(0, a);if (this.checkTooFewPoints(i), null !== this.validErr) return null;if (this.checkConsistentArea(i), null !== this.validErr) return null;if (!this.isSelfTouchingRingFormingHoleValid && (this.checkNoSelfIntersectingRings(i), null !== this.validErr)) return null;for (var u = 0; u < a.getNumGeometries(); u++) {
	          var l = a.getGeometryN(u);if (this.checkHolesInShell(l, i), null !== this.validErr) return null;
	        }for (var u = 0; u < a.getNumGeometries(); u++) {
	          var l = a.getGeometryN(u);if (this.checkHolesNotNested(l, i), null !== this.validErr) return null;
	        }if (this.checkShellsNotNested(a, i), null !== this.validErr) return null;this.checkConnectedInteriors(i);
	      } else if (arguments[0] instanceof lt) for (var h = arguments[0], u = 0; u < h.getNumGeometries(); u++) {
	        var c = h.getGeometryN(u);if (this.checkValid(c), null !== this.validErr) return null;
	      } else if (arguments[0] instanceof F) {
	        var f = arguments[0];if (this.validErr = null, f.isEmpty()) return null;if (f instanceof Ct) this.checkValid(f);else if (f instanceof Rt) this.checkValid(f);else if (f instanceof wt) this.checkValid(f);else if (f instanceof xt) this.checkValid(f);else if (f instanceof Lt) this.checkValid(f);else if (f instanceof Tt) this.checkValid(f);else {
	          if (!(f instanceof lt)) throw new UnsupportedOperationException(f.getClass().getName());this.checkValid(f);
	        }
	      }
	    }, setSelfTouchingRingFormingHoleValid: function setSelfTouchingRingFormingHoleValid(t) {
	      this.isSelfTouchingRingFormingHoleValid = t;
	    }, checkShellNotNested: function checkShellNotNested(t, e, n) {
	      var i = t.getCoordinates(),
	          r = e.getExteriorRing(),
	          s = r.getCoordinates(),
	          o = Jn.findPtNotNode(i, r, n);if (null === o) return null;if (!oe.isPointInRing(o, s)) return null;if (e.getNumInteriorRing() <= 0) return this.validErr = new Kn(Kn.NESTED_SHELLS, o), null;for (var a = null, u = 0; u < e.getNumInteriorRing(); u++) {
	        var l = e.getInteriorRingN(u);if (null === (a = this.checkShellInsideHole(t, l, n))) return null;
	      }this.validErr = new Kn(Kn.NESTED_SHELLS, a);
	    }, checkClosedRings: function checkClosedRings(t) {
	      if (this.checkClosedRing(t.getExteriorRing()), null !== this.validErr) return null;for (var e = 0; e < t.getNumInteriorRing(); e++) {
	        if (this.checkClosedRing(t.getInteriorRingN(e)), null !== this.validErr) return null;
	      }
	    }, checkClosedRing: function checkClosedRing(t) {
	      if (!t.isClosed()) {
	        var e = null;t.getNumPoints() >= 1 && (e = t.getCoordinateN(0)), this.validErr = new Kn(Kn.RING_NOT_CLOSED, e);
	      }
	    }, checkShellsNotNested: function checkShellsNotNested(t, e) {
	      for (var n = 0; n < t.getNumGeometries(); n++) {
	        for (var i = t.getGeometryN(n), r = i.getExteriorRing(), s = 0; s < t.getNumGeometries(); s++) {
	          if (n !== s) {
	            var o = t.getGeometryN(s);if (this.checkShellNotNested(r, o, e), null !== this.validErr) return null;
	          }
	        }
	      }
	    }, interfaces_: function interfaces_() {
	      return [];
	    }, getClass: function getClass() {
	      return Jn;
	    } }), Jn.findPtNotNode = function (t, e, n) {
	    for (var i = n.findEdge(e), r = i.getEdgeIntersectionList(), s = 0; s < t.length; s++) {
	      var o = t[s];if (!r.isIntersection(o)) return o;
	    }return null;
	  }, Jn.isValid = function () {
	    if (arguments[0] instanceof F) {
	      return new Jn(arguments[0]).isValid();
	    }if (arguments[0] instanceof c) {
	      var t = arguments[0];return !i.isNaN(t.x) && !i.isInfinite(t.x) && !i.isNaN(t.y) && !i.isInfinite(t.y);
	    }
	  }, Or(Qn.prototype, { transformPoint: function transformPoint(t, e) {
	      return this.factory.createPoint(this.transformCoordinates(t.getCoordinateSequence(), t));
	    }, transformPolygon: function transformPolygon(t, e) {
	      var n = !0,
	          i = this.transformLinearRing(t.getExteriorRing(), t);null !== i && i instanceof wt && !i.isEmpty() || (n = !1);for (var r = new I(), s = 0; s < t.getNumInteriorRing(); s++) {
	        var o = this.transformLinearRing(t.getInteriorRingN(s), t);null === o || o.isEmpty() || (o instanceof wt || (n = !1), r.add(o));
	      }if (n) return this.factory.createPolygon(i, r.toArray([]));var a = new I();return null !== i && a.add(i), a.addAll(r), this.factory.buildGeometry(a);
	    }, createCoordinateSequence: function createCoordinateSequence(t) {
	      return this.factory.getCoordinateSequenceFactory().create(t);
	    }, getInputGeometry: function getInputGeometry() {
	      return this.inputGeom;
	    }, transformMultiLineString: function transformMultiLineString(t, e) {
	      for (var n = new I(), i = 0; i < t.getNumGeometries(); i++) {
	        var r = this.transformLineString(t.getGeometryN(i), t);null !== r && (r.isEmpty() || n.add(r));
	      }return this.factory.buildGeometry(n);
	    }, transformCoordinates: function transformCoordinates(t, e) {
	      return this.copy(t);
	    }, transformLineString: function transformLineString(t, e) {
	      return this.factory.createLineString(this.transformCoordinates(t.getCoordinateSequence(), t));
	    }, transformMultiPoint: function transformMultiPoint(t, e) {
	      for (var n = new I(), i = 0; i < t.getNumGeometries(); i++) {
	        var r = this.transformPoint(t.getGeometryN(i), t);null !== r && (r.isEmpty() || n.add(r));
	      }return this.factory.buildGeometry(n);
	    }, transformMultiPolygon: function transformMultiPolygon(t, e) {
	      for (var n = new I(), i = 0; i < t.getNumGeometries(); i++) {
	        var r = this.transformPolygon(t.getGeometryN(i), t);null !== r && (r.isEmpty() || n.add(r));
	      }return this.factory.buildGeometry(n);
	    }, copy: function copy(t) {
	      return t.copy();
	    }, transformGeometryCollection: function transformGeometryCollection(t, e) {
	      for (var n = new I(), i = 0; i < t.getNumGeometries(); i++) {
	        var r = this.transform(t.getGeometryN(i));null !== r && (this.pruneEmptyGeometry && r.isEmpty() || n.add(r));
	      }return this.preserveGeometryCollectionType ? this.factory.createGeometryCollection($t.toGeometryArray(n)) : this.factory.buildGeometry(n);
	    }, transform: function transform(t) {
	      if (this.inputGeom = t, this.factory = t.getFactory(), t instanceof Ct) return this.transformPoint(t, null);if (t instanceof Rt) return this.transformMultiPoint(t, null);if (t instanceof wt) return this.transformLinearRing(t, null);if (t instanceof xt) return this.transformLineString(t, null);if (t instanceof ht) return this.transformMultiLineString(t, null);if (t instanceof Lt) return this.transformPolygon(t, null);if (t instanceof Tt) return this.transformMultiPolygon(t, null);if (t instanceof lt) return this.transformGeometryCollection(t, null);throw new n("Unknown Geometry subtype: " + t.getClass().getName());
	    }, transformLinearRing: function transformLinearRing(t, e) {
	      var n = this.transformCoordinates(t.getCoordinateSequence(), t);if (null === n) return this.factory.createLinearRing(null);var i = n.size();return i > 0 && i < 4 && !this.preserveType ? this.factory.createLineString(n) : this.factory.createLinearRing(n);
	    }, interfaces_: function interfaces_() {
	      return [];
	    }, getClass: function getClass() {
	      return Qn;
	    } }), Or(Zn.prototype, { snapVertices: function snapVertices(t, e) {
	      for (var n = this._isClosed ? t.size() - 1 : t.size(), i = 0; i < n; i++) {
	        var r = t.get(i),
	            s = this.findSnapForVertex(r, e);null !== s && (t.set(i, new c(s)), 0 === i && this._isClosed && t.set(t.size() - 1, new c(s)));
	      }
	    }, findSnapForVertex: function findSnapForVertex(t, e) {
	      for (var n = 0; n < e.length; n++) {
	        if (t.equals2D(e[n])) return null;if (t.distance(e[n]) < this.snapTolerance) return e[n];
	      }return null;
	    }, snapTo: function snapTo(t) {
	      var e = new E(this.srcPts);return this.snapVertices(e, t), this.snapSegments(e, t), e.toCoordinateArray();
	    }, snapSegments: function snapSegments(t, e) {
	      if (0 === e.length) return null;var n = e.length;e[0].equals2D(e[e.length - 1]) && (n = e.length - 1);for (var i = 0; i < n; i++) {
	        var r = e[i],
	            s = this.findSegmentIndexToSnap(r, t);s >= 0 && t.add(s + 1, new c(r), !1);
	      }
	    }, findSegmentIndexToSnap: function findSegmentIndexToSnap(t, e) {
	      for (var n = i.MAX_VALUE, r = -1, s = 0; s < e.size() - 1; s++) {
	        if (this.seg.p0 = e.get(s), this.seg.p1 = e.get(s + 1), this.seg.p0.equals2D(t) || this.seg.p1.equals2D(t)) {
	          if (this.allowSnappingToSourceVertices) continue;return -1;
	        }var o = this.seg.distance(t);o < this.snapTolerance && o < n && (n = o, r = s);
	      }return r;
	    }, setAllowSnappingToSourceVertices: function setAllowSnappingToSourceVertices(t) {
	      this.allowSnappingToSourceVertices = t;
	    }, interfaces_: function interfaces_() {
	      return [];
	    }, getClass: function getClass() {
	      return Zn;
	    } }), Zn.isClosed = function (t) {
	    return !(t.length <= 1) && t[0].equals2D(t[t.length - 1]);
	  }, Or($n.prototype, { snapTo: function snapTo(t, e) {
	      return new ti(e, this.extractTargetCoordinates(t)).transform(this.srcGeom);
	    }, snapToSelf: function snapToSelf(t, e) {
	      var n = this.extractTargetCoordinates(this.srcGeom),
	          i = new ti(t, n, !0),
	          r = i.transform(this.srcGeom),
	          s = r;return e && _r(s, St) && (s = r.buffer(0)), s;
	    }, computeSnapTolerance: function computeSnapTolerance(t) {
	      return this.computeMinimumSegmentLength(t) / 10;
	    }, extractTargetCoordinates: function extractTargetCoordinates(t) {
	      for (var e = new rt(), n = t.getCoordinates(), i = 0; i < n.length; i++) {
	        e.add(n[i]);
	      }return e.toArray(new Array(0).fill(null));
	    }, computeMinimumSegmentLength: function computeMinimumSegmentLength(t) {
	      for (var e = i.MAX_VALUE, n = 0; n < t.length - 1; n++) {
	        var r = t[n].distance(t[n + 1]);r < e && (e = r);
	      }return e;
	    }, interfaces_: function interfaces_() {
	      return [];
	    }, getClass: function getClass() {
	      return $n;
	    } }), $n.snap = function (t, e, n) {
	    var i = new Array(2).fill(null),
	        r = new $n(t);i[0] = r.snapTo(e, n);var s = new $n(e);return i[1] = s.snapTo(i[0], n), i;
	  }, $n.computeOverlaySnapTolerance = function () {
	    if (1 === arguments.length) {
	      var t = arguments[0],
	          e = $n.computeSizeBasedSnapTolerance(t),
	          n = t.getPrecisionModel();if (n.getType() === Qt.FIXED) {
	        var i = 1 / n.getScale() * 2 / 1.415;i > e && (e = i);
	      }return e;
	    }if (2 === arguments.length) {
	      var r = arguments[0],
	          s = arguments[1];return Math.min($n.computeOverlaySnapTolerance(r), $n.computeOverlaySnapTolerance(s));
	    }
	  }, $n.computeSizeBasedSnapTolerance = function (t) {
	    var e = t.getEnvelopeInternal();return Math.min(e.getHeight(), e.getWidth()) * $n.SNAP_PRECISION_FACTOR;
	  }, $n.snapToSelf = function (t, e, n) {
	    return new $n(t).snapToSelf(e, n);
	  }, $n.SNAP_PRECISION_FACTOR = 1e-9, br(ti, Qn), Or(ti.prototype, { snapLine: function snapLine(t, e) {
	      var n = new Zn(t, this.snapTolerance);return n.setAllowSnappingToSourceVertices(this.isSelfSnap), n.snapTo(e);
	    }, transformCoordinates: function transformCoordinates(t, e) {
	      var n = t.toCoordinateArray(),
	          i = this.snapLine(n, this.snapPts);return this.factory.getCoordinateSequenceFactory().create(i);
	    }, interfaces_: function interfaces_() {
	      return [];
	    }, getClass: function getClass() {
	      return ti;
	    } }), Or(ei.prototype, { getCommon: function getCommon() {
	      return i.longBitsToDouble(this.commonBits);
	    }, add: function add(t) {
	      var e = i.doubleToLongBits(t);return this.isFirst ? (this.commonBits = e, this.commonSignExp = ei.signExpBits(this.commonBits), this.isFirst = !1, null) : ei.signExpBits(e) !== this.commonSignExp ? (this.commonBits = 0, null) : (this.commonMantissaBitsCount = ei.numCommonMostSigMantissaBits(this.commonBits, e), void (this.commonBits = ei.zeroLowerBits(this.commonBits, 64 - (12 + this.commonMantissaBitsCount))));
	    }, toString: function toString() {
	      if (1 === arguments.length) {
	        var t = arguments[0],
	            e = i.longBitsToDouble(t),
	            n = Long.toBinaryString(t),
	            r = "0000000000000000000000000000000000000000000000000000000000000000" + n,
	            s = r.substring(r.length - 64);return s.substring(0, 1) + "  " + s.substring(1, 12) + "(exp) " + s.substring(12) + " [ " + e + " ]";
	      }
	    }, interfaces_: function interfaces_() {
	      return [];
	    }, getClass: function getClass() {
	      return ei;
	    } }), ei.getBit = function (t, e) {
	    return 0 != (t & 1 << e) ? 1 : 0;
	  }, ei.signExpBits = function (t) {
	    return t >> 52;
	  }, ei.zeroLowerBits = function (t, e) {
	    return t & ~((1 << e) - 1);
	  }, ei.numCommonMostSigMantissaBits = function (t, e) {
	    for (var n = 0, i = 52; i >= 0; i--) {
	      if (ei.getBit(t, i) !== ei.getBit(e, i)) return n;n++;
	    }return 52;
	  }, Or(ni.prototype, { addCommonBits: function addCommonBits(t) {
	      var e = new ri(this.commonCoord);t.apply(e), t.geometryChanged();
	    }, removeCommonBits: function removeCommonBits(t) {
	      if (0 === this.commonCoord.x && 0 === this.commonCoord.y) return t;var e = new c(this.commonCoord);e.x = -e.x, e.y = -e.y;var n = new ri(e);return t.apply(n), t.geometryChanged(), t;
	    }, getCommonCoordinate: function getCommonCoordinate() {
	      return this.commonCoord;
	    }, add: function add(t) {
	      t.apply(this.ccFilter), this.commonCoord = this.ccFilter.getCommonCoordinate();
	    }, interfaces_: function interfaces_() {
	      return [];
	    }, getClass: function getClass() {
	      return ni;
	    } }), Or(ii.prototype, { filter: function filter(t) {
	      this.commonBitsX.add(t.x), this.commonBitsY.add(t.y);
	    }, getCommonCoordinate: function getCommonCoordinate() {
	      return new c(this.commonBitsX.getCommon(), this.commonBitsY.getCommon());
	    }, interfaces_: function interfaces_() {
	      return [G];
	    }, getClass: function getClass() {
	      return ii;
	    } }), Or(ri.prototype, { filter: function filter(t, e) {
	      var n = t.getOrdinate(e, 0) + this.trans.x,
	          i = t.getOrdinate(e, 1) + this.trans.y;t.setOrdinate(e, 0, n), t.setOrdinate(e, 1, i);
	    }, isDone: function isDone() {
	      return !1;
	    }, isGeometryChanged: function isGeometryChanged() {
	      return !0;
	    }, interfaces_: function interfaces_() {
	      return [ut];
	    }, getClass: function getClass() {
	      return ri;
	    } }), ni.CommonCoordinateFilter = ii, ni.Translater = ri, Or(si.prototype, { interfaces_: function interfaces_() {
	      return [];
	    }, getClass: function getClass() {
	      return si;
	    } }), si.octant = function () {
	    if ("number" == typeof arguments[0] && "number" == typeof arguments[1]) {
	      var t = arguments[0],
	          e = arguments[1];if (0 === t && 0 === e) throw new n("Cannot compute the octant for point ( " + t + ", " + e + " )");var i = Math.abs(t),
	          r = Math.abs(e);return t >= 0 ? e >= 0 ? i >= r ? 0 : 1 : i >= r ? 7 : 6 : e >= 0 ? i >= r ? 3 : 2 : i >= r ? 4 : 5;
	    }if (arguments[0] instanceof c && arguments[1] instanceof c) {
	      var s = arguments[0],
	          o = arguments[1],
	          a = o.x - s.x,
	          u = o.y - s.y;if (0 === a && 0 === u) throw new n("Cannot compute the octant for two identical points " + s);return si.octant(a, u);
	    }
	  }, Or(oi.prototype, { getCoordinates: function getCoordinates() {}, size: function size() {}, getCoordinate: function getCoordinate(t) {}, isClosed: function isClosed() {}, setData: function setData(t) {}, getData: function getData() {}, interfaces_: function interfaces_() {
	      return [];
	    }, getClass: function getClass() {
	      return oi;
	    } }), Or(ai.prototype, { getCoordinates: function getCoordinates() {
	      return this.pts;
	    }, size: function size() {
	      return this.pts.length;
	    }, getCoordinate: function getCoordinate(t) {
	      return this.pts[t];
	    }, isClosed: function isClosed() {
	      return this.pts[0].equals(this.pts[this.pts.length - 1]);
	    }, getSegmentOctant: function getSegmentOctant(t) {
	      return t === this.pts.length - 1 ? -1 : si.octant(this.getCoordinate(t), this.getCoordinate(t + 1));
	    }, setData: function setData(t) {
	      this.data = t;
	    }, getData: function getData() {
	      return this.data;
	    }, toString: function toString() {
	      return ee.toLineString(new At(this.pts));
	    }, interfaces_: function interfaces_() {
	      return [oi];
	    }, getClass: function getClass() {
	      return ai;
	    } }), Or(ui.prototype, { interfaces_: function interfaces_() {
	      return [];
	    }, getClass: function getClass() {
	      return ui;
	    } }), ui.relativeSign = function (t, e) {
	    return t < e ? -1 : t > e ? 1 : 0;
	  }, ui.compare = function (t, e, n) {
	    if (e.equals2D(n)) return 0;var i = ui.relativeSign(e.x, n.x),
	        r = ui.relativeSign(e.y, n.y);switch (t) {case 0:
	        return ui.compareValue(i, r);case 1:
	        return ui.compareValue(r, i);case 2:
	        return ui.compareValue(r, -i);case 3:
	        return ui.compareValue(-i, r);case 4:
	        return ui.compareValue(-i, -r);case 5:
	        return ui.compareValue(-r, -i);case 6:
	        return ui.compareValue(-r, i);case 7:
	        return ui.compareValue(i, -r);}return h.shouldNeverReachHere("invalid octant value"), 0;
	  }, ui.compareValue = function (t, e) {
	    return t < 0 ? -1 : t > 0 ? 1 : e < 0 ? -1 : e > 0 ? 1 : 0;
	  }, Or(li.prototype, { getCoordinate: function getCoordinate() {
	      return this.coord;
	    }, print: function print(t) {
	      t.print(this.coord), t.print(" seg # = " + this.segmentIndex);
	    }, compareTo: function compareTo(t) {
	      var e = t;return this.segmentIndex < e.segmentIndex ? -1 : this.segmentIndex > e.segmentIndex ? 1 : this.coord.equals2D(e.coord) ? 0 : ui.compare(this.segmentOctant, this.coord, e.coord);
	    }, isEndPoint: function isEndPoint(t) {
	      return 0 === this.segmentIndex && !this._isInterior || this.segmentIndex === t;
	    }, isInterior: function isInterior() {
	      return this._isInterior;
	    }, interfaces_: function interfaces_() {
	      return [r];
	    }, getClass: function getClass() {
	      return li;
	    } });Or(hi.prototype, { getSplitCoordinates: function getSplitCoordinates() {
	      var t = new E();this.addEndpoints();for (var e = this.iterator(), n = e.next(); e.hasNext();) {
	        var i = e.next();this.addEdgeCoordinates(n, i, t), n = i;
	      }return t.toCoordinateArray();
	    }, addCollapsedNodes: function addCollapsedNodes() {
	      var t = new I();this.findCollapsesFromInsertedNodes(t), this.findCollapsesFromExistingVertices(t);for (var e = t.iterator(); e.hasNext();) {
	        var n = e.next().intValue();this.add(this.edge.getCoordinate(n), n);
	      }
	    }, print: function print(t) {
	      t.println("Intersections:");for (var e = this.iterator(); e.hasNext();) {
	        e.next().print(t);
	      }
	    }, findCollapsesFromExistingVertices: function findCollapsesFromExistingVertices(t) {
	      for (var e = 0; e < this.edge.size() - 2; e++) {
	        var n = this.edge.getCoordinate(e),
	            i = (this.edge.getCoordinate(e + 1), this.edge.getCoordinate(e + 2));n.equals2D(i) && t.add(new w(e + 1));
	      }
	    }, addEdgeCoordinates: function addEdgeCoordinates(t, e, n) {
	      var i = e.segmentIndex - t.segmentIndex + 2,
	          r = this.edge.getCoordinate(e.segmentIndex),
	          s = e.isInterior() || !e.coord.equals2D(r);s || i--;n.add(new c(t.coord), !1);for (var o = t.segmentIndex + 1; o <= e.segmentIndex; o++) {
	        n.add(this.edge.getCoordinate(o));
	      }s && n.add(new c(e.coord));
	    }, iterator: function iterator() {
	      return this.nodeMap.values().iterator();
	    }, addSplitEdges: function addSplitEdges(t) {
	      this.addEndpoints(), this.addCollapsedNodes();for (var e = this.iterator(), n = e.next(); e.hasNext();) {
	        var i = e.next(),
	            r = this.createSplitEdge(n, i);t.add(r), n = i;
	      }
	    }, findCollapseIndex: function findCollapseIndex(t, e, n) {
	      if (!t.coord.equals2D(e.coord)) return !1;var i = e.segmentIndex - t.segmentIndex;return e.isInterior() || i--, 1 === i && (n[0] = t.segmentIndex + 1, !0);
	    }, findCollapsesFromInsertedNodes: function findCollapsesFromInsertedNodes(t) {
	      for (var e = new Array(1).fill(null), n = this.iterator(), i = n.next(); n.hasNext();) {
	        var r = n.next();this.findCollapseIndex(i, r, e) && t.add(new w(e[0])), i = r;
	      }
	    }, getEdge: function getEdge() {
	      return this.edge;
	    }, addEndpoints: function addEndpoints() {
	      var t = this.edge.size() - 1;this.add(this.edge.getCoordinate(0), 0), this.add(this.edge.getCoordinate(t), t);
	    }, createSplitEdge: function createSplitEdge(t, e) {
	      var n = e.segmentIndex - t.segmentIndex + 2,
	          i = this.edge.getCoordinate(e.segmentIndex),
	          r = e.isInterior() || !e.coord.equals2D(i);r || n--;var s = new Array(n).fill(null),
	          o = 0;s[o++] = new c(t.coord);for (var a = t.segmentIndex + 1; a <= e.segmentIndex; a++) {
	        s[o++] = this.edge.getCoordinate(a);
	      }return r && (s[o] = new c(e.coord)), new gi(s, this.edge.getData());
	    }, add: function add(t, e) {
	      var n = new li(this.edge, t, e, this.edge.getSegmentOctant(e)),
	          i = this.nodeMap.get(n);return null !== i ? (h.isTrue(i.coord.equals2D(t), "Found equal nodes with different coordinates"), i) : (this.nodeMap.put(n, n), n);
	    }, checkSplitEdgesCorrectness: function checkSplitEdgesCorrectness(t) {
	      var e = this.edge.getCoordinates(),
	          n = t.get(0),
	          i = n.getCoordinate(0);if (!i.equals2D(e[0])) throw new u("bad split edge start point at " + i);var r = t.get(t.size() - 1),
	          s = r.getCoordinates(),
	          o = s[s.length - 1];if (!o.equals2D(e[e.length - 1])) throw new u("bad split edge end point at " + o);
	    }, interfaces_: function interfaces_() {
	      return [];
	    }, getClass: function getClass() {
	      return hi;
	    } }), Or(ci.prototype, { next: function next() {
	      return null === this.currNode ? (this.currNode = this.nextNode, this.currSegIndex = this.currNode.segmentIndex, this.readNextNode(), this.currNode) : null === this.nextNode ? null : this.nextNode.segmentIndex === this.currNode.segmentIndex ? (this.currNode = this.nextNode, this.currSegIndex = this.currNode.segmentIndex, this.readNextNode(), this.currNode) : (this.nextNode.segmentIndex, this.currNode.segmentIndex, null);
	    }, remove: function remove() {
	      throw new UnsupportedOperationException(this.getClass().getName());
	    }, hasNext: function hasNext() {
	      return null !== this.nextNode;
	    }, readNextNode: function readNextNode() {
	      this.nodeIt.hasNext() ? this.nextNode = this.nodeIt.next() : this.nextNode = null;
	    }, interfaces_: function interfaces_() {
	      return [g];
	    }, getClass: function getClass() {
	      return ci;
	    } }), Or(fi.prototype, { addIntersection: function addIntersection(t, e) {}, interfaces_: function interfaces_() {
	      return [oi];
	    }, getClass: function getClass() {
	      return fi;
	    } }), Or(gi.prototype, { getCoordinates: function getCoordinates() {
	      return this.pts;
	    }, size: function size() {
	      return this.pts.length;
	    }, getCoordinate: function getCoordinate(t) {
	      return this.pts[t];
	    }, isClosed: function isClosed() {
	      return this.pts[0].equals(this.pts[this.pts.length - 1]);
	    }, getSegmentOctant: function getSegmentOctant(t) {
	      return t === this.pts.length - 1 ? -1 : this.safeOctant(this.getCoordinate(t), this.getCoordinate(t + 1));
	    }, setData: function setData(t) {
	      this.data = t;
	    }, safeOctant: function safeOctant(t, e) {
	      return t.equals2D(e) ? 0 : si.octant(t, e);
	    }, getData: function getData() {
	      return this.data;
	    }, addIntersection: function addIntersection() {
	      if (2 === arguments.length) {
	        var t = arguments[0],
	            e = arguments[1];this.addIntersectionNode(t, e);
	      } else if (4 === arguments.length) {
	        var n = arguments[0],
	            i = arguments[1],
	            r = (arguments[2], arguments[3]),
	            s = new c(n.getIntersection(r));this.addIntersection(s, i);
	      }
	    }, toString: function toString() {
	      return ee.toLineString(new At(this.pts));
	    }, getNodeList: function getNodeList() {
	      return this.nodeList;
	    }, addIntersectionNode: function addIntersectionNode(t, e) {
	      var n = e,
	          i = n + 1;if (i < this.pts.length) {
	        var r = this.pts[i];t.equals2D(r) && (n = i);
	      }return this.nodeList.add(t, n);
	    }, addIntersections: function addIntersections(t, e, n) {
	      for (var i = 0; i < t.getIntersectionNum(); i++) {
	        this.addIntersection(t, e, n, i);
	      }
	    }, interfaces_: function interfaces_() {
	      return [fi];
	    }, getClass: function getClass() {
	      return gi;
	    } }), gi.getNodedSubstrings = function () {
	    if (1 === arguments.length) {
	      var t = arguments[0],
	          e = new I();return gi.getNodedSubstrings(t, e), e;
	    }if (2 === arguments.length) for (var n = arguments[0], i = arguments[1], r = n.iterator(); r.hasNext();) {
	      var s = r.next();s.getNodeList().addSplitEdges(i);
	    }
	  }, Or(di.prototype, { overlap: function overlap() {
	      if (2 === arguments.length) {
	        arguments[0], arguments[1];
	      } else if (4 === arguments.length) {
	        var t = arguments[0],
	            e = arguments[1],
	            n = arguments[2],
	            i = arguments[3];t.getLineSegment(e, this.overlapSeg1), n.getLineSegment(i, this.overlapSeg2), this.overlap(this.overlapSeg1, this.overlapSeg2);
	      }
	    }, interfaces_: function interfaces_() {
	      return [];
	    }, getClass: function getClass() {
	      return di;
	    } }), Or(pi.prototype, { computeNodes: function computeNodes(t) {}, getNodedSubstrings: function getNodedSubstrings() {}, interfaces_: function interfaces_() {
	      return [];
	    }, getClass: function getClass() {
	      return pi;
	    } }), Or(mi.prototype, { setSegmentIntersector: function setSegmentIntersector(t) {
	      this.segInt = t;
	    }, interfaces_: function interfaces_() {
	      return [pi];
	    }, getClass: function getClass() {
	      return mi;
	    } }), br(vi, mi), Or(vi.prototype, { getMonotoneChains: function getMonotoneChains() {
	      return this.monoChains;
	    }, getNodedSubstrings: function getNodedSubstrings() {
	      return gi.getNodedSubstrings(this.nodedSegStrings);
	    }, getIndex: function getIndex() {
	      return this.index;
	    }, add: function add(t) {
	      for (var e = an.getChains(t.getCoordinates(), t), n = e.iterator(); n.hasNext();) {
	        var i = n.next();i.setId(this.idCounter++), this.index.insert(i.getEnvelope(), i), this.monoChains.add(i);
	      }
	    }, computeNodes: function computeNodes(t) {
	      this.nodedSegStrings = t;for (var e = t.iterator(); e.hasNext();) {
	        this.add(e.next());
	      }this.intersectChains();
	    }, intersectChains: function intersectChains() {
	      for (var t = new yi(this.segInt), e = this.monoChains.iterator(); e.hasNext();) {
	        for (var n = e.next(), i = this.index.query(n.getEnvelope()), r = i.iterator(); r.hasNext();) {
	          var s = r.next();if (s.getId() > n.getId() && (n.computeOverlaps(s, t), this.nOverlaps++), this.segInt.isDone()) return null;
	        }
	      }
	    }, interfaces_: function interfaces_() {
	      return [];
	    }, getClass: function getClass() {
	      return vi;
	    } }), br(yi, di), Or(yi.prototype, { overlap: function overlap() {
	      if (4 !== arguments.length) return di.prototype.overlap.apply(this, arguments);var t = arguments[0],
	          e = arguments[1],
	          n = arguments[2],
	          i = arguments[3],
	          r = t.getContext(),
	          s = n.getContext();this.si.processIntersections(r, e, s, i);
	    }, interfaces_: function interfaces_() {
	      return [];
	    }, getClass: function getClass() {
	      return yi;
	    } }), vi.SegmentOverlapAction = yi, Or(Ii.prototype, { processIntersections: function processIntersections(t, e, n, i) {}, isDone: function isDone() {}, interfaces_: function interfaces_() {
	      return [];
	    }, getClass: function getClass() {
	      return Ii;
	    } }), Or(Ei.prototype, { getInteriorIntersection: function getInteriorIntersection() {
	      return this.interiorIntersection;
	    }, setCheckEndSegmentsOnly: function setCheckEndSegmentsOnly(t) {
	      this.isCheckEndSegmentsOnly = t;
	    }, getIntersectionSegments: function getIntersectionSegments() {
	      return this.intSegments;
	    }, count: function count() {
	      return this.intersectionCount;
	    }, getIntersections: function getIntersections() {
	      return this.intersections;
	    }, setFindAllIntersections: function setFindAllIntersections(t) {
	      this.findAllIntersections = t;
	    }, setKeepIntersections: function setKeepIntersections(t) {
	      this.keepIntersections = t;
	    }, processIntersections: function processIntersections(t, e, n, i) {
	      if (!this.findAllIntersections && this.hasIntersection()) return null;if (t === n && e === i) return null;if (this.isCheckEndSegmentsOnly) {
	        if (!(this.isEndSegment(t, e) || this.isEndSegment(n, i))) return null;
	      }var r = t.getCoordinates()[e],
	          s = t.getCoordinates()[e + 1],
	          o = n.getCoordinates()[i],
	          a = n.getCoordinates()[i + 1];this.li.computeIntersection(r, s, o, a), this.li.hasIntersection() && this.li.isInteriorIntersection() && (this.intSegments = new Array(4).fill(null), this.intSegments[0] = r, this.intSegments[1] = s, this.intSegments[2] = o, this.intSegments[3] = a, this.interiorIntersection = this.li.getIntersection(0), this.keepIntersections && this.intersections.add(this.interiorIntersection), this.intersectionCount++);
	    }, isEndSegment: function isEndSegment(t, e) {
	      return 0 === e || e >= t.size() - 2;
	    }, hasIntersection: function hasIntersection() {
	      return null !== this.interiorIntersection;
	    }, isDone: function isDone() {
	      return !this.findAllIntersections && null !== this.interiorIntersection;
	    }, interfaces_: function interfaces_() {
	      return [Ii];
	    }, getClass: function getClass() {
	      return Ei;
	    } }), Ei.createAllIntersectionsFinder = function (t) {
	    var e = new Ei(t);return e.setFindAllIntersections(!0), e;
	  }, Ei.createAnyIntersectionFinder = function (t) {
	    return new Ei(t);
	  }, Ei.createIntersectionCounter = function (t) {
	    var e = new Ei(t);return e.setFindAllIntersections(!0), e.setKeepIntersections(!1), e;
	  }, Or(xi.prototype, { execute: function execute() {
	      if (null !== this.segInt) return null;this.checkInteriorIntersections();
	    }, getIntersections: function getIntersections() {
	      return this.segInt.getIntersections();
	    }, isValid: function isValid() {
	      return this.execute(), this._isValid;
	    }, setFindAllIntersections: function setFindAllIntersections(t) {
	      this.findAllIntersections = t;
	    }, checkInteriorIntersections: function checkInteriorIntersections() {
	      this._isValid = !0, this.segInt = new Ei(this.li), this.segInt.setFindAllIntersections(this.findAllIntersections);var t = new vi();if (t.setSegmentIntersector(this.segInt), t.computeNodes(this.segStrings), this.segInt.hasIntersection()) return this._isValid = !1, null;
	    }, checkValid: function checkValid() {
	      if (this.execute(), !this._isValid) throw new _e(this.getErrorMessage(), this.segInt.getInteriorIntersection());
	    }, getErrorMessage: function getErrorMessage() {
	      if (this._isValid) return "no intersections found";var t = this.segInt.getIntersectionSegments();return "found non-noded intersection between " + ee.toLineString(t[0], t[1]) + " and " + ee.toLineString(t[2], t[3]);
	    }, interfaces_: function interfaces_() {
	      return [];
	    }, getClass: function getClass() {
	      return xi;
	    } }), xi.computeIntersections = function (t) {
	    var e = new xi(t);return e.setFindAllIntersections(!0), e.isValid(), e.getIntersections();
	  }, Or(Ni.prototype, { checkValid: function checkValid() {
	      this.nv.checkValid();
	    }, interfaces_: function interfaces_() {
	      return [];
	    }, getClass: function getClass() {
	      return Ni;
	    } }), Ni.toSegmentStrings = function (t) {
	    for (var e = new I(), n = t.iterator(); n.hasNext();) {
	      var i = n.next();e.add(new ai(i.getCoordinates(), i));
	    }return e;
	  }, Ni.checkValid = function (t) {
	    new Ni(t).checkValid();
	  }, Or(Ci.prototype, { sortShellsAndHoles: function sortShellsAndHoles(t, e, n) {
	      for (var i = t.iterator(); i.hasNext();) {
	        var r = i.next();r.isHole() ? n.add(r) : e.add(r);
	      }
	    }, computePolygons: function computePolygons(t) {
	      for (var e = new I(), n = t.iterator(); n.hasNext();) {
	        var i = n.next(),
	            r = i.toPolygon(this.geometryFactory);e.add(r);
	      }return e;
	    }, placeFreeHoles: function placeFreeHoles(t, e) {
	      for (var n = e.iterator(); n.hasNext();) {
	        var i = n.next();if (null === i.getShell()) {
	          var r = this.findEdgeRingContaining(i, t);if (null === r) throw new _e("unable to assign hole to a shell", i.getCoordinate(0));i.setShell(r);
	        }
	      }
	    }, buildMinimalEdgeRings: function buildMinimalEdgeRings(t, e, n) {
	      for (var i = new I(), r = t.iterator(); r.hasNext();) {
	        var s = r.next();if (s.getMaxNodeDegree() > 2) {
	          s.linkDirectedEdgesForMinimalEdgeRings();var o = s.buildMinimalRings(),
	              a = this.findShell(o);null !== a ? (this.placePolygonHoles(a, o), e.add(a)) : n.addAll(o);
	        } else i.add(s);
	      }return i;
	    }, containsPoint: function containsPoint(t) {
	      for (var e = this.shellList.iterator(); e.hasNext();) {
	        if (e.next().containsPoint(t)) return !0;
	      }return !1;
	    }, buildMaximalEdgeRings: function buildMaximalEdgeRings(t) {
	      for (var e = new I(), n = t.iterator(); n.hasNext();) {
	        var i = n.next();if (i.isInResult() && i.getLabel().isArea() && null === i.getEdgeRing()) {
	          var r = new Ge(i, this.geometryFactory);e.add(r), r.setInResult();
	        }
	      }return e;
	    }, placePolygonHoles: function placePolygonHoles(t, e) {
	      for (var n = e.iterator(); n.hasNext();) {
	        var i = n.next();i.isHole() && i.setShell(t);
	      }
	    }, getPolygons: function getPolygons() {
	      return this.computePolygons(this.shellList);
	    }, findEdgeRingContaining: function findEdgeRingContaining(t, e) {
	      for (var n = t.getLinearRing(), i = n.getEnvelopeInternal(), r = n.getCoordinateN(0), s = null, o = null, a = e.iterator(); a.hasNext();) {
	        var u = a.next(),
	            l = u.getLinearRing(),
	            h = l.getEnvelopeInternal();null !== s && (o = s.getLinearRing().getEnvelopeInternal());var c = !1;h.contains(i) && oe.isPointInRing(r, l.getCoordinates()) && (c = !0), c && (null === s || o.contains(h)) && (s = u);
	      }return s;
	    }, findShell: function findShell(t) {
	      for (var e = 0, n = null, i = t.iterator(); i.hasNext();) {
	        var r = i.next();r.isHole() || (n = r, e++);
	      }return h.isTrue(e <= 1, "found two shells in MinimalEdgeRing list"), n;
	    }, add: function add() {
	      if (1 === arguments.length) {
	        var t = arguments[0];this.add(t.getEdgeEnds(), t.getNodes());
	      } else if (2 === arguments.length) {
	        var e = arguments[0],
	            n = arguments[1];Je.linkResultDirectedEdges(n);var i = this.buildMaximalEdgeRings(e),
	            r = new I(),
	            s = this.buildMinimalEdgeRings(i, this.shellList, r);this.sortShellsAndHoles(s, this.shellList, r), this.placeFreeHoles(this.shellList, r);
	      }
	    }, interfaces_: function interfaces_() {
	      return [];
	    }, getClass: function getClass() {
	      return Ci;
	    } }), Or(Si.prototype, { collectLines: function collectLines(t) {
	      for (var e = this.op.getGraph().getEdgeEnds().iterator(); e.hasNext();) {
	        var n = e.next();this.collectLineEdge(n, t, this.lineEdgesList), this.collectBoundaryTouchEdge(n, t, this.lineEdgesList);
	      }
	    }, labelIsolatedLine: function labelIsolatedLine(t, e) {
	      var n = this.ptLocator.locate(t.getCoordinate(), this.op.getArgGeometry(e));t.getLabel().setLocation(e, n);
	    }, build: function build(t) {
	      return this.findCoveredLineEdges(), this.collectLines(t), this.buildLines(t), this.resultLineList;
	    }, collectLineEdge: function collectLineEdge(t, e, n) {
	      var i = t.getLabel(),
	          r = t.getEdge();t.isLineEdge() && (t.isVisited() || !Oi.isResultOfOp(i, e) || r.isCovered() || (n.add(r), t.setVisitedEdge(!0)));
	    }, findCoveredLineEdges: function findCoveredLineEdges() {
	      for (var t = this.op.getGraph().getNodes().iterator(); t.hasNext();) {
	        t.next().getEdges().findCoveredLineEdges();
	      }for (var e = this.op.getGraph().getEdgeEnds().iterator(); e.hasNext();) {
	        var n = e.next(),
	            i = n.getEdge();if (n.isLineEdge() && !i.isCoveredSet()) {
	          var r = this.op.isCoveredByA(n.getCoordinate());i.setCovered(r);
	        }
	      }
	    }, labelIsolatedLines: function labelIsolatedLines(t) {
	      for (var e = t.iterator(); e.hasNext();) {
	        var n = e.next(),
	            i = n.getLabel();n.isIsolated() && (i.isNull(0) ? this.labelIsolatedLine(n, 0) : this.labelIsolatedLine(n, 1));
	      }
	    }, buildLines: function buildLines(t) {
	      for (var e = this.lineEdgesList.iterator(); e.hasNext();) {
	        var n = e.next(),
	            i = (n.getLabel(), this.geometryFactory.createLineString(n.getCoordinates()));this.resultLineList.add(i), n.setInResult(!0);
	      }
	    }, collectBoundaryTouchEdge: function collectBoundaryTouchEdge(t, e, n) {
	      var i = t.getLabel();return t.isLineEdge() ? null : t.isVisited() ? null : t.isInteriorAreaEdge() ? null : t.getEdge().isInResult() ? null : (h.isTrue(!(t.isInResult() || t.getSym().isInResult()) || !t.getEdge().isInResult()), void (Oi.isResultOfOp(i, e) && e === Oi.INTERSECTION && (n.add(t.getEdge()), t.setVisitedEdge(!0))));
	    }, interfaces_: function interfaces_() {
	      return [];
	    }, getClass: function getClass() {
	      return Si;
	    } }), Or(Li.prototype, { filterCoveredNodeToPoint: function filterCoveredNodeToPoint(t) {
	      var e = t.getCoordinate();if (!this.op.isCoveredByLA(e)) {
	        var n = this.geometryFactory.createPoint(e);this.resultPointList.add(n);
	      }
	    }, extractNonCoveredResultNodes: function extractNonCoveredResultNodes(t) {
	      for (var e = this.op.getGraph().getNodes().iterator(); e.hasNext();) {
	        var n = e.next();if (!n.isInResult() && !n.isIncidentEdgeInResult() && (0 === n.getEdges().getDegree() || t === Oi.INTERSECTION)) {
	          var i = n.getLabel();Oi.isResultOfOp(i, t) && this.filterCoveredNodeToPoint(n);
	        }
	      }
	    }, build: function build(t) {
	      return this.extractNonCoveredResultNodes(t), this.resultPointList;
	    }, interfaces_: function interfaces_() {
	      return [];
	    }, getClass: function getClass() {
	      return Li;
	    } }), Or(Ri.prototype, { getArgGeometry: function getArgGeometry(t) {
	      return this.arg[t].getGeometry();
	    }, setComputationPrecision: function setComputationPrecision(t) {
	      this.resultPrecisionModel = t, this.li.setPrecisionModel(this.resultPrecisionModel);
	    }, interfaces_: function interfaces_() {
	      return [];
	    }, getClass: function getClass() {
	      return Ri;
	    } }), Or(wi.prototype, { compareTo: function compareTo(t) {
	      var e = t;return wi.compareOriented(this.pts, this._orientation, e.pts, e._orientation);
	    }, interfaces_: function interfaces_() {
	      return [r];
	    }, getClass: function getClass() {
	      return wi;
	    } }), wi.orientation = function (t) {
	    return 1 === X.increasingDirection(t);
	  }, wi.compareOriented = function (t, e, n, i) {
	    for (var r = e ? 1 : -1, s = i ? 1 : -1, o = e ? t.length : -1, a = i ? n.length : -1, u = e ? 0 : t.length - 1, l = i ? 0 : n.length - 1;;) {
	      var h = t[u].compareTo(n[l]);if (0 !== h) return h;u += r, l += s;var c = u === o,
	          f = l === a;if (c && !f) return -1;if (!c && f) return 1;if (c && f) return 0;
	    }
	  }, Or(Ti.prototype, { print: function print(t) {
	      t.print("MULTILINESTRING ( ");for (var e = 0; e < this.edges.size(); e++) {
	        var n = this.edges.get(e);e > 0 && t.print(","), t.print("(");for (var i = n.getCoordinates(), r = 0; r < i.length; r++) {
	          r > 0 && t.print(","), t.print(i[r].x + " " + i[r].y);
	        }t.println(")");
	      }t.print(")  ");
	    }, addAll: function addAll(t) {
	      for (var e = t.iterator(); e.hasNext();) {
	        this.add(e.next());
	      }
	    }, findEdgeIndex: function findEdgeIndex(t) {
	      for (var e = 0; e < this.edges.size(); e++) {
	        if (this.edges.get(e).equals(t)) return e;
	      }return -1;
	    }, iterator: function iterator() {
	      return this.edges.iterator();
	    }, getEdges: function getEdges() {
	      return this.edges;
	    }, get: function get(t) {
	      return this.edges.get(t);
	    }, findEqualEdge: function findEqualEdge(t) {
	      var e = new wi(t.getCoordinates());return this.ocaMap.get(e);
	    }, add: function add(t) {
	      this.edges.add(t);var e = new wi(t.getCoordinates());this.ocaMap.put(e, t);
	    }, interfaces_: function interfaces_() {
	      return [];
	    }, getClass: function getClass() {
	      return Ti;
	    } }), br(Oi, Ri), Or(Oi.prototype, { insertUniqueEdge: function insertUniqueEdge(t) {
	      var e = this.edgeList.findEqualEdge(t);if (null !== e) {
	        var n = e.getLabel(),
	            i = t.getLabel();e.isPointwiseEqual(t) || (i = new Ae(t.getLabel()), i.flip());var r = e.getDepth();r.isNull() && r.add(n), r.add(i), n.merge(i);
	      } else this.edgeList.add(t);
	    }, getGraph: function getGraph() {
	      return this.graph;
	    }, cancelDuplicateResultEdges: function cancelDuplicateResultEdges() {
	      for (var t = this.graph.getEdgeEnds().iterator(); t.hasNext();) {
	        var e = t.next(),
	            n = e.getSym();e.isInResult() && n.isInResult() && (e.setInResult(!1), n.setInResult(!1));
	      }
	    }, isCoveredByLA: function isCoveredByLA(t) {
	      return !!this.isCovered(t, this.resultLineList) || !!this.isCovered(t, this.resultPolyList);
	    }, computeGeometry: function computeGeometry(t, e, n, i) {
	      var r = new I();return r.addAll(t), r.addAll(e), r.addAll(n), r.isEmpty() ? Oi.createEmptyResult(i, this.arg[0].getGeometry(), this.arg[1].getGeometry(), this.geomFact) : this.geomFact.buildGeometry(r);
	    }, mergeSymLabels: function mergeSymLabels() {
	      for (var t = this.graph.getNodes().iterator(); t.hasNext();) {
	        t.next().getEdges().mergeSymLabels();
	      }
	    }, isCovered: function isCovered(t, e) {
	      for (var n = e.iterator(); n.hasNext();) {
	        var i = n.next();if (this.ptLocator.locate(t, i) !== S.EXTERIOR) return !0;
	      }return !1;
	    }, replaceCollapsedEdges: function replaceCollapsedEdges() {
	      for (var t = new I(), e = this.edgeList.iterator(); e.hasNext();) {
	        var n = e.next();n.isCollapsed() && (e.remove(), t.add(n.getCollapsedEdge()));
	      }this.edgeList.addAll(t);
	    }, updateNodeLabelling: function updateNodeLabelling() {
	      for (var t = this.graph.getNodes().iterator(); t.hasNext();) {
	        var e = t.next(),
	            n = e.getEdges().getLabel();e.getLabel().merge(n);
	      }
	    }, getResultGeometry: function getResultGeometry(t) {
	      return this.computeOverlay(t), this.resultGeom;
	    }, insertUniqueEdges: function insertUniqueEdges(t) {
	      for (var e = t.iterator(); e.hasNext();) {
	        var n = e.next();this.insertUniqueEdge(n);
	      }
	    }, computeOverlay: function computeOverlay(t) {
	      this.copyPoints(0), this.copyPoints(1), this.arg[0].computeSelfNodes(this.li, !1), this.arg[1].computeSelfNodes(this.li, !1), this.arg[0].computeEdgeIntersections(this.arg[1], this.li, !0);var e = new I();this.arg[0].computeSplitEdges(e), this.arg[1].computeSplitEdges(e);this.insertUniqueEdges(e), this.computeLabelsFromDepths(), this.replaceCollapsedEdges(), Ni.checkValid(this.edgeList.getEdges()), this.graph.addEdges(this.edgeList.getEdges()), this.computeLabelling(), this.labelIncompleteNodes(), this.findResultAreaEdges(t), this.cancelDuplicateResultEdges();var n = new Ci(this.geomFact);n.add(this.graph), this.resultPolyList = n.getPolygons();var i = new Si(this, this.geomFact, this.ptLocator);this.resultLineList = i.build(t);var r = new Li(this, this.geomFact, this.ptLocator);this.resultPointList = r.build(t), this.resultGeom = this.computeGeometry(this.resultPointList, this.resultLineList, this.resultPolyList, t);
	    }, labelIncompleteNode: function labelIncompleteNode(t, e) {
	      var n = this.ptLocator.locate(t.getCoordinate(), this.arg[e].getGeometry());t.getLabel().setLocation(e, n);
	    }, copyPoints: function copyPoints(t) {
	      for (var e = this.arg[t].getNodeIterator(); e.hasNext();) {
	        var n = e.next();this.graph.addNode(n.getCoordinate()).setLabel(t, n.getLabel().getLocation(t));
	      }
	    }, findResultAreaEdges: function findResultAreaEdges(t) {
	      for (var e = this.graph.getEdgeEnds().iterator(); e.hasNext();) {
	        var n = e.next(),
	            i = n.getLabel();i.isArea() && !n.isInteriorAreaEdge() && Oi.isResultOfOp(i.getLocation(0, Pe.RIGHT), i.getLocation(1, Pe.RIGHT), t) && n.setInResult(!0);
	      }
	    }, computeLabelsFromDepths: function computeLabelsFromDepths() {
	      for (var t = this.edgeList.iterator(); t.hasNext();) {
	        var e = t.next(),
	            n = e.getLabel(),
	            i = e.getDepth();if (!i.isNull()) {
	          i.normalize();for (var r = 0; r < 2; r++) {
	            n.isNull(r) || !n.isArea() || i.isNull(r) || (0 === i.getDelta(r) ? n.toLine(r) : (h.isTrue(!i.isNull(r, Pe.LEFT), "depth of LEFT side has not been initialized"), n.setLocation(r, Pe.LEFT, i.getLocation(r, Pe.LEFT)), h.isTrue(!i.isNull(r, Pe.RIGHT), "depth of RIGHT side has not been initialized"), n.setLocation(r, Pe.RIGHT, i.getLocation(r, Pe.RIGHT))));
	          }
	        }
	      }
	    }, computeLabelling: function computeLabelling() {
	      for (var t = this.graph.getNodes().iterator(); t.hasNext();) {
	        t.next().getEdges().computeLabelling(this.arg);
	      }this.mergeSymLabels(), this.updateNodeLabelling();
	    }, labelIncompleteNodes: function labelIncompleteNodes() {
	      for (var t = 0, e = this.graph.getNodes().iterator(); e.hasNext();) {
	        var n = e.next(),
	            i = n.getLabel();n.isIsolated() && (t++, i.isNull(0) ? this.labelIncompleteNode(n, 0) : this.labelIncompleteNode(n, 1)), n.getEdges().updateLabelling(i);
	      }
	    }, isCoveredByA: function isCoveredByA(t) {
	      return !!this.isCovered(t, this.resultPolyList);
	    }, interfaces_: function interfaces_() {
	      return [];
	    }, getClass: function getClass() {
	      return Oi;
	    } }), Oi.overlayOp = function (t, e, n) {
	    return new Oi(t, e).getResultGeometry(n);
	  }, Oi.intersection = function (t, e) {
	    if (t.isEmpty() || e.isEmpty()) return Oi.createEmptyResult(Oi.INTERSECTION, t, e, t.getFactory());if (t.isGeometryCollection()) {
	      var n = e;return be.map(t, { interfaces_: function interfaces_() {
	          return [MapOp];
	        }, map: function map(t) {
	          return t.intersection(n);
	        } });
	    }return t.checkNotGeometryCollection(t), t.checkNotGeometryCollection(e), Pi.overlayOp(t, e, Oi.INTERSECTION);
	  }, Oi.symDifference = function (t, e) {
	    if (t.isEmpty() || e.isEmpty()) {
	      if (t.isEmpty() && e.isEmpty()) return Oi.createEmptyResult(Oi.SYMDIFFERENCE, t, e, t.getFactory());if (t.isEmpty()) return e.copy();if (e.isEmpty()) return t.copy();
	    }return t.checkNotGeometryCollection(t), t.checkNotGeometryCollection(e), Pi.overlayOp(t, e, Oi.SYMDIFFERENCE);
	  }, Oi.resultDimension = function (t, e, n) {
	    var i = e.getDimension(),
	        r = n.getDimension(),
	        s = -1;switch (t) {case Oi.INTERSECTION:
	        s = Math.min(i, r);break;case Oi.UNION:
	        s = Math.max(i, r);break;case Oi.DIFFERENCE:
	        s = i;break;case Oi.SYMDIFFERENCE:
	        s = Math.max(i, r);}return s;
	  }, Oi.createEmptyResult = function (t, e, n, i) {
	    var r = null;switch (Oi.resultDimension(t, e, n)) {case -1:
	        r = i.createGeometryCollection(new Array(0).fill(null));break;case 0:
	        r = i.createPoint();break;case 1:
	        r = i.createLineString();break;case 2:
	        r = i.createPolygon();}return r;
	  }, Oi.difference = function (t, e) {
	    return t.isEmpty() ? Oi.createEmptyResult(Oi.DIFFERENCE, t, e, t.getFactory()) : e.isEmpty() ? t.copy() : (t.checkNotGeometryCollection(t), t.checkNotGeometryCollection(e), Pi.overlayOp(t, e, Oi.DIFFERENCE));
	  }, Oi.isResultOfOp = function () {
	    if (2 === arguments.length) {
	      var t = arguments[0],
	          e = arguments[1],
	          n = t.getLocation(0),
	          i = t.getLocation(1);return Oi.isResultOfOp(n, i, e);
	    }if (3 === arguments.length) {
	      var r = arguments[0],
	          s = arguments[1],
	          o = arguments[2];switch (r === S.BOUNDARY && (r = S.INTERIOR), s === S.BOUNDARY && (s = S.INTERIOR), o) {case Oi.INTERSECTION:
	          return r === S.INTERIOR && s === S.INTERIOR;case Oi.UNION:
	          return r === S.INTERIOR || s === S.INTERIOR;case Oi.DIFFERENCE:
	          return r === S.INTERIOR && s !== S.INTERIOR;case Oi.SYMDIFFERENCE:
	          return r === S.INTERIOR && s !== S.INTERIOR || r !== S.INTERIOR && s === S.INTERIOR;}return !1;
	    }
	  }, Oi.INTERSECTION = 1, Oi.UNION = 2, Oi.DIFFERENCE = 3, Oi.SYMDIFFERENCE = 4, Or(bi.prototype, { selfSnap: function selfSnap(t) {
	      return new $n(t).snapTo(t, this.snapTolerance);
	    }, removeCommonBits: function removeCommonBits(t) {
	      this.cbr = new ni(), this.cbr.add(t[0]), this.cbr.add(t[1]);var e = new Array(2).fill(null);return e[0] = this.cbr.removeCommonBits(t[0].copy()), e[1] = this.cbr.removeCommonBits(t[1].copy()), e;
	    }, prepareResult: function prepareResult(t) {
	      return this.cbr.addCommonBits(t), t;
	    }, getResultGeometry: function getResultGeometry(t) {
	      var e = this.snap(this.geom),
	          n = Oi.overlayOp(e[0], e[1], t);return this.prepareResult(n);
	    }, checkValid: function checkValid(t) {
	      t.isValid() || _.out.println("Snapped geometry is invalid");
	    }, computeSnapTolerance: function computeSnapTolerance() {
	      this.snapTolerance = $n.computeOverlaySnapTolerance(this.geom[0], this.geom[1]);
	    }, snap: function snap(t) {
	      var e = this.removeCommonBits(t);return $n.snap(e[0], e[1], this.snapTolerance);
	    }, interfaces_: function interfaces_() {
	      return [];
	    }, getClass: function getClass() {
	      return bi;
	    } }), bi.overlayOp = function (t, e, n) {
	    return new bi(t, e).getResultGeometry(n);
	  }, bi.union = function (t, e) {
	    return bi.overlayOp(t, e, Oi.UNION);
	  }, bi.intersection = function (t, e) {
	    return bi.overlayOp(t, e, Oi.INTERSECTION);
	  }, bi.symDifference = function (t, e) {
	    return bi.overlayOp(t, e, Oi.SYMDIFFERENCE);
	  }, bi.difference = function (t, e) {
	    return bi.overlayOp(t, e, Oi.DIFFERENCE);
	  }, Or(Pi.prototype, { getResultGeometry: function getResultGeometry(t) {
	      var e = null,
	          n = !1,
	          i = null;try {
	        e = Oi.overlayOp(this.geom[0], this.geom[1], t);n = !0;
	      } catch (t) {
	        if (!(t instanceof u)) throw t;i = t;
	      } finally {}if (!n) try {
	        e = bi.overlayOp(this.geom[0], this.geom[1], t);
	      } catch (t) {
	        throw t instanceof u ? i : t;
	      } finally {}return e;
	    }, interfaces_: function interfaces_() {
	      return [];
	    }, getClass: function getClass() {
	      return Pi;
	    } }), Pi.overlayOp = function (t, e, n) {
	    return new Pi(t, e).getResultGeometry(n);
	  }, Pi.union = function (t, e) {
	    return Pi.overlayOp(t, e, Oi.UNION);
	  }, Pi.intersection = function (t, e) {
	    return Pi.overlayOp(t, e, Oi.INTERSECTION);
	  }, Pi.symDifference = function (t, e) {
	    return Pi.overlayOp(t, e, Oi.SYMDIFFERENCE);
	  }, Pi.difference = function (t, e) {
	    return Pi.overlayOp(t, e, Oi.DIFFERENCE);
	  }, Or(_i.prototype, { addPolygon: function addPolygon(t) {
	      if (t.isEmpty()) return null;var e = null,
	          n = 0,
	          i = this.horizontalBisector(t);if (0 === i.getLength()) n = 0, e = i.getCoordinate();else {
	        var r = Pi.overlayOp(i, t, Oi.INTERSECTION),
	            s = this.widestGeometry(r);n = s.getEnvelopeInternal().getWidth(), e = _i.centre(s.getEnvelopeInternal());
	      }(null === this.interiorPoint || n > this.maxWidth) && (this.interiorPoint = e, this.maxWidth = n);
	    }, getInteriorPoint: function getInteriorPoint() {
	      return this.interiorPoint;
	    }, widestGeometry: function widestGeometry() {
	      if (arguments[0] instanceof lt) {
	        var t = arguments[0];if (t.isEmpty()) return t;for (var e = t.getGeometryN(0), n = 1; n < t.getNumGeometries(); n++) {
	          t.getGeometryN(n).getEnvelopeInternal().getWidth() > e.getEnvelopeInternal().getWidth() && (e = t.getGeometryN(n));
	        }return e;
	      }if (arguments[0] instanceof F) {
	        var i = arguments[0];return i instanceof lt ? this.widestGeometry(i) : i;
	      }
	    }, horizontalBisector: function horizontalBisector(t) {
	      var e = t.getEnvelopeInternal(),
	          n = Mi.getBisectorY(t);return this.factory.createLineString([new c(e.getMinX(), n), new c(e.getMaxX(), n)]);
	    }, add: function add(t) {
	      if (t instanceof Lt) this.addPolygon(t);else if (t instanceof lt) for (var e = t, n = 0; n < e.getNumGeometries(); n++) {
	        this.add(e.getGeometryN(n));
	      }
	    }, interfaces_: function interfaces_() {
	      return [];
	    }, getClass: function getClass() {
	      return _i;
	    } }), _i.centre = function (t) {
	    return new c(_i.avg(t.getMinX(), t.getMaxX()), _i.avg(t.getMinY(), t.getMaxY()));
	  }, _i.avg = function (t, e) {
	    return (t + e) / 2;
	  }, Or(Mi.prototype, { updateInterval: function updateInterval(t) {
	      t <= this.centreY ? t > this.loY && (this.loY = t) : t > this.centreY && t < this.hiY && (this.hiY = t);
	    }, getBisectorY: function getBisectorY() {
	      this.process(this.poly.getExteriorRing());for (var t = 0; t < this.poly.getNumInteriorRing(); t++) {
	        this.process(this.poly.getInteriorRingN(t));
	      }return _i.avg(this.hiY, this.loY);
	    }, process: function process(t) {
	      for (var e = t.getCoordinateSequence(), n = 0; n < e.size(); n++) {
	        var i = e.getY(n);this.updateInterval(i);
	      }
	    }, interfaces_: function interfaces_() {
	      return [];
	    }, getClass: function getClass() {
	      return Mi;
	    } }), Mi.getBisectorY = function (t) {
	    return new Mi(t).getBisectorY();
	  }, _i.SafeBisectorFinder = Mi, Or(Ai.prototype, { extractElements: function extractElements(t, e) {
	      if (null === t) return null;for (var n = 0; n < t.getNumGeometries(); n++) {
	        var i = t.getGeometryN(n);this.skipEmpty && i.isEmpty() || e.add(i);
	      }
	    }, combine: function combine() {
	      for (var t = new I(), e = this.inputGeoms.iterator(); e.hasNext();) {
	        var n = e.next();this.extractElements(n, t);
	      }return 0 === t.size() ? null !== this.geomFactory ? this.geomFactory.createGeometryCollection(null) : null : this.geomFactory.buildGeometry(t);
	    }, interfaces_: function interfaces_() {
	      return [];
	    }, getClass: function getClass() {
	      return Ai;
	    } }), Ai.combine = function () {
	    if (1 === arguments.length) {
	      var t = arguments[0],
	          e = new Ai(t);return e.combine();
	    }if (2 === arguments.length) {
	      var n = arguments[0],
	          i = arguments[1],
	          e = new Ai(Ai.createList(n, i));return e.combine();
	    }if (3 === arguments.length) {
	      var r = arguments[0],
	          s = arguments[1],
	          o = arguments[2],
	          e = new Ai(Ai.createList(r, s, o));return e.combine();
	    }
	  }, Ai.extractFactory = function (t) {
	    return t.isEmpty() ? null : t.iterator().next().getFactory();
	  }, Ai.createList = function () {
	    if (2 === arguments.length) {
	      var t = arguments[0],
	          e = arguments[1],
	          n = new I();return n.add(t), n.add(e), n;
	    }if (3 === arguments.length) {
	      var i = arguments[0],
	          r = arguments[1],
	          s = arguments[2],
	          n = new I();return n.add(i), n.add(r), n.add(s), n;
	    }
	  }, Or(Di.prototype, { union: function union() {
	      for (var t = new Ce(), e = new rt(), n = 0; n < this.pointGeom.getNumGeometries(); n++) {
	        var i = this.pointGeom.getGeometryN(n),
	            r = i.getCoordinate();t.locate(r, this.otherGeom) === S.EXTERIOR && e.add(r);
	      }if (0 === e.size()) return this.otherGeom;var s = null,
	          o = X.toCoordinateArray(e);return s = 1 === o.length ? this.geomFact.createPoint(o[0]) : this.geomFact.createMultiPointFromCoords(o), Ai.combine(s, this.otherGeom);
	    }, interfaces_: function interfaces_() {
	      return [];
	    }, getClass: function getClass() {
	      return Di;
	    } }), Di.union = function (t, e) {
	    return new Di(t, e).union();
	  }, Or(Fi.prototype, { filter: function filter(t) {
	      this.sortIndex !== -1 && t.getSortIndex() !== this.sortIndex || this.comps.add(t);
	    }, interfaces_: function interfaces_() {
	      return [at];
	    }, getClass: function getClass() {
	      return Fi;
	    } }), Fi.extract = function () {
	    if (2 === arguments.length) {
	      var t = arguments[0],
	          e = arguments[1];return Fi.extract(t, e, new I());
	    }if (3 === arguments.length) {
	      var n = arguments[0],
	          i = arguments[1],
	          r = arguments[2];return n.getSortIndex() === i ? r.add(n) : n instanceof lt && n.apply(new Fi(i, r)), r;
	    }
	  }, Or(Gi.prototype, { reduceToGeometries: function reduceToGeometries(t) {
	      for (var e = new I(), n = t.iterator(); n.hasNext();) {
	        var i = n.next(),
	            r = null;_r(i, m) ? r = this.unionTree(i) : i instanceof F && (r = i), e.add(r);
	      }return e;
	    }, extractByEnvelope: function extractByEnvelope(t, e, n) {
	      for (var i = new I(), r = 0; r < e.getNumGeometries(); r++) {
	        var s = e.getGeometryN(r);s.getEnvelopeInternal().intersects(t) ? i.add(s) : n.add(s);
	      }return this.geomFactory.buildGeometry(i);
	    }, unionOptimized: function unionOptimized(t, e) {
	      var n = t.getEnvelopeInternal(),
	          i = e.getEnvelopeInternal();if (!n.intersects(i)) {
	        return Ai.combine(t, e);
	      }if (t.getNumGeometries() <= 1 && e.getNumGeometries() <= 1) return this.unionActual(t, e);var r = n.intersection(i);return this.unionUsingEnvelopeIntersection(t, e, r);
	    }, union: function union() {
	      if (null === this.inputPolys) throw new IllegalStateException("union() method cannot be called twice");if (this.inputPolys.isEmpty()) return null;this.geomFactory = this.inputPolys.iterator().next().getFactory();for (var t = new Hn(Gi.STRTREE_NODE_CAPACITY), e = this.inputPolys.iterator(); e.hasNext();) {
	        var n = e.next();t.insert(n.getEnvelopeInternal(), n);
	      }this.inputPolys = null;var i = t.itemsTree();return this.unionTree(i);
	    }, binaryUnion: function binaryUnion() {
	      if (1 === arguments.length) {
	        var t = arguments[0];return this.binaryUnion(t, 0, t.size());
	      }if (3 === arguments.length) {
	        var e = arguments[0],
	            n = arguments[1],
	            i = arguments[2];if (i - n <= 1) {
	          var r = Gi.getGeometry(e, n);return this.unionSafe(r, null);
	        }if (i - n == 2) return this.unionSafe(Gi.getGeometry(e, n), Gi.getGeometry(e, n + 1));var s = Math.trunc((i + n) / 2),
	            r = this.binaryUnion(e, n, s),
	            o = this.binaryUnion(e, s, i);return this.unionSafe(r, o);
	      }
	    }, repeatedUnion: function repeatedUnion(t) {
	      for (var e = null, n = t.iterator(); n.hasNext();) {
	        var i = n.next();e = null === e ? i.copy() : e.union(i);
	      }return e;
	    }, unionSafe: function unionSafe(t, e) {
	      return null === t && null === e ? null : null === t ? e.copy() : null === e ? t.copy() : this.unionOptimized(t, e);
	    }, unionActual: function unionActual(t, e) {
	      return Gi.restrictToPolygons(t.union(e));
	    }, unionTree: function unionTree(t) {
	      var e = this.reduceToGeometries(t);return this.binaryUnion(e);
	    }, unionUsingEnvelopeIntersection: function unionUsingEnvelopeIntersection(t, e, n) {
	      var i = new I(),
	          r = this.extractByEnvelope(n, t, i),
	          s = this.extractByEnvelope(n, e, i),
	          o = this.unionActual(r, s);return i.add(o), Ai.combine(i);
	    }, bufferUnion: function bufferUnion() {
	      if (1 === arguments.length) {
	        var t = arguments[0],
	            e = t.get(0).getFactory(),
	            n = e.buildGeometry(t),
	            i = n.buffer(0);return i;
	      }if (2 === arguments.length) {
	        var r = arguments[0],
	            s = arguments[1],
	            e = r.getFactory(),
	            n = e.createGeometryCollection([r, s]),
	            i = n.buffer(0);return i;
	      }
	    }, interfaces_: function interfaces_() {
	      return [];
	    }, getClass: function getClass() {
	      return Gi;
	    } }), Gi.restrictToPolygons = function (t) {
	    if (_r(t, St)) return t;var e = Se.getPolygons(t);return 1 === e.size() ? e.get(0) : t.getFactory().createMultiPolygon($t.toPolygonArray(e));
	  }, Gi.getGeometry = function (t, e) {
	    return e >= t.size() ? null : t.get(e);
	  }, Gi.union = function (t) {
	    return new Gi(t).union();
	  }, Gi.STRTREE_NODE_CAPACITY = 4, Or(Bi.prototype, { unionNoOpt: function unionNoOpt(t) {
	      var e = this.geomFact.createPoint();return Pi.overlayOp(t, e, Oi.UNION);
	    }, unionWithNull: function unionWithNull(t, e) {
	      return null === t && null === e ? null : null === e ? t : null === t ? e : t.union(e);
	    }, extract: function extract() {
	      if (_r(arguments[0], d)) for (var t = arguments[0], e = t.iterator(); e.hasNext();) {
	        var n = e.next();this.extract(n);
	      } else if (arguments[0] instanceof F) {
	        var i = arguments[0];null === this.geomFact && (this.geomFact = i.getFactory()), Fi.extract(i, F.SORTINDEX_POLYGON, this.polygons), Fi.extract(i, F.SORTINDEX_LINESTRING, this.lines), Fi.extract(i, F.SORTINDEX_POINT, this.points);
	      }
	    }, union: function union() {
	      if (null === this.geomFact) return null;var t = null;if (this.points.size() > 0) {
	        var e = this.geomFact.buildGeometry(this.points);t = this.unionNoOpt(e);
	      }var n = null;if (this.lines.size() > 0) {
	        var i = this.geomFact.buildGeometry(this.lines);n = this.unionNoOpt(i);
	      }var r = null;this.polygons.size() > 0 && (r = Gi.union(this.polygons));var s = this.unionWithNull(n, r),
	          o = null;return o = null === t ? s : null === s ? t : Di.union(t, s), null === o ? this.geomFact.createGeometryCollection() : o;
	    }, interfaces_: function interfaces_() {
	      return [];
	    }, getClass: function getClass() {
	      return Bi;
	    } }), Bi.union = function () {
	    if (1 === arguments.length) {
	      if (_r(arguments[0], d)) {
	        var t = arguments[0],
	            e = new Bi(t);return e.union();
	      }if (arguments[0] instanceof F) {
	        var n = arguments[0],
	            e = new Bi(n);return e.union();
	      }
	    } else if (2 === arguments.length) {
	      var i = arguments[0],
	          r = arguments[1],
	          e = new Bi(i, r);return e.union();
	    }
	  }, Or(qi.prototype, { interfaces_: function interfaces_() {
	      return [];
	    }, getClass: function getClass() {
	      return qi;
	    } }), qi.union = function (t, e) {
	    if (t.isEmpty() || e.isEmpty()) {
	      if (t.isEmpty() && e.isEmpty()) return Oi.createEmptyResult(Oi.UNION, t, e, t.getFactory());if (t.isEmpty()) return e.copy();if (e.isEmpty()) return t.copy();
	    }return t.checkNotGeometryCollection(t), t.checkNotGeometryCollection(e), Pi.overlayOp(t, e, Oi.UNION);
	  }, Or(zi.prototype, { addEndpoints: function addEndpoints() {
	      if (arguments[0] instanceof F) {
	        var t = arguments[0];if (t instanceof xt) this.addEndpoints(t.getCoordinates());else if (t instanceof lt) for (var e = t, n = 0; n < e.getNumGeometries(); n++) {
	          this.addEndpoints(e.getGeometryN(n));
	        }
	      } else if (arguments[0] instanceof Array) {
	        var i = arguments[0];this.add(i[0]), this.add(i[i.length - 1]);
	      }
	    }, getInteriorPoint: function getInteriorPoint() {
	      return this.interiorPoint;
	    }, addInterior: function addInterior() {
	      if (arguments[0] instanceof F) {
	        var t = arguments[0];if (t instanceof xt) this.addInterior(t.getCoordinates());else if (t instanceof lt) for (var e = t, n = 0; n < e.getNumGeometries(); n++) {
	          this.addInterior(e.getGeometryN(n));
	        }
	      } else if (arguments[0] instanceof Array) for (var i = arguments[0], n = 1; n < i.length - 1; n++) {
	        this.add(i[n]);
	      }
	    }, add: function add(t) {
	      var e = t.distance(this.centroid);e < this.minDistance && (this.interiorPoint = new c(t), this.minDistance = e);
	    }, interfaces_: function interfaces_() {
	      return [];
	    }, getClass: function getClass() {
	      return zi;
	    } }), Or(Ui.prototype, { isSimpleMultiPoint: function isSimpleMultiPoint(t) {
	      if (t.isEmpty()) return !0;for (var e = new rt(), n = 0; n < t.getNumGeometries(); n++) {
	        var i = t.getGeometryN(n),
	            r = i.getCoordinate();if (e.contains(r)) return this.nonSimpleLocation = r, !1;e.add(r);
	      }return !0;
	    }, isSimplePolygonal: function isSimplePolygonal(t) {
	      for (var e = Te.getLines(t), n = e.iterator(); n.hasNext();) {
	        var i = n.next();if (!this.isSimpleLinearGeometry(i)) return !1;
	      }return !0;
	    }, hasClosedEndpointIntersection: function hasClosedEndpointIntersection(t) {
	      for (var e = new et(), n = t.getEdgeIterator(); n.hasNext();) {
	        var i = n.next(),
	            r = (i.getMaximumSegmentIndex(), i.isClosed()),
	            s = i.getCoordinate(0);this.addEndpoint(e, s, r);var o = i.getCoordinate(i.getNumPoints() - 1);this.addEndpoint(e, o, r);
	      }for (var n = e.values().iterator(); n.hasNext();) {
	        var a = n.next();if (a.isClosed && 2 !== a.degree) return this.nonSimpleLocation = a.getCoordinate(), !0;
	      }return !1;
	    }, getNonSimpleLocation: function getNonSimpleLocation() {
	      return this.nonSimpleLocation;
	    }, isSimpleLinearGeometry: function isSimpleLinearGeometry(t) {
	      if (t.isEmpty()) return !0;var e = new bn(0, t),
	          n = new ie(),
	          i = e.computeSelfNodes(n, !0);return !i.hasIntersection() || (i.hasProperIntersection() ? (this.nonSimpleLocation = i.getProperIntersectionPoint(), !1) : !this.hasNonEndpointIntersection(e) && (!this.isClosedEndpointsInInterior || !this.hasClosedEndpointIntersection(e)));
	    }, hasNonEndpointIntersection: function hasNonEndpointIntersection(t) {
	      for (var e = t.getEdgeIterator(); e.hasNext();) {
	        for (var n = e.next(), i = n.getMaximumSegmentIndex(), r = n.getEdgeIntersectionList().iterator(); r.hasNext();) {
	          var s = r.next();if (!s.isEndPoint(i)) return this.nonSimpleLocation = s.getCoordinate(), !0;
	        }
	      }return !1;
	    }, addEndpoint: function addEndpoint(t, e, n) {
	      var i = t.get(e);null === i && (i = new Yi(e), t.put(e, i)), i.addEndpoint(n);
	    }, computeSimple: function computeSimple(t) {
	      return this.nonSimpleLocation = null, !!t.isEmpty() || (t instanceof xt ? this.isSimpleLinearGeometry(t) : t instanceof ht ? this.isSimpleLinearGeometry(t) : t instanceof Rt ? this.isSimpleMultiPoint(t) : _r(t, St) ? this.isSimplePolygonal(t) : !(t instanceof lt) || this.isSimpleGeometryCollection(t));
	    }, isSimple: function isSimple() {
	      return this.nonSimpleLocation = null, this.computeSimple(this.inputGeom);
	    }, isSimpleGeometryCollection: function isSimpleGeometryCollection(t) {
	      for (var e = 0; e < t.getNumGeometries(); e++) {
	        var n = t.getGeometryN(e);if (!this.computeSimple(n)) return !1;
	      }return !0;
	    }, interfaces_: function interfaces_() {
	      return [];
	    }, getClass: function getClass() {
	      return Ui;
	    } }), Or(Yi.prototype, { addEndpoint: function addEndpoint(t) {
	      this.degree++, this.isClosed |= t;
	    }, getCoordinate: function getCoordinate() {
	      return this.pt;
	    }, interfaces_: function interfaces_() {
	      return [];
	    }, getClass: function getClass() {
	      return Yi;
	    } }), Ui.EndpointInfo = Yi, Or(Xi.prototype, { getEndCapStyle: function getEndCapStyle() {
	      return this.endCapStyle;
	    }, isSingleSided: function isSingleSided() {
	      return this._isSingleSided;
	    }, setQuadrantSegments: function setQuadrantSegments(t) {
	      this.quadrantSegments = t, 0 === this.quadrantSegments && (this.joinStyle = Xi.JOIN_BEVEL), this.quadrantSegments < 0 && (this.joinStyle = Xi.JOIN_MITRE, this.mitreLimit = Math.abs(this.quadrantSegments)), t <= 0 && (this.quadrantSegments = 1), this.joinStyle !== Xi.JOIN_ROUND && (this.quadrantSegments = Xi.DEFAULT_QUADRANT_SEGMENTS);
	    }, getJoinStyle: function getJoinStyle() {
	      return this.joinStyle;
	    }, setJoinStyle: function setJoinStyle(t) {
	      this.joinStyle = t;
	    }, setSimplifyFactor: function setSimplifyFactor(t) {
	      this.simplifyFactor = t < 0 ? 0 : t;
	    }, getSimplifyFactor: function getSimplifyFactor() {
	      return this.simplifyFactor;
	    }, getQuadrantSegments: function getQuadrantSegments() {
	      return this.quadrantSegments;
	    }, setEndCapStyle: function setEndCapStyle(t) {
	      this.endCapStyle = t;
	    }, getMitreLimit: function getMitreLimit() {
	      return this.mitreLimit;
	    }, setMitreLimit: function setMitreLimit(t) {
	      this.mitreLimit = t;
	    }, setSingleSided: function setSingleSided(t) {
	      this._isSingleSided = t;
	    }, interfaces_: function interfaces_() {
	      return [];
	    }, getClass: function getClass() {
	      return Xi;
	    } }), Xi.bufferDistanceError = function (t) {
	    var e = Math.PI / 2 / t;return 1 - Math.cos(e / 2);
	  }, Xi.CAP_ROUND = 1, Xi.CAP_FLAT = 2, Xi.CAP_SQUARE = 3, Xi.JOIN_ROUND = 1, Xi.JOIN_MITRE = 2, Xi.JOIN_BEVEL = 3, Xi.DEFAULT_QUADRANT_SEGMENTS = 8, Xi.DEFAULT_MITRE_LIMIT = 5, Xi.DEFAULT_SIMPLIFY_FACTOR = .01, ki.prototype = new Error(), ki.prototype.name = "EmptyStackException", Vi.prototype = new m(), Vi.prototype.add = function (t) {
	    return this.array_.push(t), !0;
	  }, Vi.prototype.get = function (t) {
	    if (t < 0 || t >= this.size()) throw new IndexOutOfBoundsException();return this.array_[t];
	  }, Vi.prototype.push = function (t) {
	    return this.array_.push(t), t;
	  }, Vi.prototype.pop = function (t) {
	    if (0 === this.array_.length) throw new ki();return this.array_.pop();
	  }, Vi.prototype.peek = function () {
	    if (0 === this.array_.length) throw new ki();return this.array_[this.array_.length - 1];
	  }, Vi.prototype.empty = function () {
	    return 0 === this.array_.length;
	  }, Vi.prototype.isEmpty = function () {
	    return this.empty();
	  }, Vi.prototype.search = function (t) {
	    return this.array_.indexOf(t);
	  }, Vi.prototype.size = function () {
	    return this.array_.length;
	  }, Vi.prototype.toArray = function () {
	    for (var t = [], e = 0, n = this.array_.length; e < n; e++) {
	      t.push(this.array_[e]);
	    }return t;
	  }, Or(Hi.prototype, { getCoordinate: function getCoordinate() {
	      return this.minCoord;
	    }, getRightmostSide: function getRightmostSide(t, e) {
	      var n = this.getRightmostSideOfSegment(t, e);return n < 0 && (n = this.getRightmostSideOfSegment(t, e - 1)), n < 0 && (this.minCoord = null, this.checkForRightmostCoordinate(t)), n;
	    }, findRightmostEdgeAtVertex: function findRightmostEdgeAtVertex() {
	      var t = this.minDe.getEdge().getCoordinates();h.isTrue(this.minIndex > 0 && this.minIndex < t.length, "rightmost point expected to be interior vertex of edge");var e = t[this.minIndex - 1],
	          n = t[this.minIndex + 1],
	          i = oe.computeOrientation(this.minCoord, n, e),
	          r = !1;e.y < this.minCoord.y && n.y < this.minCoord.y && i === oe.COUNTERCLOCKWISE ? r = !0 : e.y > this.minCoord.y && n.y > this.minCoord.y && i === oe.CLOCKWISE && (r = !0), r && (this.minIndex = this.minIndex - 1);
	    }, getRightmostSideOfSegment: function getRightmostSideOfSegment(t, e) {
	      var n = t.getEdge(),
	          i = n.getCoordinates();if (e < 0 || e + 1 >= i.length) return -1;if (i[e].y === i[e + 1].y) return -1;var r = Pe.LEFT;return i[e].y < i[e + 1].y && (r = Pe.RIGHT), r;
	    }, getEdge: function getEdge() {
	      return this.orientedDe;
	    }, checkForRightmostCoordinate: function checkForRightmostCoordinate(t) {
	      for (var e = t.getEdge().getCoordinates(), n = 0; n < e.length - 1; n++) {
	        (null === this.minCoord || e[n].x > this.minCoord.x) && (this.minDe = t, this.minIndex = n, this.minCoord = e[n]);
	      }
	    }, findRightmostEdgeAtNode: function findRightmostEdgeAtNode() {
	      var t = this.minDe.getNode(),
	          e = t.getEdges();this.minDe = e.getRightmostEdge(), this.minDe.isForward() || (this.minDe = this.minDe.getSym(), this.minIndex = this.minDe.getEdge().getCoordinates().length - 1);
	    }, findEdge: function findEdge(t) {
	      for (var e = t.iterator(); e.hasNext();) {
	        var n = e.next();n.isForward() && this.checkForRightmostCoordinate(n);
	      }h.isTrue(0 !== this.minIndex || this.minCoord.equals(this.minDe.getCoordinate()), "inconsistency in rightmost processing"), 0 === this.minIndex ? this.findRightmostEdgeAtNode() : this.findRightmostEdgeAtVertex(), this.orientedDe = this.minDe, this.getRightmostSide(this.minDe, this.minIndex) === Pe.LEFT && (this.orientedDe = this.minDe.getSym());
	    }, interfaces_: function interfaces_() {
	      return [];
	    }, getClass: function getClass() {
	      return Hi;
	    } }), Wi.prototype.addLast = function (t) {
	    this.array_.push(t);
	  }, Wi.prototype.removeFirst = function () {
	    return this.array_.shift();
	  }, Wi.prototype.isEmpty = function () {
	    return 0 === this.array_.length;
	  }, Or(ji.prototype, { clearVisitedEdges: function clearVisitedEdges() {
	      for (var t = this.dirEdgeList.iterator(); t.hasNext();) {
	        t.next().setVisited(!1);
	      }
	    }, getRightmostCoordinate: function getRightmostCoordinate() {
	      return this.rightMostCoord;
	    }, computeNodeDepth: function computeNodeDepth(t) {
	      for (var e = null, n = t.getEdges().iterator(); n.hasNext();) {
	        var i = n.next();if (i.isVisited() || i.getSym().isVisited()) {
	          e = i;break;
	        }
	      }if (null === e) throw new _e("unable to find edge to compute depths at " + t.getCoordinate());t.getEdges().computeDepths(e);for (var n = t.getEdges().iterator(); n.hasNext();) {
	        var i = n.next();i.setVisited(!0), this.copySymDepths(i);
	      }
	    }, computeDepth: function computeDepth(t) {
	      this.clearVisitedEdges();var e = this.finder.getEdge();e.getNode(), e.getLabel();e.setEdgeDepths(Pe.RIGHT, t), this.copySymDepths(e), this.computeDepths(e);
	    }, create: function create(t) {
	      this.addReachable(t), this.finder.findEdge(this.dirEdgeList), this.rightMostCoord = this.finder.getCoordinate();
	    }, findResultEdges: function findResultEdges() {
	      for (var t = this.dirEdgeList.iterator(); t.hasNext();) {
	        var e = t.next();e.getDepth(Pe.RIGHT) >= 1 && e.getDepth(Pe.LEFT) <= 0 && !e.isInteriorAreaEdge() && e.setInResult(!0);
	      }
	    }, computeDepths: function computeDepths(t) {
	      var e = new K(),
	          n = new Wi(),
	          i = t.getNode();for (n.addLast(i), e.add(i), t.setVisited(!0); !n.isEmpty();) {
	        var r = n.removeFirst();e.add(r), this.computeNodeDepth(r);for (var s = r.getEdges().iterator(); s.hasNext();) {
	          var o = s.next(),
	              a = o.getSym();if (!a.isVisited()) {
	            var u = a.getNode();e.contains(u) || (n.addLast(u), e.add(u));
	          }
	        }
	      }
	    }, compareTo: function compareTo(t) {
	      var e = t;return this.rightMostCoord.x < e.rightMostCoord.x ? -1 : this.rightMostCoord.x > e.rightMostCoord.x ? 1 : 0;
	    }, getEnvelope: function getEnvelope() {
	      if (null === this.env) {
	        for (var t = new x(), e = this.dirEdgeList.iterator(); e.hasNext();) {
	          for (var n = e.next(), i = n.getEdge().getCoordinates(), r = 0; r < i.length - 1; r++) {
	            t.expandToInclude(i[r]);
	          }
	        }this.env = t;
	      }return this.env;
	    }, addReachable: function addReachable(t) {
	      var e = new Vi();for (e.add(t); !e.empty();) {
	        var n = e.pop();this.add(n, e);
	      }
	    }, copySymDepths: function copySymDepths(t) {
	      var e = t.getSym();e.setDepth(Pe.LEFT, t.getDepth(Pe.RIGHT)), e.setDepth(Pe.RIGHT, t.getDepth(Pe.LEFT));
	    }, add: function add(t, e) {
	      t.setVisited(!0), this.nodes.add(t);for (var n = t.getEdges().iterator(); n.hasNext();) {
	        var i = n.next();this.dirEdgeList.add(i);var r = i.getSym(),
	            s = r.getNode();s.isVisited() || e.push(s);
	      }
	    }, getNodes: function getNodes() {
	      return this.nodes;
	    }, getDirectedEdges: function getDirectedEdges() {
	      return this.dirEdgeList;
	    }, interfaces_: function interfaces_() {
	      return [r];
	    }, getClass: function getClass() {
	      return ji;
	    } }), Or(Ki.prototype, { isDeletable: function isDeletable(t, e, n, i) {
	      var r = this.inputLine[t],
	          s = this.inputLine[e],
	          o = this.inputLine[n];return !!this.isConcave(r, s, o) && !!this.isShallow(r, s, o, i) && this.isShallowSampled(r, s, t, n, i);
	    }, deleteShallowConcavities: function deleteShallowConcavities() {
	      for (var t = 1, e = (this.inputLine.length, this.findNextNonDeletedIndex(t)), n = this.findNextNonDeletedIndex(e), i = !1; n < this.inputLine.length;) {
	        var r = !1;this.isDeletable(t, e, n, this.distanceTol) && (this.isDeleted[e] = Ki.DELETE, r = !0, i = !0), t = r ? n : e, e = this.findNextNonDeletedIndex(t), n = this.findNextNonDeletedIndex(e);
	      }return i;
	    }, isShallowConcavity: function isShallowConcavity(t, e, n, i) {
	      return oe.computeOrientation(t, e, n) === this.angleOrientation && oe.distancePointLine(e, t, n) < i;
	    }, isShallowSampled: function isShallowSampled(t, e, n, i, r) {
	      var s = Math.trunc((i - n) / Ki.NUM_PTS_TO_CHECK);s <= 0 && (s = 1);for (var o = n; o < i; o += s) {
	        if (!this.isShallow(t, e, this.inputLine[o], r)) return !1;
	      }return !0;
	    }, isConcave: function isConcave(t, e, n) {
	      return oe.computeOrientation(t, e, n) === this.angleOrientation;
	    }, simplify: function simplify(t) {
	      this.distanceTol = Math.abs(t), t < 0 && (this.angleOrientation = oe.CLOCKWISE), this.isDeleted = new Array(this.inputLine.length).fill(null);var e = !1;do {
	        e = this.deleteShallowConcavities();
	      } while (e);return this.collapseLine();
	    }, findNextNonDeletedIndex: function findNextNonDeletedIndex(t) {
	      for (var e = t + 1; e < this.inputLine.length && this.isDeleted[e] === Ki.DELETE;) {
	        e++;
	      }return e;
	    }, isShallow: function isShallow(t, e, n, i) {
	      return oe.distancePointLine(e, t, n) < i;
	    }, collapseLine: function collapseLine() {
	      for (var t = new E(), e = 0; e < this.inputLine.length; e++) {
	        this.isDeleted[e] !== Ki.DELETE && t.add(this.inputLine[e]);
	      }return t.toCoordinateArray();
	    }, interfaces_: function interfaces_() {
	      return [];
	    }, getClass: function getClass() {
	      return Ki;
	    } }), Ki.simplify = function (t, e) {
	    return new Ki(t).simplify(e);
	  }, Ki.INIT = 0, Ki.DELETE = 1, Ki.KEEP = 1, Ki.NUM_PTS_TO_CHECK = 10, Or(Ji.prototype, { getCoordinates: function getCoordinates() {
	      return this.ptList.toArray(Ji.COORDINATE_ARRAY_TYPE);
	    }, setPrecisionModel: function setPrecisionModel(t) {
	      this.precisionModel = t;
	    }, addPt: function addPt(t) {
	      var e = new c(t);if (this.precisionModel.makePrecise(e), this.isRedundant(e)) return null;this.ptList.add(e);
	    }, reverse: function reverse() {}, addPts: function addPts(t, e) {
	      if (e) for (var n = 0; n < t.length; n++) {
	        this.addPt(t[n]);
	      } else for (var n = t.length - 1; n >= 0; n--) {
	        this.addPt(t[n]);
	      }
	    }, isRedundant: function isRedundant(t) {
	      if (this.ptList.size() < 1) return !1;var e = this.ptList.get(this.ptList.size() - 1);return t.distance(e) < this.minimimVertexDistance;
	    }, toString: function toString() {
	      return new $t().createLineString(this.getCoordinates()).toString();
	    }, closeRing: function closeRing() {
	      if (this.ptList.size() < 1) return null;var t = new c(this.ptList.get(0)),
	          e = this.ptList.get(this.ptList.size() - 1);if (this.ptList.size() >= 2 && this.ptList.get(this.ptList.size() - 2), t.equals(e)) return null;this.ptList.add(t);
	    }, setMinimumVertexDistance: function setMinimumVertexDistance(t) {
	      this.minimimVertexDistance = t;
	    }, interfaces_: function interfaces_() {
	      return [];
	    }, getClass: function getClass() {
	      return Ji;
	    } }), Ji.COORDINATE_ARRAY_TYPE = new Array(0).fill(null), Or(Qi.prototype, { interfaces_: function interfaces_() {
	      return [];
	    }, getClass: function getClass() {
	      return Qi;
	    } }), Qi.toDegrees = function (t) {
	    return 180 * t / Math.PI;
	  }, Qi.normalize = function (t) {
	    for (; t > Math.PI;) {
	      t -= Qi.PI_TIMES_2;
	    }for (; t <= -Math.PI;) {
	      t += Qi.PI_TIMES_2;
	    }return t;
	  }, Qi.angle = function () {
	    if (1 === arguments.length) {
	      var t = arguments[0];return Math.atan2(t.y, t.x);
	    }if (2 === arguments.length) {
	      var e = arguments[0],
	          n = arguments[1],
	          i = n.x - e.x,
	          r = n.y - e.y;return Math.atan2(r, i);
	    }
	  }, Qi.isAcute = function (t, e, n) {
	    var i = t.x - e.x,
	        r = t.y - e.y;return i * (n.x - e.x) + r * (n.y - e.y) > 0;
	  }, Qi.isObtuse = function (t, e, n) {
	    var i = t.x - e.x,
	        r = t.y - e.y;return i * (n.x - e.x) + r * (n.y - e.y) < 0;
	  }, Qi.interiorAngle = function (t, e, n) {
	    var i = Qi.angle(e, t),
	        r = Qi.angle(e, n);return Math.abs(r - i);
	  }, Qi.normalizePositive = function (t) {
	    if (t < 0) {
	      for (; t < 0;) {
	        t += Qi.PI_TIMES_2;
	      }t >= Qi.PI_TIMES_2 && (t = 0);
	    } else {
	      for (; t >= Qi.PI_TIMES_2;) {
	        t -= Qi.PI_TIMES_2;
	      }t < 0 && (t = 0);
	    }return t;
	  }, Qi.angleBetween = function (t, e, n) {
	    var i = Qi.angle(e, t),
	        r = Qi.angle(e, n);return Qi.diff(i, r);
	  }, Qi.diff = function (t, e) {
	    var n = null;return n = t < e ? e - t : t - e, n > Math.PI && (n = 2 * Math.PI - n), n;
	  }, Qi.toRadians = function (t) {
	    return t * Math.PI / 180;
	  }, Qi.getTurn = function (t, e) {
	    var n = Math.sin(e - t);return n > 0 ? Qi.COUNTERCLOCKWISE : n < 0 ? Qi.CLOCKWISE : Qi.NONE;
	  }, Qi.angleBetweenOriented = function (t, e, n) {
	    var i = Qi.angle(e, t),
	        r = Qi.angle(e, n),
	        s = r - i;return s <= -Math.PI ? s + Qi.PI_TIMES_2 : s > Math.PI ? s - Qi.PI_TIMES_2 : s;
	  }, Qi.PI_TIMES_2 = 2 * Math.PI, Qi.PI_OVER_2 = Math.PI / 2, Qi.PI_OVER_4 = Math.PI / 4, Qi.COUNTERCLOCKWISE = oe.COUNTERCLOCKWISE, Qi.CLOCKWISE = oe.CLOCKWISE, Qi.NONE = oe.COLLINEAR, Or(Zi.prototype, { addNextSegment: function addNextSegment(t, e) {
	      if (this.s0 = this.s1, this.s1 = this.s2, this.s2 = t, this.seg0.setCoordinates(this.s0, this.s1), this.computeOffsetSegment(this.seg0, this.side, this.distance, this.offset0), this.seg1.setCoordinates(this.s1, this.s2), this.computeOffsetSegment(this.seg1, this.side, this.distance, this.offset1), this.s1.equals(this.s2)) return null;var n = oe.computeOrientation(this.s0, this.s1, this.s2),
	          i = n === oe.CLOCKWISE && this.side === Pe.LEFT || n === oe.COUNTERCLOCKWISE && this.side === Pe.RIGHT;0 === n ? this.addCollinear(e) : i ? this.addOutsideTurn(n, e) : this.addInsideTurn(n, e);
	    }, addLineEndCap: function addLineEndCap(t, e) {
	      var n = new ae(t, e),
	          i = new ae();this.computeOffsetSegment(n, Pe.LEFT, this.distance, i);var r = new ae();this.computeOffsetSegment(n, Pe.RIGHT, this.distance, r);var s = e.x - t.x,
	          o = e.y - t.y,
	          a = Math.atan2(o, s);switch (this.bufParams.getEndCapStyle()) {case Xi.CAP_ROUND:
	          this.segList.addPt(i.p1), this.addFilletArc(e, a + Math.PI / 2, a - Math.PI / 2, oe.CLOCKWISE, this.distance), this.segList.addPt(r.p1);break;case Xi.CAP_FLAT:
	          this.segList.addPt(i.p1), this.segList.addPt(r.p1);break;case Xi.CAP_SQUARE:
	          var u = new c();u.x = Math.abs(this.distance) * Math.cos(a), u.y = Math.abs(this.distance) * Math.sin(a);var l = new c(i.p1.x + u.x, i.p1.y + u.y),
	              h = new c(r.p1.x + u.x, r.p1.y + u.y);this.segList.addPt(l), this.segList.addPt(h);}
	    }, getCoordinates: function getCoordinates() {
	      return this.segList.getCoordinates();
	    }, addMitreJoin: function addMitreJoin(t, e, n, i) {
	      var r = !0,
	          s = null;try {
	        s = M.intersection(e.p0, e.p1, n.p0, n.p1);(i <= 0 ? 1 : s.distance(t) / Math.abs(i)) > this.bufParams.getMitreLimit() && (r = !1);
	      } catch (t) {
	        if (!(t instanceof C)) throw t;s = new c(0, 0), r = !1;
	      } finally {}r ? this.segList.addPt(s) : this.addLimitedMitreJoin(e, n, i, this.bufParams.getMitreLimit());
	    }, addFilletCorner: function addFilletCorner(t, e, n, i, r) {
	      var s = e.x - t.x,
	          o = e.y - t.y,
	          a = Math.atan2(o, s),
	          u = n.x - t.x,
	          l = n.y - t.y,
	          h = Math.atan2(l, u);i === oe.CLOCKWISE ? a <= h && (a += 2 * Math.PI) : a >= h && (a -= 2 * Math.PI), this.segList.addPt(e), this.addFilletArc(t, a, h, i, r), this.segList.addPt(n);
	    }, addOutsideTurn: function addOutsideTurn(t, e) {
	      if (this.offset0.p1.distance(this.offset1.p0) < this.distance * Zi.OFFSET_SEGMENT_SEPARATION_FACTOR) return this.segList.addPt(this.offset0.p1), null;this.bufParams.getJoinStyle() === Xi.JOIN_MITRE ? this.addMitreJoin(this.s1, this.offset0, this.offset1, this.distance) : this.bufParams.getJoinStyle() === Xi.JOIN_BEVEL ? this.addBevelJoin(this.offset0, this.offset1) : (e && this.segList.addPt(this.offset0.p1), this.addFilletCorner(this.s1, this.offset0.p1, this.offset1.p0, t, this.distance), this.segList.addPt(this.offset1.p0));
	    }, createSquare: function createSquare(t) {
	      this.segList.addPt(new c(t.x + this.distance, t.y + this.distance)), this.segList.addPt(new c(t.x + this.distance, t.y - this.distance)), this.segList.addPt(new c(t.x - this.distance, t.y - this.distance)), this.segList.addPt(new c(t.x - this.distance, t.y + this.distance)), this.segList.closeRing();
	    }, addSegments: function addSegments(t, e) {
	      this.segList.addPts(t, e);
	    }, addFirstSegment: function addFirstSegment() {
	      this.segList.addPt(this.offset1.p0);
	    }, addLastSegment: function addLastSegment() {
	      this.segList.addPt(this.offset1.p1);
	    }, initSideSegments: function initSideSegments(t, e, n) {
	      this.s1 = t, this.s2 = e, this.side = n, this.seg1.setCoordinates(t, e), this.computeOffsetSegment(this.seg1, n, this.distance, this.offset1);
	    }, addLimitedMitreJoin: function addLimitedMitreJoin(t, e, n, i) {
	      var r = this.seg0.p1,
	          s = Qi.angle(r, this.seg0.p0),
	          o = (Qi.angle(r, this.seg1.p1), Qi.angleBetweenOriented(this.seg0.p0, r, this.seg1.p1)),
	          a = o / 2,
	          u = Qi.normalize(s + a),
	          l = Qi.normalize(u + Math.PI),
	          h = i * n,
	          f = h * Math.abs(Math.sin(a)),
	          g = n - f,
	          d = r.x + h * Math.cos(l),
	          p = r.y + h * Math.sin(l),
	          m = new c(d, p),
	          v = new ae(r, m),
	          y = v.pointAlongOffset(1, g),
	          I = v.pointAlongOffset(1, -g);this.side === Pe.LEFT ? (this.segList.addPt(y), this.segList.addPt(I)) : (this.segList.addPt(I), this.segList.addPt(y));
	    }, computeOffsetSegment: function computeOffsetSegment(t, e, n, i) {
	      var r = e === Pe.LEFT ? 1 : -1,
	          s = t.p1.x - t.p0.x,
	          o = t.p1.y - t.p0.y,
	          a = Math.sqrt(s * s + o * o),
	          u = r * n * s / a,
	          l = r * n * o / a;i.p0.x = t.p0.x - l, i.p0.y = t.p0.y + u, i.p1.x = t.p1.x - l, i.p1.y = t.p1.y + u;
	    }, addFilletArc: function addFilletArc(t, e, n, i, r) {
	      var s = i === oe.CLOCKWISE ? -1 : 1,
	          o = Math.abs(e - n),
	          a = Math.trunc(o / this.filletAngleQuantum + .5);if (a < 1) return null;var u = null,
	          l = null;u = 0, l = o / a;for (var h = u, f = new c(); h < o;) {
	        var g = e + s * h;f.x = t.x + r * Math.cos(g), f.y = t.y + r * Math.sin(g), this.segList.addPt(f), h += l;
	      }
	    }, addInsideTurn: function addInsideTurn(t, e) {
	      if (this.li.computeIntersection(this.offset0.p0, this.offset0.p1, this.offset1.p0, this.offset1.p1), this.li.hasIntersection()) this.segList.addPt(this.li.getIntersection(0));else if (this._hasNarrowConcaveAngle = !0, this.offset0.p1.distance(this.offset1.p0) < this.distance * Zi.INSIDE_TURN_VERTEX_SNAP_DISTANCE_FACTOR) this.segList.addPt(this.offset0.p1);else {
	        if (this.segList.addPt(this.offset0.p1), this.closingSegLengthFactor > 0) {
	          var n = new c((this.closingSegLengthFactor * this.offset0.p1.x + this.s1.x) / (this.closingSegLengthFactor + 1), (this.closingSegLengthFactor * this.offset0.p1.y + this.s1.y) / (this.closingSegLengthFactor + 1));this.segList.addPt(n);var i = new c((this.closingSegLengthFactor * this.offset1.p0.x + this.s1.x) / (this.closingSegLengthFactor + 1), (this.closingSegLengthFactor * this.offset1.p0.y + this.s1.y) / (this.closingSegLengthFactor + 1));this.segList.addPt(i);
	        } else this.segList.addPt(this.s1);this.segList.addPt(this.offset1.p0);
	      }
	    }, createCircle: function createCircle(t) {
	      var e = new c(t.x + this.distance, t.y);this.segList.addPt(e), this.addFilletArc(t, 0, 2 * Math.PI, -1, this.distance), this.segList.closeRing();
	    }, addBevelJoin: function addBevelJoin(t, e) {
	      this.segList.addPt(t.p1), this.segList.addPt(e.p0);
	    }, init: function init(t) {
	      this.distance = t, this.maxCurveSegmentError = t * (1 - Math.cos(this.filletAngleQuantum / 2)), this.segList = new Ji(), this.segList.setPrecisionModel(this.precisionModel), this.segList.setMinimumVertexDistance(t * Zi.CURVE_VERTEX_SNAP_DISTANCE_FACTOR);
	    }, addCollinear: function addCollinear(t) {
	      this.li.computeIntersection(this.s0, this.s1, this.s1, this.s2), this.li.getIntersectionNum() >= 2 && (this.bufParams.getJoinStyle() === Xi.JOIN_BEVEL || this.bufParams.getJoinStyle() === Xi.JOIN_MITRE ? (t && this.segList.addPt(this.offset0.p1), this.segList.addPt(this.offset1.p0)) : this.addFilletCorner(this.s1, this.offset0.p1, this.offset1.p0, oe.CLOCKWISE, this.distance));
	    }, closeRing: function closeRing() {
	      this.segList.closeRing();
	    }, hasNarrowConcaveAngle: function hasNarrowConcaveAngle() {
	      return this._hasNarrowConcaveAngle;
	    }, interfaces_: function interfaces_() {
	      return [];
	    }, getClass: function getClass() {
	      return Zi;
	    } }), Zi.OFFSET_SEGMENT_SEPARATION_FACTOR = .001, Zi.INSIDE_TURN_VERTEX_SNAP_DISTANCE_FACTOR = .001, Zi.CURVE_VERTEX_SNAP_DISTANCE_FACTOR = 1e-6, Zi.MAX_CLOSING_SEG_LEN_FACTOR = 80, Or($i.prototype, { getOffsetCurve: function getOffsetCurve(t, e) {
	      if (this.distance = e, 0 === e) return null;var n = e < 0,
	          i = Math.abs(e),
	          r = this.getSegGen(i);t.length <= 1 ? this.computePointCurve(t[0], r) : this.computeOffsetCurve(t, n, r);var s = r.getCoordinates();return n && X.reverse(s), s;
	    }, computeSingleSidedBufferCurve: function computeSingleSidedBufferCurve(t, e, n) {
	      var i = this.simplifyTolerance(this.distance);if (e) {
	        n.addSegments(t, !0);var r = Ki.simplify(t, -i),
	            s = r.length - 1;n.initSideSegments(r[s], r[s - 1], Pe.LEFT), n.addFirstSegment();for (var o = s - 2; o >= 0; o--) {
	          n.addNextSegment(r[o], !0);
	        }
	      } else {
	        n.addSegments(t, !1);var a = Ki.simplify(t, i),
	            u = a.length - 1;n.initSideSegments(a[0], a[1], Pe.LEFT), n.addFirstSegment();for (var o = 2; o <= u; o++) {
	          n.addNextSegment(a[o], !0);
	        }
	      }n.addLastSegment(), n.closeRing();
	    }, computeRingBufferCurve: function computeRingBufferCurve(t, e, n) {
	      var i = this.simplifyTolerance(this.distance);e === Pe.RIGHT && (i = -i);var r = Ki.simplify(t, i),
	          s = r.length - 1;n.initSideSegments(r[s - 1], r[0], e);for (var o = 1; o <= s; o++) {
	        var a = 1 !== o;n.addNextSegment(r[o], a);
	      }n.closeRing();
	    }, computeLineBufferCurve: function computeLineBufferCurve(t, e) {
	      var n = this.simplifyTolerance(this.distance),
	          i = Ki.simplify(t, n),
	          r = i.length - 1;e.initSideSegments(i[0], i[1], Pe.LEFT);for (var s = 2; s <= r; s++) {
	        e.addNextSegment(i[s], !0);
	      }e.addLastSegment(), e.addLineEndCap(i[r - 1], i[r]);var o = Ki.simplify(t, -n),
	          a = o.length - 1;e.initSideSegments(o[a], o[a - 1], Pe.LEFT);for (var s = a - 2; s >= 0; s--) {
	        e.addNextSegment(o[s], !0);
	      }e.addLastSegment(), e.addLineEndCap(o[1], o[0]), e.closeRing();
	    }, computePointCurve: function computePointCurve(t, e) {
	      switch (this.bufParams.getEndCapStyle()) {case Xi.CAP_ROUND:
	          e.createCircle(t);break;case Xi.CAP_SQUARE:
	          e.createSquare(t);}
	    }, getLineCurve: function getLineCurve(t, e) {
	      if (this.distance = e, e < 0 && !this.bufParams.isSingleSided()) return null;if (0 === e) return null;var n = Math.abs(e),
	          i = this.getSegGen(n);if (t.length <= 1) this.computePointCurve(t[0], i);else if (this.bufParams.isSingleSided()) {
	        var r = e < 0;this.computeSingleSidedBufferCurve(t, r, i);
	      } else this.computeLineBufferCurve(t, i);return i.getCoordinates();
	    }, getBufferParameters: function getBufferParameters() {
	      return this.bufParams;
	    }, simplifyTolerance: function simplifyTolerance(t) {
	      return t * this.bufParams.getSimplifyFactor();
	    }, getRingCurve: function getRingCurve(t, e, n) {
	      if (this.distance = n, t.length <= 2) return this.getLineCurve(t, n);if (0 === n) return $i.copyCoordinates(t);var i = this.getSegGen(n);return this.computeRingBufferCurve(t, e, i), i.getCoordinates();
	    }, computeOffsetCurve: function computeOffsetCurve(t, e, n) {
	      var i = this.simplifyTolerance(this.distance);if (e) {
	        var r = Ki.simplify(t, -i),
	            s = r.length - 1;n.initSideSegments(r[s], r[s - 1], Pe.LEFT), n.addFirstSegment();for (var o = s - 2; o >= 0; o--) {
	          n.addNextSegment(r[o], !0);
	        }
	      } else {
	        var a = Ki.simplify(t, i),
	            u = a.length - 1;n.initSideSegments(a[0], a[1], Pe.LEFT), n.addFirstSegment();for (var o = 2; o <= u; o++) {
	          n.addNextSegment(a[o], !0);
	        }
	      }n.addLastSegment();
	    }, getSegGen: function getSegGen(t) {
	      return new Zi(this.precisionModel, this.bufParams, t);
	    }, interfaces_: function interfaces_() {
	      return [];
	    }, getClass: function getClass() {
	      return $i;
	    } }), $i.copyCoordinates = function (t) {
	    for (var e = new Array(t.length).fill(null), n = 0; n < e.length; n++) {
	      e[n] = new c(t[n]);
	    }return e;
	  }, Or(tr.prototype, { findStabbedSegments: function findStabbedSegments() {
	      if (1 === arguments.length) {
	        for (var t = arguments[0], e = new I(), n = this.subgraphs.iterator(); n.hasNext();) {
	          var i = n.next(),
	              r = i.getEnvelope();t.y < r.getMinY() || t.y > r.getMaxY() || this.findStabbedSegments(t, i.getDirectedEdges(), e);
	        }return e;
	      }if (3 === arguments.length) if (_r(arguments[2], m) && arguments[0] instanceof c && arguments[1] instanceof Ke) for (var s = arguments[0], o = arguments[1], a = arguments[2], u = o.getEdge().getCoordinates(), n = 0; n < u.length - 1; n++) {
	        this.seg.p0 = u[n], this.seg.p1 = u[n + 1], this.seg.p0.y > this.seg.p1.y && this.seg.reverse();var l = Math.max(this.seg.p0.x, this.seg.p1.x);if (!(l < s.x) && !(this.seg.isHorizontal() || s.y < this.seg.p0.y || s.y > this.seg.p1.y || oe.computeOrientation(this.seg.p0, this.seg.p1, s) === oe.RIGHT)) {
	          var h = o.getDepth(Pe.LEFT);this.seg.p0.equals(u[n]) || (h = o.getDepth(Pe.RIGHT));var f = new er(this.seg, h);a.add(f);
	        }
	      } else if (_r(arguments[2], m) && arguments[0] instanceof c && _r(arguments[1], m)) for (var g = arguments[0], d = arguments[1], p = arguments[2], n = d.iterator(); n.hasNext();) {
	        var v = n.next();v.isForward() && this.findStabbedSegments(g, v, p);
	      }
	    }, getDepth: function getDepth(t) {
	      var e = this.findStabbedSegments(t);return 0 === e.size() ? 0 : Jr.min(e).leftDepth;
	    }, interfaces_: function interfaces_() {
	      return [];
	    }, getClass: function getClass() {
	      return tr;
	    } }), Or(er.prototype, { compareTo: function compareTo(t) {
	      var e = t;if (this.upwardSeg.minX() >= e.upwardSeg.maxX()) return 1;if (this.upwardSeg.maxX() <= e.upwardSeg.minX()) return -1;var n = this.upwardSeg.orientationIndex(e.upwardSeg);return 0 !== n ? n : (n = -1 * e.upwardSeg.orientationIndex(this.upwardSeg), 0 !== n ? n : this.upwardSeg.compareTo(e.upwardSeg));
	    }, compareX: function compareX(t, e) {
	      var n = t.p0.compareTo(e.p0);return 0 !== n ? n : t.p1.compareTo(e.p1);
	    }, toString: function toString() {
	      return this.upwardSeg.toString();
	    }, interfaces_: function interfaces_() {
	      return [r];
	    }, getClass: function getClass() {
	      return er;
	    } }), tr.DepthSegment = er, Or(nr.prototype, { area: function area() {
	      return nr.area(this.p0, this.p1, this.p2);
	    }, signedArea: function signedArea() {
	      return nr.signedArea(this.p0, this.p1, this.p2);
	    }, interpolateZ: function interpolateZ(t) {
	      if (null === t) throw new n("Supplied point is null.");return nr.interpolateZ(t, this.p0, this.p1, this.p2);
	    }, longestSideLength: function longestSideLength() {
	      return nr.longestSideLength(this.p0, this.p1, this.p2);
	    }, isAcute: function isAcute() {
	      return nr.isAcute(this.p0, this.p1, this.p2);
	    }, circumcentre: function circumcentre() {
	      return nr.circumcentre(this.p0, this.p1, this.p2);
	    }, area3D: function area3D() {
	      return nr.area3D(this.p0, this.p1, this.p2);
	    }, centroid: function centroid() {
	      return nr.centroid(this.p0, this.p1, this.p2);
	    }, inCentre: function inCentre() {
	      return nr.inCentre(this.p0, this.p1, this.p2);
	    }, interfaces_: function interfaces_() {
	      return [];
	    }, getClass: function getClass() {
	      return nr;
	    } }), nr.area = function (t, e, n) {
	    return Math.abs(((n.x - t.x) * (e.y - t.y) - (e.x - t.x) * (n.y - t.y)) / 2);
	  }, nr.signedArea = function (t, e, n) {
	    return ((n.x - t.x) * (e.y - t.y) - (e.x - t.x) * (n.y - t.y)) / 2;
	  }, nr.det = function (t, e, n, i) {
	    return t * i - e * n;
	  }, nr.interpolateZ = function (t, e, n, i) {
	    var r = e.x,
	        s = e.y,
	        o = n.x - r,
	        a = i.x - r,
	        u = n.y - s,
	        l = i.y - s,
	        h = o * l - a * u,
	        c = t.x - r,
	        f = t.y - s,
	        g = (l * c - a * f) / h,
	        d = (-u * c + o * f) / h;return e.z + g * (n.z - e.z) + d * (i.z - e.z);
	  }, nr.longestSideLength = function (t, e, n) {
	    var i = t.distance(e),
	        r = e.distance(n),
	        s = n.distance(t),
	        o = i;return r > o && (o = r), s > o && (o = s), o;
	  }, nr.isAcute = function (t, e, n) {
	    return !!Qi.isAcute(t, e, n) && !!Qi.isAcute(e, n, t) && !!Qi.isAcute(n, t, e);
	  }, nr.circumcentre = function (t, e, n) {
	    var i = n.x,
	        r = n.y,
	        s = t.x - i,
	        o = t.y - r,
	        a = e.x - i,
	        u = e.y - r,
	        l = 2 * nr.det(s, o, a, u);return new c(i - nr.det(o, s * s + o * o, u, a * a + u * u) / l, r + nr.det(s, s * s + o * o, a, a * a + u * u) / l);
	  }, nr.perpendicularBisector = function (t, e) {
	    var n = e.x - t.x,
	        i = e.y - t.y;return new M(new M(t.x + n / 2, t.y + i / 2, 1), new M(t.x - i + n / 2, t.y + n + i / 2, 1));
	  }, nr.angleBisector = function (t, e, n) {
	    var i = e.distance(t),
	        r = e.distance(n),
	        s = i / (i + r),
	        o = n.x - t.x,
	        a = n.y - t.y;return new c(t.x + s * o, t.y + s * a);
	  }, nr.area3D = function (t, e, n) {
	    var i = e.x - t.x,
	        r = e.y - t.y,
	        s = e.z - t.z,
	        o = n.x - t.x,
	        a = n.y - t.y,
	        u = n.z - t.z,
	        l = r * u - s * a,
	        h = s * o - i * u,
	        c = i * a - r * o,
	        f = l * l + h * h + c * c;return Math.sqrt(f) / 2;
	  }, nr.centroid = function (t, e, n) {
	    return new c((t.x + e.x + n.x) / 3, (t.y + e.y + n.y) / 3);
	  }, nr.inCentre = function (t, e, n) {
	    var i = e.distance(n),
	        r = t.distance(n),
	        s = t.distance(e),
	        o = i + r + s;return new c((i * t.x + r * e.x + s * n.x) / o, (i * t.y + r * e.y + s * n.y) / o);
	  }, Or(ir.prototype, { addPoint: function addPoint(t) {
	      if (this.distance <= 0) return null;var e = t.getCoordinates(),
	          n = this.curveBuilder.getLineCurve(e, this.distance);this.addCurve(n, S.EXTERIOR, S.INTERIOR);
	    }, addPolygon: function addPolygon(t) {
	      var e = this.distance,
	          n = Pe.LEFT;this.distance < 0 && (e = -this.distance, n = Pe.RIGHT);var i = t.getExteriorRing(),
	          r = X.removeRepeatedPoints(i.getCoordinates());if (this.distance < 0 && this.isErodedCompletely(i, this.distance)) return null;if (this.distance <= 0 && r.length < 3) return null;this.addPolygonRing(r, e, n, S.EXTERIOR, S.INTERIOR);for (var s = 0; s < t.getNumInteriorRing(); s++) {
	        var o = t.getInteriorRingN(s),
	            a = X.removeRepeatedPoints(o.getCoordinates());this.distance > 0 && this.isErodedCompletely(o, -this.distance) || this.addPolygonRing(a, e, Pe.opposite(n), S.INTERIOR, S.EXTERIOR);
	      }
	    }, isTriangleErodedCompletely: function isTriangleErodedCompletely(t, e) {
	      var n = new nr(t[0], t[1], t[2]),
	          i = n.inCentre();return oe.distancePointLine(i, n.p0, n.p1) < Math.abs(e);
	    }, addLineString: function addLineString(t) {
	      if (this.distance <= 0 && !this.curveBuilder.getBufferParameters().isSingleSided()) return null;var e = X.removeRepeatedPoints(t.getCoordinates()),
	          n = this.curveBuilder.getLineCurve(e, this.distance);this.addCurve(n, S.EXTERIOR, S.INTERIOR);
	    }, addCurve: function addCurve(t, e, n) {
	      if (null === t || t.length < 2) return null;var i = new gi(t, new Ae(0, S.BOUNDARY, e, n));this.curveList.add(i);
	    }, getCurves: function getCurves() {
	      return this.add(this.inputGeom), this.curveList;
	    }, addPolygonRing: function addPolygonRing(t, e, n, i, r) {
	      if (0 === e && t.length < wt.MINIMUM_VALID_SIZE) return null;var s = i,
	          o = r;t.length >= wt.MINIMUM_VALID_SIZE && oe.isCCW(t) && (s = r, o = i, n = Pe.opposite(n));var a = this.curveBuilder.getRingCurve(t, n, e);this.addCurve(a, s, o);
	    }, add: function add(t) {
	      if (t.isEmpty()) return null;if (t instanceof Lt) this.addPolygon(t);else if (t instanceof xt) this.addLineString(t);else if (t instanceof Ct) this.addPoint(t);else if (t instanceof Rt) this.addCollection(t);else if (t instanceof ht) this.addCollection(t);else if (t instanceof Tt) this.addCollection(t);else {
	        if (!(t instanceof lt)) throw new UnsupportedOperationException(t.getClass().getName());this.addCollection(t);
	      }
	    }, isErodedCompletely: function isErodedCompletely(t, e) {
	      var n = t.getCoordinates();if (n.length < 4) return e < 0;if (4 === n.length) return this.isTriangleErodedCompletely(n, e);var i = t.getEnvelopeInternal(),
	          r = Math.min(i.getHeight(), i.getWidth());return e < 0 && 2 * Math.abs(e) > r;
	    }, addCollection: function addCollection(t) {
	      for (var e = 0; e < t.getNumGeometries(); e++) {
	        var n = t.getGeometryN(e);this.add(n);
	      }
	    }, interfaces_: function interfaces_() {
	      return [];
	    }, getClass: function getClass() {
	      return ir;
	    } }), Or(rr.prototype, { isTrivialIntersection: function isTrivialIntersection(t, e, n, i) {
	      if (t === n && 1 === this.li.getIntersectionNum()) {
	        if (rr.isAdjacentSegments(e, i)) return !0;if (t.isClosed()) {
	          var r = t.size() - 1;if (0 === e && i === r || 0 === i && e === r) return !0;
	        }
	      }return !1;
	    }, getProperIntersectionPoint: function getProperIntersectionPoint() {
	      return this.properIntersectionPoint;
	    }, hasProperInteriorIntersection: function hasProperInteriorIntersection() {
	      return this.hasProperInterior;
	    }, getLineIntersector: function getLineIntersector() {
	      return this.li;
	    }, hasProperIntersection: function hasProperIntersection() {
	      return this.hasProper;
	    }, processIntersections: function processIntersections(t, e, n, i) {
	      if (t === n && e === i) return null;this.numTests++;var r = t.getCoordinates()[e],
	          s = t.getCoordinates()[e + 1],
	          o = n.getCoordinates()[i],
	          a = n.getCoordinates()[i + 1];this.li.computeIntersection(r, s, o, a), this.li.hasIntersection() && (this.numIntersections++, this.li.isInteriorIntersection() && (this.numInteriorIntersections++, this.hasInterior = !0), this.isTrivialIntersection(t, e, n, i) || (this._hasIntersection = !0, t.addIntersections(this.li, e, 0), n.addIntersections(this.li, i, 1), this.li.isProper() && (this.numProperIntersections++, this.hasProper = !0, this.hasProperInterior = !0)));
	    }, hasIntersection: function hasIntersection() {
	      return this._hasIntersection;
	    }, isDone: function isDone() {
	      return !1;
	    }, hasInteriorIntersection: function hasInteriorIntersection() {
	      return this.hasInterior;
	    }, interfaces_: function interfaces_() {
	      return [Ii];
	    }, getClass: function getClass() {
	      return rr;
	    } }), rr.isAdjacentSegments = function (t, e) {
	    return 1 === Math.abs(t - e);
	  }, Or(sr.prototype, { setWorkingPrecisionModel: function setWorkingPrecisionModel(t) {
	      this.workingPrecisionModel = t;
	    }, insertUniqueEdge: function insertUniqueEdge(t) {
	      var e = this.edgeList.findEqualEdge(t);if (null !== e) {
	        var n = e.getLabel(),
	            i = t.getLabel();e.isPointwiseEqual(t) || (i = new Ae(t.getLabel()), i.flip()), n.merge(i);var r = sr.depthDelta(i),
	            s = e.getDepthDelta(),
	            o = s + r;e.setDepthDelta(o);
	      } else this.edgeList.add(t), t.setDepthDelta(sr.depthDelta(t.getLabel()));
	    }, buildSubgraphs: function buildSubgraphs(t, e) {
	      for (var n = new I(), i = t.iterator(); i.hasNext();) {
	        var r = i.next(),
	            s = r.getRightmostCoordinate(),
	            o = new tr(n),
	            a = o.getDepth(s);r.computeDepth(a), r.findResultEdges(), n.add(r), e.add(r.getDirectedEdges(), r.getNodes());
	      }
	    }, createSubgraphs: function createSubgraphs(t) {
	      for (var e = new I(), n = t.getNodes().iterator(); n.hasNext();) {
	        var i = n.next();if (!i.isVisited()) {
	          var r = new ji();r.create(i), e.add(r);
	        }
	      }return Jr.sort(e, Jr.reverseOrder()), e;
	    }, createEmptyResultGeometry: function createEmptyResultGeometry() {
	      return this.geomFact.createPolygon();
	    }, getNoder: function getNoder(t) {
	      if (null !== this.workingNoder) return this.workingNoder;var e = new vi(),
	          n = new ie();return n.setPrecisionModel(t), e.setSegmentIntersector(new rr(n)), e;
	    }, buffer: function buffer(t, e) {
	      var n = this.workingPrecisionModel;null === n && (n = t.getPrecisionModel()), this.geomFact = t.getFactory();var i = new $i(n, this.bufParams),
	          r = new ir(t, e, i),
	          s = r.getCurves();if (s.size() <= 0) return this.createEmptyResultGeometry();this.computeNodedEdges(s, n), this.graph = new Je(new He()), this.graph.addEdges(this.edgeList.getEdges());var o = this.createSubgraphs(this.graph),
	          a = new Ci(this.geomFact);this.buildSubgraphs(o, a);var u = a.getPolygons();return u.size() <= 0 ? this.createEmptyResultGeometry() : this.geomFact.buildGeometry(u);
	    }, computeNodedEdges: function computeNodedEdges(t, e) {
	      var n = this.getNoder(e);n.computeNodes(t);for (var i = n.getNodedSubstrings(), r = i.iterator(); r.hasNext();) {
	        var s = r.next(),
	            o = s.getCoordinates();if (2 !== o.length || !o[0].equals2D(o[1])) {
	          var a = s.getData(),
	              u = new On(s.getCoordinates(), new Ae(a));this.insertUniqueEdge(u);
	        }
	      }
	    }, setNoder: function setNoder(t) {
	      this.workingNoder = t;
	    }, interfaces_: function interfaces_() {
	      return [];
	    }, getClass: function getClass() {
	      return sr;
	    } }), sr.depthDelta = function (t) {
	    var e = t.getLocation(0, Pe.LEFT),
	        n = t.getLocation(0, Pe.RIGHT);return e === S.INTERIOR && n === S.EXTERIOR ? 1 : e === S.EXTERIOR && n === S.INTERIOR ? -1 : 0;
	  }, sr.convertSegStrings = function (t) {
	    for (var e = new $t(), n = new I(); t.hasNext();) {
	      var i = t.next(),
	          r = e.createLineString(i.getCoordinates());n.add(r);
	    }return e.buildGeometry(n);
	  }, Or(or.prototype, { rescale: function rescale() {
	      if (_r(arguments[0], d)) for (var t = arguments[0], e = t.iterator(); e.hasNext();) {
	        var n = e.next();this.rescale(n.getCoordinates());
	      } else if (arguments[0] instanceof Array) {
	        var i = arguments[0];2 === i.length && (new c(i[0]), new c(i[1]));for (var e = 0; e < i.length; e++) {
	          i[e].x = i[e].x / this.scaleFactor + this.offsetX, i[e].y = i[e].y / this.scaleFactor + this.offsetY;
	        }2 === i.length && i[0].equals2D(i[1]) && _.out.println(i);
	      }
	    }, scale: function scale() {
	      if (_r(arguments[0], d)) {
	        for (var t = arguments[0], e = new I(), n = t.iterator(); n.hasNext();) {
	          var i = n.next();e.add(new gi(this.scale(i.getCoordinates()), i.getData()));
	        }return e;
	      }if (arguments[0] instanceof Array) {
	        for (var r = arguments[0], s = new Array(r.length).fill(null), n = 0; n < r.length; n++) {
	          s[n] = new c(Math.round((r[n].x - this.offsetX) * this.scaleFactor), Math.round((r[n].y - this.offsetY) * this.scaleFactor), r[n].z);
	        }return X.removeRepeatedPoints(s);
	      }
	    }, isIntegerPrecision: function isIntegerPrecision() {
	      return 1 === this.scaleFactor;
	    }, getNodedSubstrings: function getNodedSubstrings() {
	      var t = this.noder.getNodedSubstrings();return this.isScaled && this.rescale(t), t;
	    }, computeNodes: function computeNodes(t) {
	      var e = t;this.isScaled && (e = this.scale(t)), this.noder.computeNodes(e);
	    }, interfaces_: function interfaces_() {
	      return [pi];
	    }, getClass: function getClass() {
	      return or;
	    } }), Or(ar.prototype, { checkEndPtVertexIntersections: function checkEndPtVertexIntersections() {
	      if (0 === arguments.length) for (var t = this.segStrings.iterator(); t.hasNext();) {
	        var e = t.next(),
	            n = e.getCoordinates();this.checkEndPtVertexIntersections(n[0], this.segStrings), this.checkEndPtVertexIntersections(n[n.length - 1], this.segStrings);
	      } else if (2 === arguments.length) for (var i = arguments[0], r = arguments[1], t = r.iterator(); t.hasNext();) {
	        for (var e = t.next(), n = e.getCoordinates(), s = 1; s < n.length - 1; s++) {
	          if (n[s].equals(i)) throw new u("found endpt/interior pt intersection at index " + s + " :pt " + i);
	        }
	      }
	    }, checkInteriorIntersections: function checkInteriorIntersections() {
	      if (0 === arguments.length) for (var t = this.segStrings.iterator(); t.hasNext();) {
	        for (var e = t.next(), n = this.segStrings.iterator(); n.hasNext();) {
	          var i = n.next();this.checkInteriorIntersections(e, i);
	        }
	      } else if (2 === arguments.length) for (var r = arguments[0], s = arguments[1], o = r.getCoordinates(), a = s.getCoordinates(), l = 0; l < o.length - 1; l++) {
	        for (var h = 0; h < a.length - 1; h++) {
	          this.checkInteriorIntersections(r, l, s, h);
	        }
	      } else if (4 === arguments.length) {
	        var c = arguments[0],
	            f = arguments[1],
	            g = arguments[2],
	            d = arguments[3];if (c === g && f === d) return null;var p = c.getCoordinates()[f],
	            m = c.getCoordinates()[f + 1],
	            v = g.getCoordinates()[d],
	            y = g.getCoordinates()[d + 1];if (this.li.computeIntersection(p, m, v, y), this.li.hasIntersection() && (this.li.isProper() || this.hasInteriorIntersection(this.li, p, m) || this.hasInteriorIntersection(this.li, v, y))) throw new u("found non-noded intersection at " + p + "-" + m + " and " + v + "-" + y);
	      }
	    }, checkValid: function checkValid() {
	      this.checkEndPtVertexIntersections(), this.checkInteriorIntersections(), this.checkCollapses();
	    }, checkCollapses: function checkCollapses() {
	      if (0 === arguments.length) for (var t = this.segStrings.iterator(); t.hasNext();) {
	        var e = t.next();this.checkCollapses(e);
	      } else if (1 === arguments.length) for (var n = arguments[0], i = n.getCoordinates(), t = 0; t < i.length - 2; t++) {
	        this.checkCollapse(i[t], i[t + 1], i[t + 2]);
	      }
	    }, hasInteriorIntersection: function hasInteriorIntersection(t, e, n) {
	      for (var i = 0; i < t.getIntersectionNum(); i++) {
	        var r = t.getIntersection(i);if (!r.equals(e) && !r.equals(n)) return !0;
	      }return !1;
	    }, checkCollapse: function checkCollapse(t, e, n) {
	      if (t.equals(n)) throw new u("found non-noded collapse at " + ar.fact.createLineString([t, e, n]));
	    }, interfaces_: function interfaces_() {
	      return [];
	    }, getClass: function getClass() {
	      return ar;
	    } }), ar.fact = new $t(), Or(ur.prototype, { intersectsScaled: function intersectsScaled(t, e) {
	      var n = Math.min(t.x, e.x),
	          i = Math.max(t.x, e.x),
	          r = Math.min(t.y, e.y),
	          s = Math.max(t.y, e.y),
	          o = this.maxx < n || this.minx > i || this.maxy < r || this.miny > s;if (o) return !1;var a = this.intersectsToleranceSquare(t, e);return h.isTrue(!(o && a), "Found bad envelope test"), a;
	    }, initCorners: function initCorners(t) {
	      this.minx = t.x - .5, this.maxx = t.x + .5, this.miny = t.y - .5, this.maxy = t.y + .5, this.corner[0] = new c(this.maxx, this.maxy), this.corner[1] = new c(this.minx, this.maxy), this.corner[2] = new c(this.minx, this.miny), this.corner[3] = new c(this.maxx, this.miny);
	    }, intersects: function intersects(t, e) {
	      return 1 === this.scaleFactor ? this.intersectsScaled(t, e) : (this.copyScaled(t, this.p0Scaled), this.copyScaled(e, this.p1Scaled), this.intersectsScaled(this.p0Scaled, this.p1Scaled));
	    }, scale: function scale(t) {
	      return Math.round(t * this.scaleFactor);
	    }, getCoordinate: function getCoordinate() {
	      return this.originalPt;
	    }, copyScaled: function copyScaled(t, e) {
	      e.x = this.scale(t.x), e.y = this.scale(t.y);
	    }, getSafeEnvelope: function getSafeEnvelope() {
	      if (null === this.safeEnv) {
	        var t = ur.SAFE_ENV_EXPANSION_FACTOR / this.scaleFactor;this.safeEnv = new x(this.originalPt.x - t, this.originalPt.x + t, this.originalPt.y - t, this.originalPt.y + t);
	      }return this.safeEnv;
	    }, intersectsPixelClosure: function intersectsPixelClosure(t, e) {
	      return this.li.computeIntersection(t, e, this.corner[0], this.corner[1]), !!this.li.hasIntersection() || (this.li.computeIntersection(t, e, this.corner[1], this.corner[2]), !!this.li.hasIntersection() || (this.li.computeIntersection(t, e, this.corner[2], this.corner[3]), !!this.li.hasIntersection() || (this.li.computeIntersection(t, e, this.corner[3], this.corner[0]), !!this.li.hasIntersection())));
	    }, intersectsToleranceSquare: function intersectsToleranceSquare(t, e) {
	      var n = !1,
	          i = !1;return this.li.computeIntersection(t, e, this.corner[0], this.corner[1]), !!this.li.isProper() || (this.li.computeIntersection(t, e, this.corner[1], this.corner[2]), !!this.li.isProper() || (this.li.hasIntersection() && (n = !0), this.li.computeIntersection(t, e, this.corner[2], this.corner[3]), !!this.li.isProper() || (this.li.hasIntersection() && (i = !0), this.li.computeIntersection(t, e, this.corner[3], this.corner[0]), !!this.li.isProper() || !(!n || !i) || !!t.equals(this.pt) || !!e.equals(this.pt))));
	    }, addSnappedNode: function addSnappedNode(t, e) {
	      var n = t.getCoordinate(e),
	          i = t.getCoordinate(e + 1);return !!this.intersects(n, i) && (t.addIntersection(this.getCoordinate(), e), !0);
	    }, interfaces_: function interfaces_() {
	      return [];
	    }, getClass: function getClass() {
	      return ur;
	    } }), ur.SAFE_ENV_EXPANSION_FACTOR = .75, Or(lr.prototype, { snap: function snap() {
	      if (1 === arguments.length) {
	        var t = arguments[0];return this.snap(t, null, -1);
	      }if (3 === arguments.length) {
	        var e = arguments[0],
	            n = arguments[1],
	            i = arguments[2],
	            r = e.getSafeEnvelope(),
	            s = new hr(e, n, i);return this.index.query(r, { interfaces_: function interfaces_() {
	            return [me];
	          }, visitItem: function visitItem(t) {
	            t.select(r, s);
	          } }), s.isNodeAdded();
	      }
	    }, interfaces_: function interfaces_() {
	      return [];
	    }, getClass: function getClass() {
	      return lr;
	    } }), br(hr, Ze), Or(hr.prototype, { isNodeAdded: function isNodeAdded() {
	      return this._isNodeAdded;
	    }, select: function select() {
	      if (2 !== arguments.length) return Ze.prototype.select.apply(this, arguments);var t = arguments[0],
	          e = arguments[1],
	          n = t.getContext();if (null !== this.parentEdge && n === this.parentEdge && e === this.hotPixelVertexIndex) return null;this._isNodeAdded = this.hotPixel.addSnappedNode(n, e);
	    }, interfaces_: function interfaces_() {
	      return [];
	    }, getClass: function getClass() {
	      return hr;
	    } }), lr.HotPixelSnapAction = hr, Or(cr.prototype, { processIntersections: function processIntersections(t, e, n, i) {
	      if (t === n && e === i) return null;var r = t.getCoordinates()[e],
	          s = t.getCoordinates()[e + 1],
	          o = n.getCoordinates()[i],
	          a = n.getCoordinates()[i + 1];if (this.li.computeIntersection(r, s, o, a), this.li.hasIntersection() && this.li.isInteriorIntersection()) {
	        for (var u = 0; u < this.li.getIntersectionNum(); u++) {
	          this.interiorIntersections.add(this.li.getIntersection(u));
	        }t.addIntersections(this.li, e, 0), n.addIntersections(this.li, i, 1);
	      }
	    }, isDone: function isDone() {
	      return !1;
	    }, getInteriorIntersections: function getInteriorIntersections() {
	      return this.interiorIntersections;
	    }, interfaces_: function interfaces_() {
	      return [Ii];
	    }, getClass: function getClass() {
	      return cr;
	    } }), Or(fr.prototype, { checkCorrectness: function checkCorrectness(t) {
	      var e = gi.getNodedSubstrings(t),
	          n = new ar(e);try {
	        n.checkValid();
	      } catch (t) {
	        if (!(t instanceof N)) throw t;t.printStackTrace();
	      } finally {}
	    }, getNodedSubstrings: function getNodedSubstrings() {
	      return gi.getNodedSubstrings(this.nodedSegStrings);
	    }, snapRound: function snapRound(t, e) {
	      var n = this.findInteriorIntersections(t, e);this.computeIntersectionSnaps(n), this.computeVertexSnaps(t);
	    }, findInteriorIntersections: function findInteriorIntersections(t, e) {
	      var n = new cr(e);return this.noder.setSegmentIntersector(n), this.noder.computeNodes(t), n.getInteriorIntersections();
	    }, computeVertexSnaps: function computeVertexSnaps() {
	      if (_r(arguments[0], d)) for (var t = arguments[0], e = t.iterator(); e.hasNext();) {
	        var n = e.next();this.computeVertexSnaps(n);
	      } else if (arguments[0] instanceof gi) for (var i = arguments[0], r = i.getCoordinates(), s = 0; s < r.length; s++) {
	        var o = new ur(r[s], this.scaleFactor, this.li),
	            a = this.pointSnapper.snap(o, i, s);a && i.addIntersection(r[s], s);
	      }
	    }, computeNodes: function computeNodes(t) {
	      this.nodedSegStrings = t, this.noder = new vi(), this.pointSnapper = new lr(this.noder.getIndex()), this.snapRound(t, this.li);
	    }, computeIntersectionSnaps: function computeIntersectionSnaps(t) {
	      for (var e = t.iterator(); e.hasNext();) {
	        var n = e.next(),
	            i = new ur(n, this.scaleFactor, this.li);this.pointSnapper.snap(i);
	      }
	    }, interfaces_: function interfaces_() {
	      return [pi];
	    }, getClass: function getClass() {
	      return fr;
	    } }), Or(gr.prototype, { bufferFixedPrecision: function bufferFixedPrecision(t) {
	      var e = new or(new fr(new Qt(1)), t.getScale()),
	          n = new sr(this.bufParams);n.setWorkingPrecisionModel(t), n.setNoder(e), this.resultGeometry = n.buffer(this.argGeom, this.distance);
	    }, bufferReducedPrecision: function bufferReducedPrecision() {
	      if (0 === arguments.length) {
	        for (var t = gr.MAX_PRECISION_DIGITS; t >= 0; t--) {
	          try {
	            this.bufferReducedPrecision(t);
	          } catch (t) {
	            if (!(t instanceof _e)) throw t;this.saveException = t;
	          } finally {}if (null !== this.resultGeometry) return null;
	        }throw this.saveException;
	      }if (1 === arguments.length) {
	        var e = arguments[0],
	            n = gr.precisionScaleFactor(this.argGeom, this.distance, e),
	            i = new Qt(n);this.bufferFixedPrecision(i);
	      }
	    }, computeGeometry: function computeGeometry() {
	      if (this.bufferOriginalPrecision(), null !== this.resultGeometry) return null;var t = this.argGeom.getFactory().getPrecisionModel();t.getType() === Qt.FIXED ? this.bufferFixedPrecision(t) : this.bufferReducedPrecision();
	    }, setQuadrantSegments: function setQuadrantSegments(t) {
	      this.bufParams.setQuadrantSegments(t);
	    }, bufferOriginalPrecision: function bufferOriginalPrecision() {
	      try {
	        var t = new sr(this.bufParams);this.resultGeometry = t.buffer(this.argGeom, this.distance);
	      } catch (t) {
	        if (!(t instanceof u)) throw t;this.saveException = t;
	      } finally {}
	    }, getResultGeometry: function getResultGeometry(t) {
	      return this.distance = t, this.computeGeometry(), this.resultGeometry;
	    }, setEndCapStyle: function setEndCapStyle(t) {
	      this.bufParams.setEndCapStyle(t);
	    }, interfaces_: function interfaces_() {
	      return [];
	    }, getClass: function getClass() {
	      return gr;
	    } }), gr.bufferOp = function () {
	    if (2 === arguments.length) {
	      var t = arguments[0],
	          e = arguments[1],
	          n = new gr(t),
	          i = n.getResultGeometry(e);return i;
	    }if (3 === arguments.length) {
	      if (Number.isInteger(arguments[2]) && arguments[0] instanceof F && "number" == typeof arguments[1]) {
	        var r = arguments[0],
	            s = arguments[1],
	            o = arguments[2],
	            a = new gr(r);a.setQuadrantSegments(o);var i = a.getResultGeometry(s);return i;
	      }if (arguments[2] instanceof Xi && arguments[0] instanceof F && "number" == typeof arguments[1]) {
	        var u = arguments[0],
	            l = arguments[1],
	            h = arguments[2],
	            a = new gr(u, h),
	            i = a.getResultGeometry(l);return i;
	      }
	    } else if (4 === arguments.length) {
	      var c = arguments[0],
	          f = arguments[1],
	          g = arguments[2],
	          d = arguments[3],
	          a = new gr(c);a.setQuadrantSegments(g), a.setEndCapStyle(d);var i = a.getResultGeometry(f);return i;
	    }
	  }, gr.precisionScaleFactor = function (t, e, n) {
	    var i = t.getEnvelopeInternal(),
	        r = L.max(Math.abs(i.getMaxX()), Math.abs(i.getMaxY()), Math.abs(i.getMinX()), Math.abs(i.getMinY())),
	        s = e > 0 ? e : 0,
	        o = r + 2 * s,
	        a = Math.trunc(Math.log(o) / Math.log(10) + 1),
	        u = n - a;return Math.pow(10, u);
	  }, gr.CAP_ROUND = Xi.CAP_ROUND, gr.CAP_BUTT = Xi.CAP_FLAT, gr.CAP_FLAT = Xi.CAP_FLAT, gr.CAP_SQUARE = Xi.CAP_SQUARE, gr.MAX_PRECISION_DIGITS = 12, Or(dr.prototype, { filter: function filter(t) {
	      this.treeSet.contains(t) || (this.list.add(t), this.treeSet.add(t));
	    }, getCoordinates: function getCoordinates() {
	      var t = new Array(this.list.size()).fill(null);return this.list.toArray(t);
	    }, interfaces_: function interfaces_() {
	      return [G];
	    }, getClass: function getClass() {
	      return dr;
	    } }), dr.filterCoordinates = function (t) {
	    for (var e = new dr(), n = 0; n < t.length; n++) {
	      e.filter(t[n]);
	    }return e.getCoordinates();
	  }, Or(pr.prototype, { preSort: function preSort(t) {
	      for (var e = null, n = 1; n < t.length; n++) {
	        (t[n].y < t[0].y || t[n].y === t[0].y && t[n].x < t[0].x) && (e = t[0], t[0] = t[n], t[n] = e);
	      }return st.sort(t, 1, t.length, new mr(t[0])), t;
	    }, computeOctRing: function computeOctRing(t) {
	      var e = this.computeOctPts(t),
	          n = new E();return n.add(e, !1), n.size() < 3 ? null : (n.closeRing(), n.toCoordinateArray());
	    }, lineOrPolygon: function lineOrPolygon(t) {
	      if (t = this.cleanRing(t), 3 === t.length) return this.geomFactory.createLineString([t[0], t[1]]);var e = this.geomFactory.createLinearRing(t);return this.geomFactory.createPolygon(e, null);
	    }, cleanRing: function cleanRing(t) {
	      h.equals(t[0], t[t.length - 1]);for (var e = new I(), n = null, i = 0; i <= t.length - 2; i++) {
	        var r = t[i],
	            s = t[i + 1];r.equals(s) || null !== n && this.isBetween(n, r, s) || (e.add(r), n = r);
	      }e.add(t[t.length - 1]);var o = new Array(e.size()).fill(null);return e.toArray(o);
	    }, isBetween: function isBetween(t, e, n) {
	      if (0 !== oe.computeOrientation(t, e, n)) return !1;if (t.x !== n.x) {
	        if (t.x <= e.x && e.x <= n.x) return !0;if (n.x <= e.x && e.x <= t.x) return !0;
	      }if (t.y !== n.y) {
	        if (t.y <= e.y && e.y <= n.y) return !0;if (n.y <= e.y && e.y <= t.y) return !0;
	      }return !1;
	    }, reduce: function reduce(t) {
	      var e = this.computeOctRing(t);if (null === e) return t;for (var n = new rt(), i = 0; i < e.length; i++) {
	        n.add(e[i]);
	      }for (var i = 0; i < t.length; i++) {
	        oe.isPointInRing(t[i], e) || n.add(t[i]);
	      }var r = X.toCoordinateArray(n);return r.length < 3 ? this.padArray3(r) : r;
	    }, getConvexHull: function getConvexHull() {
	      if (0 === this.inputPts.length) return this.geomFactory.createGeometryCollection(null);if (1 === this.inputPts.length) return this.geomFactory.createPoint(this.inputPts[0]);if (2 === this.inputPts.length) return this.geomFactory.createLineString(this.inputPts);var t = this.inputPts;this.inputPts.length > 50 && (t = this.reduce(this.inputPts));var e = this.preSort(t),
	          n = this.grahamScan(e),
	          i = this.toCoordinateArray(n);return this.lineOrPolygon(i);
	    }, padArray3: function padArray3(t) {
	      for (var e = new Array(3).fill(null), n = 0; n < e.length; n++) {
	        n < t.length ? e[n] = t[n] : e[n] = t[0];
	      }return e;
	    }, computeOctPts: function computeOctPts(t) {
	      for (var e = new Array(8).fill(null), n = 0; n < e.length; n++) {
	        e[n] = t[0];
	      }for (var i = 1; i < t.length; i++) {
	        t[i].x < e[0].x && (e[0] = t[i]), t[i].x - t[i].y < e[1].x - e[1].y && (e[1] = t[i]), t[i].y > e[2].y && (e[2] = t[i]), t[i].x + t[i].y > e[3].x + e[3].y && (e[3] = t[i]), t[i].x > e[4].x && (e[4] = t[i]), t[i].x - t[i].y > e[5].x - e[5].y && (e[5] = t[i]), t[i].y < e[6].y && (e[6] = t[i]), t[i].x + t[i].y < e[7].x + e[7].y && (e[7] = t[i]);
	      }return e;
	    }, toCoordinateArray: function toCoordinateArray(t) {
	      for (var e = new Array(t.size()).fill(null), n = 0; n < t.size(); n++) {
	        var i = t.get(n);e[n] = i;
	      }return e;
	    }, grahamScan: function grahamScan(t) {
	      var e = null,
	          n = new Vi();e = n.push(t[0]), e = n.push(t[1]), e = n.push(t[2]);for (var i = 3; i < t.length; i++) {
	        for (e = n.pop(); !n.empty() && oe.computeOrientation(n.peek(), e, t[i]) > 0;) {
	          e = n.pop();
	        }e = n.push(e), e = n.push(t[i]);
	      }return e = n.push(t[0]), n;
	    }, interfaces_: function interfaces_() {
	      return [];
	    }, getClass: function getClass() {
	      return pr;
	    } }), pr.extractCoordinates = function (t) {
	    var e = new dr();return t.apply(e), e.getCoordinates();
	  }, Or(mr.prototype, { compare: function compare(t, e) {
	      var n = t,
	          i = e;return mr.polarCompare(this.origin, n, i);
	    }, interfaces_: function interfaces_() {
	      return [o];
	    }, getClass: function getClass() {
	      return mr;
	    } }), mr.polarCompare = function (t, e, n) {
	    var i = e.x - t.x,
	        r = e.y - t.y,
	        s = n.x - t.x,
	        o = n.y - t.y,
	        a = oe.computeOrientation(t, e, n);if (a === oe.COUNTERCLOCKWISE) return 1;if (a === oe.CLOCKWISE) return -1;var u = i * i + r * r,
	        l = s * s + o * o;return u < l ? -1 : u > l ? 1 : 0;
	  }, pr.RadialComparator = mr, Or(vr.prototype, { addPoint: function addPoint(t) {
	      this.ptCount += 1, this.ptCentSum.x += t.x, this.ptCentSum.y += t.y;
	    }, setBasePoint: function setBasePoint(t) {
	      null === this.areaBasePt && (this.areaBasePt = t);
	    }, addLineSegments: function addLineSegments(t) {
	      for (var e = 0, n = 0; n < t.length - 1; n++) {
	        var i = t[n].distance(t[n + 1]);if (0 !== i) {
	          e += i;var r = (t[n].x + t[n + 1].x) / 2;this.lineCentSum.x += i * r;var s = (t[n].y + t[n + 1].y) / 2;this.lineCentSum.y += i * s;
	        }
	      }this.totalLength += e, 0 === e && t.length > 0 && this.addPoint(t[0]);
	    }, addHole: function addHole(t) {
	      for (var e = oe.isCCW(t), n = 0; n < t.length - 1; n++) {
	        this.addTriangle(this.areaBasePt, t[n], t[n + 1], e);
	      }this.addLineSegments(t);
	    }, getCentroid: function getCentroid() {
	      var t = new c();if (Math.abs(this.areasum2) > 0) t.x = this.cg3.x / 3 / this.areasum2, t.y = this.cg3.y / 3 / this.areasum2;else if (this.totalLength > 0) t.x = this.lineCentSum.x / this.totalLength, t.y = this.lineCentSum.y / this.totalLength;else {
	        if (!(this.ptCount > 0)) return null;t.x = this.ptCentSum.x / this.ptCount, t.y = this.ptCentSum.y / this.ptCount;
	      }return t;
	    }, addShell: function addShell(t) {
	      t.length > 0 && this.setBasePoint(t[0]);for (var e = !oe.isCCW(t), n = 0; n < t.length - 1; n++) {
	        this.addTriangle(this.areaBasePt, t[n], t[n + 1], e);
	      }this.addLineSegments(t);
	    }, addTriangle: function addTriangle(t, e, n, i) {
	      var r = i ? 1 : -1;vr.centroid3(t, e, n, this.triangleCent3);var s = vr.area2(t, e, n);this.cg3.x += r * s * this.triangleCent3.x, this.cg3.y += r * s * this.triangleCent3.y, this.areasum2 += r * s;
	    }, add: function add() {
	      if (arguments[0] instanceof Lt) {
	        var t = arguments[0];this.addShell(t.getExteriorRing().getCoordinates());for (var e = 0; e < t.getNumInteriorRing(); e++) {
	          this.addHole(t.getInteriorRingN(e).getCoordinates());
	        }
	      } else if (arguments[0] instanceof F) {
	        var n = arguments[0];if (n.isEmpty()) return null;if (n instanceof Ct) this.addPoint(n.getCoordinate());else if (n instanceof xt) this.addLineSegments(n.getCoordinates());else if (n instanceof Lt) {
	          var i = n;this.add(i);
	        } else if (n instanceof lt) for (var r = n, e = 0; e < r.getNumGeometries(); e++) {
	          this.add(r.getGeometryN(e));
	        }
	      }
	    }, interfaces_: function interfaces_() {
	      return [];
	    }, getClass: function getClass() {
	      return vr;
	    } }), vr.area2 = function (t, e, n) {
	    return (e.x - t.x) * (n.y - t.y) - (n.x - t.x) * (e.y - t.y);
	  }, vr.centroid3 = function (t, e, n, i) {
	    return i.x = t.x + e.x + n.x, i.y = t.y + e.y + n.y, null;
	  }, vr.getCentroid = function (t) {
	    return new vr(t).getCentroid();
	  }, Or(yr.prototype, { isIntersects: function isIntersects() {
	      return !this.isDisjoint();
	    }, isCovers: function isCovers() {
	      return (yr.isTrue(this.matrix[S.INTERIOR][S.INTERIOR]) || yr.isTrue(this.matrix[S.INTERIOR][S.BOUNDARY]) || yr.isTrue(this.matrix[S.BOUNDARY][S.INTERIOR]) || yr.isTrue(this.matrix[S.BOUNDARY][S.BOUNDARY])) && this.matrix[S.EXTERIOR][S.INTERIOR] === ot.FALSE && this.matrix[S.EXTERIOR][S.BOUNDARY] === ot.FALSE;
	    }, isCoveredBy: function isCoveredBy() {
	      return (yr.isTrue(this.matrix[S.INTERIOR][S.INTERIOR]) || yr.isTrue(this.matrix[S.INTERIOR][S.BOUNDARY]) || yr.isTrue(this.matrix[S.BOUNDARY][S.INTERIOR]) || yr.isTrue(this.matrix[S.BOUNDARY][S.BOUNDARY])) && this.matrix[S.INTERIOR][S.EXTERIOR] === ot.FALSE && this.matrix[S.BOUNDARY][S.EXTERIOR] === ot.FALSE;
	    }, set: function set() {
	      if (1 === arguments.length) for (var t = arguments[0], e = 0; e < t.length; e++) {
	        var n = Math.trunc(e / 3),
	            i = e % 3;this.matrix[n][i] = ot.toDimensionValue(t.charAt(e));
	      } else if (3 === arguments.length) {
	        var r = arguments[0],
	            s = arguments[1],
	            o = arguments[2];this.matrix[r][s] = o;
	      }
	    }, isContains: function isContains() {
	      return yr.isTrue(this.matrix[S.INTERIOR][S.INTERIOR]) && this.matrix[S.EXTERIOR][S.INTERIOR] === ot.FALSE && this.matrix[S.EXTERIOR][S.BOUNDARY] === ot.FALSE;
	    }, setAtLeast: function setAtLeast() {
	      if (1 === arguments.length) for (var t = arguments[0], e = 0; e < t.length; e++) {
	        var n = Math.trunc(e / 3),
	            i = e % 3;this.setAtLeast(n, i, ot.toDimensionValue(t.charAt(e)));
	      } else if (3 === arguments.length) {
	        var r = arguments[0],
	            s = arguments[1],
	            o = arguments[2];this.matrix[r][s] < o && (this.matrix[r][s] = o);
	      }
	    }, setAtLeastIfValid: function setAtLeastIfValid(t, e, n) {
	      t >= 0 && e >= 0 && this.setAtLeast(t, e, n);
	    }, isWithin: function isWithin() {
	      return yr.isTrue(this.matrix[S.INTERIOR][S.INTERIOR]) && this.matrix[S.INTERIOR][S.EXTERIOR] === ot.FALSE && this.matrix[S.BOUNDARY][S.EXTERIOR] === ot.FALSE;
	    }, isTouches: function isTouches(t, e) {
	      return t > e ? this.isTouches(e, t) : (t === ot.A && e === ot.A || t === ot.L && e === ot.L || t === ot.L && e === ot.A || t === ot.P && e === ot.A || t === ot.P && e === ot.L) && this.matrix[S.INTERIOR][S.INTERIOR] === ot.FALSE && (yr.isTrue(this.matrix[S.INTERIOR][S.BOUNDARY]) || yr.isTrue(this.matrix[S.BOUNDARY][S.INTERIOR]) || yr.isTrue(this.matrix[S.BOUNDARY][S.BOUNDARY]));
	    }, isOverlaps: function isOverlaps(t, e) {
	      return t === ot.P && e === ot.P || t === ot.A && e === ot.A ? yr.isTrue(this.matrix[S.INTERIOR][S.INTERIOR]) && yr.isTrue(this.matrix[S.INTERIOR][S.EXTERIOR]) && yr.isTrue(this.matrix[S.EXTERIOR][S.INTERIOR]) : t === ot.L && e === ot.L && 1 === this.matrix[S.INTERIOR][S.INTERIOR] && yr.isTrue(this.matrix[S.INTERIOR][S.EXTERIOR]) && yr.isTrue(this.matrix[S.EXTERIOR][S.INTERIOR]);
	    }, isEquals: function isEquals(t, e) {
	      return t === e && yr.isTrue(this.matrix[S.INTERIOR][S.INTERIOR]) && this.matrix[S.INTERIOR][S.EXTERIOR] === ot.FALSE && this.matrix[S.BOUNDARY][S.EXTERIOR] === ot.FALSE && this.matrix[S.EXTERIOR][S.INTERIOR] === ot.FALSE && this.matrix[S.EXTERIOR][S.BOUNDARY] === ot.FALSE;
	    }, toString: function toString() {
	      for (var t = new R("123456789"), e = 0; e < 3; e++) {
	        for (var n = 0; n < 3; n++) {
	          t.setCharAt(3 * e + n, ot.toDimensionSymbol(this.matrix[e][n]));
	        }
	      }return t.toString();
	    }, setAll: function setAll(t) {
	      for (var e = 0; e < 3; e++) {
	        for (var n = 0; n < 3; n++) {
	          this.matrix[e][n] = t;
	        }
	      }
	    }, get: function get(t, e) {
	      return this.matrix[t][e];
	    }, transpose: function transpose() {
	      var t = this.matrix[1][0];return this.matrix[1][0] = this.matrix[0][1], this.matrix[0][1] = t, t = this.matrix[2][0], this.matrix[2][0] = this.matrix[0][2], this.matrix[0][2] = t, t = this.matrix[2][1], this.matrix[2][1] = this.matrix[1][2], this.matrix[1][2] = t, this;
	    }, matches: function matches(t) {
	      if (9 !== t.length) throw new n("Should be length 9: " + t);for (var e = 0; e < 3; e++) {
	        for (var i = 0; i < 3; i++) {
	          if (!yr.matches(this.matrix[e][i], t.charAt(3 * e + i))) return !1;
	        }
	      }return !0;
	    }, add: function add(t) {
	      for (var e = 0; e < 3; e++) {
	        for (var n = 0; n < 3; n++) {
	          this.setAtLeast(e, n, t.get(e, n));
	        }
	      }
	    }, isDisjoint: function isDisjoint() {
	      return this.matrix[S.INTERIOR][S.INTERIOR] === ot.FALSE && this.matrix[S.INTERIOR][S.BOUNDARY] === ot.FALSE && this.matrix[S.BOUNDARY][S.INTERIOR] === ot.FALSE && this.matrix[S.BOUNDARY][S.BOUNDARY] === ot.FALSE;
	    }, isCrosses: function isCrosses(t, e) {
	      return t === ot.P && e === ot.L || t === ot.P && e === ot.A || t === ot.L && e === ot.A ? yr.isTrue(this.matrix[S.INTERIOR][S.INTERIOR]) && yr.isTrue(this.matrix[S.INTERIOR][S.EXTERIOR]) : t === ot.L && e === ot.P || t === ot.A && e === ot.P || t === ot.A && e === ot.L ? yr.isTrue(this.matrix[S.INTERIOR][S.INTERIOR]) && yr.isTrue(this.matrix[S.EXTERIOR][S.INTERIOR]) : t === ot.L && e === ot.L && 0 === this.matrix[S.INTERIOR][S.INTERIOR];
	    }, interfaces_: function interfaces_() {
	      return [s];
	    }, getClass: function getClass() {
	      return yr;
	    } }), yr.matches = function () {
	    if (Number.isInteger(arguments[0]) && "string" == typeof arguments[1]) {
	      var t = arguments[0],
	          e = arguments[1];return e === ot.SYM_DONTCARE || e === ot.SYM_TRUE && (t >= 0 || t === ot.TRUE) || e === ot.SYM_FALSE && t === ot.FALSE || e === ot.SYM_P && t === ot.P || e === ot.SYM_L && t === ot.L || e === ot.SYM_A && t === ot.A;
	    }if ("string" == typeof arguments[0] && "string" == typeof arguments[1]) {
	      var n = arguments[0],
	          i = arguments[1];return new yr(n).matches(i);
	    }
	  };yr.isTrue = function (t) {
	    return t >= 0 || t === ot.TRUE;
	  }, Or(Ir.prototype, { insertEdgeEnds: function insertEdgeEnds(t) {
	      for (var e = t.iterator(); e.hasNext();) {
	        var n = e.next();this.nodes.add(n);
	      }
	    }, computeProperIntersectionIM: function computeProperIntersectionIM(t, e) {
	      var n = this.arg[0].getGeometry().getDimension(),
	          i = this.arg[1].getGeometry().getDimension(),
	          r = t.hasProperIntersection(),
	          s = t.hasProperInteriorIntersection();2 === n && 2 === i ? r && e.setAtLeast("212101212") : 2 === n && 1 === i ? (r && e.setAtLeast("FFF0FFFF2"), s && e.setAtLeast("1FFFFF1FF")) : 1 === n && 2 === i ? (r && e.setAtLeast("F0FFFFFF2"), s && e.setAtLeast("1F1FFFFFF")) : 1 === n && 1 === i && s && e.setAtLeast("0FFFFFFFF");
	    }, labelIsolatedEdges: function labelIsolatedEdges(t, e) {
	      for (var n = this.arg[t].getEdgeIterator(); n.hasNext();) {
	        var i = n.next();i.isIsolated() && (this.labelIsolatedEdge(i, e, this.arg[e].getGeometry()), this.isolatedEdges.add(i));
	      }
	    }, labelIsolatedEdge: function labelIsolatedEdge(t, e, n) {
	      if (n.getDimension() > 0) {
	        var i = this.ptLocator.locate(t.getCoordinate(), n);t.getLabel().setAllLocations(e, i);
	      } else t.getLabel().setAllLocations(e, S.EXTERIOR);
	    }, computeIM: function computeIM() {
	      var t = new yr();if (t.set(S.EXTERIOR, S.EXTERIOR, 2), !this.arg[0].getGeometry().getEnvelopeInternal().intersects(this.arg[1].getGeometry().getEnvelopeInternal())) return this.computeDisjointIM(t), t;this.arg[0].computeSelfNodes(this.li, !1), this.arg[1].computeSelfNodes(this.li, !1);var e = this.arg[0].computeEdgeIntersections(this.arg[1], this.li, !1);this.computeIntersectionNodes(0), this.computeIntersectionNodes(1), this.copyNodesAndLabels(0), this.copyNodesAndLabels(1), this.labelIsolatedNodes(), this.computeProperIntersectionIM(e, t);var n = new Pn(),
	          i = n.computeEdgeEnds(this.arg[0].getEdgeIterator());this.insertEdgeEnds(i);var r = n.computeEdgeEnds(this.arg[1].getEdgeIterator());return this.insertEdgeEnds(r), this.labelNodeEdges(), this.labelIsolatedEdges(0, 1), this.labelIsolatedEdges(1, 0), this.updateIM(t), t;
	    }, labelNodeEdges: function labelNodeEdges() {
	      for (var t = this.nodes.iterator(); t.hasNext();) {
	        t.next().getEdges().computeLabelling(this.arg);
	      }
	    }, copyNodesAndLabels: function copyNodesAndLabels(t) {
	      for (var e = this.arg[t].getNodeIterator(); e.hasNext();) {
	        var n = e.next();this.nodes.addNode(n.getCoordinate()).setLabel(t, n.getLabel().getLocation(t));
	      }
	    }, labelIntersectionNodes: function labelIntersectionNodes(t) {
	      for (var e = this.arg[t].getEdgeIterator(); e.hasNext();) {
	        for (var n = e.next(), i = n.getLabel().getLocation(t), r = n.getEdgeIntersectionList().iterator(); r.hasNext();) {
	          var s = r.next(),
	              o = this.nodes.find(s.coord);o.getLabel().isNull(t) && (i === S.BOUNDARY ? o.setLabelBoundary(t) : o.setLabel(t, S.INTERIOR));
	        }
	      }
	    }, labelIsolatedNode: function labelIsolatedNode(t, e) {
	      var n = this.ptLocator.locate(t.getCoordinate(), this.arg[e].getGeometry());t.getLabel().setAllLocations(e, n);
	    }, computeIntersectionNodes: function computeIntersectionNodes(t) {
	      for (var e = this.arg[t].getEdgeIterator(); e.hasNext();) {
	        for (var n = e.next(), i = n.getLabel().getLocation(t), r = n.getEdgeIntersectionList().iterator(); r.hasNext();) {
	          var s = r.next(),
	              o = this.nodes.addNode(s.coord);i === S.BOUNDARY ? o.setLabelBoundary(t) : o.getLabel().isNull(t) && o.setLabel(t, S.INTERIOR);
	        }
	      }
	    }, labelIsolatedNodes: function labelIsolatedNodes() {
	      for (var t = this.nodes.iterator(); t.hasNext();) {
	        var e = t.next(),
	            n = e.getLabel();h.isTrue(n.getGeometryCount() > 0, "node with empty label found"), e.isIsolated() && (n.isNull(0) ? this.labelIsolatedNode(e, 0) : this.labelIsolatedNode(e, 1));
	      }
	    }, updateIM: function updateIM(t) {
	      for (var e = this.isolatedEdges.iterator(); e.hasNext();) {
	        e.next().updateIM(t);
	      }for (var n = this.nodes.iterator(); n.hasNext();) {
	        var i = n.next();i.updateIM(t), i.updateIMFromEdges(t);
	      }
	    }, computeDisjointIM: function computeDisjointIM(t) {
	      var e = this.arg[0].getGeometry();e.isEmpty() || (t.set(S.INTERIOR, S.EXTERIOR, e.getDimension()), t.set(S.BOUNDARY, S.EXTERIOR, e.getBoundaryDimension()));var n = this.arg[1].getGeometry();n.isEmpty() || (t.set(S.EXTERIOR, S.INTERIOR, n.getDimension()), t.set(S.EXTERIOR, S.BOUNDARY, n.getBoundaryDimension()));
	    }, interfaces_: function interfaces_() {
	      return [];
	    }, getClass: function getClass() {
	      return Ir;
	    } }), Or(Er.prototype, { isContainedInBoundary: function isContainedInBoundary(t) {
	      if (t instanceof Lt) return !1;if (t instanceof Ct) return this.isPointContainedInBoundary(t);if (t instanceof xt) return this.isLineStringContainedInBoundary(t);for (var e = 0; e < t.getNumGeometries(); e++) {
	        var n = t.getGeometryN(e);if (!this.isContainedInBoundary(n)) return !1;
	      }return !0;
	    }, isLineSegmentContainedInBoundary: function isLineSegmentContainedInBoundary(t, e) {
	      if (t.equals(e)) return this.isPointContainedInBoundary(t);if (t.x === e.x) {
	        if (t.x === this.rectEnv.getMinX() || t.x === this.rectEnv.getMaxX()) return !0;
	      } else if (t.y === e.y && (t.y === this.rectEnv.getMinY() || t.y === this.rectEnv.getMaxY())) return !0;return !1;
	    }, isLineStringContainedInBoundary: function isLineStringContainedInBoundary(t) {
	      for (var e = t.getCoordinateSequence(), n = new c(), i = new c(), r = 0; r < e.size() - 1; r++) {
	        if (e.getCoordinate(r, n), e.getCoordinate(r + 1, i), !this.isLineSegmentContainedInBoundary(n, i)) return !1;
	      }return !0;
	    }, isPointContainedInBoundary: function isPointContainedInBoundary() {
	      if (arguments[0] instanceof Ct) {
	        var t = arguments[0];return this.isPointContainedInBoundary(t.getCoordinate());
	      }if (arguments[0] instanceof c) {
	        var e = arguments[0];return e.x === this.rectEnv.getMinX() || e.x === this.rectEnv.getMaxX() || e.y === this.rectEnv.getMinY() || e.y === this.rectEnv.getMaxY();
	      }
	    }, contains: function contains(t) {
	      return !!this.rectEnv.contains(t.getEnvelopeInternal()) && !this.isContainedInBoundary(t);
	    }, interfaces_: function interfaces_() {
	      return [];
	    }, getClass: function getClass() {
	      return Er;
	    } }), Er.contains = function (t, e) {
	    return new Er(t).contains(e);
	  }, Or(xr.prototype, { intersects: function intersects(t, e) {
	      var n = new x(t, e);if (!this.rectEnv.intersects(n)) return !1;if (this.rectEnv.intersects(t)) return !0;if (this.rectEnv.intersects(e)) return !0;if (t.compareTo(e) > 0) {
	        var i = t;t = e, e = i;
	      }var r = !1;return e.y > t.y && (r = !0), r ? this.li.computeIntersection(t, e, this.diagDown0, this.diagDown1) : this.li.computeIntersection(t, e, this.diagUp0, this.diagUp1), !!this.li.hasIntersection();
	    }, interfaces_: function interfaces_() {
	      return [];
	    }, getClass: function getClass() {
	      return xr;
	    } }), Or(Nr.prototype, { applyTo: function applyTo(t) {
	      for (var e = 0; e < t.getNumGeometries() && !this._isDone; e++) {
	        var n = t.getGeometryN(e);if (n instanceof lt) this.applyTo(n);else if (this.visit(n), this.isDone()) return this._isDone = !0, null;
	      }
	    }, interfaces_: function interfaces_() {
	      return [];
	    }, getClass: function getClass() {
	      return Nr;
	    } }), Or(Cr.prototype, { intersects: function intersects(t) {
	      if (!this.rectEnv.intersects(t.getEnvelopeInternal())) return !1;var e = new Sr(this.rectEnv);if (e.applyTo(t), e.intersects()) return !0;var n = new Lr(this.rectangle);if (n.applyTo(t), n.containsPoint()) return !0;var i = new Rr(this.rectangle);return i.applyTo(t), !!i.intersects();
	    }, interfaces_: function interfaces_() {
	      return [];
	    }, getClass: function getClass() {
	      return Cr;
	    } }), Cr.intersects = function (t, e) {
	    return new Cr(t).intersects(e);
	  }, br(Sr, Nr), Or(Sr.prototype, { isDone: function isDone() {
	      return this._intersects === !0;
	    }, visit: function visit(t) {
	      var e = t.getEnvelopeInternal();return this.rectEnv.intersects(e) ? this.rectEnv.contains(e) ? (this._intersects = !0, null) : e.getMinX() >= this.rectEnv.getMinX() && e.getMaxX() <= this.rectEnv.getMaxX() ? (this._intersects = !0, null) : e.getMinY() >= this.rectEnv.getMinY() && e.getMaxY() <= this.rectEnv.getMaxY() ? (this._intersects = !0, null) : void 0 : null;
	    }, intersects: function intersects() {
	      return this._intersects;
	    }, interfaces_: function interfaces_() {
	      return [];
	    }, getClass: function getClass() {
	      return Sr;
	    } }), br(Lr, Nr), Or(Lr.prototype, { isDone: function isDone() {
	      return this._containsPoint === !0;
	    }, visit: function visit(t) {
	      if (!(t instanceof Lt)) return null;var e = t.getEnvelopeInternal();if (!this.rectEnv.intersects(e)) return null;for (var n = new c(), i = 0; i < 4; i++) {
	        if (this.rectSeq.getCoordinate(i, n), e.contains(n) && qe.containsPointInPolygon(n, t)) return this._containsPoint = !0, null;
	      }
	    }, containsPoint: function containsPoint() {
	      return this._containsPoint;
	    }, interfaces_: function interfaces_() {
	      return [];
	    }, getClass: function getClass() {
	      return Lr;
	    } }), br(Rr, Nr), Or(Rr.prototype, { intersects: function intersects() {
	      return this.hasIntersection;
	    }, isDone: function isDone() {
	      return this.hasIntersection === !0;
	    }, visit: function visit(t) {
	      var e = t.getEnvelopeInternal();if (!this.rectEnv.intersects(e)) return null;var n = Te.getLines(t);this.checkIntersectionWithLineStrings(n);
	    }, checkIntersectionWithLineStrings: function checkIntersectionWithLineStrings(t) {
	      for (var e = t.iterator(); e.hasNext();) {
	        var n = e.next();if (this.checkIntersectionWithSegments(n), this.hasIntersection) return null;
	      }
	    }, checkIntersectionWithSegments: function checkIntersectionWithSegments(t) {
	      for (var e = t.getCoordinateSequence(), n = 1; n < e.size(); n++) {
	        if (e.getCoordinate(n - 1, this.p0), e.getCoordinate(n, this.p1), this.rectIntersector.intersects(this.p0, this.p1)) return this.hasIntersection = !0, null;
	      }
	    }, interfaces_: function interfaces_() {
	      return [];
	    }, getClass: function getClass() {
	      return Rr;
	    } }), br(wr, Ri), Or(wr.prototype, { getIntersectionMatrix: function getIntersectionMatrix() {
	      return this._relate.computeIM();
	    }, interfaces_: function interfaces_() {
	      return [];
	    }, getClass: function getClass() {
	      return wr;
	    } }), wr.covers = function (t, e) {
	    return !!t.getEnvelopeInternal().covers(e.getEnvelopeInternal()) && (!!t.isRectangle() || wr.relate(t, e).isCovers());
	  }, wr.intersects = function (t, e) {
	    return !!t.getEnvelopeInternal().intersects(e.getEnvelopeInternal()) && (t.isRectangle() ? Cr.intersects(t, e) : e.isRectangle() ? Cr.intersects(e, t) : wr.relate(t, e).isIntersects());
	  }, wr.touches = function (t, e) {
	    return !!t.getEnvelopeInternal().intersects(e.getEnvelopeInternal()) && wr.relate(t, e).isTouches(t.getDimension(), e.getDimension());
	  }, wr.within = function (t, e) {
	    return e.contains(t);
	  }, wr.coveredBy = function (t, e) {
	    return wr.covers(e, t);
	  }, wr.relate = function () {
	    if (2 === arguments.length) {
	      var t = arguments[0],
	          e = arguments[1],
	          n = new wr(t, e),
	          i = n.getIntersectionMatrix();return i;
	    }if (3 === arguments.length) {
	      if ("string" == typeof arguments[2] && arguments[0] instanceof F && arguments[1] instanceof F) {
	        var r = arguments[0],
	            s = arguments[1],
	            o = arguments[2];return wr.relateWithCheck(r, s).matches(o);
	      }if (_r(arguments[2], B) && arguments[0] instanceof F && arguments[1] instanceof F) {
	        var a = arguments[0],
	            u = arguments[1],
	            l = arguments[2],
	            n = new wr(a, u, l),
	            i = n.getIntersectionMatrix();return i;
	      }
	    }
	  }, wr.overlaps = function (t, e) {
	    return !!t.getEnvelopeInternal().intersects(e.getEnvelopeInternal()) && wr.relate(t, e).isOverlaps(t.getDimension(), e.getDimension());
	  }, wr.disjoint = function (t, e) {
	    return !t.intersects(e);
	  }, wr.relateWithCheck = function (t, e) {
	    return t.checkNotGeometryCollection(t), t.checkNotGeometryCollection(e), wr.relate(t, e);
	  }, wr.crosses = function (t, e) {
	    return !!t.getEnvelopeInternal().intersects(e.getEnvelopeInternal()) && wr.relate(t, e).isCrosses(t.getDimension(), e.getDimension());
	  }, wr.contains = function (t, e) {
	    return !!t.getEnvelopeInternal().contains(e.getEnvelopeInternal()) && (t.isRectangle() ? Er.contains(t, e) : wr.relate(t, e).isContains());
	  }, Or(Tr.prototype, { getInteriorPoint: function getInteriorPoint() {
	      return this.interiorPoint;
	    }, add: function add() {
	      if (arguments[0] instanceof F) {
	        var t = arguments[0];if (t instanceof Ct) this.add(t.getCoordinate());else if (t instanceof lt) for (var e = t, n = 0; n < e.getNumGeometries(); n++) {
	          this.add(e.getGeometryN(n));
	        }
	      } else if (arguments[0] instanceof c) {
	        var i = arguments[0],
	            r = i.distance(this.centroid);r < this.minDistance && (this.interiorPoint = new c(i), this.minDistance = r);
	      }
	    }, interfaces_: function interfaces_() {
	      return [];
	    }, getClass: function getClass() {
	      return Tr;
	    } }), Or(F.prototype, { equalsTopo: function equalsTopo(t) {
	      return !!this.getEnvelopeInternal().equals(t.getEnvelopeInternal()) && wr.relate(this, t).isEquals(this.getDimension(), t.getDimension());
	    }, union: function union() {
	      if (0 === arguments.length) return Bi.union(this);if (1 === arguments.length) {
	        var t = arguments[0];return qi.union(this, t);
	      }
	    }, isValid: function isValid() {
	      return Jn.isValid(this);
	    }, intersection: function intersection(t) {
	      if (this.isEmpty() || t.isEmpty()) return Oi.createEmptyResult(Oi.INTERSECTION, this, t, this.factory);if (this.isGeometryCollection()) {
	        var e = t;return be.map(this, { interfaces_: function interfaces_() {
	            return [MapOp];
	          }, map: function map(t) {
	            return t.intersection(e);
	          } });
	      }return this.checkNotGeometryCollection(this), this.checkNotGeometryCollection(t), Pi.overlayOp(this, t, Oi.INTERSECTION);
	    }, covers: function covers(t) {
	      return wr.covers(this, t);
	    }, coveredBy: function coveredBy(t) {
	      return wr.coveredBy(this, t);
	    }, touches: function touches(t) {
	      return wr.touches(this, t);
	    }, intersects: function intersects(t) {
	      return wr.intersects(this, t);
	    }, within: function within(t) {
	      return wr.within(this, t);
	    }, overlaps: function overlaps(t) {
	      return wr.overlaps(this, t);
	    }, disjoint: function disjoint(t) {
	      return wr.disjoint(this, t);
	    }, crosses: function crosses(t) {
	      return wr.crosses(this, t);
	    }, buffer: function buffer() {
	      if (1 === arguments.length) {
	        var t = arguments[0];return gr.bufferOp(this, t);
	      }if (2 === arguments.length) {
	        var e = arguments[0],
	            n = arguments[1];return gr.bufferOp(this, e, n);
	      }if (3 === arguments.length) {
	        var i = arguments[0],
	            r = arguments[1],
	            s = arguments[2];return gr.bufferOp(this, i, r, s);
	      }
	    }, convexHull: function convexHull() {
	      return new pr(this).getConvexHull();
	    }, relate: function relate() {
	      for (var t = arguments.length, e = Array(t), n = 0; n < t; n++) {
	        e[n] = arguments[n];
	      }return wr.relate.apply(wr, [this].concat(e));
	    }, getCentroid: function getCentroid() {
	      if (this.isEmpty()) return this.factory.createPoint();var t = vr.getCentroid(this);return this.createPointFromInternalCoord(t, this);
	    }, getInteriorPoint: function getInteriorPoint() {
	      if (this.isEmpty()) return this.factory.createPoint();var t = null,
	          e = this.getDimension();if (0 === e) {
	        var n = new Tr(this);t = n.getInteriorPoint();
	      } else if (1 === e) {
	        var n = new zi(this);t = n.getInteriorPoint();
	      } else {
	        var n = new _i(this);t = n.getInteriorPoint();
	      }return this.createPointFromInternalCoord(t, this);
	    }, symDifference: function symDifference(t) {
	      if (this.isEmpty() || t.isEmpty()) {
	        if (this.isEmpty() && t.isEmpty()) return Oi.createEmptyResult(Oi.SYMDIFFERENCE, this, t, this.factory);if (this.isEmpty()) return t.copy();if (t.isEmpty()) return this.copy();
	      }return this.checkNotGeometryCollection(this), this.checkNotGeometryCollection(t), Pi.overlayOp(this, t, Oi.SYMDIFFERENCE);
	    }, createPointFromInternalCoord: function createPointFromInternalCoord(t, e) {
	      return e.getPrecisionModel().makePrecise(t), e.getFactory().createPoint(t);
	    }, toText: function toText() {
	      return new ee().write(this);
	    }, toString: function toString() {
	      this.toText();
	    }, contains: function contains(t) {
	      return wr.contains(this, t);
	    }, difference: function difference(t) {
	      return this.isEmpty() ? Oi.createEmptyResult(Oi.DIFFERENCE, this, t, this.factory) : t.isEmpty() ? this.copy() : (this.checkNotGeometryCollection(this), this.checkNotGeometryCollection(t), Pi.overlayOp(this, t, Oi.DIFFERENCE));
	    }, isSimple: function isSimple() {
	      return new Ui(this).isSimple();
	    }, isWithinDistance: function isWithinDistance(t, e) {
	      return !(this.getEnvelopeInternal().distance(t.getEnvelopeInternal()) > e) && Oe.isWithinDistance(this, t, e);
	    }, distance: function distance(t) {
	      return Oe.distance(this, t);
	    }, isEquivalentClass: function isEquivalentClass(t) {
	      return this.getClass() === t.getClass();
	    } });t.version = "1.4.0 (1ba5f4e)", t.geom = Xr, t.index = Vr, t.io = Kr, t.operation = Zr, Object.defineProperty(t, "__esModule", { value: !0 });
	});
	//# sourceMappingURL=jsts.min.js.map

/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * This is the web browser implementation of `debug()`.
	 *
	 * Expose `debug()` as the module.
	 */
	
	exports = module.exports = __webpack_require__(224);
	exports.log = log;
	exports.formatArgs = formatArgs;
	exports.save = save;
	exports.load = load;
	exports.useColors = useColors;
	exports.storage = 'undefined' != typeof chrome
	               && 'undefined' != typeof chrome.storage
	                  ? chrome.storage.local
	                  : localstorage();
	
	/**
	 * Colors.
	 */
	
	exports.colors = [
	  'lightseagreen',
	  'forestgreen',
	  'goldenrod',
	  'dodgerblue',
	  'darkorchid',
	  'crimson'
	];
	
	/**
	 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
	 * and the Firebug extension (any Firefox version) are known
	 * to support "%c" CSS customizations.
	 *
	 * TODO: add a `localStorage` variable to explicitly enable/disable colors
	 */
	
	function useColors() {
	  // NB: In an Electron preload script, document will be defined but not fully
	  // initialized. Since we know we're in Chrome, we'll just detect this case
	  // explicitly
	  if (typeof window !== 'undefined' && window.process && window.process.type === 'renderer') {
	    return true;
	  }
	
	  // is webkit? http://stackoverflow.com/a/16459606/376773
	  // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632
	  return (typeof document !== 'undefined' && document && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||
	    // is firebug? http://stackoverflow.com/a/398120/376773
	    (typeof window !== 'undefined' && window && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||
	    // is firefox >= v31?
	    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
	    (typeof navigator !== 'undefined' && navigator && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31) ||
	    // double check webkit in userAgent just in case we are in a worker
	    (typeof navigator !== 'undefined' && navigator && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/));
	}
	
	/**
	 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
	 */
	
	exports.formatters.j = function(v) {
	  try {
	    return JSON.stringify(v);
	  } catch (err) {
	    return '[UnexpectedJSONParseError]: ' + err.message;
	  }
	};
	
	
	/**
	 * Colorize log arguments if enabled.
	 *
	 * @api public
	 */
	
	function formatArgs(args) {
	  var useColors = this.useColors;
	
	  args[0] = (useColors ? '%c' : '')
	    + this.namespace
	    + (useColors ? ' %c' : ' ')
	    + args[0]
	    + (useColors ? '%c ' : ' ')
	    + '+' + exports.humanize(this.diff);
	
	  if (!useColors) return;
	
	  var c = 'color: ' + this.color;
	  args.splice(1, 0, c, 'color: inherit')
	
	  // the final "%c" is somewhat tricky, because there could be other
	  // arguments passed either before or after the %c, so we need to
	  // figure out the correct index to insert the CSS into
	  var index = 0;
	  var lastC = 0;
	  args[0].replace(/%[a-zA-Z%]/g, function(match) {
	    if ('%%' === match) return;
	    index++;
	    if ('%c' === match) {
	      // we only are interested in the *last* %c
	      // (the user may have provided their own)
	      lastC = index;
	    }
	  });
	
	  args.splice(lastC, 0, c);
	}
	
	/**
	 * Invokes `console.log()` when available.
	 * No-op when `console.log` is not a "function".
	 *
	 * @api public
	 */
	
	function log() {
	  // this hackery is required for IE8/9, where
	  // the `console.log` function doesn't have 'apply'
	  return 'object' === typeof console
	    && console.log
	    && Function.prototype.apply.call(console.log, console, arguments);
	}
	
	/**
	 * Save `namespaces`.
	 *
	 * @param {String} namespaces
	 * @api private
	 */
	
	function save(namespaces) {
	  try {
	    if (null == namespaces) {
	      exports.storage.removeItem('debug');
	    } else {
	      exports.storage.debug = namespaces;
	    }
	  } catch(e) {}
	}
	
	/**
	 * Load `namespaces`.
	 *
	 * @return {String} returns the previously persisted debug modes
	 * @api private
	 */
	
	function load() {
	  var r;
	  try {
	    r = exports.storage.debug;
	  } catch(e) {}
	
	  // If debug isn't set in LS, and we're in Electron, try to load $DEBUG
	  if (!r && typeof process !== 'undefined' && 'env' in process) {
	    r = ({"NODE_ENV":"development","BUILD_ENV":"standard"}).DEBUG;
	  }
	
	  return r;
	}
	
	/**
	 * Enable namespaces listed in `localStorage.debug` initially.
	 */
	
	exports.enable(load());
	
	/**
	 * Localstorage attempts to return the localstorage.
	 *
	 * This is necessary because safari throws
	 * when a user disables cookies/localstorage
	 * and you attempt to access it.
	 *
	 * @return {LocalStorage}
	 * @api private
	 */
	
	function localstorage() {
	  try {
	    return window.localStorage;
	  } catch (e) {}
	}
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(50)))

/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _index = __webpack_require__(55);
	
	var _index2 = _interopRequireDefault(_index);
	
	var _IdGenerator = __webpack_require__(152);
	
	var _IdGenerator2 = _interopRequireDefault(_IdGenerator);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	/**
	 * NGR对象的基本类,包含构造基本对象的元素和方法。
	 */
	var NGRObject = function () {
	  /**
	   * 构造方法。
	   */
	  function NGRObject() {
	    _classCallCheck(this, NGRObject);
	
	    this._emitter = new _index2.default();
	    this.id = _IdGenerator2.default.generate();
	  }
	
	  /**
	   * Id getter.
	   * @ignore
	   * @return {Number} Id.
	   */
	
	
	  _createClass(NGRObject, [{
	    key: 'on',
	
	
	    /**
	     * 用以响应对控件的操作，监听特定事件。
	     * @param  {...(String|Function)}  args  最后一个参数是监听器，之前的参数均是事件名。
	     * @return {NGRObject}                   this。
	     */
	    value: function on() {
	      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	        args[_key] = arguments[_key];
	      }
	
	      if (args.length < 2) {
	        return this;
	      }
	
	      var func = args.pop();
	
	      for (var _iterator = args, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
	        var _ref;
	
	        if (_isArray) {
	          if (_i >= _iterator.length) break;
	          _ref = _iterator[_i++];
	        } else {
	          _i = _iterator.next();
	          if (_i.done) break;
	          _ref = _i.value;
	        }
	
	        var e = _ref;
	
	        this._emitter.on(e, func);
	      }
	      return this;
	    }
	
	    /**
	     * 用以响应对控件的操作，监听特定事件，并且只监听一次。
	     * @param  {...(String|Function)}   args  最后一个参数是监听器，之前的参数均是事件名。
	     * @return {NGRObject}                    this。
	     */
	
	  }, {
	    key: 'once',
	    value: function once() {
	      for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
	        args[_key2] = arguments[_key2];
	      }
	
	      if (args.length < 2) {
	        return this;
	      }
	
	      var func = args.pop();
	
	      for (var _iterator2 = args, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator]();;) {
	        var _ref2;
	
	        if (_isArray2) {
	          if (_i2 >= _iterator2.length) break;
	          _ref2 = _iterator2[_i2++];
	        } else {
	          _i2 = _iterator2.next();
	          if (_i2.done) break;
	          _ref2 = _i2.value;
	        }
	
	        var e = _ref2;
	
	        this._emitter.once(e, func);
	      }
	
	      return this;
	    }
	
	    /**
	     * 解绑监听器。
	     * @param  {...(String|Function)}   args  最后一个参数是监听器，之前的参数均是事件名。
	     * @return {NGRObject}                    this。
	     */
	
	  }, {
	    key: 'off',
	    value: function off() {
	      for (var _len3 = arguments.length, args = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
	        args[_key3] = arguments[_key3];
	      }
	
	      if (args.length < 2) {
	        return this;
	      }
	
	      var func = args.pop();
	
	      for (var _iterator3 = args, _isArray3 = Array.isArray(_iterator3), _i3 = 0, _iterator3 = _isArray3 ? _iterator3 : _iterator3[Symbol.iterator]();;) {
	        var _ref3;
	
	        if (_isArray3) {
	          if (_i3 >= _iterator3.length) break;
	          _ref3 = _iterator3[_i3++];
	        } else {
	          _i3 = _iterator3.next();
	          if (_i3.done) break;
	          _ref3 = _i3.value;
	        }
	
	        var e = _ref3;
	
	        this._emitter.off(e, func);
	      }
	
	      return this;
	    }
	
	    /**
	     * 用以响应对控件的操作,触发特定事件。
	     * @param  {String}    event   事件名。
	     * @param  {...Object} options 传入监听器的参数。
	     * @return {NGRObject}         this。
	     */
	
	  }, {
	    key: 'emit',
	    value: function emit(event) {
	      var _emitter;
	
	      for (var _len4 = arguments.length, options = Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {
	        options[_key4 - 1] = arguments[_key4];
	      }
	
	      (_emitter = this._emitter).emit.apply(_emitter, [event].concat(options));
	      return this;
	    }
	
	    /**
	     * 用以响应对控件的操作,触发特定事件。
	     * @param  {String}    event   事件名。
	     * @param  {...Object} options 传入监听器的参数。
	     * @return {NGRObject}         this。
	     */
	
	  }, {
	    key: 'fire',
	    value: function fire(event) {
	      for (var _len5 = arguments.length, options = Array(_len5 > 1 ? _len5 - 1 : 0), _key5 = 1; _key5 < _len5; _key5++) {
	        options[_key5 - 1] = arguments[_key5];
	      }
	
	      return this.emit.apply(this, [event].concat(options));
	    }
	
	    /**
	     * 返回事件的监听器。
	     * @param  {String} event 事件名。
	     * @return {Listener[]}   监听器列表。
	     */
	
	  }, {
	    key: 'listeners',
	    value: function listeners(event) {
	      return this._emitter.listeners(event);
	    }
	
	    /**
	     * 检查某事件是否绑定监听器。
	     * @param  {String}  event 事件名。
	     * @return {Boolean}       是否绑定监听器，true即为绑定。
	     */
	
	  }, {
	    key: 'hasListeners',
	    value: function hasListeners(event) {
	      return this._emitter.hasListeners(event);
	    }
	  }, {
	    key: 'id',
	    get: function get() {
	      return this._id;
	    }
	
	    /**
	     * Id setter.
	     * @ignore
	     * @param  {String} id Id.
	     */
	    ,
	    set: function set(id) {
	      this._id = id;
	    }
	  }]);
	
	  return NGRObject;
	}();
	
	exports.default = NGRObject;

/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var inherits = __webpack_require__(3)
	  , EventTarget = __webpack_require__(90)
	  ;
	
	function EventEmitter() {
	  EventTarget.call(this);
	}
	
	inherits(EventEmitter, EventTarget);
	
	EventEmitter.prototype.removeAllListeners = function(type) {
	  if (type) {
	    delete this._listeners[type];
	  } else {
	    this._listeners = {};
	  }
	};
	
	EventEmitter.prototype.once = function(type, listener) {
	  var self = this
	    , fired = false;
	
	  function g() {
	    self.removeListener(type, g);
	
	    if (!fired) {
	      fired = true;
	      listener.apply(this, arguments);
	    }
	  }
	
	  this.on(type, g);
	};
	
	EventEmitter.prototype.emit = function() {
	  var type = arguments[0];
	  var listeners = this._listeners[type];
	  if (!listeners) {
	    return;
	  }
	  // equivalent of Array.prototype.slice.call(arguments, 1);
	  var l = arguments.length;
	  var args = new Array(l - 1);
	  for (var ai = 1; ai < l; ai++) {
	    args[ai - 1] = arguments[ai];
	  }
	  for (var i = 0; i < listeners.length; i++) {
	    listeners[i].apply(this, args);
	  }
	};
	
	EventEmitter.prototype.on = EventEmitter.prototype.addListener = EventTarget.prototype.addEventListener;
	EventEmitter.prototype.removeListener = EventTarget.prototype.removeEventListener;
	
	module.exports.EventEmitter = EventEmitter;


/***/ }),
/* 9 */
/***/ (function(module, exports) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var factory = void 0;
	
	/**
	 * 动画工厂类,用于创建和修改动画的具体实现效果。
	 * @memberOf NGR.animation
	 */
	
	var AnimatorFactory = function () {
	  function AnimatorFactory() {
	    _classCallCheck(this, AnimatorFactory);
	  }
	
	  _createClass(AnimatorFactory, [{
	    key: "update",
	
	
	    /**
	     * 根据时间戳更新动画状态。
	     * @ignore
	     * @param  {Number} timestamp 时间戳。
	     * @return {undefined}           undefined。
	     */
	    value: function update(timestamp) {
	      this._provider.update(timestamp);
	    }
	
	    /**
	     * 根据两个数值创建动画效果。如用两个数值50%,90%表示透明度,持续时间为1000毫秒,则该动画效果为对象在1秒钟内透明度从50%渐变90%。
	     * @param  {...Number} params 第一个参数表示初始动画显示效果，
	     *                            第二个参数表示结束结束动画显示显示效果，第三个参数为动画持续时间(毫秒)。
	     * @return {Animator}         动画对象。
	     */
	
	  }, {
	    key: "ofNumber",
	    value: function ofNumber() {
	      var _provider;
	
	      return (_provider = this._provider).ofNumber.apply(_provider, arguments);
	    }
	
	    /**
	     * 根据对象属性的参数来创建动画。如使用两个点的坐标作为参数,第一个参数为(x1,y1),第二个参数为(x2,y2)。持续时间为500毫秒,则该动画效果为动画对象(如地图)在0.5秒内从(x1,y1)位移到(x2,y2)。
	     * @param  {...(Object|Nubmer)} params 第一个参数表示初始动画显示效果，
	     *                                           第二个参数表示结束结束动画显示显示效果，
	     *                                           第三个参数为动画持续时间(毫秒)。
	     * @return {Animator}           动画对象。
	     */
	
	  }, {
	    key: "ofObject",
	    value: function ofObject() {
	      var _provider2;
	
	      return (_provider2 = this._provider).ofObject.apply(_provider2, arguments);
	    }
	
	    /**
	     * 获取一个新的动画工厂实例,即会被应用动画效果的对象。
	     * @static
	     * @return {AnimatorFactory} 动画工厂实例。
	     */
	
	  }, {
	    key: "provider",
	    get: function get() {
	      return this._provider;
	    },
	    set: function set(provider) {
	      this._provider = provider;
	    }
	  }], [{
	    key: "getInstance",
	    value: function getInstance() {
	      if (!factory) {
	        factory = new AnimatorFactory();
	      }
	      return factory;
	    }
	  }]);
	
	  return AnimatorFactory;
	}();
	
	exports.default = AnimatorFactory;

/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var URL = __webpack_require__(104);
	
	var debug = function() {};
	if (true) {
	  debug = __webpack_require__(6)('sockjs-client:utils:url');
	}
	
	module.exports = {
	  getOrigin: function(url) {
	    if (!url) {
	      return null;
	    }
	
	    var p = new URL(url);
	    if (p.protocol === 'file:') {
	      return null;
	    }
	
	    var port = p.port;
	    if (!port) {
	      port = (p.protocol === 'https:') ? '443' : '80';
	    }
	
	    return p.protocol + '//' + p.hostname + ':' + port;
	  }
	
	, isOriginEqual: function(a, b) {
	    var res = this.getOrigin(a) === this.getOrigin(b);
	    debug('same', a, b, res);
	    return res;
	  }
	
	, isSchemeEqual: function(a, b) {
	    return (a.split(':')[0] === b.split(':')[0]);
	  }
	
	, addPath: function (url, path) {
	    var qs = url.split('?');
	    return qs[0] + path + (qs[1] ? '?' + qs[1] : '');
	  }
	
	, addQuery: function (url, q) {
	    return url + (url.indexOf('?') === -1 ? ('?' + q) : ('&' + q));
	  }
	};


/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.DOMUtils = undefined;
	
	var _DOMUtils = __webpack_require__(65);
	
	var DOMUtils = _interopRequireWildcard(_DOMUtils);
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	exports.DOMUtils = DOMUtils;

/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _jsts = __webpack_require__(5);
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var _factory = new _jsts.geom.GeometryFactory();
	var _geoReader = new _jsts.io.GeoJSONReader(_factory);
	var _geoWriter = new _jsts.io.GeoJSONWriter();
	
	var JTSUtils = function () {
	  function JTSUtils() {
	    _classCallCheck(this, JTSUtils);
	  }
	
	  _createClass(JTSUtils, null, [{
	    key: 'getFactory',
	    value: function getFactory() {
	      return _factory;
	    }
	  }, {
	    key: 'getGeoReader',
	    value: function getGeoReader() {
	      return _geoReader;
	    }
	  }, {
	    key: 'getGeoWriter',
	    value: function getGeoWriter() {
	      return _geoWriter;
	    }
	  }, {
	    key: 'getLongEdge',
	    value: function getLongEdge(geometry) {
	      var longEdge = null;
	
	      if (!geometry) {
	        return longEdge;
	      }
	
	      var type = geometry.getGeometryType();
	
	      if (type === 'Polygon') {
	        var exteriorRing = geometry.getExteriorRing();
	        var coordinates = exteriorRing.getCoordinates();
	        var maxDistance = 0;
	
	        // Why not filter out collinear segments?
	        for (var index = 1; index < coordinates.length; index++) {
	          var lineSegment = new _jsts.geom.LineSegment(coordinates[index - 1], coordinates[index]);
	          var length = lineSegment.getLength();
	
	          if (maxDistance < length) {
	            longEdge = lineSegment;
	            maxDistance = length;
	          }
	        }
	      }
	      return longEdge;
	    }
	  }]);
	
	  return JTSUtils;
	}();
	
	exports.default = JTSUtils;

/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.Response = exports.Request = exports.Headers = undefined;
	
	var _globalFetch = __webpack_require__(109);
	
	var _globalFetch2 = _interopRequireDefault(_globalFetch);
	
	var _Headers = __webpack_require__(31);
	
	var _Headers2 = _interopRequireDefault(_Headers);
	
	var _Request = __webpack_require__(57);
	
	var _Request2 = _interopRequireDefault(_Request);
	
	var _Response = __webpack_require__(58);
	
	var _Response2 = _interopRequireDefault(_Response);
	
	var _timeout = __webpack_require__(110);
	
	var _timeout2 = _interopRequireDefault(_timeout);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	// import abort from './helper/abort';
	
	_globalFetch2.default.helper = {
	  timeout: _timeout2.default
	};
	
	exports.default = _globalFetch2.default;
	exports.Headers = _Headers2.default;
	exports.Request = _Request2.default;
	exports.Response = _Response2.default;

/***/ }),
/* 14 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _assign = __webpack_require__(1);
	
	var defaultProps = {
	  /**
	   * 返回样式类型。
	   * @memberof NGR.style.Style.prototype
	   * @return {String} 样式类型。
	   */
	  type: function type() {
	    return 'default';
	  },
	  /**
	   * 设置渲染对象的边缘大小，单位米。
	   * @type {number}
	   * @memberof NGR.style.Style.prototype
	   */
	  margin: 0
	};
	
	/**
	 * 样式设置，用于对地图上的各种渲染元素，如文字、图形、线条的大小、颜色等显示效果进行配置。
	 * @memberOf NGR.style
	 * @class Style
	 */
	function Style() {
	  _assign(this, defaultProps);
	}
	
	exports.default = Style;

/***/ }),
/* 15 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/* WEBPACK VAR INJECTION */(function(module, global) {/*! JSON v3.3.2 | http://bestiejs.github.io/json3 | Copyright 2012-2014, Kit Cambridge | http://kit.mit-license.org */
	;(function () {
	  // Detect the `define` function exposed by asynchronous module loaders. The
	  // strict `define` check is necessary for compatibility with `r.js`.
	  var isLoader = "function" === "function" && __webpack_require__(285);
	
	  // A set of types used to distinguish objects from primitives.
	  var objectTypes = {
	    "function": true,
	    "object": true
	  };
	
	  // Detect the `exports` object exposed by CommonJS implementations.
	  var freeExports = objectTypes[typeof exports] && exports && !exports.nodeType && exports;
	
	  // Use the `global` object exposed by Node (including Browserify via
	  // `insert-module-globals`), Narwhal, and Ringo as the default context,
	  // and the `window` object in browsers. Rhino exports a `global` function
	  // instead.
	  var root = objectTypes[typeof window] && window || this,
	      freeGlobal = freeExports && objectTypes[typeof module] && module && !module.nodeType && typeof global == "object" && global;
	
	  if (freeGlobal && (freeGlobal["global"] === freeGlobal || freeGlobal["window"] === freeGlobal || freeGlobal["self"] === freeGlobal)) {
	    root = freeGlobal;
	  }
	
	  // Public: Initializes JSON 3 using the given `context` object, attaching the
	  // `stringify` and `parse` functions to the specified `exports` object.
	  function runInContext(context, exports) {
	    context || (context = root["Object"]());
	    exports || (exports = root["Object"]());
	
	    // Native constructor aliases.
	    var Number = context["Number"] || root["Number"],
	        String = context["String"] || root["String"],
	        Object = context["Object"] || root["Object"],
	        Date = context["Date"] || root["Date"],
	        SyntaxError = context["SyntaxError"] || root["SyntaxError"],
	        TypeError = context["TypeError"] || root["TypeError"],
	        Math = context["Math"] || root["Math"],
	        nativeJSON = context["JSON"] || root["JSON"];
	
	    // Delegate to the native `stringify` and `parse` implementations.
	    if (typeof nativeJSON == "object" && nativeJSON) {
	      exports.stringify = nativeJSON.stringify;
	      exports.parse = nativeJSON.parse;
	    }
	
	    // Convenience aliases.
	    var objectProto = Object.prototype,
	        getClass = objectProto.toString,
	        isProperty, forEach, undef;
	
	    // Test the `Date#getUTC*` methods. Based on work by @Yaffle.
	    var isExtended = new Date(-3509827334573292);
	    try {
	      // The `getUTCFullYear`, `Month`, and `Date` methods return nonsensical
	      // results for certain dates in Opera >= 10.53.
	      isExtended = isExtended.getUTCFullYear() == -109252 && isExtended.getUTCMonth() === 0 && isExtended.getUTCDate() === 1 &&
	        // Safari < 2.0.2 stores the internal millisecond time value correctly,
	        // but clips the values returned by the date methods to the range of
	        // signed 32-bit integers ([-2 ** 31, 2 ** 31 - 1]).
	        isExtended.getUTCHours() == 10 && isExtended.getUTCMinutes() == 37 && isExtended.getUTCSeconds() == 6 && isExtended.getUTCMilliseconds() == 708;
	    } catch (exception) {}
	
	    // Internal: Determines whether the native `JSON.stringify` and `parse`
	    // implementations are spec-compliant. Based on work by Ken Snyder.
	    function has(name) {
	      if (has[name] !== undef) {
	        // Return cached feature test result.
	        return has[name];
	      }
	      var isSupported;
	      if (name == "bug-string-char-index") {
	        // IE <= 7 doesn't support accessing string characters using square
	        // bracket notation. IE 8 only supports this for primitives.
	        isSupported = "a"[0] != "a";
	      } else if (name == "json") {
	        // Indicates whether both `JSON.stringify` and `JSON.parse` are
	        // supported.
	        isSupported = has("json-stringify") && has("json-parse");
	      } else {
	        var value, serialized = '{"a":[1,true,false,null,"\\u0000\\b\\n\\f\\r\\t"]}';
	        // Test `JSON.stringify`.
	        if (name == "json-stringify") {
	          var stringify = exports.stringify, stringifySupported = typeof stringify == "function" && isExtended;
	          if (stringifySupported) {
	            // A test function object with a custom `toJSON` method.
	            (value = function () {
	              return 1;
	            }).toJSON = value;
	            try {
	              stringifySupported =
	                // Firefox 3.1b1 and b2 serialize string, number, and boolean
	                // primitives as object literals.
	                stringify(0) === "0" &&
	                // FF 3.1b1, b2, and JSON 2 serialize wrapped primitives as object
	                // literals.
	                stringify(new Number()) === "0" &&
	                stringify(new String()) == '""' &&
	                // FF 3.1b1, 2 throw an error if the value is `null`, `undefined`, or
	                // does not define a canonical JSON representation (this applies to
	                // objects with `toJSON` properties as well, *unless* they are nested
	                // within an object or array).
	                stringify(getClass) === undef &&
	                // IE 8 serializes `undefined` as `"undefined"`. Safari <= 5.1.7 and
	                // FF 3.1b3 pass this test.
	                stringify(undef) === undef &&
	                // Safari <= 5.1.7 and FF 3.1b3 throw `Error`s and `TypeError`s,
	                // respectively, if the value is omitted entirely.
	                stringify() === undef &&
	                // FF 3.1b1, 2 throw an error if the given value is not a number,
	                // string, array, object, Boolean, or `null` literal. This applies to
	                // objects with custom `toJSON` methods as well, unless they are nested
	                // inside object or array literals. YUI 3.0.0b1 ignores custom `toJSON`
	                // methods entirely.
	                stringify(value) === "1" &&
	                stringify([value]) == "[1]" &&
	                // Prototype <= 1.6.1 serializes `[undefined]` as `"[]"` instead of
	                // `"[null]"`.
	                stringify([undef]) == "[null]" &&
	                // YUI 3.0.0b1 fails to serialize `null` literals.
	                stringify(null) == "null" &&
	                // FF 3.1b1, 2 halts serialization if an array contains a function:
	                // `[1, true, getClass, 1]` serializes as "[1,true,],". FF 3.1b3
	                // elides non-JSON values from objects and arrays, unless they
	                // define custom `toJSON` methods.
	                stringify([undef, getClass, null]) == "[null,null,null]" &&
	                // Simple serialization test. FF 3.1b1 uses Unicode escape sequences
	                // where character escape codes are expected (e.g., `\b` => `\u0008`).
	                stringify({ "a": [value, true, false, null, "\x00\b\n\f\r\t"] }) == serialized &&
	                // FF 3.1b1 and b2 ignore the `filter` and `width` arguments.
	                stringify(null, value) === "1" &&
	                stringify([1, 2], null, 1) == "[\n 1,\n 2\n]" &&
	                // JSON 2, Prototype <= 1.7, and older WebKit builds incorrectly
	                // serialize extended years.
	                stringify(new Date(-8.64e15)) == '"-271821-04-20T00:00:00.000Z"' &&
	                // The milliseconds are optional in ES 5, but required in 5.1.
	                stringify(new Date(8.64e15)) == '"+275760-09-13T00:00:00.000Z"' &&
	                // Firefox <= 11.0 incorrectly serializes years prior to 0 as negative
	                // four-digit years instead of six-digit years. Credits: @Yaffle.
	                stringify(new Date(-621987552e5)) == '"-000001-01-01T00:00:00.000Z"' &&
	                // Safari <= 5.1.5 and Opera >= 10.53 incorrectly serialize millisecond
	                // values less than 1000. Credits: @Yaffle.
	                stringify(new Date(-1)) == '"1969-12-31T23:59:59.999Z"';
	            } catch (exception) {
	              stringifySupported = false;
	            }
	          }
	          isSupported = stringifySupported;
	        }
	        // Test `JSON.parse`.
	        if (name == "json-parse") {
	          var parse = exports.parse;
	          if (typeof parse == "function") {
	            try {
	              // FF 3.1b1, b2 will throw an exception if a bare literal is provided.
	              // Conforming implementations should also coerce the initial argument to
	              // a string prior to parsing.
	              if (parse("0") === 0 && !parse(false)) {
	                // Simple parsing test.
	                value = parse(serialized);
	                var parseSupported = value["a"].length == 5 && value["a"][0] === 1;
	                if (parseSupported) {
	                  try {
	                    // Safari <= 5.1.2 and FF 3.1b1 allow unescaped tabs in strings.
	                    parseSupported = !parse('"\t"');
	                  } catch (exception) {}
	                  if (parseSupported) {
	                    try {
	                      // FF 4.0 and 4.0.1 allow leading `+` signs and leading
	                      // decimal points. FF 4.0, 4.0.1, and IE 9-10 also allow
	                      // certain octal literals.
	                      parseSupported = parse("01") !== 1;
	                    } catch (exception) {}
	                  }
	                  if (parseSupported) {
	                    try {
	                      // FF 4.0, 4.0.1, and Rhino 1.7R3-R4 allow trailing decimal
	                      // points. These environments, along with FF 3.1b1 and 2,
	                      // also allow trailing commas in JSON objects and arrays.
	                      parseSupported = parse("1.") !== 1;
	                    } catch (exception) {}
	                  }
	                }
	              }
	            } catch (exception) {
	              parseSupported = false;
	            }
	          }
	          isSupported = parseSupported;
	        }
	      }
	      return has[name] = !!isSupported;
	    }
	
	    if (!has("json")) {
	      // Common `[[Class]]` name aliases.
	      var functionClass = "[object Function]",
	          dateClass = "[object Date]",
	          numberClass = "[object Number]",
	          stringClass = "[object String]",
	          arrayClass = "[object Array]",
	          booleanClass = "[object Boolean]";
	
	      // Detect incomplete support for accessing string characters by index.
	      var charIndexBuggy = has("bug-string-char-index");
	
	      // Define additional utility methods if the `Date` methods are buggy.
	      if (!isExtended) {
	        var floor = Math.floor;
	        // A mapping between the months of the year and the number of days between
	        // January 1st and the first of the respective month.
	        var Months = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334];
	        // Internal: Calculates the number of days between the Unix epoch and the
	        // first day of the given month.
	        var getDay = function (year, month) {
	          return Months[month] + 365 * (year - 1970) + floor((year - 1969 + (month = +(month > 1))) / 4) - floor((year - 1901 + month) / 100) + floor((year - 1601 + month) / 400);
	        };
	      }
	
	      // Internal: Determines if a property is a direct property of the given
	      // object. Delegates to the native `Object#hasOwnProperty` method.
	      if (!(isProperty = objectProto.hasOwnProperty)) {
	        isProperty = function (property) {
	          var members = {}, constructor;
	          if ((members.__proto__ = null, members.__proto__ = {
	            // The *proto* property cannot be set multiple times in recent
	            // versions of Firefox and SeaMonkey.
	            "toString": 1
	          }, members).toString != getClass) {
	            // Safari <= 2.0.3 doesn't implement `Object#hasOwnProperty`, but
	            // supports the mutable *proto* property.
	            isProperty = function (property) {
	              // Capture and break the object's prototype chain (see section 8.6.2
	              // of the ES 5.1 spec). The parenthesized expression prevents an
	              // unsafe transformation by the Closure Compiler.
	              var original = this.__proto__, result = property in (this.__proto__ = null, this);
	              // Restore the original prototype chain.
	              this.__proto__ = original;
	              return result;
	            };
	          } else {
	            // Capture a reference to the top-level `Object` constructor.
	            constructor = members.constructor;
	            // Use the `constructor` property to simulate `Object#hasOwnProperty` in
	            // other environments.
	            isProperty = function (property) {
	              var parent = (this.constructor || constructor).prototype;
	              return property in this && !(property in parent && this[property] === parent[property]);
	            };
	          }
	          members = null;
	          return isProperty.call(this, property);
	        };
	      }
	
	      // Internal: Normalizes the `for...in` iteration algorithm across
	      // environments. Each enumerated key is yielded to a `callback` function.
	      forEach = function (object, callback) {
	        var size = 0, Properties, members, property;
	
	        // Tests for bugs in the current environment's `for...in` algorithm. The
	        // `valueOf` property inherits the non-enumerable flag from
	        // `Object.prototype` in older versions of IE, Netscape, and Mozilla.
	        (Properties = function () {
	          this.valueOf = 0;
	        }).prototype.valueOf = 0;
	
	        // Iterate over a new instance of the `Properties` class.
	        members = new Properties();
	        for (property in members) {
	          // Ignore all properties inherited from `Object.prototype`.
	          if (isProperty.call(members, property)) {
	            size++;
	          }
	        }
	        Properties = members = null;
	
	        // Normalize the iteration algorithm.
	        if (!size) {
	          // A list of non-enumerable properties inherited from `Object.prototype`.
	          members = ["valueOf", "toString", "toLocaleString", "propertyIsEnumerable", "isPrototypeOf", "hasOwnProperty", "constructor"];
	          // IE <= 8, Mozilla 1.0, and Netscape 6.2 ignore shadowed non-enumerable
	          // properties.
	          forEach = function (object, callback) {
	            var isFunction = getClass.call(object) == functionClass, property, length;
	            var hasProperty = !isFunction && typeof object.constructor != "function" && objectTypes[typeof object.hasOwnProperty] && object.hasOwnProperty || isProperty;
	            for (property in object) {
	              // Gecko <= 1.0 enumerates the `prototype` property of functions under
	              // certain conditions; IE does not.
	              if (!(isFunction && property == "prototype") && hasProperty.call(object, property)) {
	                callback(property);
	              }
	            }
	            // Manually invoke the callback for each non-enumerable property.
	            for (length = members.length; property = members[--length]; hasProperty.call(object, property) && callback(property));
	          };
	        } else if (size == 2) {
	          // Safari <= 2.0.4 enumerates shadowed properties twice.
	          forEach = function (object, callback) {
	            // Create a set of iterated properties.
	            var members = {}, isFunction = getClass.call(object) == functionClass, property;
	            for (property in object) {
	              // Store each property name to prevent double enumeration. The
	              // `prototype` property of functions is not enumerated due to cross-
	              // environment inconsistencies.
	              if (!(isFunction && property == "prototype") && !isProperty.call(members, property) && (members[property] = 1) && isProperty.call(object, property)) {
	                callback(property);
	              }
	            }
	          };
	        } else {
	          // No bugs detected; use the standard `for...in` algorithm.
	          forEach = function (object, callback) {
	            var isFunction = getClass.call(object) == functionClass, property, isConstructor;
	            for (property in object) {
	              if (!(isFunction && property == "prototype") && isProperty.call(object, property) && !(isConstructor = property === "constructor")) {
	                callback(property);
	              }
	            }
	            // Manually invoke the callback for the `constructor` property due to
	            // cross-environment inconsistencies.
	            if (isConstructor || isProperty.call(object, (property = "constructor"))) {
	              callback(property);
	            }
	          };
	        }
	        return forEach(object, callback);
	      };
	
	      // Public: Serializes a JavaScript `value` as a JSON string. The optional
	      // `filter` argument may specify either a function that alters how object and
	      // array members are serialized, or an array of strings and numbers that
	      // indicates which properties should be serialized. The optional `width`
	      // argument may be either a string or number that specifies the indentation
	      // level of the output.
	      if (!has("json-stringify")) {
	        // Internal: A map of control characters and their escaped equivalents.
	        var Escapes = {
	          92: "\\\\",
	          34: '\\"',
	          8: "\\b",
	          12: "\\f",
	          10: "\\n",
	          13: "\\r",
	          9: "\\t"
	        };
	
	        // Internal: Converts `value` into a zero-padded string such that its
	        // length is at least equal to `width`. The `width` must be <= 6.
	        var leadingZeroes = "000000";
	        var toPaddedString = function (width, value) {
	          // The `|| 0` expression is necessary to work around a bug in
	          // Opera <= 7.54u2 where `0 == -0`, but `String(-0) !== "0"`.
	          return (leadingZeroes + (value || 0)).slice(-width);
	        };
	
	        // Internal: Double-quotes a string `value`, replacing all ASCII control
	        // characters (characters with code unit values between 0 and 31) with
	        // their escaped equivalents. This is an implementation of the
	        // `Quote(value)` operation defined in ES 5.1 section 15.12.3.
	        var unicodePrefix = "\\u00";
	        var quote = function (value) {
	          var result = '"', index = 0, length = value.length, useCharIndex = !charIndexBuggy || length > 10;
	          var symbols = useCharIndex && (charIndexBuggy ? value.split("") : value);
	          for (; index < length; index++) {
	            var charCode = value.charCodeAt(index);
	            // If the character is a control character, append its Unicode or
	            // shorthand escape sequence; otherwise, append the character as-is.
	            switch (charCode) {
	              case 8: case 9: case 10: case 12: case 13: case 34: case 92:
	                result += Escapes[charCode];
	                break;
	              default:
	                if (charCode < 32) {
	                  result += unicodePrefix + toPaddedString(2, charCode.toString(16));
	                  break;
	                }
	                result += useCharIndex ? symbols[index] : value.charAt(index);
	            }
	          }
	          return result + '"';
	        };
	
	        // Internal: Recursively serializes an object. Implements the
	        // `Str(key, holder)`, `JO(value)`, and `JA(value)` operations.
	        var serialize = function (property, object, callback, properties, whitespace, indentation, stack) {
	          var value, className, year, month, date, time, hours, minutes, seconds, milliseconds, results, element, index, length, prefix, result;
	          try {
	            // Necessary for host object support.
	            value = object[property];
	          } catch (exception) {}
	          if (typeof value == "object" && value) {
	            className = getClass.call(value);
	            if (className == dateClass && !isProperty.call(value, "toJSON")) {
	              if (value > -1 / 0 && value < 1 / 0) {
	                // Dates are serialized according to the `Date#toJSON` method
	                // specified in ES 5.1 section 15.9.5.44. See section 15.9.1.15
	                // for the ISO 8601 date time string format.
	                if (getDay) {
	                  // Manually compute the year, month, date, hours, minutes,
	                  // seconds, and milliseconds if the `getUTC*` methods are
	                  // buggy. Adapted from @Yaffle's `date-shim` project.
	                  date = floor(value / 864e5);
	                  for (year = floor(date / 365.2425) + 1970 - 1; getDay(year + 1, 0) <= date; year++);
	                  for (month = floor((date - getDay(year, 0)) / 30.42); getDay(year, month + 1) <= date; month++);
	                  date = 1 + date - getDay(year, month);
	                  // The `time` value specifies the time within the day (see ES
	                  // 5.1 section 15.9.1.2). The formula `(A % B + B) % B` is used
	                  // to compute `A modulo B`, as the `%` operator does not
	                  // correspond to the `modulo` operation for negative numbers.
	                  time = (value % 864e5 + 864e5) % 864e5;
	                  // The hours, minutes, seconds, and milliseconds are obtained by
	                  // decomposing the time within the day. See section 15.9.1.10.
	                  hours = floor(time / 36e5) % 24;
	                  minutes = floor(time / 6e4) % 60;
	                  seconds = floor(time / 1e3) % 60;
	                  milliseconds = time % 1e3;
	                } else {
	                  year = value.getUTCFullYear();
	                  month = value.getUTCMonth();
	                  date = value.getUTCDate();
	                  hours = value.getUTCHours();
	                  minutes = value.getUTCMinutes();
	                  seconds = value.getUTCSeconds();
	                  milliseconds = value.getUTCMilliseconds();
	                }
	                // Serialize extended years correctly.
	                value = (year <= 0 || year >= 1e4 ? (year < 0 ? "-" : "+") + toPaddedString(6, year < 0 ? -year : year) : toPaddedString(4, year)) +
	                  "-" + toPaddedString(2, month + 1) + "-" + toPaddedString(2, date) +
	                  // Months, dates, hours, minutes, and seconds should have two
	                  // digits; milliseconds should have three.
	                  "T" + toPaddedString(2, hours) + ":" + toPaddedString(2, minutes) + ":" + toPaddedString(2, seconds) +
	                  // Milliseconds are optional in ES 5.0, but required in 5.1.
	                  "." + toPaddedString(3, milliseconds) + "Z";
	              } else {
	                value = null;
	              }
	            } else if (typeof value.toJSON == "function" && ((className != numberClass && className != stringClass && className != arrayClass) || isProperty.call(value, "toJSON"))) {
	              // Prototype <= 1.6.1 adds non-standard `toJSON` methods to the
	              // `Number`, `String`, `Date`, and `Array` prototypes. JSON 3
	              // ignores all `toJSON` methods on these objects unless they are
	              // defined directly on an instance.
	              value = value.toJSON(property);
	            }
	          }
	          if (callback) {
	            // If a replacement function was provided, call it to obtain the value
	            // for serialization.
	            value = callback.call(object, property, value);
	          }
	          if (value === null) {
	            return "null";
	          }
	          className = getClass.call(value);
	          if (className == booleanClass) {
	            // Booleans are represented literally.
	            return "" + value;
	          } else if (className == numberClass) {
	            // JSON numbers must be finite. `Infinity` and `NaN` are serialized as
	            // `"null"`.
	            return value > -1 / 0 && value < 1 / 0 ? "" + value : "null";
	          } else if (className == stringClass) {
	            // Strings are double-quoted and escaped.
	            return quote("" + value);
	          }
	          // Recursively serialize objects and arrays.
	          if (typeof value == "object") {
	            // Check for cyclic structures. This is a linear search; performance
	            // is inversely proportional to the number of unique nested objects.
	            for (length = stack.length; length--;) {
	              if (stack[length] === value) {
	                // Cyclic structures cannot be serialized by `JSON.stringify`.
	                throw TypeError();
	              }
	            }
	            // Add the object to the stack of traversed objects.
	            stack.push(value);
	            results = [];
	            // Save the current indentation level and indent one additional level.
	            prefix = indentation;
	            indentation += whitespace;
	            if (className == arrayClass) {
	              // Recursively serialize array elements.
	              for (index = 0, length = value.length; index < length; index++) {
	                element = serialize(index, value, callback, properties, whitespace, indentation, stack);
	                results.push(element === undef ? "null" : element);
	              }
	              result = results.length ? (whitespace ? "[\n" + indentation + results.join(",\n" + indentation) + "\n" + prefix + "]" : ("[" + results.join(",") + "]")) : "[]";
	            } else {
	              // Recursively serialize object members. Members are selected from
	              // either a user-specified list of property names, or the object
	              // itself.
	              forEach(properties || value, function (property) {
	                var element = serialize(property, value, callback, properties, whitespace, indentation, stack);
	                if (element !== undef) {
	                  // According to ES 5.1 section 15.12.3: "If `gap` {whitespace}
	                  // is not the empty string, let `member` {quote(property) + ":"}
	                  // be the concatenation of `member` and the `space` character."
	                  // The "`space` character" refers to the literal space
	                  // character, not the `space` {width} argument provided to
	                  // `JSON.stringify`.
	                  results.push(quote(property) + ":" + (whitespace ? " " : "") + element);
	                }
	              });
	              result = results.length ? (whitespace ? "{\n" + indentation + results.join(",\n" + indentation) + "\n" + prefix + "}" : ("{" + results.join(",") + "}")) : "{}";
	            }
	            // Remove the object from the traversed object stack.
	            stack.pop();
	            return result;
	          }
	        };
	
	        // Public: `JSON.stringify`. See ES 5.1 section 15.12.3.
	        exports.stringify = function (source, filter, width) {
	          var whitespace, callback, properties, className;
	          if (objectTypes[typeof filter] && filter) {
	            if ((className = getClass.call(filter)) == functionClass) {
	              callback = filter;
	            } else if (className == arrayClass) {
	              // Convert the property names array into a makeshift set.
	              properties = {};
	              for (var index = 0, length = filter.length, value; index < length; value = filter[index++], ((className = getClass.call(value)), className == stringClass || className == numberClass) && (properties[value] = 1));
	            }
	          }
	          if (width) {
	            if ((className = getClass.call(width)) == numberClass) {
	              // Convert the `width` to an integer and create a string containing
	              // `width` number of space characters.
	              if ((width -= width % 1) > 0) {
	                for (whitespace = "", width > 10 && (width = 10); whitespace.length < width; whitespace += " ");
	              }
	            } else if (className == stringClass) {
	              whitespace = width.length <= 10 ? width : width.slice(0, 10);
	            }
	          }
	          // Opera <= 7.54u2 discards the values associated with empty string keys
	          // (`""`) only if they are used directly within an object member list
	          // (e.g., `!("" in { "": 1})`).
	          return serialize("", (value = {}, value[""] = source, value), callback, properties, whitespace, "", []);
	        };
	      }
	
	      // Public: Parses a JSON source string.
	      if (!has("json-parse")) {
	        var fromCharCode = String.fromCharCode;
	
	        // Internal: A map of escaped control characters and their unescaped
	        // equivalents.
	        var Unescapes = {
	          92: "\\",
	          34: '"',
	          47: "/",
	          98: "\b",
	          116: "\t",
	          110: "\n",
	          102: "\f",
	          114: "\r"
	        };
	
	        // Internal: Stores the parser state.
	        var Index, Source;
	
	        // Internal: Resets the parser state and throws a `SyntaxError`.
	        var abort = function () {
	          Index = Source = null;
	          throw SyntaxError();
	        };
	
	        // Internal: Returns the next token, or `"$"` if the parser has reached
	        // the end of the source string. A token may be a string, number, `null`
	        // literal, or Boolean literal.
	        var lex = function () {
	          var source = Source, length = source.length, value, begin, position, isSigned, charCode;
	          while (Index < length) {
	            charCode = source.charCodeAt(Index);
	            switch (charCode) {
	              case 9: case 10: case 13: case 32:
	                // Skip whitespace tokens, including tabs, carriage returns, line
	                // feeds, and space characters.
	                Index++;
	                break;
	              case 123: case 125: case 91: case 93: case 58: case 44:
	                // Parse a punctuator token (`{`, `}`, `[`, `]`, `:`, or `,`) at
	                // the current position.
	                value = charIndexBuggy ? source.charAt(Index) : source[Index];
	                Index++;
	                return value;
	              case 34:
	                // `"` delimits a JSON string; advance to the next character and
	                // begin parsing the string. String tokens are prefixed with the
	                // sentinel `@` character to distinguish them from punctuators and
	                // end-of-string tokens.
	                for (value = "@", Index++; Index < length;) {
	                  charCode = source.charCodeAt(Index);
	                  if (charCode < 32) {
	                    // Unescaped ASCII control characters (those with a code unit
	                    // less than the space character) are not permitted.
	                    abort();
	                  } else if (charCode == 92) {
	                    // A reverse solidus (`\`) marks the beginning of an escaped
	                    // control character (including `"`, `\`, and `/`) or Unicode
	                    // escape sequence.
	                    charCode = source.charCodeAt(++Index);
	                    switch (charCode) {
	                      case 92: case 34: case 47: case 98: case 116: case 110: case 102: case 114:
	                        // Revive escaped control characters.
	                        value += Unescapes[charCode];
	                        Index++;
	                        break;
	                      case 117:
	                        // `\u` marks the beginning of a Unicode escape sequence.
	                        // Advance to the first character and validate the
	                        // four-digit code point.
	                        begin = ++Index;
	                        for (position = Index + 4; Index < position; Index++) {
	                          charCode = source.charCodeAt(Index);
	                          // A valid sequence comprises four hexdigits (case-
	                          // insensitive) that form a single hexadecimal value.
	                          if (!(charCode >= 48 && charCode <= 57 || charCode >= 97 && charCode <= 102 || charCode >= 65 && charCode <= 70)) {
	                            // Invalid Unicode escape sequence.
	                            abort();
	                          }
	                        }
	                        // Revive the escaped character.
	                        value += fromCharCode("0x" + source.slice(begin, Index));
	                        break;
	                      default:
	                        // Invalid escape sequence.
	                        abort();
	                    }
	                  } else {
	                    if (charCode == 34) {
	                      // An unescaped double-quote character marks the end of the
	                      // string.
	                      break;
	                    }
	                    charCode = source.charCodeAt(Index);
	                    begin = Index;
	                    // Optimize for the common case where a string is valid.
	                    while (charCode >= 32 && charCode != 92 && charCode != 34) {
	                      charCode = source.charCodeAt(++Index);
	                    }
	                    // Append the string as-is.
	                    value += source.slice(begin, Index);
	                  }
	                }
	                if (source.charCodeAt(Index) == 34) {
	                  // Advance to the next character and return the revived string.
	                  Index++;
	                  return value;
	                }
	                // Unterminated string.
	                abort();
	              default:
	                // Parse numbers and literals.
	                begin = Index;
	                // Advance past the negative sign, if one is specified.
	                if (charCode == 45) {
	                  isSigned = true;
	                  charCode = source.charCodeAt(++Index);
	                }
	                // Parse an integer or floating-point value.
	                if (charCode >= 48 && charCode <= 57) {
	                  // Leading zeroes are interpreted as octal literals.
	                  if (charCode == 48 && ((charCode = source.charCodeAt(Index + 1)), charCode >= 48 && charCode <= 57)) {
	                    // Illegal octal literal.
	                    abort();
	                  }
	                  isSigned = false;
	                  // Parse the integer component.
	                  for (; Index < length && ((charCode = source.charCodeAt(Index)), charCode >= 48 && charCode <= 57); Index++);
	                  // Floats cannot contain a leading decimal point; however, this
	                  // case is already accounted for by the parser.
	                  if (source.charCodeAt(Index) == 46) {
	                    position = ++Index;
	                    // Parse the decimal component.
	                    for (; position < length && ((charCode = source.charCodeAt(position)), charCode >= 48 && charCode <= 57); position++);
	                    if (position == Index) {
	                      // Illegal trailing decimal.
	                      abort();
	                    }
	                    Index = position;
	                  }
	                  // Parse exponents. The `e` denoting the exponent is
	                  // case-insensitive.
	                  charCode = source.charCodeAt(Index);
	                  if (charCode == 101 || charCode == 69) {
	                    charCode = source.charCodeAt(++Index);
	                    // Skip past the sign following the exponent, if one is
	                    // specified.
	                    if (charCode == 43 || charCode == 45) {
	                      Index++;
	                    }
	                    // Parse the exponential component.
	                    for (position = Index; position < length && ((charCode = source.charCodeAt(position)), charCode >= 48 && charCode <= 57); position++);
	                    if (position == Index) {
	                      // Illegal empty exponent.
	                      abort();
	                    }
	                    Index = position;
	                  }
	                  // Coerce the parsed value to a JavaScript number.
	                  return +source.slice(begin, Index);
	                }
	                // A negative sign may only precede numbers.
	                if (isSigned) {
	                  abort();
	                }
	                // `true`, `false`, and `null` literals.
	                if (source.slice(Index, Index + 4) == "true") {
	                  Index += 4;
	                  return true;
	                } else if (source.slice(Index, Index + 5) == "false") {
	                  Index += 5;
	                  return false;
	                } else if (source.slice(Index, Index + 4) == "null") {
	                  Index += 4;
	                  return null;
	                }
	                // Unrecognized token.
	                abort();
	            }
	          }
	          // Return the sentinel `$` character if the parser has reached the end
	          // of the source string.
	          return "$";
	        };
	
	        // Internal: Parses a JSON `value` token.
	        var get = function (value) {
	          var results, hasMembers;
	          if (value == "$") {
	            // Unexpected end of input.
	            abort();
	          }
	          if (typeof value == "string") {
	            if ((charIndexBuggy ? value.charAt(0) : value[0]) == "@") {
	              // Remove the sentinel `@` character.
	              return value.slice(1);
	            }
	            // Parse object and array literals.
	            if (value == "[") {
	              // Parses a JSON array, returning a new JavaScript array.
	              results = [];
	              for (;; hasMembers || (hasMembers = true)) {
	                value = lex();
	                // A closing square bracket marks the end of the array literal.
	                if (value == "]") {
	                  break;
	                }
	                // If the array literal contains elements, the current token
	                // should be a comma separating the previous element from the
	                // next.
	                if (hasMembers) {
	                  if (value == ",") {
	                    value = lex();
	                    if (value == "]") {
	                      // Unexpected trailing `,` in array literal.
	                      abort();
	                    }
	                  } else {
	                    // A `,` must separate each array element.
	                    abort();
	                  }
	                }
	                // Elisions and leading commas are not permitted.
	                if (value == ",") {
	                  abort();
	                }
	                results.push(get(value));
	              }
	              return results;
	            } else if (value == "{") {
	              // Parses a JSON object, returning a new JavaScript object.
	              results = {};
	              for (;; hasMembers || (hasMembers = true)) {
	                value = lex();
	                // A closing curly brace marks the end of the object literal.
	                if (value == "}") {
	                  break;
	                }
	                // If the object literal contains members, the current token
	                // should be a comma separator.
	                if (hasMembers) {
	                  if (value == ",") {
	                    value = lex();
	                    if (value == "}") {
	                      // Unexpected trailing `,` in object literal.
	                      abort();
	                    }
	                  } else {
	                    // A `,` must separate each object member.
	                    abort();
	                  }
	                }
	                // Leading commas are not permitted, object property names must be
	                // double-quoted strings, and a `:` must separate each property
	                // name and value.
	                if (value == "," || typeof value != "string" || (charIndexBuggy ? value.charAt(0) : value[0]) != "@" || lex() != ":") {
	                  abort();
	                }
	                results[value.slice(1)] = get(lex());
	              }
	              return results;
	            }
	            // Unexpected token encountered.
	            abort();
	          }
	          return value;
	        };
	
	        // Internal: Updates a traversed object member.
	        var update = function (source, property, callback) {
	          var element = walk(source, property, callback);
	          if (element === undef) {
	            delete source[property];
	          } else {
	            source[property] = element;
	          }
	        };
	
	        // Internal: Recursively traverses a parsed JSON object, invoking the
	        // `callback` function for each value. This is an implementation of the
	        // `Walk(holder, name)` operation defined in ES 5.1 section 15.12.2.
	        var walk = function (source, property, callback) {
	          var value = source[property], length;
	          if (typeof value == "object" && value) {
	            // `forEach` can't be used to traverse an array in Opera <= 8.54
	            // because its `Object#hasOwnProperty` implementation returns `false`
	            // for array indices (e.g., `![1, 2, 3].hasOwnProperty("0")`).
	            if (getClass.call(value) == arrayClass) {
	              for (length = value.length; length--;) {
	                update(value, length, callback);
	              }
	            } else {
	              forEach(value, function (property) {
	                update(value, property, callback);
	              });
	            }
	          }
	          return callback.call(source, property, value);
	        };
	
	        // Public: `JSON.parse`. See ES 5.1 section 15.12.2.
	        exports.parse = function (source, callback) {
	          var result, value;
	          Index = 0;
	          Source = "" + source;
	          result = get(lex());
	          // If a JSON string contains multiple tokens, it is invalid.
	          if (lex() != "$") {
	            abort();
	          }
	          // Reset the parser state.
	          Index = Source = null;
	          return callback && getClass.call(callback) == functionClass ? walk((value = {}, value[""] = result, value), "", callback) : result;
	        };
	      }
	    }
	
	    exports["runInContext"] = runInContext;
	    return exports;
	  }
	
	  if (freeExports && !isLoader) {
	    // Export for CommonJS environments.
	    runInContext(root, freeExports);
	  } else {
	    // Export for web browsers and JavaScript engines.
	    var nativeJSON = root.JSON,
	        previousJSON = root["JSON3"],
	        isRestored = false;
	
	    var JSON3 = runInContext(root, (root["JSON3"] = {
	      // Public: Restores the original value of the global `JSON` object and
	      // returns a reference to the `JSON3` object.
	      "noConflict": function () {
	        if (!isRestored) {
	          isRestored = true;
	          root.JSON = nativeJSON;
	          root["JSON3"] = previousJSON;
	          nativeJSON = previousJSON = null;
	        }
	        return JSON3;
	      }
	    }));
	
	    root.JSON = {
	      "parse": JSON3.parse,
	      "stringify": JSON3.stringify
	    };
	  }
	
	  // Export for asynchronous module loaders.
	  if (isLoader) {
	    !(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
	      return JSON3;
	    }.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	  }
	}).call(this);
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(30)(module), (function() { return this; }())))

/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _assign = __webpack_require__(1);
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _NGRObject2 = __webpack_require__(7);
	
	var _NGRObject3 = _interopRequireDefault(_NGRObject2);
	
	var _MapView = __webpack_require__(26);
	
	var _MapView2 = _interopRequireDefault(_MapView);
	
	var _lang = __webpack_require__(4);
	
	var _dom = __webpack_require__(11);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	/**
	 * 控件类,用于构造大多数控件及控件所需的配置元素。
	 * @extends {NGRObject}
	 * @memberOf NGR.control
	 */
	var Control = function (_NGRObject) {
	  _inherits(Control, _NGRObject);
	
	  /**
	   * 构造方法。
	   * @param  {String}     name              控件名字。
	   * @param  {Object}     [options]         控件选项,即构成控件的一些配置元素。
	   * @param  {HTMLElment} [options.element] 放置控件的DOM元素。
	   */
	  function Control(name) {
	    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
	
	    _classCallCheck(this, Control);
	
	    if (!name) {
	      throw new Error('Control: Invalid name');
	    }
	
	    var _this = _possibleConstructorReturn(this, (Control.__proto__ || Object.getPrototypeOf(Control)).call(this));
	
	    _this._options = _assign({
	      position: 'bottomleft'
	    }, options);
	    _this._name = name;
	    _this._element = _this._options.element;
	    _this._container = null;
	    _this._map = null;
	    _this._needAppend = true;
	
	    if (_this._element) {
	      _this._needAppend = false;
	    }
	    if (_this._options.container) {
	      _this.setContainer(options.container);
	    }
	    return _this;
	  }
	
	  /**
	   * Set a container element for the control.
	   * @ignore
	   * @interface
	   * @param {Element|String} container Container.
	   * @return {NGR.control.Control} this.
	   */
	
	
	  _createClass(Control, [{
	    key: 'setContainer',
	    value: function setContainer(container) {
	      this._container = (0, _lang.isString)(container) ? document.getElementById(container) : container;
	
	      return this;
	    }
	
	    /**
	     * Get the container of this control.
	     * @ignore
	     * @interface
	     * @return {Element} Container.
	     */
	
	  }, {
	    key: 'getContainer',
	    value: function getContainer() {
	      return this._container;
	    }
	
	    /**
	     * 获取应用该控件的地图对象。
	     * @return {NGR.view.MapView} MapView地图对象。
	     */
	
	  }, {
	    key: 'getMap',
	    value: function getMap() {
	      return this._map;
	    }
	
	    /**
	     * 把控件加到地图上。
	     * @param {NGR.view.MapView} map 应用控件的地图对象。
	     * @return {NGR.control.Control} this。
	     */
	
	  }, {
	    key: 'addTo',
	    value: function addTo(map) {
	      if (map instanceof _MapView2.default) {
	        map.addDomControl(this);
	      } else {
	        console.warn('addTo: Invalid map');
	      }
	
	      return this;
	    }
	
	    /**
	     * 从地图上删除控件。
	     * @param  {NGR.view.MapView} map 应用控件的地图对象。
	     * @return {NGR.control.Control} this。
	     */
	
	  }, {
	    key: 'removeFrom',
	    value: function removeFrom(map) {
	      if (map === this._map) {
	        map.removeDomControl(this);
	      }
	
	      return this;
	    }
	
	    /**
	     * 隐藏控件。通过将控件元素的display属性值设为'none'来实现。
	     * @return {NGR.control.Control} this。
	     */
	
	  }, {
	    key: 'hide',
	    value: function hide() {
	      this._element.style.display = 'none';
	
	      return this;
	    }
	
	    /**
	     * 设置是否启用控件元素的display属性。
	     * @param  {String} [display='block'] CSS display 属性，默认是'block'。
	     * @return {NGR.control.Control}                  this。
	     */
	
	  }, {
	    key: 'display',
	    value: function display() {
	      var _display = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'block';
	
	      this._element.style.display = _display;
	
	      return this;
	    }
	  }, {
	    key: 'disable',
	    value: function disable() {
	      return this;
	    }
	  }, {
	    key: 'enable',
	    value: function enable() {
	      return this;
	    }
	
	    /**
	     * For inheritance.
	     * @private
	     * @interface
	     * @param  {NGR.view.MapView} mapView MapView.
	     * @return {NGR.control.Control}      this.
	     */
	
	  }, {
	    key: '_onAdd',
	    value: function _onAdd(mapView) {
	      var position = this._options.position;
	
	
	      this.emit('add', this);
	      this._map = mapView;
	
	      if (mapView.controlDom && !this._container) {
	        var corner = mapView.controlCorners[position];
	        var className = void 0,
	            container = void 0;
	
	        if (corner) {
	          className = 'ngr-control';
	          container = corner;
	        } else if (position === 'custom') {
	          className = 'ngr-custom-control';
	          container = mapView.controlDom;
	        } else {
	          throw new Error('Invalid control position');
	        }
	
	        _dom.DOMUtils.addClass(this._element, className);
	        this.setContainer(container);
	      }
	      if (this._needAppend) {
	        if (position.indexOf('bottom') !== -1) {
	          this._container.insertBefore(this._element, this._container.firstChild);
	        } else {
	          this._container.appendChild(this._element);
	        }
	      }
	
	      return this;
	    }
	
	    /**
	     * For inheritance.
	     * @private
	     * @interface
	     * @param  {NGR.view.MapView} mapView MapView.
	     * @return {NGR.control.Control}      this.
	     */
	
	  }, {
	    key: '_onRemove',
	    value: function _onRemove(mapView) {
	      // eslint-disable-line no-unused-vars
	      this.emit('remove', this);
	      this._map = null;
	      if (this._needAppend) {
	        this._container.removeChild(this._element);
	        this._container = null;
	      }
	
	      return this;
	    }
	
	    /**
	     * Set focus on the targetDom of map.
	     * @private
	     * @return {NGR.control.Control} Control.
	     */
	
	  }, {
	    key: '_refocusOnMap',
	    value: function _refocusOnMap() {
	      if (this._map) {
	        this._map.targetDom.focus();
	      }
	
	      return this;
	    }
	  }, {
	    key: 'element',
	    get: function get() {
	      return this._element;
	    }
	  }]);
	
	  return Control;
	}(_NGRObject3.default);
	
	exports.default = Control;

/***/ }),
/* 17 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {'use strict';
	
	var random = __webpack_require__(22);
	
	var onUnload = {}
	  , afterUnload = false
	    // detect google chrome packaged apps because they don't allow the 'unload' event
	  , isChromePackagedApp = global.chrome && global.chrome.app && global.chrome.app.runtime
	  ;
	
	module.exports = {
	  attachEvent: function(event, listener) {
	    if (typeof global.addEventListener !== 'undefined') {
	      global.addEventListener(event, listener, false);
	    } else if (global.document && global.attachEvent) {
	      // IE quirks.
	      // According to: http://stevesouders.com/misc/test-postmessage.php
	      // the message gets delivered only to 'document', not 'window'.
	      global.document.attachEvent('on' + event, listener);
	      // I get 'window' for ie8.
	      global.attachEvent('on' + event, listener);
	    }
	  }
	
	, detachEvent: function(event, listener) {
	    if (typeof global.addEventListener !== 'undefined') {
	      global.removeEventListener(event, listener, false);
	    } else if (global.document && global.detachEvent) {
	      global.document.detachEvent('on' + event, listener);
	      global.detachEvent('on' + event, listener);
	    }
	  }
	
	, unloadAdd: function(listener) {
	    if (isChromePackagedApp) {
	      return null;
	    }
	
	    var ref = random.string(8);
	    onUnload[ref] = listener;
	    if (afterUnload) {
	      setTimeout(this.triggerUnloadCallbacks, 0);
	    }
	    return ref;
	  }
	
	, unloadDel: function(ref) {
	    if (ref in onUnload) {
	      delete onUnload[ref];
	    }
	  }
	
	, triggerUnloadCallbacks: function() {
	    for (var ref in onUnload) {
	      onUnload[ref]();
	      delete onUnload[ref];
	    }
	  }
	};
	
	var unloadTriggered = function() {
	  if (afterUnload) {
	    return;
	  }
	  afterUnload = true;
	  module.exports.triggerUnloadCallbacks();
	};
	
	// 'unload' alone is not reliable in opera within an iframe, but we
	// can't use `beforeunload` as IE fires it on javascript: links.
	if (!isChromePackagedApp) {
	  module.exports.attachEvent('unload', unloadTriggered);
	}
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ }),
/* 18 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	var devServerHost = exports.devServerHost = 'http://localhost';
	var blueVersion = exports.blueVersion = '2.0';
	var supportParticle = exports.supportParticle = false;
	var enableQuadTree = exports.enableQuadTree = false;
	var isDev = exports.isDev = ("development") === 'development';
	var isProd = exports.isProd = ("development") === 'production';
	var isLite = exports.isLite = ("standard") === 'lite';
	var touchEmulator = exports.touchEmulator = false;

/***/ }),
/* 19 */
/***/ (function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	/**
	 * Style utilities.
	 * @ignore
	 * @memberOf NGR.style
	 */
	var StyleUtil = function () {
	  function StyleUtil() {
	    _classCallCheck(this, StyleUtil);
	  }
	
	  _createClass(StyleUtil, null, [{
	    key: 'parseColor',
	
	    /**
	     * Parse a number or a string into a hexadecimal color code.
	     * @param  {Number|String} color Color.
	     * @return {Number}       Hexadecimal color code.
	     */
	    value: function parseColor(color) {
	      // default color is 0xffffff.
	      var hexColor = 0xffffff;
	
	      if (typeof color === 'number') {
	        hexColor = Math.floor(color);
	      } else if (typeof color === 'string') {
	        hexColor = parseInt(color, 16);
	        // hexColor = StyleUtil.parseStringColor(color);
	      } else {
	        console.warn('Unknown Color', color);
	      }
	
	      return hexColor;
	    }
	  }, {
	    key: 'converToSharp',
	    value: function converToSharp(color) {
	      var temp = color;
	      if (typeof color === 'string') {
	        temp = temp.replace('0x', '#');
	      }
	      return temp;
	    }
	
	    /**
	     * Parse a string into a hexadecimal color code.
	     * @param  {String} color Color.
	     * @return {Number}       hexadecimal color code.
	     */
	
	  }, {
	    key: 'parseStringColor',
	    value: function parseStringColor(color) {
	      // default color is 0xffffff.
	      var hexColor = 0xffffff;
	
	      if (typeof color !== 'string') {
	        console.warn('Invalid String');
	        return hexColor;
	      }
	
	      var match = /^\#([A-Fa-f0-9]+)$/.exec(color);
	      if (match) {
	        var hex = match[1];
	        var size = hex.length;
	
	        if (size === 3) {
	          // #ff0
	          var extendedStr = hex.charAt(0) + hex.charAt(0) + hex.charAt(1) + hex.charAt(1) + hex.charAt(2) + hex.charAt(2);
	          hexColor = parseInt(extendedStr, 16);
	        } else if (size === 6) {
	          // #ff0000
	          hexColor = parseInt(color, 16);
	        } else {
	          console.warn('Unknown Color', color);
	        }
	      } else {
	        console.warn('Unknown Color', color);
	      }
	
	      return hexColor;
	    }
	  }]);
	
	  return StyleUtil;
	}();
	
	exports.default = StyleUtil;

/***/ }),
/* 20 */
/***/ (function(module, exports, __webpack_require__) {

	var require;/* WEBPACK VAR INJECTION */(function(process, global) {/*!
	 * @overview es6-promise - a tiny implementation of Promises/A+.
	 * @copyright Copyright (c) 2014 Yehuda Katz, Tom Dale, Stefan Penner and contributors (Conversion to ES6 API by Jake Archibald)
	 * @license   Licensed under MIT license
	 *            See https://raw.githubusercontent.com/stefanpenner/es6-promise/master/LICENSE
	 * @version   4.1.0
	 */
	
	(function (global, factory) {
	     true ? module.exports = factory() :
	    typeof define === 'function' && define.amd ? define(factory) :
	    (global.ES6Promise = factory());
	}(this, (function () { 'use strict';
	
	function objectOrFunction(x) {
	  return typeof x === 'function' || typeof x === 'object' && x !== null;
	}
	
	function isFunction(x) {
	  return typeof x === 'function';
	}
	
	var _isArray = undefined;
	if (!Array.isArray) {
	  _isArray = function (x) {
	    return Object.prototype.toString.call(x) === '[object Array]';
	  };
	} else {
	  _isArray = Array.isArray;
	}
	
	var isArray = _isArray;
	
	var len = 0;
	var vertxNext = undefined;
	var customSchedulerFn = undefined;
	
	var asap = function asap(callback, arg) {
	  queue[len] = callback;
	  queue[len + 1] = arg;
	  len += 2;
	  if (len === 2) {
	    // If len is 2, that means that we need to schedule an async flush.
	    // If additional callbacks are queued before the queue is flushed, they
	    // will be processed by this flush that we are scheduling.
	    if (customSchedulerFn) {
	      customSchedulerFn(flush);
	    } else {
	      scheduleFlush();
	    }
	  }
	};
	
	function setScheduler(scheduleFn) {
	  customSchedulerFn = scheduleFn;
	}
	
	function setAsap(asapFn) {
	  asap = asapFn;
	}
	
	var browserWindow = typeof window !== 'undefined' ? window : undefined;
	var browserGlobal = browserWindow || {};
	var BrowserMutationObserver = browserGlobal.MutationObserver || browserGlobal.WebKitMutationObserver;
	var isNode = typeof self === 'undefined' && typeof process !== 'undefined' && ({}).toString.call(process) === '[object process]';
	
	// test for web worker but not in IE10
	var isWorker = typeof Uint8ClampedArray !== 'undefined' && typeof importScripts !== 'undefined' && typeof MessageChannel !== 'undefined';
	
	// node
	function useNextTick() {
	  // node version 0.10.x displays a deprecation warning when nextTick is used recursively
	  // see https://github.com/cujojs/when/issues/410 for details
	  return function () {
	    return process.nextTick(flush);
	  };
	}
	
	// vertx
	function useVertxTimer() {
	  if (typeof vertxNext !== 'undefined') {
	    return function () {
	      vertxNext(flush);
	    };
	  }
	
	  return useSetTimeout();
	}
	
	function useMutationObserver() {
	  var iterations = 0;
	  var observer = new BrowserMutationObserver(flush);
	  var node = document.createTextNode('');
	  observer.observe(node, { characterData: true });
	
	  return function () {
	    node.data = iterations = ++iterations % 2;
	  };
	}
	
	// web worker
	function useMessageChannel() {
	  var channel = new MessageChannel();
	  channel.port1.onmessage = flush;
	  return function () {
	    return channel.port2.postMessage(0);
	  };
	}
	
	function useSetTimeout() {
	  // Store setTimeout reference so es6-promise will be unaffected by
	  // other code modifying setTimeout (like sinon.useFakeTimers())
	  var globalSetTimeout = setTimeout;
	  return function () {
	    return globalSetTimeout(flush, 1);
	  };
	}
	
	var queue = new Array(1000);
	function flush() {
	  for (var i = 0; i < len; i += 2) {
	    var callback = queue[i];
	    var arg = queue[i + 1];
	
	    callback(arg);
	
	    queue[i] = undefined;
	    queue[i + 1] = undefined;
	  }
	
	  len = 0;
	}
	
	function attemptVertx() {
	  try {
	    var r = require;
	    var vertx = __webpack_require__(289);
	    vertxNext = vertx.runOnLoop || vertx.runOnContext;
	    return useVertxTimer();
	  } catch (e) {
	    return useSetTimeout();
	  }
	}
	
	var scheduleFlush = undefined;
	// Decide what async method to use to triggering processing of queued callbacks:
	if (isNode) {
	  scheduleFlush = useNextTick();
	} else if (BrowserMutationObserver) {
	  scheduleFlush = useMutationObserver();
	} else if (isWorker) {
	  scheduleFlush = useMessageChannel();
	} else if (browserWindow === undefined && "function" === 'function') {
	  scheduleFlush = attemptVertx();
	} else {
	  scheduleFlush = useSetTimeout();
	}
	
	function then(onFulfillment, onRejection) {
	  var _arguments = arguments;
	
	  var parent = this;
	
	  var child = new this.constructor(noop);
	
	  if (child[PROMISE_ID] === undefined) {
	    makePromise(child);
	  }
	
	  var _state = parent._state;
	
	  if (_state) {
	    (function () {
	      var callback = _arguments[_state - 1];
	      asap(function () {
	        return invokeCallback(_state, child, callback, parent._result);
	      });
	    })();
	  } else {
	    subscribe(parent, child, onFulfillment, onRejection);
	  }
	
	  return child;
	}
	
	/**
	  `Promise.resolve` returns a promise that will become resolved with the
	  passed `value`. It is shorthand for the following:
	
	  ```javascript
	  let promise = new Promise(function(resolve, reject){
	    resolve(1);
	  });
	
	  promise.then(function(value){
	    // value === 1
	  });
	  ```
	
	  Instead of writing the above, your code now simply becomes the following:
	
	  ```javascript
	  let promise = Promise.resolve(1);
	
	  promise.then(function(value){
	    // value === 1
	  });
	  ```
	
	  @method resolve
	  @static
	  @param {Any} value value that the returned promise will be resolved with
	  Useful for tooling.
	  @return {Promise} a promise that will become fulfilled with the given
	  `value`
	*/
	function resolve(object) {
	  /*jshint validthis:true */
	  var Constructor = this;
	
	  if (object && typeof object === 'object' && object.constructor === Constructor) {
	    return object;
	  }
	
	  var promise = new Constructor(noop);
	  _resolve(promise, object);
	  return promise;
	}
	
	var PROMISE_ID = Math.random().toString(36).substring(16);
	
	function noop() {}
	
	var PENDING = void 0;
	var FULFILLED = 1;
	var REJECTED = 2;
	
	var GET_THEN_ERROR = new ErrorObject();
	
	function selfFulfillment() {
	  return new TypeError("You cannot resolve a promise with itself");
	}
	
	function cannotReturnOwn() {
	  return new TypeError('A promises callback cannot return that same promise.');
	}
	
	function getThen(promise) {
	  try {
	    return promise.then;
	  } catch (error) {
	    GET_THEN_ERROR.error = error;
	    return GET_THEN_ERROR;
	  }
	}
	
	function tryThen(then, value, fulfillmentHandler, rejectionHandler) {
	  try {
	    then.call(value, fulfillmentHandler, rejectionHandler);
	  } catch (e) {
	    return e;
	  }
	}
	
	function handleForeignThenable(promise, thenable, then) {
	  asap(function (promise) {
	    var sealed = false;
	    var error = tryThen(then, thenable, function (value) {
	      if (sealed) {
	        return;
	      }
	      sealed = true;
	      if (thenable !== value) {
	        _resolve(promise, value);
	      } else {
	        fulfill(promise, value);
	      }
	    }, function (reason) {
	      if (sealed) {
	        return;
	      }
	      sealed = true;
	
	      _reject(promise, reason);
	    }, 'Settle: ' + (promise._label || ' unknown promise'));
	
	    if (!sealed && error) {
	      sealed = true;
	      _reject(promise, error);
	    }
	  }, promise);
	}
	
	function handleOwnThenable(promise, thenable) {
	  if (thenable._state === FULFILLED) {
	    fulfill(promise, thenable._result);
	  } else if (thenable._state === REJECTED) {
	    _reject(promise, thenable._result);
	  } else {
	    subscribe(thenable, undefined, function (value) {
	      return _resolve(promise, value);
	    }, function (reason) {
	      return _reject(promise, reason);
	    });
	  }
	}
	
	function handleMaybeThenable(promise, maybeThenable, then$$) {
	  if (maybeThenable.constructor === promise.constructor && then$$ === then && maybeThenable.constructor.resolve === resolve) {
	    handleOwnThenable(promise, maybeThenable);
	  } else {
	    if (then$$ === GET_THEN_ERROR) {
	      _reject(promise, GET_THEN_ERROR.error);
	      GET_THEN_ERROR.error = null;
	    } else if (then$$ === undefined) {
	      fulfill(promise, maybeThenable);
	    } else if (isFunction(then$$)) {
	      handleForeignThenable(promise, maybeThenable, then$$);
	    } else {
	      fulfill(promise, maybeThenable);
	    }
	  }
	}
	
	function _resolve(promise, value) {
	  if (promise === value) {
	    _reject(promise, selfFulfillment());
	  } else if (objectOrFunction(value)) {
	    handleMaybeThenable(promise, value, getThen(value));
	  } else {
	    fulfill(promise, value);
	  }
	}
	
	function publishRejection(promise) {
	  if (promise._onerror) {
	    promise._onerror(promise._result);
	  }
	
	  publish(promise);
	}
	
	function fulfill(promise, value) {
	  if (promise._state !== PENDING) {
	    return;
	  }
	
	  promise._result = value;
	  promise._state = FULFILLED;
	
	  if (promise._subscribers.length !== 0) {
	    asap(publish, promise);
	  }
	}
	
	function _reject(promise, reason) {
	  if (promise._state !== PENDING) {
	    return;
	  }
	  promise._state = REJECTED;
	  promise._result = reason;
	
	  asap(publishRejection, promise);
	}
	
	function subscribe(parent, child, onFulfillment, onRejection) {
	  var _subscribers = parent._subscribers;
	  var length = _subscribers.length;
	
	  parent._onerror = null;
	
	  _subscribers[length] = child;
	  _subscribers[length + FULFILLED] = onFulfillment;
	  _subscribers[length + REJECTED] = onRejection;
	
	  if (length === 0 && parent._state) {
	    asap(publish, parent);
	  }
	}
	
	function publish(promise) {
	  var subscribers = promise._subscribers;
	  var settled = promise._state;
	
	  if (subscribers.length === 0) {
	    return;
	  }
	
	  var child = undefined,
	      callback = undefined,
	      detail = promise._result;
	
	  for (var i = 0; i < subscribers.length; i += 3) {
	    child = subscribers[i];
	    callback = subscribers[i + settled];
	
	    if (child) {
	      invokeCallback(settled, child, callback, detail);
	    } else {
	      callback(detail);
	    }
	  }
	
	  promise._subscribers.length = 0;
	}
	
	function ErrorObject() {
	  this.error = null;
	}
	
	var TRY_CATCH_ERROR = new ErrorObject();
	
	function tryCatch(callback, detail) {
	  try {
	    return callback(detail);
	  } catch (e) {
	    TRY_CATCH_ERROR.error = e;
	    return TRY_CATCH_ERROR;
	  }
	}
	
	function invokeCallback(settled, promise, callback, detail) {
	  var hasCallback = isFunction(callback),
	      value = undefined,
	      error = undefined,
	      succeeded = undefined,
	      failed = undefined;
	
	  if (hasCallback) {
	    value = tryCatch(callback, detail);
	
	    if (value === TRY_CATCH_ERROR) {
	      failed = true;
	      error = value.error;
	      value.error = null;
	    } else {
	      succeeded = true;
	    }
	
	    if (promise === value) {
	      _reject(promise, cannotReturnOwn());
	      return;
	    }
	  } else {
	    value = detail;
	    succeeded = true;
	  }
	
	  if (promise._state !== PENDING) {
	    // noop
	  } else if (hasCallback && succeeded) {
	      _resolve(promise, value);
	    } else if (failed) {
	      _reject(promise, error);
	    } else if (settled === FULFILLED) {
	      fulfill(promise, value);
	    } else if (settled === REJECTED) {
	      _reject(promise, value);
	    }
	}
	
	function initializePromise(promise, resolver) {
	  try {
	    resolver(function resolvePromise(value) {
	      _resolve(promise, value);
	    }, function rejectPromise(reason) {
	      _reject(promise, reason);
	    });
	  } catch (e) {
	    _reject(promise, e);
	  }
	}
	
	var id = 0;
	function nextId() {
	  return id++;
	}
	
	function makePromise(promise) {
	  promise[PROMISE_ID] = id++;
	  promise._state = undefined;
	  promise._result = undefined;
	  promise._subscribers = [];
	}
	
	function Enumerator(Constructor, input) {
	  this._instanceConstructor = Constructor;
	  this.promise = new Constructor(noop);
	
	  if (!this.promise[PROMISE_ID]) {
	    makePromise(this.promise);
	  }
	
	  if (isArray(input)) {
	    this._input = input;
	    this.length = input.length;
	    this._remaining = input.length;
	
	    this._result = new Array(this.length);
	
	    if (this.length === 0) {
	      fulfill(this.promise, this._result);
	    } else {
	      this.length = this.length || 0;
	      this._enumerate();
	      if (this._remaining === 0) {
	        fulfill(this.promise, this._result);
	      }
	    }
	  } else {
	    _reject(this.promise, validationError());
	  }
	}
	
	function validationError() {
	  return new Error('Array Methods must be provided an Array');
	};
	
	Enumerator.prototype._enumerate = function () {
	  var length = this.length;
	  var _input = this._input;
	
	  for (var i = 0; this._state === PENDING && i < length; i++) {
	    this._eachEntry(_input[i], i);
	  }
	};
	
	Enumerator.prototype._eachEntry = function (entry, i) {
	  var c = this._instanceConstructor;
	  var resolve$$ = c.resolve;
	
	  if (resolve$$ === resolve) {
	    var _then = getThen(entry);
	
	    if (_then === then && entry._state !== PENDING) {
	      this._settledAt(entry._state, i, entry._result);
	    } else if (typeof _then !== 'function') {
	      this._remaining--;
	      this._result[i] = entry;
	    } else if (c === Promise) {
	      var promise = new c(noop);
	      handleMaybeThenable(promise, entry, _then);
	      this._willSettleAt(promise, i);
	    } else {
	      this._willSettleAt(new c(function (resolve$$) {
	        return resolve$$(entry);
	      }), i);
	    }
	  } else {
	    this._willSettleAt(resolve$$(entry), i);
	  }
	};
	
	Enumerator.prototype._settledAt = function (state, i, value) {
	  var promise = this.promise;
	
	  if (promise._state === PENDING) {
	    this._remaining--;
	
	    if (state === REJECTED) {
	      _reject(promise, value);
	    } else {
	      this._result[i] = value;
	    }
	  }
	
	  if (this._remaining === 0) {
	    fulfill(promise, this._result);
	  }
	};
	
	Enumerator.prototype._willSettleAt = function (promise, i) {
	  var enumerator = this;
	
	  subscribe(promise, undefined, function (value) {
	    return enumerator._settledAt(FULFILLED, i, value);
	  }, function (reason) {
	    return enumerator._settledAt(REJECTED, i, reason);
	  });
	};
	
	/**
	  `Promise.all` accepts an array of promises, and returns a new promise which
	  is fulfilled with an array of fulfillment values for the passed promises, or
	  rejected with the reason of the first passed promise to be rejected. It casts all
	  elements of the passed iterable to promises as it runs this algorithm.
	
	  Example:
	
	  ```javascript
	  let promise1 = resolve(1);
	  let promise2 = resolve(2);
	  let promise3 = resolve(3);
	  let promises = [ promise1, promise2, promise3 ];
	
	  Promise.all(promises).then(function(array){
	    // The array here would be [ 1, 2, 3 ];
	  });
	  ```
	
	  If any of the `promises` given to `all` are rejected, the first promise
	  that is rejected will be given as an argument to the returned promises's
	  rejection handler. For example:
	
	  Example:
	
	  ```javascript
	  let promise1 = resolve(1);
	  let promise2 = reject(new Error("2"));
	  let promise3 = reject(new Error("3"));
	  let promises = [ promise1, promise2, promise3 ];
	
	  Promise.all(promises).then(function(array){
	    // Code here never runs because there are rejected promises!
	  }, function(error) {
	    // error.message === "2"
	  });
	  ```
	
	  @method all
	  @static
	  @param {Array} entries array of promises
	  @param {String} label optional string for labeling the promise.
	  Useful for tooling.
	  @return {Promise} promise that is fulfilled when all `promises` have been
	  fulfilled, or rejected if any of them become rejected.
	  @static
	*/
	function all(entries) {
	  return new Enumerator(this, entries).promise;
	}
	
	/**
	  `Promise.race` returns a new promise which is settled in the same way as the
	  first passed promise to settle.
	
	  Example:
	
	  ```javascript
	  let promise1 = new Promise(function(resolve, reject){
	    setTimeout(function(){
	      resolve('promise 1');
	    }, 200);
	  });
	
	  let promise2 = new Promise(function(resolve, reject){
	    setTimeout(function(){
	      resolve('promise 2');
	    }, 100);
	  });
	
	  Promise.race([promise1, promise2]).then(function(result){
	    // result === 'promise 2' because it was resolved before promise1
	    // was resolved.
	  });
	  ```
	
	  `Promise.race` is deterministic in that only the state of the first
	  settled promise matters. For example, even if other promises given to the
	  `promises` array argument are resolved, but the first settled promise has
	  become rejected before the other promises became fulfilled, the returned
	  promise will become rejected:
	
	  ```javascript
	  let promise1 = new Promise(function(resolve, reject){
	    setTimeout(function(){
	      resolve('promise 1');
	    }, 200);
	  });
	
	  let promise2 = new Promise(function(resolve, reject){
	    setTimeout(function(){
	      reject(new Error('promise 2'));
	    }, 100);
	  });
	
	  Promise.race([promise1, promise2]).then(function(result){
	    // Code here never runs
	  }, function(reason){
	    // reason.message === 'promise 2' because promise 2 became rejected before
	    // promise 1 became fulfilled
	  });
	  ```
	
	  An example real-world use case is implementing timeouts:
	
	  ```javascript
	  Promise.race([ajax('foo.json'), timeout(5000)])
	  ```
	
	  @method race
	  @static
	  @param {Array} promises array of promises to observe
	  Useful for tooling.
	  @return {Promise} a promise which settles in the same way as the first passed
	  promise to settle.
	*/
	function race(entries) {
	  /*jshint validthis:true */
	  var Constructor = this;
	
	  if (!isArray(entries)) {
	    return new Constructor(function (_, reject) {
	      return reject(new TypeError('You must pass an array to race.'));
	    });
	  } else {
	    return new Constructor(function (resolve, reject) {
	      var length = entries.length;
	      for (var i = 0; i < length; i++) {
	        Constructor.resolve(entries[i]).then(resolve, reject);
	      }
	    });
	  }
	}
	
	/**
	  `Promise.reject` returns a promise rejected with the passed `reason`.
	  It is shorthand for the following:
	
	  ```javascript
	  let promise = new Promise(function(resolve, reject){
	    reject(new Error('WHOOPS'));
	  });
	
	  promise.then(function(value){
	    // Code here doesn't run because the promise is rejected!
	  }, function(reason){
	    // reason.message === 'WHOOPS'
	  });
	  ```
	
	  Instead of writing the above, your code now simply becomes the following:
	
	  ```javascript
	  let promise = Promise.reject(new Error('WHOOPS'));
	
	  promise.then(function(value){
	    // Code here doesn't run because the promise is rejected!
	  }, function(reason){
	    // reason.message === 'WHOOPS'
	  });
	  ```
	
	  @method reject
	  @static
	  @param {Any} reason value that the returned promise will be rejected with.
	  Useful for tooling.
	  @return {Promise} a promise rejected with the given `reason`.
	*/
	function reject(reason) {
	  /*jshint validthis:true */
	  var Constructor = this;
	  var promise = new Constructor(noop);
	  _reject(promise, reason);
	  return promise;
	}
	
	function needsResolver() {
	  throw new TypeError('You must pass a resolver function as the first argument to the promise constructor');
	}
	
	function needsNew() {
	  throw new TypeError("Failed to construct 'Promise': Please use the 'new' operator, this object constructor cannot be called as a function.");
	}
	
	/**
	  Promise objects represent the eventual result of an asynchronous operation. The
	  primary way of interacting with a promise is through its `then` method, which
	  registers callbacks to receive either a promise's eventual value or the reason
	  why the promise cannot be fulfilled.
	
	  Terminology
	  -----------
	
	  - `promise` is an object or function with a `then` method whose behavior conforms to this specification.
	  - `thenable` is an object or function that defines a `then` method.
	  - `value` is any legal JavaScript value (including undefined, a thenable, or a promise).
	  - `exception` is a value that is thrown using the throw statement.
	  - `reason` is a value that indicates why a promise was rejected.
	  - `settled` the final resting state of a promise, fulfilled or rejected.
	
	  A promise can be in one of three states: pending, fulfilled, or rejected.
	
	  Promises that are fulfilled have a fulfillment value and are in the fulfilled
	  state.  Promises that are rejected have a rejection reason and are in the
	  rejected state.  A fulfillment value is never a thenable.
	
	  Promises can also be said to *resolve* a value.  If this value is also a
	  promise, then the original promise's settled state will match the value's
	  settled state.  So a promise that *resolves* a promise that rejects will
	  itself reject, and a promise that *resolves* a promise that fulfills will
	  itself fulfill.
	
	
	  Basic Usage:
	  ------------
	
	  ```js
	  let promise = new Promise(function(resolve, reject) {
	    // on success
	    resolve(value);
	
	    // on failure
	    reject(reason);
	  });
	
	  promise.then(function(value) {
	    // on fulfillment
	  }, function(reason) {
	    // on rejection
	  });
	  ```
	
	  Advanced Usage:
	  ---------------
	
	  Promises shine when abstracting away asynchronous interactions such as
	  `XMLHttpRequest`s.
	
	  ```js
	  function getJSON(url) {
	    return new Promise(function(resolve, reject){
	      let xhr = new XMLHttpRequest();
	
	      xhr.open('GET', url);
	      xhr.onreadystatechange = handler;
	      xhr.responseType = 'json';
	      xhr.setRequestHeader('Accept', 'application/json');
	      xhr.send();
	
	      function handler() {
	        if (this.readyState === this.DONE) {
	          if (this.status === 200) {
	            resolve(this.response);
	          } else {
	            reject(new Error('getJSON: `' + url + '` failed with status: [' + this.status + ']'));
	          }
	        }
	      };
	    });
	  }
	
	  getJSON('/posts.json').then(function(json) {
	    // on fulfillment
	  }, function(reason) {
	    // on rejection
	  });
	  ```
	
	  Unlike callbacks, promises are great composable primitives.
	
	  ```js
	  Promise.all([
	    getJSON('/posts'),
	    getJSON('/comments')
	  ]).then(function(values){
	    values[0] // => postsJSON
	    values[1] // => commentsJSON
	
	    return values;
	  });
	  ```
	
	  @class Promise
	  @param {function} resolver
	  Useful for tooling.
	  @constructor
	*/
	function Promise(resolver) {
	  this[PROMISE_ID] = nextId();
	  this._result = this._state = undefined;
	  this._subscribers = [];
	
	  if (noop !== resolver) {
	    typeof resolver !== 'function' && needsResolver();
	    this instanceof Promise ? initializePromise(this, resolver) : needsNew();
	  }
	}
	
	Promise.all = all;
	Promise.race = race;
	Promise.resolve = resolve;
	Promise.reject = reject;
	Promise._setScheduler = setScheduler;
	Promise._setAsap = setAsap;
	Promise._asap = asap;
	
	Promise.prototype = {
	  constructor: Promise,
	
	  /**
	    The primary way of interacting with a promise is through its `then` method,
	    which registers callbacks to receive either a promise's eventual value or the
	    reason why the promise cannot be fulfilled.
	  
	    ```js
	    findUser().then(function(user){
	      // user is available
	    }, function(reason){
	      // user is unavailable, and you are given the reason why
	    });
	    ```
	  
	    Chaining
	    --------
	  
	    The return value of `then` is itself a promise.  This second, 'downstream'
	    promise is resolved with the return value of the first promise's fulfillment
	    or rejection handler, or rejected if the handler throws an exception.
	  
	    ```js
	    findUser().then(function (user) {
	      return user.name;
	    }, function (reason) {
	      return 'default name';
	    }).then(function (userName) {
	      // If `findUser` fulfilled, `userName` will be the user's name, otherwise it
	      // will be `'default name'`
	    });
	  
	    findUser().then(function (user) {
	      throw new Error('Found user, but still unhappy');
	    }, function (reason) {
	      throw new Error('`findUser` rejected and we're unhappy');
	    }).then(function (value) {
	      // never reached
	    }, function (reason) {
	      // if `findUser` fulfilled, `reason` will be 'Found user, but still unhappy'.
	      // If `findUser` rejected, `reason` will be '`findUser` rejected and we're unhappy'.
	    });
	    ```
	    If the downstream promise does not specify a rejection handler, rejection reasons will be propagated further downstream.
	  
	    ```js
	    findUser().then(function (user) {
	      throw new PedagogicalException('Upstream error');
	    }).then(function (value) {
	      // never reached
	    }).then(function (value) {
	      // never reached
	    }, function (reason) {
	      // The `PedgagocialException` is propagated all the way down to here
	    });
	    ```
	  
	    Assimilation
	    ------------
	  
	    Sometimes the value you want to propagate to a downstream promise can only be
	    retrieved asynchronously. This can be achieved by returning a promise in the
	    fulfillment or rejection handler. The downstream promise will then be pending
	    until the returned promise is settled. This is called *assimilation*.
	  
	    ```js
	    findUser().then(function (user) {
	      return findCommentsByAuthor(user);
	    }).then(function (comments) {
	      // The user's comments are now available
	    });
	    ```
	  
	    If the assimliated promise rejects, then the downstream promise will also reject.
	  
	    ```js
	    findUser().then(function (user) {
	      return findCommentsByAuthor(user);
	    }).then(function (comments) {
	      // If `findCommentsByAuthor` fulfills, we'll have the value here
	    }, function (reason) {
	      // If `findCommentsByAuthor` rejects, we'll have the reason here
	    });
	    ```
	  
	    Simple Example
	    --------------
	  
	    Synchronous Example
	  
	    ```javascript
	    let result;
	  
	    try {
	      result = findResult();
	      // success
	    } catch(reason) {
	      // failure
	    }
	    ```
	  
	    Errback Example
	  
	    ```js
	    findResult(function(result, err){
	      if (err) {
	        // failure
	      } else {
	        // success
	      }
	    });
	    ```
	  
	    Promise Example;
	  
	    ```javascript
	    findResult().then(function(result){
	      // success
	    }, function(reason){
	      // failure
	    });
	    ```
	  
	    Advanced Example
	    --------------
	  
	    Synchronous Example
	  
	    ```javascript
	    let author, books;
	  
	    try {
	      author = findAuthor();
	      books  = findBooksByAuthor(author);
	      // success
	    } catch(reason) {
	      // failure
	    }
	    ```
	  
	    Errback Example
	  
	    ```js
	  
	    function foundBooks(books) {
	  
	    }
	  
	    function failure(reason) {
	  
	    }
	  
	    findAuthor(function(author, err){
	      if (err) {
	        failure(err);
	        // failure
	      } else {
	        try {
	          findBoooksByAuthor(author, function(books, err) {
	            if (err) {
	              failure(err);
	            } else {
	              try {
	                foundBooks(books);
	              } catch(reason) {
	                failure(reason);
	              }
	            }
	          });
	        } catch(error) {
	          failure(err);
	        }
	        // success
	      }
	    });
	    ```
	  
	    Promise Example;
	  
	    ```javascript
	    findAuthor().
	      then(findBooksByAuthor).
	      then(function(books){
	        // found books
	    }).catch(function(reason){
	      // something went wrong
	    });
	    ```
	  
	    @method then
	    @param {Function} onFulfilled
	    @param {Function} onRejected
	    Useful for tooling.
	    @return {Promise}
	  */
	  then: then,
	
	  /**
	    `catch` is simply sugar for `then(undefined, onRejection)` which makes it the same
	    as the catch block of a try/catch statement.
	  
	    ```js
	    function findAuthor(){
	      throw new Error('couldn't find that author');
	    }
	  
	    // synchronous
	    try {
	      findAuthor();
	    } catch(reason) {
	      // something went wrong
	    }
	  
	    // async with promises
	    findAuthor().catch(function(reason){
	      // something went wrong
	    });
	    ```
	  
	    @method catch
	    @param {Function} onRejection
	    Useful for tooling.
	    @return {Promise}
	  */
	  'catch': function _catch(onRejection) {
	    return this.then(null, onRejection);
	  }
	};
	
	function polyfill() {
	    var local = undefined;
	
	    if (typeof global !== 'undefined') {
	        local = global;
	    } else if (typeof self !== 'undefined') {
	        local = self;
	    } else {
	        try {
	            local = Function('return this')();
	        } catch (e) {
	            throw new Error('polyfill failed because global object is unavailable in this environment');
	        }
	    }
	
	    var P = local.Promise;
	
	    if (P) {
	        var promiseToString = null;
	        try {
	            promiseToString = Object.prototype.toString.call(P.resolve());
	        } catch (e) {
	            // silently ignored
	        }
	
	        if (promiseToString === '[object Promise]' && !P.cast) {
	            return;
	        }
	    }
	
	    local.Promise = Promise;
	}
	
	// Strange compat..
	Promise.polyfill = polyfill;
	Promise.Promise = Promise;
	
	return Promise;
	
	})));
	//# sourceMappingURL=es6-promise.map
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(50), (function() { return this; }())))

/***/ }),
/* 21 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var inherits = __webpack_require__(3)
	  , urlUtils = __webpack_require__(10)
	  , SenderReceiver = __webpack_require__(99)
	  ;
	
	var debug = function() {};
	if (true) {
	  debug = __webpack_require__(6)('sockjs-client:ajax-based');
	}
	
	function createAjaxSender(AjaxObject) {
	  return function(url, payload, callback) {
	    debug('create ajax sender', url, payload);
	    var opt = {};
	    if (typeof payload === 'string') {
	      opt.headers = {'Content-type': 'text/plain'};
	    }
	    var ajaxUrl = urlUtils.addPath(url, '/xhr_send');
	    var xo = new AjaxObject('POST', ajaxUrl, payload, opt);
	    xo.once('finish', function(status) {
	      debug('finish', status);
	      xo = null;
	
	      if (status !== 200 && status !== 204) {
	        return callback(new Error('http status ' + status));
	      }
	      callback();
	    });
	    return function() {
	      debug('abort');
	      xo.close();
	      xo = null;
	
	      var err = new Error('Aborted');
	      err.code = 1000;
	      callback(err);
	    };
	  };
	}
	
	function AjaxBasedTransport(transUrl, urlSuffix, Receiver, AjaxObject) {
	  SenderReceiver.call(this, transUrl, urlSuffix, createAjaxSender(AjaxObject), Receiver, AjaxObject);
	}
	
	inherits(AjaxBasedTransport, SenderReceiver);
	
	module.exports = AjaxBasedTransport;


/***/ }),
/* 22 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	/* global crypto:true */
	var crypto = __webpack_require__(274);
	
	// This string has length 32, a power of 2, so the modulus doesn't introduce a
	// bias.
	var _randomStringChars = 'abcdefghijklmnopqrstuvwxyz012345';
	module.exports = {
	  string: function(length) {
	    var max = _randomStringChars.length;
	    var bytes = crypto.randomBytes(length);
	    var ret = [];
	    for (var i = 0; i < length; i++) {
	      ret.push(_randomStringChars.substr(bytes[i] % max, 1));
	    }
	    return ret.join('');
	  }
	
	, number: function(max) {
	    return Math.floor(Math.random() * max);
	  }
	
	, numberString: function(max) {
	    var t = ('' + (max - 1)).length;
	    var p = new Array(t + 1).join('0');
	    return (p + this.number(max)).slice(-t);
	  }
	};


/***/ }),
/* 23 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _lang = __webpack_require__(4);
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	/**
	 * FeatureCollection类，是Feature元素的集合类，也能代表一个图层的信息，用于管理其中的Feature元素。
	 * @memberOf NGR.data
	 */
	var FeatureCollection = function () {
	  /**
	   * 构造方法。
	   * @param  {String} name FeatureCollection对象的名称。
	   */
	  function FeatureCollection(name) {
	    _classCallCheck(this, FeatureCollection);
	
	    this.name = name;
	    this.features = [];
	    this._featureMap = {};
	  }
	
	  _createClass(FeatureCollection, [{
	    key: '_setFeatureParent',
	    value: function _setFeatureParent(layer) {
	      this.forEach(function (feature) {
	        feature.parent = layer;
	      });
	
	      return this;
	    }
	  }, {
	    key: 'forEach',
	    value: function forEach(callback) {
	      var thisArg = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this;
	
	      if ((0, _lang.isArray)(this.features)) {
	        this.features.forEach(callback, thisArg);
	      }
	
	      return this;
	    }
	
	    /**
	     * 在FeatureCollection对象中加入Feature元素。
	     * @param {NGR.data.Feature} feature    需要被添加的Feature对象。
	     * @return {NGR.data.FeatureCollection} this。
	     */
	
	  }, {
	    key: 'addFeature',
	    value: function addFeature(feature) {
	      var id = feature.id;
	
	
	      if ((0, _lang.isBlank)(feature.id)) {
	        console.warn('Invalid feature');
	
	        return this;
	      }
	      if (this._featureMap[id]) {
	        console.warn('Feature is existed');
	
	        return this;
	      }
	
	      var len = this.features.push(feature);
	
	      feature.parent = this.parent;
	      this._featureMap[feature.id] = len - 1;
	
	      return this;
	    }
	
	    /**
	     * Update a feature in this feature collection.
	     * @ignore
	     * @param  {NGR.data.Feature} feature   Feature.
	     * @return {NGR.data.FeatureCollection} this.
	     */
	
	  }, {
	    key: 'updateFeature',
	    value: function updateFeature(feature) {
	      var id = feature.id;
	      var index = this._featureMap[id];
	
	      if (index > -1) {
	        this.features[index] = feature;
	        feature.parent = this.parent;
	      }
	
	      return this;
	    }
	  }, {
	    key: '_removeFeature',
	    value: function _removeFeature(id, index) {
	      if (index > -1) {
	        this.features[index].parent = null;
	        this.features.splice(index, 1);
	        delete this._featureMap[id];
	        for (var key in this._featureMap) {
	          if (this._featureMap[key] > index) {
	            this._featureMan[key] -= 1;
	          }
	        }
	      }
	
	      return this;
	    }
	
	    /**
	     * 删除FeatureCollection中的Feature元素。
	     * @param  {NGR.data.Feature}   feature 需要被删除的Feature对象或Feature对象的的id。
	     * @return {NGR.data.FeatureCollection} this。
	     */
	
	  }, {
	    key: 'removeFeature',
	    value: function removeFeature(feature) {
	      this.removeFeatureById(feature.id);
	
	      return this;
	    }
	  }, {
	    key: 'removeFeatureById',
	    value: function removeFeatureById(id) {
	      var index = this._featureMap[id];
	
	      this._removeFeature(id, index);
	
	      return this;
	    }
	
	    /**
	     * 检查FeatureColletion是否包含特定Feature对象。
	     * @param  {NGR.data.Feature}  feature 符合条件的Feature对象。
	     * @return {Boolean}                   检查结果，包含则返回true。
	     */
	
	  }, {
	    key: 'has',
	    value: function has(feature) {
	      return !!feature && (feature.id in this._featureMap || this._features.indexOf(feature) !== -1);
	    }
	
	    /**
	     * 通过Feature元素的id获取这个Feature对象。
	     * @param  {Number} id                  符合条件的Feature对象的id。
	     * @return {NGR.data.Feature} Feature对象。
	     */
	
	  }, {
	    key: 'getFeatureById',
	    value: function getFeatureById(id) {
	      var i = this._featureMap[id];
	
	      if (i > -1) {
	        return this.features[i];
	      }
	
	      return null;
	    }
	
	    /**
	     * 获取FeatureCollection对象中Feature对象的数量。
	     * @return {Number} Feature对象的数量。
	     */
	
	  }, {
	    key: 'getFeatureCount',
	    value: function getFeatureCount() {
	      return this._features.length;
	    }
	
	    /**
	     * 复制一个FeatureCollection对象，对该对象的修改不会影响被复制的对象。
	     * @return {NGR.data.FeatureCollection} 复制的FeatureCollection对象。
	     */
	
	  }, {
	    key: 'copy',
	    value: function copy() {
	      var ret = new FeatureCollection(this.name);
	      var features = this.features;
	
	      ret.features = features.map(function (feature) {
	        return feature.copy();
	      });
	
	      return ret;
	    }
	
	    // [Symbol.iterator]() {
	    //   let index = 0;
	    //   const features = this._features;
	    //   return {
	    //     next: () => ({ value: features[++index], done: index in features }),
	    //   };
	    // }
	
	  }, {
	    key: 'name',
	    get: function get() {
	      return this._name;
	    }
	
	    /**
	     * FeatureCollection对象的名称。
	     * @type {String}
	     * @param  {String} name 名称。
	     */
	    ,
	    set: function set(name) {
	      this._name = name;
	    }
	  }, {
	    key: 'features',
	    get: function get() {
	      return this._features;
	    }
	
	    /**
	     * Features setter. Set the features array of this feature collection,
	     * and build a map from feature ids to indexes in features array.
	     * @ignore
	     * @param  {Array} features Features array
	     */
	    ,
	    set: function set(features) {
	      this._setFeatureParent(null);
	      this._features = [];
	      if ((0, _lang.isArray)(features)) {
	        this._featureMap = {};
	        for (var i in features) {
	          var feature = features[i];
	
	          if ((0, _lang.isBlank)(feature.id)) {
	            console.warn('Invalid feature');
	            continue;
	          }
	          if (this._featureMap[feature.id]) {
	            console.warn('Feature is existed');
	            continue;
	          }
	
	          features.parent = this.parent;
	          this._featureMap[features.id] = this._features.push(feature) - 1;
	        }
	      }
	    }
	  }, {
	    key: 'parent',
	    set: function set(layer) {
	      this._setFeatureParent(layer);
	      this._parent = layer;
	    },
	    get: function get() {
	      return this._parent;
	    }
	  }]);
	
	  return FeatureCollection;
	}();
	
	exports.default = FeatureCollection;

/***/ }),
/* 24 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _NGRObject2 = __webpack_require__(7);
	
	var _NGRObject3 = _interopRequireDefault(_NGRObject2);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	/**
	 * 渲染场景节点。Feature对象用于保存渲染对象的空间数据，style用于描述对应的Feature对象的形态。
	 * 而渲染场景节点则是将Feature和style所表示的渲染对象绘制到地图上的实例。
	 * @extends {NGRObject}
	 */
	var SceneNode = function (_NGRObject) {
	  _inherits(SceneNode, _NGRObject);
	
	  /**
	   * 构造函数。
	   * @param  {Number} sceneId 场景节点id。
	   */
	  function SceneNode(sceneId) {
	    _classCallCheck(this, SceneNode);
	
	    var _this = _possibleConstructorReturn(this, (SceneNode.__proto__ || Object.getPrototypeOf(SceneNode)).call(this));
	
	    _this._scenes = {};
	    _this.id = sceneId;
	    _this._sceneManager = null;
	    _this.visible = true;
	    return _this;
	  }
	
	  /**
	   * This function will be called when being added to a sceneManager.
	   * @ignore
	   * @param  {SceneManager} sceneManager SceneManager.
	   * @return {undefined}              undefined.
	   */
	
	
	  _createClass(SceneNode, [{
	    key: 'onAdd',
	    value: function onAdd(sceneManager) {
	      this._sceneManager = sceneManager;
	      for (var i in this._scenes) {
	        this._sceneManager.addScene(this._scenes[i]);
	      }
	    }
	
	    /**
	     * This function will be called when being removed from a sceneManager.
	     * @ignore
	     * @param  {SceneManager} sceneManager SceneManager.
	     * @return {undefined}              undefined.
	     */
	
	  }, {
	    key: 'onRemove',
	    value: function onRemove(sceneManager) {
	      // eslint-disable-line no-unused-vars
	      for (var i in this._scenes) {
	        this._sceneManager.removeScene(this._scenes[i]);
	      }
	      this._sceneManager = null;
	    }
	
	    /**
	     * 添加子场景节点。
	     * @param {SceneNode} scene 场景节点。
	     * @return {SceneNode} This。
	     */
	
	  }, {
	    key: 'add',
	    value: function add(scene) {
	      if (scene.id && !this.has(scene)) {
	        this._scenes[scene.id] = scene;
	
	        if (this._sceneManager) {
	          this._sceneManager.addScene(scene);
	        }
	      }
	      return this;
	    }
	
	    /**
	     * 删除一个子场景节点。
	     * @param {SceneNode} scene 场景节点。
	     * @return {SceneNode} This。
	     */
	
	  }, {
	    key: 'remove',
	    value: function remove(scene) {
	      if (this.has(scene)) {
	        delete this._scenes[scene.id];
	        if (this._sceneManager) {
	          this._sceneManager.removeScene(scene);
	        }
	      }
	      return this;
	    }
	
	    /**
	     * 获取一个场景的外包盒
	     * @ignore
	     * @todo Calculate AABB.
	     * @return {AABB} 外包盒提供一个场景xyz三个轴向下物体的最大最小坐标值
	     */
	
	  }, {
	    key: 'getAABB',
	    value: function getAABB() {}
	
	    /**
	     * Do collision detection.
	     * @ignore
	     * @todo Do collision detection.
	     * @param  {Collision} collision Collision.
	     * @return {undefined} undefined.
	     */
	
	  }, {
	    key: 'makeCollision',
	    value: function makeCollision(collision) {} // eslint-disable-line no-unused-vars
	
	
	    /**
	     * Visible getter.
	     * @ignore
	     * @return {Boolean} Visible.
	     */
	
	  }, {
	    key: 'get',
	
	
	    /**
	     * 通过场景节点id获取当前场景节点下的子节点。
	     * @param  {Number} sceneId 场景节点id。
	     * @return {Scene}         子场景节点。
	     */
	    value: function get(sceneId) {
	      var temp = null;
	      if (this.has(sceneId)) {
	        temp = this._scenes[sceneId];
	      }
	      return temp;
	    }
	
	    /**
	     * 判断当前场景下是否有某个特定子节点场景。
	     * @param  {Scene}  scene 某个特定子节点。
	     * @return {Boolean}       有返回true，否则返回false。
	     */
	
	  }, {
	    key: 'has',
	    value: function has(scene) {
	      return !!scene && (scene in this._scenes || scene.id in this._scenes);
	    }
	
	    /**
	     * 使每个被添加入场景的场景节点，在渲染循环开始后都调用render方法。
	     * @return {undefined} undefined。
	     */
	
	  }, {
	    key: 'render',
	    value: function render() {
	      if (!this.visible) {
	        return;
	      }
	      for (var i in this._scenes) {
	        this._scenes[i].render();
	      }
	    }
	  }, {
	    key: 'visible',
	    get: function get() {
	      return this._visible;
	    }
	
	    /**
	     * Visible getter.
	     * @ignore
	     * @param {Boolean} visible Visible.
	     */
	    ,
	    set: function set(visible) {
	      this._visible = visible;
	    }
	
	    /**
	     * OriginStyle setter.
	     * @ignore
	     * @param  {Style} style Origin style.
	     */
	
	  }, {
	    key: 'originStyle',
	    set: function set(style) {
	      this._originStyle = style;
	    }
	
	    /**
	     * OriginStyle getter.
	     * @ignore
	     * @return {Style} Origin style.
	     */
	    ,
	    get: function get() {
	      return this._originStyle;
	    }
	  }]);
	
	  return SceneNode;
	}(_NGRObject3.default);
	
	exports.default = SceneNode;

/***/ }),
/* 25 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.CAType = exports.CollisionAnimation = undefined;
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _AnimatorFactory = __webpack_require__(9);
	
	var _AnimatorFactory2 = _interopRequireDefault(_AnimatorFactory);
	
	var _lang = __webpack_require__(4);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var CAType = null;
	
	/**
	 * 碰撞检测动画类，用于设置碰撞检测时的动画效果。
	 */
	
	var CollisionAnimation = function () {
	  function CollisionAnimation() {
	    _classCallCheck(this, CollisionAnimation);
	  }
	
	  _createClass(CollisionAnimation, [{
	    key: 'hasAnimation',
	    value: function hasAnimation(scene) {
	      // eslint-disable-line no-unused-vars
	      return false;
	    }
	
	    /**
	     * 进行一次碰撞检测。
	     * @param  {Scene}   scene     发生碰撞的两个渲染场景。
	     * @param  {Boolean} collision 是否碰撞。
	     * @return {undefined}
	     */
	
	  }, {
	    key: 'makeCollision',
	    value: function makeCollision(scene, collision) {// eslint-disable-line no-unused-vars
	    }
	  }, {
	    key: 'reset',
	    value: function reset(manager) {// eslint-disable-line no-unused-vars
	    }
	  }]);
	
	  return CollisionAnimation;
	}();
	
	/**
	 * 默认碰撞检测动画，即不使用动画效果。
	 * @extends {CollisionAnimation}
	 */
	
	
	var DefaultAnimation = function (_CollisionAnimation) {
	  _inherits(DefaultAnimation, _CollisionAnimation);
	
	  function DefaultAnimation() {
	    _classCallCheck(this, DefaultAnimation);
	
	    return _possibleConstructorReturn(this, (DefaultAnimation.__proto__ || Object.getPrototypeOf(DefaultAnimation)).apply(this, arguments));
	  }
	
	  return DefaultAnimation;
	}(CollisionAnimation);
	
	/**
	 * 透明度碰撞检测动画。
	 * @ignore
	 * @extends {CollisionAnimation}
	 */
	
	
	var OpacityAnimation = function (_CollisionAnimation2) {
	  _inherits(OpacityAnimation, _CollisionAnimation2);
	
	  function OpacityAnimation() {
	    _classCallCheck(this, OpacityAnimation);
	
	    return _possibleConstructorReturn(this, (OpacityAnimation.__proto__ || Object.getPrototypeOf(OpacityAnimation)).apply(this, arguments));
	  }
	
	  _createClass(OpacityAnimation, [{
	    key: 'hasAnimation',
	    value: function hasAnimation(scene) {
	      var has = false;
	      if (scene.children.length > 0) {
	        for (var _iterator = scene.children, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
	          var _ref;
	
	          if (_isArray) {
	            if (_i >= _iterator.length) break;
	            _ref = _iterator[_i++];
	          } else {
	            _i = _iterator.next();
	            if (_i.done) break;
	            _ref = _i.value;
	          }
	
	          var c = _ref;
	
	          has = this.hasAnimation(c);
	          break;
	        }
	      }
	
	      return this._hasOpacity(scene) || has;
	    }
	  }, {
	    key: 'makeParams',
	    value: function makeParams(scene, params, collision) {
	      if (scene.children.length > 0) {
	        for (var _iterator2 = scene.children, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator]();;) {
	          var _ref2;
	
	          if (_isArray2) {
	            if (_i2 >= _iterator2.length) break;
	            _ref2 = _iterator2[_i2++];
	          } else {
	            _i2 = _iterator2.next();
	            if (_i2.done) break;
	            _ref2 = _i2.value;
	          }
	
	          var c = _ref2;
	
	          this.makeParams(c, params, collision);
	        }
	      }
	      if (this._hasOpacity(scene)) {
	        scene.material.opacity = params.num;
	      }
	    }
	  }, {
	    key: 'complete',
	    value: function complete(scene, collision) {
	      this._visibleScene(scene, !collision);
	    }
	  }, {
	    key: 'makeCollision',
	    value: function makeCollision(scene, collision) {
	      var _this3 = this;
	
	      var curOpacity = this._getOpacity(scene);
	      var destOpacity = void 0;
	
	      if (collision) {
	        if (!scene.visible) {
	          curOpacity = 0;
	        }
	        destOpacity = 0;
	      } else if ((0, _lang.isNumber)(scene.destOpacity)) {
	        destOpacity = scene.destOpacity;
	      } else if (scene.children[0] && (0, _lang.isNumber)(scene.children[0].destOpacity)) {
	        destOpacity = scene.children[0].destOpacity;
	      } else {
	        destOpacity = 1;
	      }
	
	      if (!scene.visible && curOpacity === destOpacity) {
	        this.makeParams(scene, { num: 0 }, collision);
	        curOpacity = 0;
	      }
	
	      if (curOpacity === destOpacity) {
	        return null;
	      }
	
	      return _AnimatorFactory2.default.getInstance().ofNumber(curOpacity, destOpacity, 300).on('update', function (animator, target) {
	        _this3.makeParams(scene, target, collision);
	      }).on('start', function () {
	        _this3._visibleScene(scene, true);
	      }).on('complete', function () {
	        _this3.makeParams(scene, { num: destOpacity }, collision);
	        _this3.complete(scene, collision);
	      }).on('stop', function () {
	        // this.makeParams(scene, { num: destOpacity }, collision);
	        _this3.complete(scene, collision);
	      }).start();
	    }
	  }, {
	    key: 'reset',
	    value: function reset(manager) {
	      manager.animation(CAType.Default);
	    }
	  }, {
	    key: '_getOpacity',
	    value: function _getOpacity(scene) {
	      if (scene.children.length > 0) {
	        for (var _iterator3 = scene.children, _isArray3 = Array.isArray(_iterator3), _i3 = 0, _iterator3 = _isArray3 ? _iterator3 : _iterator3[Symbol.iterator]();;) {
	          var _ref3;
	
	          if (_isArray3) {
	            if (_i3 >= _iterator3.length) break;
	            _ref3 = _iterator3[_i3++];
	          } else {
	            _i3 = _iterator3.next();
	            if (_i3.done) break;
	            _ref3 = _i3.value;
	          }
	
	          var c = _ref3;
	
	          if (this._hasOpacity(c)) {
	            return c.material.opacity;
	          }
	        }
	      }
	
	      return scene.material ? scene.material.opacity : 0;
	    }
	  }, {
	    key: '_visibleScene',
	    value: function _visibleScene(scene, visible) {
	      if (scene.children.length > 0) {
	        for (var _iterator4 = scene.children, _isArray4 = Array.isArray(_iterator4), _i4 = 0, _iterator4 = _isArray4 ? _iterator4 : _iterator4[Symbol.iterator]();;) {
	          var _ref4;
	
	          if (_isArray4) {
	            if (_i4 >= _iterator4.length) break;
	            _ref4 = _iterator4[_i4++];
	          } else {
	            _i4 = _iterator4.next();
	            if (_i4.done) break;
	            _ref4 = _i4.value;
	          }
	
	          var c = _ref4;
	
	          this._visibleScene(c, visible);
	        }
	      }
	      scene.visible = visible;
	    }
	  }, {
	    key: '_hasOpacity',
	    value: function _hasOpacity(scene) {
	      return scene && scene.material && (0, _lang.isNumber)(scene.material.opacity);
	    }
	  }]);
	
	  return OpacityAnimation;
	}(CollisionAnimation);
	
	/**
	 * 碰撞动画类型。
	 * @type {Object}
	 * @property {DefaultAnimation} Default 默认碰撞检测效果，目前默认效果为不使用动画。
	 * @property {OpacityAnimation} Opacity 透明度碰撞检测动画，即碰撞对象会渐变消失。
	 * @memberOf NGR.scene
	 */
	
	
	exports.CAType = CAType = {
	  Default: new DefaultAnimation(),
	  Opacity: new OpacityAnimation()
	};
	
	exports.CollisionAnimation = CollisionAnimation;
	exports.CAType = CAType;

/***/ }),
/* 26 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();
	
	var _assign = __webpack_require__(1);
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _CoordinateSystem = __webpack_require__(86);
	
	var _CoordinateSystem2 = _interopRequireDefault(_CoordinateSystem);
	
	var _NGRObject2 = __webpack_require__(7);
	
	var _NGRObject3 = _interopRequireDefault(_NGRObject2);
	
	var _FeatureLayer = __webpack_require__(36);
	
	var _FeatureLayer2 = _interopRequireDefault(_FeatureLayer);
	
	var _LayerGroup = __webpack_require__(43);
	
	var _LayerGroup2 = _interopRequireDefault(_LayerGroup);
	
	var _SceneManager = __webpack_require__(202);
	
	var _SceneManager2 = _interopRequireDefault(_SceneManager);
	
	var _CollisionSceneManager = __webpack_require__(207);
	
	var _CollisionSceneManager2 = _interopRequireDefault(_CollisionSceneManager);
	
	var _AnimatorFactory = __webpack_require__(9);
	
	var _AnimatorFactory2 = _interopRequireDefault(_AnimatorFactory);
	
	var _StyleGenerator = __webpack_require__(46);
	
	var _StyleGenerator2 = _interopRequireDefault(_StyleGenerator);
	
	var _Control = __webpack_require__(16);
	
	var _Control2 = _interopRequireDefault(_Control);
	
	var _CollisionAnimation = __webpack_require__(25);
	
	var _DataUtil = __webpack_require__(63);
	
	var _DataUtil2 = _interopRequireDefault(_DataUtil);
	
	var _RenderLoop = __webpack_require__(87);
	
	var _config = __webpack_require__(18);
	
	var _lang = __webpack_require__(4);
	
	var _core = __webpack_require__(62);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var MapViewLifeCycle = {
	  Uninitialized: 0,
	  Initialized: 1,
	  Start: 2,
	  Loop: 3,
	  Stop: 4,
	  Destroy: 5
	};
	
	/**
	 * 地图类，是地图渲染引擎的视图类，用于创建地图。
	 * @emits NGR.view.MapView#changePlanarGraph
	 * @extends {NGRObject}
	 * @memberOf NGR.view
	 */
	
	var MapView = function (_NGRObject) {
	  _inherits(MapView, _NGRObject);
	
	  /**
	   * 创建一个地图类。
	   * @param {String}         name                   地图类的名字，如果有多个地图类，请保证他们的名字不一样。
	   * @param {Object}         options                地图类参数，即构成地图的一些元素。
	   * @param {StyleGenerator} options.styleGenerator 样式生成器，用于配置地图上各种元素颜色、大小等样式。
	   */
	  function MapView(name) {
	    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
	
	    _classCallCheck(this, MapView);
	
	    var _this = _possibleConstructorReturn(this, (MapView.__proto__ || Object.getPrototypeOf(MapView)).call(this));
	
	    _this._name = name;
	    _this._layers = {};
	    _this._layersIndex = [];
	    _this._planarGraphs = [];
	    _this._domControl = {};
	    _this._floorHeight = 30;
	    _this._options = _assign({
	      styleGenerator: new _StyleGenerator2.default()
	    }, options);
	    _this.styleGenerator = _this._options.styleGenerator;
	    _this._collisionSceneManager = new _CollisionSceneManager2.default();
	    _this._sceneManager = new _SceneManager2.default(_this);
	    _this.renderLoop = new _RenderLoop.AnimationFrameRenderLoop();
	    _this._frame = 0;
	    _this._frameF = {};
	    if (_this._options.geomMap) {
	      _this._goemMap = _this._options.geomMap;
	    }
	
	    _this._beginFrame = _this._beginFrame.bind(_this);
	    _this.on('beginDraw', _this._beginFrame);
	    return _this;
	  }
	
	  _createClass(MapView, [{
	    key: '_beginFrame',
	    value: function _beginFrame(mapView, frame) {
	      var funcs = this._frameF[frame];
	
	      if (funcs && funcs.length) {
	        try {
	          for (var _iterator = funcs, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
	            var _ref;
	
	            if (_isArray) {
	              if (_i >= _iterator.length) break;
	              _ref = _iterator[_i++];
	            } else {
	              _i = _iterator.next();
	              if (_i.done) break;
	              _ref = _i.value;
	            }
	
	            var func = _ref;
	
	            func();
	          }
	        } catch (e) {
	          delete this._frameF[frame];
	          throw e;
	        }
	        delete this._frameF[frame];
	      }
	    }
	
	    /**
	     * 改变生命周期。
	     * @ignore
	     * @param {MapViewLifeCycle} lifeCycle 生命周期类型。
	     * @return {undefined}
	     */
	
	  }, {
	    key: 'changeMapViewLifeCycle',
	    value: function changeMapViewLifeCycle(lifeCycle) {
	      if (this._lifeCycle !== lifeCycle) {
	        this.emit('lifeCycleChange', this, this._lifeCycle, lifeCycle);
	        this._lifeCycle = lifeCycle;
	      }
	    }
	
	    /**
	     * 为地图对象MapView添加DOM控件，用于和HTML页面的交互。
	     * @param {NGR.control.Control} control DOM控件。
	     * @return {Boolean}                    是否添加成功，成功则返回true，否则返回false。
	     */
	
	  }, {
	    key: 'addDomControl',
	    value: function addDomControl(control) {
	      if (!(control instanceof _Control2.default) || control._map || control._name in this._domControl) {
	        console.warn('adding control failed');
	        return false;
	      }
	
	      control._onAdd(this);
	      this._domControl[control._name] = control;
	
	      return true;
	    }
	
	    /**
	     * 删除地图对象MapView的DOM控件。
	     * @param  {NGR.control.Control|String} control 控件对象或控件名。
	     * @return {Boolean}                            是否删除成功，成功返回true，否则返回false。
	     */
	
	  }, {
	    key: 'removeDomControl',
	    value: function removeDomControl(control) {
	      var rmControl = null;
	
	      if (control instanceof _Control2.default && control._name in this._domControl && control._map === this) {
	        rmControl = control;
	      } else {
	        rmControl = this.getDomControl(control);
	      }
	
	      if (!rmControl) {
	        console.warn('removing control failed');
	        return false;
	      }
	
	      rmControl._onRemove(this);
	      delete this._domControl[rmControl._name];
	
	      return true;
	    }
	
	    /**
	     * 获取地图对象MapView的DOM控件。
	     * @param  {String} name         控件名。
	     * @return {NGR.control.Control} 控件。
	     */
	
	  }, {
	    key: 'getDomControl',
	    value: function getDomControl(name) {
	      return this._domControl[name];
	    }
	
	    /**
	     * 在地图对象MapView上添加一个地图覆盖物。
	     * @param {NGR.overlay.Overlay} overlay 覆盖物对象。
	     * @param {Layer}               layer   添加覆盖物的图层。
	     * @return {undefined}
	     */
	
	  }, {
	    key: 'addOverlay',
	    value: function addOverlay(overlay, layer) {
	      var tempLayer = layer;
	
	      if (!layer) {
	        tempLayer = this.getLayer(this.currentPlanarGraphIds[0]);
	        if (!tempLayer) {
	          for (var name in this._layers) {
	            tempLayer = this._layers[name];
	            break;
	          }
	        }
	      }
	      this.emit('addOverlay', this, tempLayer, overlay);
	    }
	
	    /**
	     * 把一个覆盖物重新添加到一个图层上。
	     * @param  {NGR.overlay.Overlay} overlay 覆盖物对象。
	     * @param  {Layer}               layer   添加覆盖物的图层。
	     * @return {undefined}
	     */
	
	  }, {
	    key: 'reAttachOverlay',
	    value: function reAttachOverlay(overlay, layer) {
	      this.emit('reAttachOverlay', this, layer, overlay);
	    }
	
	    /**
	     * 删除一个地图覆盖物。
	     * @param {NGR.overlay.Overlay} overlay 覆盖物对象。
	     * @param {Layer}               layer   删除覆盖物的图层。
	     * @return {undefined}
	     */
	
	  }, {
	    key: 'removeOverlay',
	    value: function removeOverlay(overlay) {
	      if (!overlay.layer) {
	        return;
	      }
	      this.emit('removeOverlay', this, overlay.layer, overlay);
	    }
	
	    /**
	     * 添加一个图层到地图上。
	     * @param {Layer} layer 图层。
	     * @return {SceneNode}  渲染场景节点。
	     */
	
	  }, {
	    key: 'addLayer',
	    value: function addLayer(layer) {
	      if (layer.parent) {
	        console.warn('addLayer: Existed parent');
	        return null;
	      }
	      if (this.hasLayer(layer.name)) {
	        console.warn('addLayer: Existed layer');
	        return null;
	      }
	
	      var sceneNode = this._sceneGenerator.generator(layer, this);
	      var indexOf = this._layersIndex.indexOf(layer.name);
	
	      if (sceneNode) {
	        this._sceneManager.add(sceneNode);
	      }
	      layer.parent = this;
	      this._layers[layer.name] = layer;
	      if (indexOf !== -1) {
	        this._layersIndex.splice(indexOf, 1);
	      }
	      this._layersIndex.push(layer.name);
	      this.emit('addLayer', this, layer);
	      return sceneNode;
	    }
	
	    /**
	     * 根据图层的名字获取对应图层。
	     * @param {Layer} name 图层名字。
	     * @return {Layer}     图层。
	     */
	
	  }, {
	    key: 'getLayer',
	    value: function getLayer(name) {
	      return this._layers[name];
	    }
	  }, {
	    key: 'hasLayer',
	    value: function hasLayer(name) {
	      return !!this._layers[name];
	    }
	
	    /**
	     * 根据name获取图层的集合，结果不会包含{@link LayerGroup}。
	     * @param {String} name 图层的名字。
	     * @return {Layer[]}    图层的集合。
	     */
	
	  }, {
	    key: 'getLayers',
	    value: function getLayers(name) {
	      var layers = [];
	
	      for (var ln in this._layers) {
	        var layer = this._layers[ln];
	        if (layer instanceof _LayerGroup2.default) {
	          layer.foreach(function (layerName, tempLayer) {
	            if (layerName === name) {
	              layers.push(tempLayer);
	            }
	          });
	        } else if (layer.name === name) {
	          layers.push(layer);
	        }
	      }
	
	      return layers;
	    }
	
	    /**
	     * 删除图层。
	     * @param {Layer} layer       图层。
	     * @return {NGR.view.MapView} this。
	     */
	
	  }, {
	    key: 'removeLayer',
	    value: function removeLayer(layer) {
	      var sceneNode = this._sceneGenerator.find(layer);
	      var indexOf = this._layersIndex.indexOf(layer.name);
	
	      if (sceneNode) {
	        this._sceneManager.remove(sceneNode);
	      }
	      layer.parent = null;
	      delete this._layers[layer.name];
	      if (indexOf !== -1) {
	        this._layersIndex.splice(indexOf, 1);
	      }
	      this.emit('removeLayer', this, layer);
	
	      return this;
	    }
	
	    /**
	     * 重新设置一个地图的宽度和高度。
	     * @param {Number} width  地图的宽度。
	     * @param {Number} height 地图的高度。
	     * @return {undefined}
	     */
	
	  }, {
	    key: 'reSize',
	    value: function reSize(width, height) {
	      this.engine.reSize(this, width, height);
	      this.activeCamera.reSize(width, height);
	      this.emit('reSize', this, width, height);
	    }
	
	    /**
	     * 在地图对象MapView中添加一个平面图。
	     * @param {NGR.data.PlanarGrahp} planarGraph                        平面图。
	     * @param {Boolean}              [options]                          可选项。支持设置平面图的其它属性。
	     * @param {Boolean}              [options.added=false]              是否添加，true为添加，false为不添加。
	     * @param {Boolean}              [options.visible=true]             是否显示，true为显示，false为不显示。
	     * @param {Boolean}              [options.fireEvent=true]           是否触发changePlanarGraph事件，true为触发，false为不触发。
	     * @param {Boolean}              [options.autoAreaTextHeight=false] 是否需要自动适配AreaText层高度。
	     * @return {undefined}
	     */
	
	  }, {
	    key: 'drawPlanarGraph',
	    value: function drawPlanarGraph(planarGraph) {
	      var _this2 = this;
	
	      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
	      var _options$added = options.added,
	          added = _options$added === undefined ? false : _options$added,
	          _options$visible = options.visible,
	          visible = _options$visible === undefined ? true : _options$visible,
	          _options$fireEvent = options.fireEvent,
	          fireEvent = _options$fireEvent === undefined ? true : _options$fireEvent,
	          _options$autoAreaText = options.autoAreaTextHeight,
	          autoAreaTextHeight = _options$autoAreaText === undefined ? false : _options$autoAreaText;
	
	      var group = new _LayerGroup2.default(planarGraph.planarGraphId);
	      var features = planarGraph.features;
	
	      if (!added) {
	        this.clear();
	      }
	      this._planarGraphs.push(planarGraph.planarGraphId);
	      if (!this._coordinateSystem || !added) {
	        var _options = this._options,
	            initSkewAngle = _options.initSkewAngle,
	            initRotationAngle = _options.initRotationAngle;
	
	
	        for (var name in features) {
	          if (name === 'Frame') {
	            var envelope = features[name].features[0].geometry.getEnvelopeInternal();
	            var rect = [envelope.minx, envelope.miny, envelope.maxx, envelope.maxy];
	
	            var _CoordinateSystem$get = _CoordinateSystem2.default.getExtentCenter(rect),
	                _CoordinateSystem$get2 = _slicedToArray(_CoordinateSystem$get, 2),
	                offsetX = _CoordinateSystem$get2[0],
	                offsetY = _CoordinateSystem$get2[1];
	
	            this._camera.initRect(rect);
	            this._coordinateSystem = new _CoordinateSystem2.default();
	            this._coordinateSystem.setOffset([-offsetX, -offsetY]);
	          }
	        }
	        if (this.activeControl) {
	          if ((0, _lang.isNumber)(initSkewAngle)) {
	            this.activeControl.skewTo(initSkewAngle);
	          }
	          if ((0, _lang.isNumber)(initRotationAngle)) {
	            this.activeControl.rotateTo(0, 0, initRotationAngle);
	          }
	        }
	      }
	
	      for (var _name in features) {
	        var featureCollection = features[_name];
	        var layer = new _FeatureLayer2.default(_name, this._styleGenerator);
	
	        layer.coordinateSystem = this._coordinateSystem;
	        layer.features = featureCollection;
	        group.addLayer(layer);
	        if (_config.enableQuadTree && _name === 'Frame' || _name === 'Area') {
	          layer.clickable = true;
	        }
	        if (_name === 'Area') {
	          var areaTextLayer = new _FeatureLayer2.default('AreaText', this._styleGenerator);
	
	          if (!layer.renderer) {
	            areaTextLayer.coordinateSystem = this._coordinateSystem;
	          }
	          // fzz you motherf__ker
	          if (autoAreaTextHeight) {
	            areaTextLayer.features = _DataUtil2.default.kickYourAss(featureCollection, layer, this._options.interiorPoint);
	          } else {
	            areaTextLayer.features = _DataUtil2.default.featureCollectionPolygon2Point(featureCollection, this._options.interiorPoint);
	          }
	          group.addLayer(areaTextLayer);
	        }
	      }
	
	      this.addLayer(group);
	
	      var areaText = group.getLayer('AreaText');
	
	      if (areaText) {
	        this._sceneManager.setVisible(areaText, null, null, false);
	      }
	      // const index = this._planarGraphs.length - 1;
	      this._sceneManager.setVisible(group, null, null, false);
	
	      this.next(1, function () {
	        _this2._sceneManager.setPosition(group, null, null, 0, 0, _this2._planarGraphs.indexOf(planarGraph.planarGraphId) * _this2._floorHeight);
	        if (visible) {
	          _this2._sceneManager.setVisible(group, null, null, true);
	          _this2.collisionSceneManager.updateCollision();
	        } else {
	          // this._sceneManager.setVisible(group, null, null, false);
	        }
	        if (areaText) {
	          _this2._sceneManager.setVisible(areaText, null, null, true);
	        }
	      });
	
	      if (fireEvent) {
	        this._changePlanarGraph(this._curPlanarGraphs ? this._curPlanarGraphs.concat([planarGraph.planarGraphId]) : [planarGraph.planarGraphId], this._curPlanarGraphs ? this._curPlanarGraphs.concat() : [].concat(this.planarGraph && this.planarGraph.planarGraphId || []));
	      }
	
	      if (!added) {
	        this._planarGraph = planarGraph;
	      } else {
	        this._curPlanarGraphs = this._curPlanarGraphs || [];
	        if (visible) {
	          this._curPlanarGraphs.push(planarGraph.planarGraphId);
	        }
	      }
	    }
	
	    /**
	     * 根据{@link NGR.data.PlanarGraph}集合在地图上同时绘制多张平面图，用于显示多楼层。
	     * @param {NGR.data.PlanarGraph[]} planarGraphs=[]                    平面图集合。
	     * @param {Boolean}                [options]                          可选项。支持设置平面图的其它属性。
	     * @param {Boolean}                [options.added=false]              是否添加，true为添加，false为不添加。
	     * @param {Boolean}                [options.visible=true]             是否显示，true为显示，false为不显示。
	     * @param {Boolean}                [options.autoAreaTextHeight=false] 是否需要自动适配AreaText层高度。
	     * @return {undefined}
	     */
	
	  }, {
	    key: 'drawMultiPlanarGraph',
	    value: function drawMultiPlanarGraph() {
	      var planarGraphs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
	      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
	      var _options$added2 = options.added,
	          added = _options$added2 === undefined ? false : _options$added2,
	          _options$visible2 = options.visible,
	          visible = _options$visible2 === undefined ? true : _options$visible2,
	          _options$autoAreaText2 = options.autoAreaTextHeight,
	          autoAreaTextHeight = _options$autoAreaText2 === undefined ? false : _options$autoAreaText2;
	
	      if (!added) {
	        this.clear();
	      }
	
	      var temp = this._curPlanarGraphs ? this._curPlanarGraphs.concat() : [];
	
	      this._curPlanarGraphs = [];
	      for (var _iterator2 = planarGraphs, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator]();;) {
	        var _ref2;
	
	        if (_isArray2) {
	          if (_i2 >= _iterator2.length) break;
	          _ref2 = _iterator2[_i2++];
	        } else {
	          _i2 = _iterator2.next();
	          if (_i2.done) break;
	          _ref2 = _i2.value;
	        }
	
	        var planarGraph = _ref2;
	
	        this.drawPlanarGraph(planarGraph, {
	          added: true,
	          visible: visible,
	          autoAreaTextHeight: autoAreaTextHeight
	        });
	      }
	      this._changePlanarGraph(this._curPlanarGraphs.concat(), temp);
	    }
	  }, {
	    key: 'changePlanarGraphIndex',
	    value: function changePlanarGraphIndex(planarGraphIds) {
	      if ((0, _lang.isArray)(planarGraphIds)) {
	        var WholePGIds = this._planarGraphs.concat();
	        var temp = [];
	
	        for (var _iterator3 = planarGraphIds, _isArray3 = Array.isArray(_iterator3), _i3 = 0, _iterator3 = _isArray3 ? _iterator3 : _iterator3[Symbol.iterator]();;) {
	          var _ref3;
	
	          if (_isArray3) {
	            if (_i3 >= _iterator3.length) break;
	            _ref3 = _iterator3[_i3++];
	          } else {
	            _i3 = _iterator3.next();
	            if (_i3.done) break;
	            _ref3 = _i3.value;
	          }
	
	          var planarGraphId = _ref3;
	
	          var group = this._layers[planarGraphId];
	
	          if (group) {
	            var indexOf = WholePGIds.indexOf(planarGraphId);
	
	            WholePGIds.splice(indexOf, 1);
	            // this.next(1, () => {
	            this.sceneManager.setPosition(group, null, null, 0, 0, temp.length * this._floorHeight);
	            // });
	            temp[temp.length] = planarGraphId;
	          }
	        }
	        temp.push.apply(temp, _toConsumableArray(WholePGIds));
	        this._planarGraphs = temp;
	
	        return true;
	      }
	
	      return false;
	    }
	
	    /**
	     * 主要用于多楼层显示。根据{@link NGR.data.PlanarGraph}的id的集合显示一张或几张平面图，隐藏其它平面图。参数中的id
	     * 必须是MapView中已经存在的planarGraph平面图的id。
	     * @param  {Number[]} planarGraphIds   PlanarGraphId数组。
	     * @param  {Boolean}  [collision=true] 是否更新碰撞检测。
	     * @param  {Object}   [aOptions]       动画选项。
	     * @return {Number}                    最终显示的平面图数量。
	     */
	
	  }, {
	    key: 'showPlanarGraphs',
	    value: function showPlanarGraphs(planarGraphIds) {
	      var _this3 = this;
	
	      var collision = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
	      var aOptions = arguments[2];
	
	      if (!(0, _lang.isArray)(planarGraphIds)) {
	        throw new Error('showPlanarGraph: Invalid parameters');
	      }
	
	      var WholePGIds = this._planarGraphs;
	      var sceneMng = this.sceneManager;
	      var CDMng = this.collisionSceneManager;
	      var visiblePGIds = [];
	      var count = 0;
	
	      var _loop2 = function _loop2() {
	        if (_isArray4) {
	          if (_i4 >= _iterator4.length) return 'break';
	          _ref4 = _iterator4[_i4++];
	        } else {
	          _i4 = _iterator4.next();
	          if (_i4.done) return 'break';
	          _ref4 = _i4.value;
	        }
	
	        var PGId = _ref4;
	
	        var group = _this3._layers[PGId];
	        var enable = void 0;
	
	        if (planarGraphIds.indexOf(PGId) !== -1) {
	          sceneMng.setPosition(group, null, null, 0, 0, count++ * _this3._floorHeight, aOptions);
	          sceneMng.setVisible(group, null, null, true);
	          visiblePGIds.push(PGId);
	          enable = true;
	        } else {
	          sceneMng.setVisible(group, null, null, false);
	          enable = false;
	        }
	
	        group.foreach(function (name, layer) {
	          CDMng.setFeatureLayerEnable(layer, enable);
	        });
	      };
	
	      for (var _iterator4 = WholePGIds, _isArray4 = Array.isArray(_iterator4), _i4 = 0, _iterator4 = _isArray4 ? _iterator4 : _iterator4[Symbol.iterator]();;) {
	        var _ref4;
	
	        var _ret = _loop2();
	
	        if (_ret === 'break') break;
	      }
	      this._changePlanarGraph(visiblePGIds, this._curPlanarGraphs);
	      this._curPlanarGraphs = visiblePGIds;
	      if (collision) {
	        this.next(1, function () {
	          _this3.collisionSceneManager.animation(_CollisionAnimation.CAType.Opacity).updateCollision(true);
	        });
	      }
	
	      return count;
	    }
	  }, {
	    key: '_changePlanarGraph',
	    value: function _changePlanarGraph(current, last) {
	      /**
	       * 切换当前显示楼层的事件。
	       * @event NGR.view.MapView#changePlanarGraph
	       * @param {NGR.view.MapView} mapView 地图。
	       * @param {Number[]} currentPGs      当前需要显示的楼层列表。
	       * @param {Number[]} lastPGs         切换前的楼层列表。
	       */
	      this.emit('changePlanarGraph', this, current.concat(), last.concat());
	    }
	
	    /**
	     * 根据{@link NGR.data.PlanarGraph}删除平面图。
	     * @param {NGR.data.PlanarGraph} planarGraph 要被删除的平面图。
	     * @return {undefined}
	     */
	
	  }, {
	    key: 'removePlanarGraph',
	    value: function removePlanarGraph(planarGraph) {
	      var planarGraphId = planarGraph.planarGraphId;
	      var indexOf = this._planarGraphs.indexOf(planarGraphId);
	      var layerGroup = this.getLayer(planarGraphId);
	
	      if (indexOf !== -1 && layerGroup && layerGroup instanceof _LayerGroup2.default) {
	        this.removeLayer(layerGroup);
	        this._planarGraphs.splice(indexOf, 1);
	      }
	    }
	
	    /**
	     * 通过id搜索对应的{@link NGR.data.Feature}对象。
	     * @deprecated
	     * @param {String} id         Feature对象的ID。
	     * @return {NGR.data.Feature} Feature对象。
	     */
	
	  }, {
	    key: 'searchFeatureById',
	    value: function searchFeatureById(id) {
	      console.warn('searchFeatureById is deprecated, please use searchFeature');
	
	      var layers = this._layers;
	
	      for (var layerName in layers) {
	        var layer = layers[layerName];
	
	        if (layer instanceof _LayerGroup2.default) {
	          for (var name in layer._layers) {
	            var feature = layer._layers[name].searchById(id);
	
	            if (feature) {
	              return feature;
	            }
	          }
	        } else {
	          var _feature = layer.searchById(id);
	
	          if (_feature) {
	            return _feature;
	          }
	        }
	      }
	
	      return null;
	    }
	  }, {
	    key: 'searchFeature',
	    value: function searchFeature(layerId, featureId) {
	      for (var layerName in this._layers) {
	        var layer = this._layers[layerName];
	        var feature = null;
	
	        if (layer instanceof _LayerGroup2.default) {
	          feature = layer.searchFeature(layerId, featureId);
	        } else if (layer.id === layerId) {
	          feature = layer.searchById(featureId);
	        }
	
	        if (feature) {
	          return feature;
	        }
	      }
	
	      return null;
	    }
	
	    /**
	     * 开始渲染地图。
	     * @return {undefined}
	     */
	
	  }, {
	    key: 'start',
	    value: function start() {
	      var _this4 = this;
	
	      if (this._lifeCycle === MapViewLifeCycle.Start || this._lifeCycle === MapViewLifeCycle.Loop) {
	        return;
	      }
	      this.changeMapViewLifeCycle(MapViewLifeCycle.Start);
	      this._renderLoop.loop(function (timeStamp) {
	        _this4._loop(timeStamp);
	      });
	      // this._loop(null);
	    }
	
	    /**
	     * 停止渲染地图。
	     * @return {undefined}
	     */
	
	  }, {
	    key: 'stop',
	    value: function stop() {
	      this.changeMapViewLifeCycle(MapViewLifeCycle.Stop);
	      this._renderLoop.stop();
	    }
	
	    /**
	     * 销毁地图。
	     * @return {undefined}
	     */
	
	  }, {
	    key: 'destroy',
	    value: function destroy() {
	      var _this5 = this;
	
	      this.clear();
	      var _destroy = function _destroy() {
	        _this5.stop();
	        _this5.changeMapViewLifeCycle(MapViewLifeCycle.Destroy);
	
	        _this5._collisionSceneManager.clear();
	        _this5._sceneManager.destroy();
	        _this5._control.dispose();
	        _this5._camera.destroy();
	        _this5._gestureManager.destroy();
	
	        _this5._camera = null;
	        _this5._control = null;
	        _this5._planarGraph = null;
	        _this5._control = null;
	        _this5.sceneGenerator = null;
	        _this5._coordinateSystem = null;
	        _this5._engine = null;
	        _this5._gestureManager = null;
	        _this5._layers = null;
	        _this5._layersIndex = null;
	        _this5._options = null;
	        _this5._styleGenerator = null;
	        _this5._collisionSceneManager = null;
	        _this5._sceneManager = null;
	        _this5.off('beginDraw', _this5._beginFrame);
	        // this._frame = 0;
	        // this._frameF = null;
	      };
	      _destroy();
	      // if (this._renderLoop.hasRunning()) {
	      //   this.next(1, _destroy);
	      // } else {
	      //   _destroy();
	      // }
	    }
	  }, {
	    key: 'next',
	    value: function next(frame, fn) {
	      var tempFrame = frame + this._frame;
	
	      if (tempFrame < this._frame) {
	        return;
	      }
	      if (!this._frameF[tempFrame]) {
	        this._frameF[tempFrame] = [];
	      }
	      this._frameF[tempFrame].push(fn);
	    }
	
	    /**
	     * 清除当前地图上的所有图层。
	     * @return {NGR.view.MapView} this。
	     */
	
	  }, {
	    key: 'clear',
	    value: function clear() {
	      for (var name in this._layers) {
	        this.removeLayer(this._layers[name]);
	      }
	      this._sceneManager.clearOctree();
	      this._collisionSceneManager.clear();
	
	      this._coordinateSystem = null;
	
	      this._planarGraphs = [];
	      this._curPlanarGraphs = null;
	
	      return this;
	    }
	
	    /**
	     * 通过一个坐标搜索包含该坐标的所有{@link NGR.data.Feature}对象。不推荐使用，建议使用searchObjectsByClient。
	     * @param {Number}             x                                          X轴坐标。
	     * @param {Number}             y                                          Y轴坐标。
	     * @param {NGR.core.CoordType} [coordinateType=NGR.core.CoordType.Screen] 坐标类型。
	     * @return {NGR.datra.Feature[]}                                          Feature对象列表。
	     */
	
	  }, {
	    key: 'searchObjectsByPoint',
	    value: function searchObjectsByPoint(x, y) {
	      var _this6 = this;
	
	      var coordinateType = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : _core.CoordType.Screen;
	
	      var result = [];
	      var coordinate = [x, y];
	
	      switch (coordinateType) {
	        case _core.CoordType.Screen:
	          {
	            if (this.activeCamera && this._coordinateSystem) {
	              var cameraCoordinate = this.activeCamera.toCameraCoordinate(x, y, 0);
	
	              coordinate = this._coordinateSystem.offset(cameraCoordinate.x, cameraCoordinate.y);
	            }
	            break;
	          }
	        case _core.CoordType.World:
	          {
	            if (this._coordinateSystem) {
	              coordinate = this._coordinateSystem.offset(x, y);
	            }
	            break;
	          }
	        case _core.CoordType.WGS84:
	          break;
	        default:
	          break;
	      }
	
	      var _loop3 = function _loop3() {
	        if (_isArray5) {
	          if (_i5 >= _iterator5.length) return 'break';
	          _ref5 = _iterator5[_i5++];
	        } else {
	          _i5 = _iterator5.next();
	          if (_i5.done) return 'break';
	          _ref5 = _i5.value;
	        }
	
	        var name = _ref5;
	
	        var layer = _this6._layers[name];
	        var features = void 0;
	
	        if (layer instanceof _LayerGroup2.default) {
	          layer.foreach(function (name, l) {
	            features = _this6._searchByPoint.apply(_this6, [l].concat(_toConsumableArray(coordinate)));
	            result.push.apply(result, _toConsumableArray(features));
	          });
	        } else {
	          features = _this6._searchByPoint.apply(_this6, [layer].concat(_toConsumableArray(coordinate)));
	          result.push.apply(result, _toConsumableArray(features));
	        }
	      };
	
	      for (var _iterator5 = this._layersIndex, _isArray5 = Array.isArray(_iterator5), _i5 = 0, _iterator5 = _isArray5 ? _iterator5 : _iterator5[Symbol.iterator]();;) {
	        var _ref5;
	
	        var _ret2 = _loop3();
	
	        if (_ret2 === 'break') break;
	      }
	
	      return result;
	    }
	  }, {
	    key: '_searchByPoint',
	    value: function _searchByPoint(layer, x, y) {
	      if (!layer.clickable) {
	        return [];
	      }
	
	      return layer.searchByPoint(x, y);
	    }
	
	    /**
	     * 通过一个屏幕坐标搜索包含该坐标的所有{@link NGR.data.Feature}对象。
	     * @param  {Number} x           X轴坐标。
	     * @param  {Number} y           Y轴坐标。
	     * @return {NGR.data.Feature[]} Feature对象列表。
	     */
	
	  }, {
	    key: 'searchFeaturesByClientPoint',
	    value: function searchFeaturesByClientPoint(x, y) {
	      var objList = this._getObjectsByClinet(x, y);
	      var retFeatures = [];
	
	      for (var _iterator6 = objList, _isArray6 = Array.isArray(_iterator6), _i6 = 0, _iterator6 = _isArray6 ? _iterator6 : _iterator6[Symbol.iterator]();;) {
	        var _ref6;
	
	        if (_isArray6) {
	          if (_i6 >= _iterator6.length) break;
	          _ref6 = _iterator6[_i6++];
	        } else {
	          _i6 = _iterator6.next();
	          if (_i6.done) break;
	          _ref6 = _i6.value;
	        }
	
	        var obj = _ref6;
	        var _obj$object = obj.object,
	            layerId = _obj$object._layerId,
	            featureId = _obj$object._sceneId;
	
	        var feature = this.searchFeature(layerId, featureId);
	
	        if (feature) {
	          retFeatures.push(feature);
	        }
	      }
	
	      return retFeatures;
	    }
	
	    /**
	     * 通过一个屏幕坐标搜索包含该坐标的feature对象。返回的对象包含feature和point（即feature对象的屏幕坐标转化而成的3D世界坐标）。
	     * @param  {Number} x X轴坐标。
	     * @param  {Number} y Y轴坐标。
	     * @return {Object[]} 搜索结果列表。
	     */
	
	  }, {
	    key: 'searchObjectsByClient',
	    value: function searchObjectsByClient(x, y) {
	      var objList = this._getObjectsByClinet(x, y);
	      var retObjects = [];
	
	      for (var _iterator7 = objList, _isArray7 = Array.isArray(_iterator7), _i7 = 0, _iterator7 = _isArray7 ? _iterator7 : _iterator7[Symbol.iterator]();;) {
	        var _ref7;
	
	        if (_isArray7) {
	          if (_i7 >= _iterator7.length) break;
	          _ref7 = _iterator7[_i7++];
	        } else {
	          _i7 = _iterator7.next();
	          if (_i7.done) break;
	          _ref7 = _i7.value;
	        }
	
	        var obj = _ref7;
	        var _obj$object2 = obj.object,
	            layerId = _obj$object2._layerId,
	            featureId = _obj$object2._sceneId;
	
	        var feature = this.searchFeature(layerId, featureId);
	
	        if (feature) {
	          retObjects.push({
	            feature: feature,
	            point: obj.point
	          });
	        }
	      }
	
	      return retObjects;
	    }
	  }, {
	    key: '_getObjectsByClinet',
	    value: function _getObjectsByClinet(x, y) {
	      var objList = [];
	
	      if (!this._camera) {
	        console.warn('Invalid Camera');
	        return objList;
	      }
	      if (this.engine.type() !== 'three') {
	        console.warn('Invalid Engine');
	        return objList;
	      }
	
	      objList = this._sceneManager._searchObjectsInOctree(x / this.width * 2 - 1, -(y / this.height) * 2 + 1);
	
	      return objList;
	    }
	  }, {
	    key: '_loop',
	    value: function _loop(timestamp) {
	      if (this._lifeCycle === MapViewLifeCycle.Stop || this._lifeCycle === MapViewLifeCycle.Destroy) {
	        return;
	      }
	      this.changeMapViewLifeCycle(MapViewLifeCycle.Loop);
	      _AnimatorFactory2.default.getInstance().update(timestamp);
	
	      if (timestamp) {
	        this.emit('beginDraw', this, this._frame, timestamp);
	        if (this._sceneManager) {
	          this.emit('drawing', this, this._frame, timestamp);
	          this._sceneManager.render();
	        }
	        this.emit('endDraw', this, this._frame++, timestamp);
	      }
	    }
	  }, {
	    key: 'particleEngine',
	    set: function set(particleEngine) {
	      this._particleEngine = particleEngine;
	    },
	    get: function get() {
	      return this._particleEngine;
	    }
	
	    /**
	     * 场景管理器。
	     * @type {SceneManager}
	     * @return {SceneManager} 场景管理器对象。
	     */
	
	  }, {
	    key: 'sceneGenerator',
	    set: function set(sceneGenerator) {
	      this._sceneGenerator = sceneGenerator;
	    }
	  }, {
	    key: 'gestureManager',
	    get: function get() {
	      return this._gestureManager;
	    },
	    set: function set(gestureManager) {
	      this._gestureManager = gestureManager;
	    }
	
	    /**
	     * 相机对象，用于更改用户查看地图的视角。
	     * @type {CameraNode}
	     * @param  {CameraNode} camera 相机。
	     */
	
	  }, {
	    key: 'activeCamera',
	    set: function set(camera) {
	      this._camera = camera;
	      this._camera.onActiveCamera(this);
	      this._collisionSceneManager.activeCamera = camera;
	    },
	    get: function get() {
	      return this._camera;
	    }
	
	    /**
	     * 控制器，用于控制相机对象，改变用户查看地图的视角。
	     * @type {ThirdPersonControl}
	     * @param  {ThirdPersonControl} control 控制器对象。
	     */
	
	  }, {
	    key: 'activeControl',
	    set: function set(control) {
	      this._control = control;
	      if (this._control && this._control.onActiveControl) {
	        this._control.onActiveControl(this);
	      }
	    },
	    get: function get() {
	      return this._control;
	    }
	
	    /**
	     * 地图的名称。
	     * @type {String}
	     * @return {String} 名称。
	     */
	
	  }, {
	    key: 'name',
	    get: function get() {
	      return this._name;
	    }
	  }, {
	    key: 'engine',
	    set: function set(engine) {
	      this._engine = engine;
	    },
	    get: function get() {
	      return this._engine;
	    }
	  }, {
	    key: 'renderLoop',
	    set: function set(renderLoop) {
	      this._renderLoop = renderLoop;
	    },
	    get: function get() {
	      return this._renderLoop;
	    }
	  }, {
	    key: 'sceneManager',
	    get: function get() {
	      return this._sceneManager;
	    }
	  }, {
	    key: 'collisionSceneManager',
	    get: function get() {
	      return this._collisionSceneManager;
	    }
	
	    /**
	     * 碰撞检测管理器。
	     * @type {CollisionSceneManager}
	     * @param  {CollisionSceneManager} collisionSceneManager 碰撞检测管理器对象。
	     */
	    ,
	    set: function set(collisionSceneManager) {
	      this._collisionSceneManager = collisionSceneManager;
	    }
	
	    /**
	     * 坐标系。
	     * @type {NGR.view.CoordinateSystem}
	     * @return {NGR.view.CoordinateSystem} CoordinateSystem 坐标系对象。
	     */
	
	  }, {
	    key: 'coordinateSystem',
	    get: function get() {
	      return this._coordinateSystem;
	    }
	
	    /**
	     * 地图显示区域的长度。
	     * @type {Number}
	     * @param  {Number} height 长度，单位像素。
	     */
	
	  }, {
	    key: 'height',
	    set: function set(height) {
	      this._height = height;
	    },
	    get: function get() {
	      return this._height;
	    }
	
	    /**
	     * 地图显示区域的宽度。
	     * @type {Number}
	     * @param  {Number} width 宽度，单位像素。
	     */
	
	  }, {
	    key: 'width',
	    set: function set(width) {
	      this._width = width;
	    },
	    get: function get() {
	      return this._width;
	    }
	  }, {
	    key: 'maxDistance',
	    set: function set(distance) {
	      this._maxDistance = distance;
	    },
	    get: function get() {
	      return this._maxDistance;
	    }
	  }, {
	    key: 'minDistance',
	    set: function set(distance) {
	      this._minDistance = distance;
	    },
	    get: function get() {
	      return this._minDistance;
	    }
	  }, {
	    key: 'currentPlanarGraphIds',
	    set: function set(planargraphs) {
	      // eslint-disable-line no-unused-vars
	      console.warn('currentPlanarGraphIds is readonly');
	    }
	
	    /**
	     * 多楼层显示时，当前所有展示的楼层的id列表。
	     * @type {Number[]}
	     * @return {Number[]} 楼层id列表。
	     */
	    ,
	    get: function get() {
	      return this._curPlanarGraphs ? this._curPlanarGraphs : this._planarGraphs;
	    }
	  }, {
	    key: 'planarGraphs',
	    set: function set(planargraphs) {
	      // eslint-disable-line no-unused-vars
	      console.warn('planargraphs is readonly');
	    }
	
	    /**
	     * 所有楼层id列表。
	     * @type {Number[]}
	     * @return {Number[]} Planargraph 楼层id列表。
	     */
	    ,
	    get: function get() {
	      return this._planarGraphs;
	    }
	  }, {
	    key: 'container',
	    set: function set(container) {
	      this._container = container;
	    },
	    get: function get() {
	      return this._container;
	    }
	  }, {
	    key: 'targetDom',
	    set: function set(targetDom) {
	      this._targetDom = targetDom;
	    }
	
	    /**
	     * 目标DOM元素，用于存放地图对象。
	     * @type {HTMLElement}
	     * @return {HTMLElement} 目标DOM元素。
	     */
	    ,
	    get: function get() {
	      return this._targetDom;
	    }
	  }, {
	    key: 'controlDom',
	    set: function set(controlDom) {
	      this._controlDom = controlDom;
	    }
	
	    /**
	     * 控件DOM元素，用于存放控件对象，如指南针等。
	     * @type {HTMLElement}
	     * @return {HTMLElement} 控件DOM元素。
	     */
	    ,
	    get: function get() {
	      return this._controlDom;
	    }
	  }, {
	    key: 'overlayDom',
	    set: function set(dom) {
	      this._overlayDom = dom;
	    }
	
	    /**
	     * 覆盖物DOM元素，用于存放覆盖物。
	     * @type {HTMLElement}
	     * @return {HTMLElement} 覆盖物DOM元素。
	     */
	    ,
	    get: function get() {
	      return this._overlayDom;
	    }
	  }, {
	    key: 'styleGenerator',
	    set: function set(generator) {
	      this._styleGenerator = generator;
	    }
	
	    /**
	     * 样式生成器。样式是用于配置地图上的各种渲染元素(文字、图形、线条)的显示效果，如大小、颜色等。
	     * @type {StyleGenerator}
	     * @return {StyleGenerator} Style 样式生成器。
	     */
	    ,
	    get: function get() {
	      return this._styleGenerator;
	    }
	  }, {
	    key: 'floorHeight',
	    set: function set(height) {
	      this._floorHeight = height;
	    }
	
	    /**
	     * 楼层高度。
	     * @type {Number}
	     * @return {Number} Floor 层高，单位米。
	     */
	    ,
	    get: function get() {
	      return this._floorHeight;
	    }
	  }]);
	
	  return MapView;
	}(_NGRObject3.default);
	
	exports.default = MapView;

/***/ }),
/* 27 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var inherits = __webpack_require__(3)
	  , XhrDriver = __webpack_require__(94)
	  ;
	
	function XHRLocalObject(method, url, payload /*, opts */) {
	  XhrDriver.call(this, method, url, payload, {
	    noCredentials: true
	  });
	}
	
	inherits(XHRLocalObject, XhrDriver);
	
	XHRLocalObject.enabled = XhrDriver.enabled;
	
	module.exports = XHRLocalObject;


/***/ }),
/* 28 */
/***/ (function(module, exports) {

	/* WEBPACK VAR INJECTION */(function(global) {'use strict';
	
	module.exports = {
	  isOpera: function() {
	    return global.navigator &&
	      /opera/i.test(global.navigator.userAgent);
	  }
	
	, isKonqueror: function() {
	    return global.navigator &&
	      /konqueror/i.test(global.navigator.userAgent);
	  }
	
	  // #187 wrap document.domain in try/catch because of WP8 from file:///
	, hasDomain: function () {
	    // non-browser client always has a domain
	    if (!global.document) {
	      return true;
	    }
	
	    try {
	      return !!global.document.domain;
	    } catch (e) {
	      return false;
	    }
	  }
	};
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ }),
/* 29 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {'use strict';
	
	var eventUtils = __webpack_require__(17)
	  , JSON3 = __webpack_require__(15)
	  , browser = __webpack_require__(28)
	  ;
	
	var debug = function() {};
	if (true) {
	  debug = __webpack_require__(6)('sockjs-client:utils:iframe');
	}
	
	module.exports = {
	  WPrefix: '_jp'
	, currentWindowId: null
	
	, polluteGlobalNamespace: function() {
	    if (!(module.exports.WPrefix in global)) {
	      global[module.exports.WPrefix] = {};
	    }
	  }
	
	, postMessage: function(type, data) {
	    if (global.parent !== global) {
	      global.parent.postMessage(JSON3.stringify({
	        windowId: module.exports.currentWindowId
	      , type: type
	      , data: data || ''
	      }), '*');
	    } else {
	      debug('Cannot postMessage, no parent window.', type, data);
	    }
	  }
	
	, createIframe: function(iframeUrl, errorCallback) {
	    var iframe = global.document.createElement('iframe');
	    var tref, unloadRef;
	    var unattach = function() {
	      debug('unattach');
	      clearTimeout(tref);
	      // Explorer had problems with that.
	      try {
	        iframe.onload = null;
	      } catch (x) {
	        // intentionally empty
	      }
	      iframe.onerror = null;
	    };
	    var cleanup = function() {
	      debug('cleanup');
	      if (iframe) {
	        unattach();
	        // This timeout makes chrome fire onbeforeunload event
	        // within iframe. Without the timeout it goes straight to
	        // onunload.
	        setTimeout(function() {
	          if (iframe) {
	            iframe.parentNode.removeChild(iframe);
	          }
	          iframe = null;
	        }, 0);
	        eventUtils.unloadDel(unloadRef);
	      }
	    };
	    var onerror = function(err) {
	      debug('onerror', err);
	      if (iframe) {
	        cleanup();
	        errorCallback(err);
	      }
	    };
	    var post = function(msg, origin) {
	      debug('post', msg, origin);
	      try {
	        // When the iframe is not loaded, IE raises an exception
	        // on 'contentWindow'.
	        setTimeout(function() {
	          if (iframe && iframe.contentWindow) {
	            iframe.contentWindow.postMessage(msg, origin);
	          }
	        }, 0);
	      } catch (x) {
	        // intentionally empty
	      }
	    };
	
	    iframe.src = iframeUrl;
	    iframe.style.display = 'none';
	    iframe.style.position = 'absolute';
	    iframe.onerror = function() {
	      onerror('onerror');
	    };
	    iframe.onload = function() {
	      debug('onload');
	      // `onload` is triggered before scripts on the iframe are
	      // executed. Give it few seconds to actually load stuff.
	      clearTimeout(tref);
	      tref = setTimeout(function() {
	        onerror('onload timeout');
	      }, 2000);
	    };
	    global.document.body.appendChild(iframe);
	    tref = setTimeout(function() {
	      onerror('timeout');
	    }, 15000);
	    unloadRef = eventUtils.unloadAdd(cleanup);
	    return {
	      post: post
	    , cleanup: cleanup
	    , loaded: unattach
	    };
	  }
	
	/* eslint no-undef: "off", new-cap: "off" */
	, createHtmlfile: function(iframeUrl, errorCallback) {
	    var axo = ['Active'].concat('Object').join('X');
	    var doc = new global[axo]('htmlfile');
	    var tref, unloadRef;
	    var iframe;
	    var unattach = function() {
	      clearTimeout(tref);
	      iframe.onerror = null;
	    };
	    var cleanup = function() {
	      if (doc) {
	        unattach();
	        eventUtils.unloadDel(unloadRef);
	        iframe.parentNode.removeChild(iframe);
	        iframe = doc = null;
	        CollectGarbage();
	      }
	    };
	    var onerror = function(r) {
	      debug('onerror', r);
	      if (doc) {
	        cleanup();
	        errorCallback(r);
	      }
	    };
	    var post = function(msg, origin) {
	      try {
	        // When the iframe is not loaded, IE raises an exception
	        // on 'contentWindow'.
	        setTimeout(function() {
	          if (iframe && iframe.contentWindow) {
	              iframe.contentWindow.postMessage(msg, origin);
	          }
	        }, 0);
	      } catch (x) {
	        // intentionally empty
	      }
	    };
	
	    doc.open();
	    doc.write('<html><s' + 'cript>' +
	              'document.domain="' + global.document.domain + '";' +
	              '</s' + 'cript></html>');
	    doc.close();
	    doc.parentWindow[module.exports.WPrefix] = global[module.exports.WPrefix];
	    var c = doc.createElement('div');
	    doc.body.appendChild(c);
	    iframe = doc.createElement('iframe');
	    c.appendChild(iframe);
	    iframe.src = iframeUrl;
	    iframe.onerror = function() {
	      onerror('onerror');
	    };
	    tref = setTimeout(function() {
	      onerror('timeout');
	    }, 15000);
	    unloadRef = eventUtils.unloadAdd(cleanup);
	    return {
	      post: post
	    , cleanup: cleanup
	    , loaded: unattach
	    };
	  }
	};
	
	module.exports.iframeEnabled = false;
	if (global.document) {
	  // postMessage misbehaves in konqueror 4.6.5 - the messages are delivered with
	  // huge delay, or not at all.
	  module.exports.iframeEnabled = (typeof global.postMessage === 'function' ||
	    typeof global.postMessage === 'object') && (!browser.isKonqueror());
	}
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ }),
/* 30 */
/***/ (function(module, exports) {

	module.exports = function(module) {
		if(!module.webpackPolyfill) {
			module.deprecate = function() {};
			module.paths = [];
			// module.parent = undefined by default
			module.children = [];
			module.webpackPolyfill = 1;
		}
		return module;
	}


/***/ }),
/* 31 */
/***/ (function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	// https://fetch.spec.whatwg.org/#dom-headers
	
	var supportIterator = 'Symbol' in self && 'iterator' in Symbol;
	
	function normalizeName(name) {
	  var headerName = name;
	  if (typeof name !== 'string') {
	    headerName = String(name);
	  }
	
	  if (/[^a-z0-9\-#$%&'*+.\^_`|~]/i.test(name)) {
	    throw new TypeError('Invalid character in header field name');
	  }
	
	  return headerName;
	}
	
	function normalizeValue(value) {
	  var newValue = value;
	  if (typeof value !== 'string') {
	    newValue = String(value);
	  }
	
	  return newValue;
	}
	
	function iteratorFor(items) {
	  var iterator = {
	    next: function next() {
	      var value = items.shift();
	      return {
	        value: value,
	        done: typeof value === 'undefined'
	      };
	    }
	  };
	
	  if (supportIterator) {
	    iterator[Symbol.iterator] = function () {
	      return iterator;
	    };
	  }
	
	  return iterator;
	}
	
	var Headers = function () {
	  function Headers(init) {
	    var _this = this;
	
	    _classCallCheck(this, Headers);
	
	    this.map = {};
	
	    if (init instanceof Headers) {
	      init.forEach(function (_ref) {
	        var name = _ref.name,
	            value = _ref.value;
	        return _this.append(name, value);
	      });
	    } else if (init) {
	      Object.getOwnPropertyNames(init).forEach(function (name) {
	        _this.append(name, init[name]);
	      });
	    }
	  }
	
	  // Appends a new value onto an existing header inside a Headers object
	  // or adds the header if it does not already exist.
	
	
	  _createClass(Headers, [{
	    key: 'append',
	    value: function append(name, value) {
	      var normalizedName = normalizeName(name);
	      var list = this.map[normalizedName];
	      if (!list) {
	        list = [];
	        this.map[normalizedName] = list;
	      }
	
	      list.push(value);
	    }
	
	    // Sets a new value for an existing header inside a Headers object,
	    // or adds the header if it does not already exist.
	
	  }, {
	    key: 'set',
	    value: function set(name, value) {
	      this.map[normalizeName(name)] = [normalizeValue(value)];
	    }
	
	    // Deletes a header from a Headers object.
	
	  }, {
	    key: 'delete',
	    value: function _delete(name) {
	      delete this.map[normalizeName(name)];
	    }
	
	    // Returns the first value of a given header from within a Headers object.
	
	  }, {
	    key: 'get',
	    value: function get(name) {
	      var values = this.map[normalizeName(name)];
	      return values ? values[0] : null;
	    }
	
	    // Returns an array of all the values of a header within a Headers object with a given name.
	
	  }, {
	    key: 'getAll',
	    value: function getAll(name) {
	      return this.map[normalizeName(name)] || [];
	    }
	
	    // Returns a boolean stating whether a Headers object contains a certain header.
	
	  }, {
	    key: 'has',
	    value: function has(name) {
	      return this.map.hasOwnProperty(normalizeName(name));
	    }
	  }, {
	    key: 'forEach',
	    value: function forEach(callback, context) {
	      var _this2 = this;
	
	      Object.getOwnPropertyNames(this.map).forEach(function (name) {
	        _this2.map[name].forEach(function (value) {
	          callback.call(context, name, value, _this2);
	        });
	      });
	    }
	
	    // Returns an iterator allowing to go through all keys f the key/value pairs contained in this object.
	
	  }, {
	    key: 'keys',
	    value: function keys() {
	      var items = [];
	      this.forEach(function (name) {
	        return items.push(name);
	      });
	      return iteratorFor(items);
	    }
	
	    // @return Iterator
	
	  }, {
	    key: 'values',
	    value: function values() {
	      var items = [];
	      this.forEach(function (name, value) {
	        return items.push(value);
	      });
	      return iteratorFor(items);
	    }
	
	    // Returns an iterator allowing to go through all key/value pairs contained in this object.
	
	  }, {
	    key: 'entries',
	    value: function entries() {
	      var items = [];
	      this.forEach(function (name, value) {
	        return items.push([name, value]);
	      });
	      return iteratorFor(items);
	    }
	  }]);
	
	  return Headers;
	}();
	
	// use for...of structure directly on my instead of entries()
	
	
	if (supportIterator) {
	  Headers.prototype[Symbol.iterator] = Headers.prototype.entries;
	}
	
	exports.default = Headers;
	// export default self.Headers ? self.Headers : Headers;

/***/ }),
/* 32 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _set = function set(object, property, value, receiver) { var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent !== null) { set(parent, property, value, receiver); } } else if ("value" in desc && desc.writable) { desc.value = value; } else { var setter = desc.set; if (setter !== undefined) { setter.call(receiver, value); } } return value; };
	
	var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };
	
	var _CameraNode2 = __webpack_require__(142);
	
	var _CameraNode3 = _interopRequireDefault(_CameraNode2);
	
	var _three = __webpack_require__(2);
	
	var THREE = _interopRequireWildcard(_three);
	
	var _Cylinder = __webpack_require__(122);
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	/**
	 * 3D透视投影相机类,用于创建拥有透视效果的相机对象。
	 * @extends {CameraNode}
	 * @memberOf NGR.camera
	 */
	var ThreeCamera = function (_CameraNode) {
	  _inherits(ThreeCamera, _CameraNode);
	
	  /**
	   * 初始化一个3D透视投影相机对象。
	   * @param  {Number} fov    相机视锥体水平视角的角度(Camera frustum vertical field of view)。
	   * @param  {Number} aspect 相机视锥体缩放比例(Camera frustum aspect ratio)。
	   * @param  {Number} near   相机视锥体的前裁剪平面大小(Camera frustum near plane)。
	   * @param  {Number} far    相机视锥体的后裁剪平面大小(Camera frustum far plane)。
	   */
	  function ThreeCamera(fov, aspect, near, far) {
	    _classCallCheck(this, ThreeCamera);
	
	    var _this = _possibleConstructorReturn(this, (ThreeCamera.__proto__ || Object.getPrototypeOf(ThreeCamera)).call(this, -2));
	
	    _this._camera = new THREE.PerspectiveCamera(fov, aspect, near, far);
	    _this.id = _this._camera.id;
	
	    _this._quaternion = _this._camera.quaternion.clone();
	    _this._rotation = _this._camera.rotation.clone();
	
	    _this._target0 = new THREE.Vector3();
	    _this._originDistance = 100;
	    return _this;
	  }
	
	  _createClass(ThreeCamera, [{
	    key: 'addLight',
	
	
	    /**
	     * 往相机中添加灯光，随着相机移动
	     * @ignore
	     * @param {String}    type   灯光类型.
	     * @param {...Object} params 灯光参数.
	     * @return {THREE.Light} Light.
	     */
	    value: function addLight(type) {
	      var light = null;
	      if (type === 'Point') {
	        for (var _len = arguments.length, params = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
	          params[_key - 1] = arguments[_key];
	        }
	
	        light = new (Function.prototype.bind.apply(THREE.PointLight, [null].concat(params)))();
	        this._camera.add(light);
	      }
	      return light;
	    }
	
	    /**
	     * @override
	     */
	
	  }, {
	    key: 'reSize',
	    value: function reSize(width, height) {
	      this._camera.aspect = width / height;
	      this._camera.updateProjectionMatrix();
	    }
	
	    /**
	     * 释放相机对象。
	     * @return {undefined}
	     */
	
	  }, {
	    key: 'destroy',
	    value: function destroy() {
	      this._camera = null;
	      this._quaternion = null;
	      this._rotation = null;
	    }
	
	    /**
	     * @override
	     */
	
	  }, {
	    key: 'initRect',
	    value: function initRect(rect) {
	      var ratio = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0.667;
	      var skewAngle = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 60;
	
	      var origin = new THREE.Vector3(0, 0, 0);
	
	      if (this._mapView && rect.length === 4) {
	        this._camera.quaternion.set(this._quaternion.x, this._quaternion.y, this._quaternion.z, this._quaternion.w);
	        this._camera.rotation.set(this._rotation.x, this._rotation.y, this._rotation.z);
	        this._camera.position.setZ(this._originDistance);
	
	        var left = rect[0];
	        var bottom = rect[1];
	        var right = rect[2];
	        var top = rect[3];
	
	        var centerX = (left + right) / 2;
	        var centerY = (top + bottom) / 2;
	
	        var leftBottomVector = new THREE.Vector3(left - centerX, bottom - centerY, 1);
	        var rightTopVector = new THREE.Vector3(right - centerX, top - centerY, 1);
	        // this._mapBound = new THREE.Box3(leftBottomVector, rightTopVector);
	        var cylinderRadius = Math.sqrt(Math.pow(rightTopVector.x - leftBottomVector.x, 2) + Math.pow(rightTopVector.y - leftBottomVector.y, 2) + Math.pow(rightTopVector.z - leftBottomVector.z, 2)) / 2;
	        // this._mapBound = new Cylinder(origin, cylinderRadius, 500);
	        this._mapBound = new _Cylinder.EllipticCylinder(origin, cylinderRadius, cylinderRadius);
	        this._camera.updateMatrix();
	        this._camera.updateMatrixWorld();
	
	        var leftBottomScreen = this.toScreenCoordinate(leftBottomVector.x, leftBottomVector.y, leftBottomVector.z);
	        var rightTopScreen = this.toScreenCoordinate(rightTopVector.x, rightTopVector.y, rightTopVector.z);
	
	        var widthRatio = (rightTopScreen.x - leftBottomScreen.x) / this._mapView.width;
	        var heightRatio = (leftBottomScreen.y - rightTopScreen.y) / this._mapView.height;
	        var minRatio = Math.max(widthRatio, heightRatio);
	        this._originDistance = this._camera.position.z * minRatio / ratio;
	        this._camera.position.setZ(this._originDistance);
	        this._camera.updateMatrix();
	        this._camera.updateMatrixWorld();
	      } else if (this._mapView && rect.length === 6) {
	        this._camera.quaternion.set(this._quaternion.x, this._quaternion.y, this._quaternion.z, this._quaternion.w);
	        this._camera.rotation.set(this._rotation.x, this._rotation.y, this._rotation.z);
	        this._camera.position.setZ(100);
	
	        var _centerX = (rect[0] + rect[3]) / 2;
	        var _centerY = (rect[1] + rect[4]) / 2;
	        var centerZ = (rect[2] + rect[5]) / 2;
	
	        var minVector = new THREE.Vector3(rect[0] - _centerX, rect[1] - _centerY, rect[2] - centerZ);
	        var maxVector = new THREE.Vector3(rect[3] - _centerX, rect[4] - _centerY, rect[5] - centerZ);
	        var _cylinderRadius = Math.sqrt(Math.pow(maxVector.x - minVector.x, 2) + Math.pow(maxVector.y - minVector.y, 2) + Math.pow(maxVector.z - minVector.z, 2)) / 2;
	        // this._mapBound = new Cylinder(origin, cylinderRadius, 500);
	        this._mapBound = new _Cylinder.EllipticCylinder(origin, _cylinderRadius, _cylinderRadius);
	        this._camera.updateMatrix();
	        this._camera.updateMatrixWorld();
	
	        var pan = new THREE.Vector3(this._camera.up.y, -this._camera.up.x, 0).normalize();
	        var skewMatrix = new THREE.Matrix4();
	        skewMatrix.makeRotationAxis(pan, skewAngle * Math.PI / 180);
	        this._camera.position.applyMatrix4(skewMatrix);
	        this._camera.up.applyMatrix4(skewMatrix);
	
	        var screenPt1 = this.toScreenCoordinate(minVector.x, minVector.y, minVector.z);
	        var screenPt2 = this.toScreenCoordinate(minVector.x, maxVector.y, minVector.z);
	        var screenPt3 = this.toScreenCoordinate(maxVector.x, minVector.y, minVector.z);
	        var screenPt4 = this.toScreenCoordinate(maxVector.x, maxVector.y, minVector.z);
	        var screenPt5 = this.toScreenCoordinate(minVector.x, minVector.y, maxVector.z);
	        var screenPt6 = this.toScreenCoordinate(minVector.x, maxVector.y, maxVector.z);
	        var screenPt7 = this.toScreenCoordinate(maxVector.x, minVector.y, maxVector.z);
	        var screenPt8 = this.toScreenCoordinate(maxVector.x, maxVector.y, maxVector.z);
	
	        var minX = Math.min(screenPt1.x, screenPt2.x, screenPt3.x, screenPt4.x, screenPt5.x, screenPt6.x, screenPt7.x, screenPt8.x);
	        var maxX = Math.max(screenPt1.x, screenPt2.x, screenPt3.x, screenPt4.x, screenPt5.x, screenPt6.x, screenPt7.x, screenPt8.x);
	        var minY = Math.min(screenPt1.y, screenPt2.y, screenPt3.y, screenPt4.y, screenPt5.y, screenPt6.y, screenPt7.y, screenPt8.y);
	        var maxY = Math.max(screenPt1.y, screenPt2.y, screenPt3.y, screenPt4.y, screenPt5.y, screenPt6.y, screenPt7.y, screenPt8.y);
	
	        var _widthRatio = (maxX - minX) / this._mapView.width;
	        var _heightRatio = (maxY - minY) / this._mapView.height;
	        var _minRatio = Math.max(_widthRatio, _heightRatio);
	
	        this._camera.position.setX(this._camera.position.x * _minRatio / ratio);
	        this._camera.position.setY(this._camera.position.y * _minRatio / ratio);
	        this._camera.position.setZ(this._camera.position.z * _minRatio / ratio);
	        this._camera.updateMatrix();
	        this._camera.updateMatrixWorld();
	      }
	    }
	
	    /**
	     * Bound getter.
	     * @ignore
	     * @return {THREE.Box3} Bound.
	     */
	
	  }, {
	    key: 'toScreenCoordinate',
	
	
	    /**
	     * @override
	     */
	    value: function toScreenCoordinate(x, y, z) {
	      var project = void 0;
	      if (this._mapView) {
	        var p = new THREE.Vector3(x, y, z);
	        project = p.project(this._camera);
	
	        project.x = (project.x + 1) / 2 * this._mapView.width;
	        project.y = -(project.y - 1) / 2 * this._mapView.height;
	      }
	      return project.setZ(0);
	    }
	
	    /**
	     * @override
	     */
	
	  }, {
	    key: 'toCameraCoordinate',
	    value: function toCameraCoordinate(x, y, z) {
	      var project = void 0;
	      if (this._mapView) {
	        this._camera.updateProjectionMatrix();
	        var p = new THREE.Vector3(x / this._mapView.width * 2 - 1, -(y / this._mapView.height) * 2 + 1, z);
	        var position = new THREE.Vector3().setFromMatrixPosition(this._camera.matrix);
	
	        project = p.unproject(this._camera);
	
	        var dir = project.sub(position).normalize();
	        var distance = -position.z / dir.z;
	
	        project = position.clone().add(dir.multiplyScalar(distance));
	      }
	      var t = (this._target.z - this._camera.position.z) / (project.z - this._camera.position.z);
	      var output = this._camera.position.clone().multiplyScalar(1 - t).add(project.multiplyScalar(t));
	
	      return output;
	      // let project;
	      // if (this._mapView) {
	      //   this._camera.updateProjectionMatrix();
	      //   const p = new THREE.Vector3(x / this._mapView.width * 2 - 1, -(y / this._mapView.height) * 2 + 1, z);
	      //   // console.log(p);
	      //   const position = new THREE.Vector3().setFromMatrixPosition(this._camera.matrix);
	      //   project = p.unproject(this._camera);
	      //   // console.log(project);
	      //   const dir = project.sub(position).normalize();
	      //   const distance = -position.z / dir.z;
	      //   project = position.clone().add(dir.multiplyScalar(distance));
	      // }
	      // return project;
	    }
	
	    /**
	     * 获取1米实际距离对应的像素点数量。
	     * @return {Number} 1米对应的像素点数。
	     */
	
	  }, {
	    key: 'getMetersPerPixel',
	    value: function getMetersPerPixel() {
	      if (!this._mapView) {
	        return 0;
	      }
	      var camera = this._camera;
	      var screenOrigin = new THREE.Vector3(this._mapView.width / 2, this._mapView.height / 2, 0);
	      var cameraOrigin = this.toCameraCoordinate(screenOrigin.x, screenOrigin.y, screenOrigin.z);
	      var cameraDst = new THREE.Vector3();
	      var vector = new THREE.Vector3(1, 0, 0);
	      var quaternion = camera.getWorldQuaternion();
	      var screenDst = null;
	      var pixels = 0;
	
	      vector.applyQuaternion(quaternion);
	      cameraDst.copy(cameraOrigin).add(vector);
	      screenDst = this.toScreenCoordinate(cameraDst.x, cameraDst.y, cameraDst.z);
	      pixels = screenOrigin.distanceTo(screenDst);
	
	      return 1 / pixels;
	    }
	
	    /**
	     * 删除相机的灯光。
	     * @ignore
	     * @param  {THREE.Light} light Light.
	     * @return {undefined}
	     */
	
	  }, {
	    key: 'removeLight',
	    value: function removeLight(light) {
	      this._camera.remove(light);
	    }
	  }, {
	    key: 'lookAt',
	
	
	    /**
	     * @override
	     */
	    value: function lookAt(position, target /* , up*/) {
	      this._target0.set(target.x, target.y, target.z);
	      this._camera.lookAt(this._target0);
	    }
	  }, {
	    key: 'originDistance',
	    get: function get() {
	      return this._originDistance;
	    }
	
	    /**
	     * Camera getter.
	     * @ignore
	     * @return {THREE.Camera} Camera.
	     */
	
	  }, {
	    key: 'camera',
	    get: function get() {
	      return this._camera;
	    }
	  }, {
	    key: 'bound',
	    get: function get() {
	      return this._mapBound;
	    }
	  }, {
	    key: 'position',
	    get: function get() {
	      var temp = _get(ThreeCamera.prototype.__proto__ || Object.getPrototypeOf(ThreeCamera.prototype), 'position', this);
	
	      temp.x = this._camera.position.x;
	      temp.y = this._camera.position.y;
	      temp.z = this._camera.position.z;
	      return temp;
	    }
	
	    /**
	     * 相机位置，使用3D世界坐标系表示。
	     * @type   {geom.Coordinate|THREE.Vector3}
	     * @param  {geom.Coordinate|THREE.Vector3} position 相机位置。
	     */
	    ,
	    set: function set(position) {
	      this._camera.position.set(position.x, position.y, position.z);
	      if (position instanceof THREE.Vector3) {
	        _get(ThreeCamera.prototype.__proto__ || Object.getPrototypeOf(ThreeCamera.prototype), 'position', this).x = position.x;
	        _get(ThreeCamera.prototype.__proto__ || Object.getPrototypeOf(ThreeCamera.prototype), 'position', this).y = position.y;
	        _get(ThreeCamera.prototype.__proto__ || Object.getPrototypeOf(ThreeCamera.prototype), 'position', this).z = position.z;
	      } else {
	        _set(ThreeCamera.prototype.__proto__ || Object.getPrototypeOf(ThreeCamera.prototype), 'position', position, this);
	      }
	    }
	  }, {
	    key: 'target',
	    get: function get() {
	      return this._target;
	    }
	
	    /**
	     * 设置相机目标的位置，即相机正对的地图中心位置的坐标，使用3D世界坐标系表示。
	     * @type   {geom.Coordinate|THREE.Vector3}
	     * @param  {geom.Coordinate|THREE.Vector3} target 相机正对的地图中心位置的坐标。
	     */
	    ,
	    set: function set(target) {
	      if (target instanceof THREE.Vector3) {
	        _get(ThreeCamera.prototype.__proto__ || Object.getPrototypeOf(ThreeCamera.prototype), 'target', this).x = target.x;
	        _get(ThreeCamera.prototype.__proto__ || Object.getPrototypeOf(ThreeCamera.prototype), 'target', this).y = target.y;
	        _get(ThreeCamera.prototype.__proto__ || Object.getPrototypeOf(ThreeCamera.prototype), 'target', this).z = target.z;
	      } else {
	        _set(ThreeCamera.prototype.__proto__ || Object.getPrototypeOf(ThreeCamera.prototype), 'target', target, this);
	      }
	    }
	  }, {
	    key: 'up',
	    get: function get() {
	      var temp = _get(ThreeCamera.prototype.__proto__ || Object.getPrototypeOf(ThreeCamera.prototype), 'up', this);
	
	      temp.x = this._camera.up.x;
	      temp.y = this._camera.up.y;
	      temp.z = this._camera.up.z;
	
	      return temp;
	    }
	
	    /**
	     * Up setter.
	     * @ignore
	     * @type   {geom.Coordinate|THREE.Vector3}
	     * @param  {geom.Coordinate|THREE.Vector3} up Up.
	     */
	    ,
	    set: function set(up) {
	      this._camera.up.set(up.x, up.y, up.z);
	      if (up instanceof THREE.Vector3) {
	        _get(ThreeCamera.prototype.__proto__ || Object.getPrototypeOf(ThreeCamera.prototype), 'up', this).x = up.x;
	        _get(ThreeCamera.prototype.__proto__ || Object.getPrototypeOf(ThreeCamera.prototype), 'up', this).y = up.y;
	        _get(ThreeCamera.prototype.__proto__ || Object.getPrototypeOf(ThreeCamera.prototype), 'up', this).z = up.z;
	      } else {
	        _set(ThreeCamera.prototype.__proto__ || Object.getPrototypeOf(ThreeCamera.prototype), 'up', up, this);
	      }
	    }
	  }]);
	
	  return ThreeCamera;
	}(_CameraNode3.default);
	
	exports.default = ThreeCamera;

/***/ }),
/* 33 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _assign = __webpack_require__(1);
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };
	
	var _Control2 = __webpack_require__(16);
	
	var _Control3 = _interopRequireDefault(_Control2);
	
	var _dom = __webpack_require__(11);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	/**
	 * 开关控件,用于控制地图上某些元素的可见或不可见。
	 * @emits NGR.control.ToggleControl#toggle
	 * @extends {NGR.control.Control}
	 * @memberOf NGR.control
	 */
	var ToggleControl = function (_Control) {
	  _inherits(ToggleControl, _Control);
	
	  /**
	   * 构造方法。
	   * @param  {Object}     [options]                控件选项,即构成控件的一些配置元素。
	   * @param  {HTMLElment} [options.element]        控件的DOM元素。
	   * @param  {String}     [options.name]           控件的名字，比如设置此参数为'name'，控件的名字为'toggle-name'。
	   * @param  {String}     [options.className]      控件DOM元素的类名。
	   * @param  {Boolean}    [options.disabled=false] 初始化时是否可用,默认为false,即可用。
	   * @param  {Boolean}    [options.selected=false] 初始化时是否被选中。
	   * @param  {String}     [options.innerHTML='']   按钮的innerHTML。
	   */
	  function ToggleControl() {
	    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
	
	    _classCallCheck(this, ToggleControl);
	
	    var _this = _possibleConstructorReturn(this, (ToggleControl.__proto__ || Object.getPrototypeOf(ToggleControl)).call(this, options.name ? 'toggle-' + options.name : 'toggle', _assign({
	      disabled: false,
	      selected: false,
	      innerHTML: '',
	      position: 'topright'
	    }, options)));
	
	    if (_this._element) {
	      console.warn('ToggleControl: Element will be overrided');
	    }
	
	    var customClassName = _this._options.className ? ' ' + _this._options.className : '';
	
	    _this._element = _dom.DOMUtils.createElement('div', 'ngr-toggle ngr-control ngr-bar' + customClassName);
	
	    _this._button = _dom.DOMUtils.createElement('a', '', _this._element);
	    _this._button.innerHTML = _this._options.innerHTML;
	    _this._button.href = '#';
	
	    _this._disabled = _this._options.disabled;
	    _this._selected = _this._options.selected;
	    if (_this._selected) {
	      _dom.DOMUtils.addClass(_this._button, 'selected');
	    }
	    if (_this._disabled) {
	      _dom.DOMUtils.addClass(_this._button, 'disabled');
	    }
	
	    _this._onClick = _this._onClick.bind(_this);
	    return _this;
	  }
	
	  /**
	   * @override
	   */
	
	
	  _createClass(ToggleControl, [{
	    key: '_onAdd',
	    value: function _onAdd(mapView) {
	      _get(ToggleControl.prototype.__proto__ || Object.getPrototypeOf(ToggleControl.prototype), '_onAdd', this).call(this, mapView);
	      this._button.addEventListener('click', this._onClick, false);
	
	      return this;
	    }
	
	    /**
	     * @override
	     */
	
	  }, {
	    key: '_onRemove',
	    value: function _onRemove(mapView) {
	      _get(ToggleControl.prototype.__proto__ || Object.getPrototypeOf(ToggleControl.prototype), '_onRemove', this).call(this, mapView);
	      this._button.removeEventListener('click', this._onClick);
	
	      return this;
	    }
	  }, {
	    key: '_onClick',
	    value: function _onClick(e) {
	      e.preventDefault();
	      e.stopPropagation();
	
	      this.trigger();
	    }
	
	    /**
	     * 触发开关。
	     * @param  {Boolean} [fireEvent=true] 是否触发'toggle'事件。
	     * @return {undefined}
	     */
	
	  }, {
	    key: 'trigger',
	    value: function trigger() {
	      var fireEvent = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
	
	      if (this._disabled) {
	
	        return;
	      } else if (this._selected) {
	        _dom.DOMUtils.removeClass(this._button, 'selected');
	        this._selected = false;
	      } else {
	        _dom.DOMUtils.addClass(this._button, 'selected');
	        this._selected = true;
	      }
	
	      if (fireEvent) {
	        /**
	         * 开关触发事件。
	         * @event NGR.control.ToggleControl#toggle
	         * @type {Object}
	         * @property {Boolean} selected 开关控件是否被选中,即开或关。
	         */
	        this.fire('toggle', {
	          selected: this._selected,
	          targetControl: this
	        });
	      }
	    }
	
	    /**
	     * 获取控件的选中状态。
	     * @return {Boolean} 若被选中则返回true。
	     */
	
	  }, {
	    key: 'getSelected',
	    value: function getSelected() {
	      return this._selected;
	    }
	  }, {
	    key: 'disable',
	    value: function disable() {
	      this.disabled = true;
	
	      return this;
	    }
	  }, {
	    key: 'enable',
	    value: function enable() {
	      this.disabled = false;
	
	      return this;
	    }
	
	    /**
	     * 控件是否被禁用。
	     * @type {Boolean}
	     * @param  {Boolean} disabled 是否被禁用，true为禁用。
	     */
	
	  }, {
	    key: 'disabled',
	    set: function set(disabled) {
	      this._disabled = !!disabled;
	      if (this._disabled) {
	        _dom.DOMUtils.addClass(this._button, 'disabled');
	      } else {
	        _dom.DOMUtils.removeClass(this._button, 'disabled');
	      }
	    },
	    get: function get() {
	      return this._disabled;
	    }
	  }]);
	
	  return ToggleControl;
	}(_Control3.default);
	
	exports.default = ToggleControl;

/***/ }),
/* 34 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _assign = __webpack_require__(1);
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	/**
	 * Feature类，用以表示一个渲染元素，保存空间数据和一些基本信息。
	 * @memberOf NGR.data
	 */
	var Feature = function () {
	  /**
	   * 构造方法。
	   * @param  {Geometry} geometry   形状，如点、线、多边形等。
	   * @param  {Object}   properties 属性，用于表示各种形状的特性，如id、name等。
	   */
	  function Feature(geometry, properties) {
	    _classCallCheck(this, Feature);
	
	    this.geometry = geometry;
	    this.properties = properties;
	    this.id = this.properties && this.properties['id'];
	    this.hasOffset = true;
	    this.priority = 5;
	  }
	
	  _createClass(Feature, [{
	    key: 'copy',
	
	
	    /**
	     * 复制一个Feature对象，对该对象的修改不会影响被复制的对象。
	     * @return {NGR.data.Feature} 复制的Feature对象。
	     */
	    value: function copy() {
	      var geometry = this.geometry.copy();
	      var properties = _assign({}, this.properties);
	      var ret = new Feature(geometry, properties);
	
	      ret.hasOffset = this.hasOffset;
	
	      return ret;
	    }
	  }, {
	    key: 'priority',
	    get: function get() {
	      return this._priority;
	    }
	
	    /**
	     * 设置渲染对象的显示级别。如多个渲染对象重合的时候，判断优先显示哪个对象。
	     * @type {Number}
	     * @param  {Number} priority 属性，数值越大则显示级别越低。
	     */
	    ,
	    set: function set(priority) {
	      this._priority = priority;
	    }
	  }, {
	    key: 'id',
	    get: function get() {
	      return this._id;
	    }
	
	    /**
	     * Feature对象的Id。
	     * @type {Number}
	     * @param  {Number} id Id。
	     */
	    ,
	    set: function set(id) {
	      this._id = id;
	    }
	  }, {
	    key: 'geometry',
	    get: function get() {
	      return this._geometry;
	    }
	
	    /**
	     * 几何图形，用来描述空间数据，表示绘制的形状。
	     * @type {Geometry}
	     * @param  {Geometry} geometry 图形。
	     */
	    ,
	    set: function set(geometry) {
	      this._geometry = geometry;
	    }
	  }, {
	    key: 'properties',
	    get: function get() {
	      return this._properties;
	    }
	
	    /**
	     * 对象的属性。
	     * @type {Object}
	     * @param  {Object} properties feature对象属性的集合，包含多种信息。
	     */
	    ,
	    set: function set(properties) {
	      this._properties = properties;
	    }
	  }, {
	    key: 'hasOffset',
	    set: function set(hasOffset) {
	      this._hasOffset = hasOffset;
	    },
	    get: function get() {
	      return this._hasOffset;
	    }
	  }, {
	    key: 'parent',
	    set: function set(layer) {
	      this._parent = layer;
	    },
	    get: function get() {
	      return this._parent;
	    }
	  }]);
	
	  return Feature;
	}();
	
	exports.default = Feature;

/***/ }),
/* 35 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _JTSUtils = __webpack_require__(12);
	
	var _JTSUtils2 = _interopRequireDefault(_JTSUtils);
	
	var _jsts = __webpack_require__(5);
	
	var _lang = __webpack_require__(4);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	/**
	 * Geometry工厂类，用于创建和管理各类形状，这些形状可以作为标记绘制在地图上。
	 * @memberOf NGR.geom
	 */
	var GeometryFactory = function () {
	  function GeometryFactory() {
	    _classCallCheck(this, GeometryFactory);
	  }
	
	  _createClass(GeometryFactory, null, [{
	    key: 'createPoint',
	
	    /**
	     * 创建一个类型为Point的Geometry对象，即一个点。
	     * @param  {Number[]} point 点坐标。
	     * @return {PointGeometry}   PointGeometry对象。
	     */
	    value: function createPoint(point) {
	      return point ? _JTSUtils2.default.getFactory().createPoint(new (Function.prototype.bind.apply(_jsts.geom.Coordinate, [null].concat(_toConsumableArray(point))))()) : null;
	    }
	
	    /**
	     * 创建一个类型为Polygon的Geometry对象，即一个多边形。
	     * @param  {Array[]} points  点坐标数组。
	     * @return {PolygonGeometry} PolygonGeometry对象。
	     */
	
	  }, {
	    key: 'createPolygon',
	    value: function createPolygon(points) {
	      if ((0, _lang.isArray)(points)) {
	        var coords = [];
	
	        for (var _iterator = points, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
	          var _ref;
	
	          if (_isArray) {
	            if (_i >= _iterator.length) break;
	            _ref = _iterator[_i++];
	          } else {
	            _i = _iterator.next();
	            if (_i.done) break;
	            _ref = _i.value;
	          }
	
	          var point = _ref;
	
	          if ((0, _lang.isArray)(point)) {
	            var coord = new (Function.prototype.bind.apply(_jsts.geom.Coordinate, [null].concat(_toConsumableArray(point))))();
	
	            coords.push(coord);
	          }
	        }
	
	        if (coords.length >= 3) {
	          return _JTSUtils2.default.getFactory().createPolygon(coords);
	        }
	      }
	
	      return null;
	    }
	
	    /**
	     * 创建一个类型为LineString的Geometry对象，即一条直线。
	     * @param  {Array[]} points     点坐标数组。
	     * @return {LineStringGeometry} LineStringGeometry对象。
	     */
	
	  }, {
	    key: 'createLineString',
	    value: function createLineString(points) {
	      if ((0, _lang.isArray)(points)) {
	        var coords = [];
	
	        for (var _iterator2 = points, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator]();;) {
	          var _ref2;
	
	          if (_isArray2) {
	            if (_i2 >= _iterator2.length) break;
	            _ref2 = _iterator2[_i2++];
	          } else {
	            _i2 = _iterator2.next();
	            if (_i2.done) break;
	            _ref2 = _i2.value;
	          }
	
	          var point = _ref2;
	
	          if ((0, _lang.isArray)(point)) {
	            var coord = new (Function.prototype.bind.apply(_jsts.geom.Coordinate, [null].concat(_toConsumableArray(point))))();
	
	            coords.push(coord);
	          }
	        }
	
	        if (coords.length >= 2) {
	          return _JTSUtils2.default.getFactory().createLineString(coords);
	        }
	      }
	
	      return null;
	    }
	
	    /**
	     * 创建一个类型为MultiPoint的Geometry对象，即多个点。
	     * @param  {Array[]} points     点坐标数组。
	     * @return {MultiPointGeometry} MultiPointGeometry对象。
	     */
	
	  }, {
	    key: 'createMultiPoint',
	    value: function createMultiPoint(points) {
	      if ((0, _lang.isArray)(points)) {
	        var coords = [];
	
	        for (var _iterator3 = points, _isArray3 = Array.isArray(_iterator3), _i3 = 0, _iterator3 = _isArray3 ? _iterator3 : _iterator3[Symbol.iterator]();;) {
	          var _ref3;
	
	          if (_isArray3) {
	            if (_i3 >= _iterator3.length) break;
	            _ref3 = _iterator3[_i3++];
	          } else {
	            _i3 = _iterator3.next();
	            if (_i3.done) break;
	            _ref3 = _i3.value;
	          }
	
	          var point = _ref3;
	
	          if ((0, _lang.isArray)(point)) {
	            var coord = new (Function.prototype.bind.apply(_jsts.geom.Coordinate, [null].concat(_toConsumableArray(point))))();
	
	            coords.push(coord);
	          }
	        }
	
	        if (coords.length >= 1) {
	          return _JTSUtils2.default.getFactory().createMultiPoint(coords);
	        }
	      }
	
	      return null;
	    }
	
	    /**
	     * 创建一个类型为MultiPolygon的Geometry对象，即多个多边形。
	     * @param  {Array[]} pointss     点坐标数组。
	     * @return {MultiPolygonGeometry} MultiPolygonGeometry对象。
	     */
	
	  }, {
	    key: 'createMultiPolygon',
	    value: function createMultiPolygon(pointss) {
	      if ((0, _lang.isArray)(pointss)) {
	        var polygons = [];
	
	        for (var _iterator4 = pointss, _isArray4 = Array.isArray(_iterator4), _i4 = 0, _iterator4 = _isArray4 ? _iterator4 : _iterator4[Symbol.iterator]();;) {
	          var _ref4;
	
	          if (_isArray4) {
	            if (_i4 >= _iterator4.length) break;
	            _ref4 = _iterator4[_i4++];
	          } else {
	            _i4 = _iterator4.next();
	            if (_i4.done) break;
	            _ref4 = _i4.value;
	          }
	
	          var points = _ref4;
	
	          var polygon = GeometryFactory.createPolygon(points);
	
	          if (polygon) {
	            polygons.push(polygon);
	          }
	        }
	
	        if (polygons.length >= 1) {
	          return _JTSUtils2.default.getFactory().createMultiPolygon(polygons);
	        }
	      }
	
	      return null;
	    }
	
	    /**
	     * 创建一个类型为MultiLineString的Geometry对象，即多条直线。
	     * @param  {Array[]} pointss     点坐标数组。
	     * @return {MultiLineStringGeometry} MultiLineStringGeometry对象。
	     */
	
	  }, {
	    key: 'createMultiLineString',
	    value: function createMultiLineString(pointss) {
	      if ((0, _lang.isArray)(pointss)) {
	        var lineStrings = [];
	
	        for (var _iterator5 = pointss, _isArray5 = Array.isArray(_iterator5), _i5 = 0, _iterator5 = _isArray5 ? _iterator5 : _iterator5[Symbol.iterator]();;) {
	          var _ref5;
	
	          if (_isArray5) {
	            if (_i5 >= _iterator5.length) break;
	            _ref5 = _iterator5[_i5++];
	          } else {
	            _i5 = _iterator5.next();
	            if (_i5.done) break;
	            _ref5 = _i5.value;
	          }
	
	          var points = _ref5;
	
	          var lineString = GeometryFactory.createPolygon(points);
	
	          if (lineString) {
	            lineStrings.push(lineString);
	          }
	        }
	
	        if (lineStrings.length >= 1) {
	          return _JTSUtils2.default.getFactory().createMultiLineString(lineStrings);
	        }
	      }
	
	      return null;
	    }
	  }]);
	
	  return GeometryFactory;
	}();
	
	exports.default = GeometryFactory;

/***/ }),
/* 36 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _Layer2 = __webpack_require__(37);
	
	var _Layer3 = _interopRequireDefault(_Layer2);
	
	var _FeatureCollection = __webpack_require__(23);
	
	var _FeatureCollection2 = _interopRequireDefault(_FeatureCollection);
	
	var _StyleGenerator = __webpack_require__(46);
	
	var _StyleGenerator2 = _interopRequireDefault(_StyleGenerator);
	
	var _jsts = __webpack_require__(5);
	
	var _JTSUtils = __webpack_require__(12);
	
	var _JTSUtils2 = _interopRequireDefault(_JTSUtils);
	
	var _GeometryTransFormer = __webpack_require__(157);
	
	var _GeometryTransFormer2 = _interopRequireDefault(_GeometryTransFormer);
	
	var _config = __webpack_require__(18);
	
	var _lang = __webpack_require__(4);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	/**
	 * 管理由Feature对象生成的图层类，可以用于增减图层中的Feature对象，或查找图层中符合条件的Feature对象。
	 * @extends {Layer}
	 * @memberOf NGR.layer
	 */
	var FeatureLayer = function (_Layer) {
	  _inherits(FeatureLayer, _Layer);
	
	  /**
	   * 构造方法。
	   * @param  {String}   name     图层名。
	   * @param  {Renderer} renderer 渲染器，用于管理配置图层内各种元素的样式，如文字的大小、颜色，不同形状的配色等。
	   */
	  function FeatureLayer(name, renderer) {
	    _classCallCheck(this, FeatureLayer);
	
	    var _this = _possibleConstructorReturn(this, (FeatureLayer.__proto__ || Object.getPrototypeOf(FeatureLayer)).call(this, name));
	
	    _this.features = new _FeatureCollection2.default(name);
	    _this._subHeight = 0.00001;
	    _this._zIndex = _this._subHeight;
	    if (renderer instanceof _StyleGenerator2.default) {
	      _this.renderer = renderer.generator(_this);
	    } else {
	      _this.renderer = renderer;
	    }
	    if (_config.enableQuadTree) {
	      _this._quadTree = new _jsts.index.quadtree.Quadtree();
	    }
	    _this.clickable = false;
	    _this._parent = null;
	    return _this;
	  }
	
	  /**
	   * 遍历图层内的所有Feature对象，并调用回调方法。传入的参数为
	   * Feature对象和对应的样式(Style)。
	   * @param  {Function} callback 回调方法。
	   * @return {undefined}
	   */
	
	
	  _createClass(FeatureLayer, [{
	    key: 'visit',
	    value: function visit(callback) {
	      var _this2 = this;
	
	      if (this.renderer) {
	        this.features.forEach(function (feature) {
	          return callback(feature, _this2.renderer.getStyle(feature));
	        }, this);
	      }
	    }
	
	    /**
	     * clickable getter.
	     * @ignore
	     * @return {Boolean} clickable.
	     */
	
	  }, {
	    key: 'addFeatures',
	
	
	    /**
	     * 在图层上添加一个FeatureCollection对象。
	     * @param {NGR.data.FeatureCollection} features FeatureCollection对象。
	     * @return {NGR.layer.FeatureLayer}             this。
	     */
	    value: function addFeatures(features) {
	      var featuresArray = features.features;
	
	      if (!(0, _lang.isArray)(featuresArray)) {
	        console.warn('Invalid Features');
	
	        return this;
	      }
	      for (var _iterator = featuresArray, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
	        var _ref;
	
	        if (_isArray) {
	          if (_i >= _iterator.length) break;
	          _ref = _iterator[_i++];
	        } else {
	          _i = _iterator.next();
	          if (_i.done) break;
	          _ref = _i.value;
	        }
	
	        var feature = _ref;
	
	        this.addFeature(feature);
	      }
	
	      return this;
	    }
	
	    /**
	     * coordinateSystem getter.
	     * @ignore
	     * @return {CoordinateSystem} coordinateSystem.
	     */
	
	  }, {
	    key: 'addFeature',
	
	
	    /**
	     * 在图层中增加Feature对象。
	     * @param {NGR.data.Feature} feature Feature对象。
	     * @return {NGR.layer.FeatureLayer}  this。
	     */
	    value: function addFeature(feature) {
	      return this._addFeature(feature, true);
	    }
	
	    /**
	     * Update a feature of the layer.
	     * @ignore
	     * @deprecated There are something to add to ThreeNode.
	     * @param  {NGR.data.Feature} feature Feature.
	     * @return {NGR.layer.FeatureLayer}   this.
	     */
	    // updateFeature(feature) {
	    //   if (feature && this._features.has(feature) && this.renderer) {
	    //     if (this._coordinateSystem && this._coordinateSystem.getOffset() && feature.hasOffset) {
	    //       this._offset(feature);
	    //     }
	    //     // if (update) {
	    //     //   this._features.updateFeature(feature);
	    //     // }
	    //     this.emit('updateFeature', this, feature, this.renderer.getStyle(feature));
	    //   }
	
	    //   return this;
	    // }
	
	    /**
	     * 在图层中删除Feature对象。
	     * @param  {NGR.data.Feature} feature Feature对象。
	     * @return {NGR.layer.FeatureLayer}   this。
	     */
	
	  }, {
	    key: 'removeFeature',
	    value: function removeFeature(feature) {
	      if (feature && this._features.has(feature)) {
	        if (feature.onRemove) {
	          feature.onRemove(this);
	        }
	        this._features.removeFeature(feature);
	        if (_config.enableQuadTree) {
	          this._quadTree.remove(feature.geometry.getEnvelopeInternal(), feature);
	        }
	        feature.parent = null;
	        this.emit('removeFeature', this, feature);
	      }
	
	      return this;
	    }
	
	    /**
	     * 清除图层中所有Feature对象。
	     * @return {NGR.layer.FeatureLayer} this。
	     */
	
	  }, {
	    key: 'clearFeatures',
	    value: function clearFeatures() {
	      if (this.features) {
	        var count = this.features.getFeatureCount();
	
	        this.features.parent = null;
	        for (var _index = count; _index >= 0; _index--) {
	          var feature = this.features.features[_index];
	
	          this.removeFeature(feature);
	        }
	      }
	
	      return this;
	    }
	
	    /**
	     * 根据Feature对象properties里的键值搜索对应的Feature对象。
	     * @param  {String} key   搜索条件的字段。
	     * @param  {Object} value 字段对应的值。
	     * @return {Array}        符合条件的Feature对象列表。
	     */
	
	  }, {
	    key: 'search',
	    value: function search(key, value) {
	      var temp = [];
	
	      for (var _iterator2 = this._features.features, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator]();;) {
	        var _ref2;
	
	        if (_isArray2) {
	          if (_i2 >= _iterator2.length) break;
	          _ref2 = _iterator2[_i2++];
	        } else {
	          _i2 = _iterator2.next();
	          if (_i2.done) break;
	          _ref2 = _i2.value;
	        }
	
	        var feature = _ref2;
	
	        var properties = feature.properties;
	        if (key in properties) {
	          if (value === properties[key]) {
	            temp.push(feature);
	          }
	        }
	      }
	
	      return temp;
	    }
	
	    /**
	     * 根据坐标搜索Feature对象。
	     * @param  {Number} x X轴坐标.
	     * @param  {Number} y Y轴坐标.
	     * @return {Array}    符合条件的Feature对象列表。
	     */
	
	  }, {
	    key: 'searchByPoint',
	    value: function searchByPoint(x, y) {
	      if (!_config.enableQuadTree) {
	        console.warn('FeatureLayer: quadTree is disabled');
	
	        return null;
	      }
	
	      var result = [];
	      var rect = [x, y];
	
	      if (!this.clickable) {
	
	        return result;
	      }
	
	      if (this._coordinateSystem) {
	        var offset = this._coordinateSystem.getOffset();
	        var _x = offset[0];
	        var _y = offset[1];
	
	        rect[0] += _x;
	        rect[1] += _y;
	      }
	      rect[2] = rect[0] + 0.01;
	      rect[3] = rect[1] + 0.01;
	      rect[0] -= 0.01;
	      rect[1] -= 0.01;
	
	      var querys = this._quadTree.query(new (Function.prototype.bind.apply(_jsts.geom.Envelope, [null].concat(rect)))());
	      var size = querys.size();
	
	      if (size > 0) {
	        var coord = _JTSUtils2.default.getFactory().createPoint(new _jsts.geom.Coordinate(rect[0] + 0.01, rect[1] + 0.01));
	
	        for (var _iterator3 = querys.array_, _isArray3 = Array.isArray(_iterator3), _i3 = 0, _iterator3 = _isArray3 ? _iterator3 : _iterator3[Symbol.iterator]();;) {
	          var _ref3;
	
	          if (_isArray3) {
	            if (_i3 >= _iterator3.length) break;
	            _ref3 = _iterator3[_i3++];
	          } else {
	            _i3 = _iterator3.next();
	            if (_i3.done) break;
	            _ref3 = _i3.value;
	          }
	
	          var feature = _ref3;
	
	          if (feature.geometry.contains(coord)) {
	            result.push(feature);
	          }
	        }
	      }
	      return result;
	    }
	
	    /**
	     * 根据id搜索对应的Feature对象。
	     * @param  {Number} value     Feature对象的id。
	     * @return {NGR.data.Feature} 符合条件的Feature对象。
	     */
	
	  }, {
	    key: 'searchById',
	    value: function searchById(value) {
	      return this._features.getFeatureById(value);
	    }
	
	    /**
	     * Add feature to the layer.
	     * @private
	     * @param {NGR.data.Feature} feature Feature.
	     * @param {Boolean}          add     Whether add the passed feature to feature collection of the layer.
	     * @return {NGR.layer.FeatureLayer}  this.
	     */
	
	  }, {
	    key: '_addFeature',
	    value: function _addFeature(feature, add) {
	      if (feature && !this._features.has(feature) && this.renderer) {
	        if (feature.onAdd && !feature.onAdd(this)) {
	
	          return this;
	        }
	        if (this._coordinateSystem && this._coordinateSystem.getOffset() && feature.hasOffset) {
	          this._offset(feature);
	        }
	        if (add) {
	          this._features.addFeature(feature);
	        }
	        if (_config.enableQuadTree) {
	          this._quadTree.insert(feature.geometry.getEnvelopeInternal(), feature);
	        }
	        feature.parent = this;
	        this.emit('addFeature', this, feature, this.renderer.getStyle(feature));
	      }
	
	      return this;
	    }
	
	    /**
	     * Offset the coordinates fo the passed feature.
	     * @private
	     * @param  {NGR.data.Feature} feature Feature.
	     * @return {NGR.layer.FeatureLayer}   this.
	     */
	
	  }, {
	    key: '_offset',
	    value: function _offset(feature) {
	      if (this._coordinateSystem && this._coordinateSystem.getOffset() && feature.hasOffset) {
	        var offset = this._coordinateSystem.getOffset();
	        var x = offset[0];
	        var y = offset[1];
	
	        var transFormer = new _GeometryTransFormer2.default(function (coords /* , parent*/) {
	          for (var _iterator4 = coords.coordinates, _isArray4 = Array.isArray(_iterator4), _i4 = 0, _iterator4 = _isArray4 ? _iterator4 : _iterator4[Symbol.iterator]();;) {
	            var _ref4;
	
	            if (_isArray4) {
	              if (_i4 >= _iterator4.length) break;
	              _ref4 = _iterator4[_i4++];
	            } else {
	              _i4 = _iterator4.next();
	              if (_i4.done) break;
	              _ref4 = _i4.value;
	            }
	
	            var coordinate = _ref4;
	
	            coordinate.x += x;
	            coordinate.y += y;
	          }
	
	          return coords;
	        });
	        feature.geometry = transFormer.transform(feature.geometry);
	        // feature.geometry.translate(offset[0], offset[1]);
	        feature.geometry.zIndex = this._zIndex;
	        this._zIndex += this._subHeight;
	        feature.hasOffset = false;
	      }
	
	      return this;
	    }
	  }, {
	    key: 'clickable',
	    get: function get() {
	      return this._clickable;
	    }
	
	    /**
	     * clickable setter.
	     * @ignore
	     * @param  {Boolean} clickable clickable.
	     */
	    ,
	    set: function set(clickable) {
	      this._clickable = clickable;
	    }
	
	    /**
	     * renderer getter.
	     * @ignore
	     * @return {Renderer} Renderer.
	     */
	
	  }, {
	    key: 'renderer',
	    get: function get() {
	      return this._renderer;
	    }
	
	    /**
	     * rederer setter.
	     * @ignore
	     * @param  {Renderer} renderer Renderer.
	     */
	    ,
	    set: function set(renderer) {
	      this._renderer = renderer;
	    }
	
	    /**
	     * features getter.
	     * @ignore
	     * @return {FeatureCollection} features.
	     */
	
	  }, {
	    key: 'features',
	    get: function get() {
	      return this._features;
	    }
	
	    /**
	     * 设置FeatureCollection对象。用新的feature对象替换图层中已有的feature对象。
	     * @type {NGR.data.FeatureCollection}
	     * @param  {NGR.data.FeatureCollection} features FeatureCollection对象。
	     */
	    ,
	    set: function set(features) {
	      var featuresArray = features.features;
	
	      if (!(0, _lang.isArray)(featuresArray)) {
	        console.warn('Invalid Features');
	
	        return;
	      }
	
	      this.clearFeatures();
	      for (var _iterator5 = featuresArray, _isArray5 = Array.isArray(_iterator5), _i5 = 0, _iterator5 = _isArray5 ? _iterator5 : _iterator5[Symbol.iterator]();;) {
	        var _ref5;
	
	        if (_isArray5) {
	          if (_i5 >= _iterator5.length) break;
	          _ref5 = _iterator5[_i5++];
	        } else {
	          _i5 = _iterator5.next();
	          if (_i5.done) break;
	          _ref5 = _i5.value;
	        }
	
	        var feature = _ref5;
	
	        this._addFeature(feature, false);
	      }
	      this._features = features;
	    }
	  }, {
	    key: 'coordinateSystem',
	    get: function get() {
	      return this._coordinateSystem;
	    }
	
	    /**
	     * 设置图层的坐标系。
	     * @type {NGR.view.CoordinateSystem}
	     * @param {NGR.view.CoordinateSystem} coordinateSystem 坐标系对象。
	     */
	    ,
	    set: function set(coordinateSystem) {
	      this._coordinateSystem = coordinateSystem;
	    }
	
	    /**
	     * parent getter.
	     * @ignore
	     * @return {NGR.layer.LayerGroup} parent.
	     */
	
	  }, {
	    key: 'parent',
	    get: function get() {
	      return this._parent;
	    }
	
	    /**
	     * parent setter.
	     * @ignore
	     * @param  {NGR.layer.LayerGroup} parent Parent.
	     */
	    ,
	    set: function set(parent) {
	      this._parent = parent;
	    }
	  }]);
	
	  return FeatureLayer;
	}(_Layer3.default);
	
	exports.default = FeatureLayer;

/***/ }),
/* 37 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _NGRObject2 = __webpack_require__(7);
	
	var _NGRObject3 = _interopRequireDefault(_NGRObject2);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	/**
	 * 图层的基本类，用于创建图层对象的各种属性。其它渲染元素，如形状、线条对象等都放置在图层对象内。
	 * @extends {NGRObject}
	 */
	var Layer = function (_NGRObject) {
	  _inherits(Layer, _NGRObject);
	
	  /**
	   * 构造方法。
	   * @param  {String} name 图层名。
	   */
	  function Layer(name) {
	    _classCallCheck(this, Layer);
	
	    var _this = _possibleConstructorReturn(this, (Layer.__proto__ || Object.getPrototypeOf(Layer)).call(this));
	
	    _this.name = name;
	    _this.height = 0;
	    return _this;
	  }
	
	  _createClass(Layer, [{
	    key: 'height',
	    get: function get() {
	      return this._height;
	    },
	    set: function set(height) {
	      this._height = height;
	    }
	  }, {
	    key: 'name',
	    get: function get() {
	      return this._name;
	    },
	    set: function set(name) {
	      this._name = name;
	    }
	  }]);
	
	  return Layer;
	}(_NGRObject3.default);
	
	exports.default = Layer;

/***/ }),
/* 38 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _three = __webpack_require__(2);
	
	var THREE = _interopRequireWildcard(_three);
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	// import { geom } from '../../lib/jsts-libs/jsts.min';
	
	var xAxis = new THREE.Vector3(1, 0, 0); // eslint-disable-line no-unused-vars
	var yAxis = new THREE.Vector3(0, 1, 0); // eslint-disable-line no-unused-vars
	var zAxis = new THREE.Vector3(0, 0, 1); // eslint-disable-line no-unused-vars
	
	/**
	 * 数学计算方法类，包含各种计算方法，如获取向量夹角、位移等。
	 * @memberOf NGR.math
	 */
	
	var Math = function () {
	  function Math() {
	    _classCallCheck(this, Math);
	  }
	
	  _createClass(Math, null, [{
	    key: 'getRelCoord',
	
	    // static shapeToPointDistance(shape, point) {
	    //   let distance = NaN;
	    //   const coords = point.getCoordinates();
	    //   const closest = shape.getClosestPoint(coords);
	    //   if (closest) {
	    //     const dx = closest[0] - coords[0];
	    //     const dy = closest[1] - coords[1];
	    //     distance = window.Math.sqrt(dx * dx + dy * dy);
	    //   }
	    //   return distance;
	    // }
	    value: function getRelCoord(vec, axis1, axis2, axis3) {
	      var x = Math.projectOnVectorScalar(vec, axis1);
	      var y = Math.projectOnVectorScalar(vec, axis2);
	      var z = Math.projectOnVectorScalar(vec, axis3);
	      return new THREE.Vector3(x, y, z);
	    }
	  }, {
	    key: 'getRelCoordOnPlane',
	    value: function getRelCoordOnPlane(vec, axis1, axis2) {
	      var x = Math.projectOnVectorScalar(vec, axis1);
	      var y = Math.projectOnVectorScalar(vec, axis2);
	      return new THREE.Vector3(x, y, 0);
	    }
	  }, {
	    key: 'directionalAdd',
	    value: function directionalAdd(vec, dirVec, magnitude) {
	      var outputVec = vec.clone();
	      var unitDirVec = dirVec.clone();
	      unitDirVec.normalize();
	      outputVec.x += magnitude * unitDirVec.x;
	      outputVec.y += magnitude * unitDirVec.y;
	      outputVec.z += magnitude * unitDirVec.z;
	      return outputVec;
	    }
	  }, {
	    key: 'projectOnVectorScalar',
	    value: function projectOnVectorScalar(vec1, onVec2) {
	      return vec1.dot(onVec2) / onVec2.length();
	    }
	
	    // static findPositive90Rotation(vec) {
	    //  const RotatedVec = new THREE.Vector3();
	    //  RotatedVec.x = -vec.y;
	    //  RotatedVec.y = vec.x;
	    //  return RotatedVec;
	    // }
	
	  }, {
	    key: 'subVector',
	    value: function subVector(v1, v2) {
	      return {
	        x: v2.x - v1.x,
	        y: v2.y - v1.y,
	        z: v2.z - v1.z || 0
	      };
	    }
	  }, {
	    key: 'getAngle',
	    value: function getAngle(from, to) {
	      var theta = Math.getVectorDot(from, to) / window.Math.sqrt(Math.getLengthSq(from) * Math.getLengthSq(to));
	      return window.Math.acos(Math.clamp(theta, -1, 1));
	    }
	  }, {
	    key: 'angleTo',
	    value: function angleTo(v) {
	      var angle = window.Math.atan2(v.y, v.x);
	      if (angle < 0) {
	        angle += 2 * window.Math.PI;
	      }
	      return angle;
	    }
	  }, {
	    key: 'getVectorDot',
	    value: function getVectorDot(v1, v2) {
	      return v1.x * v2.x + v1.y * v2.y + v1.z * v2.z;
	    }
	  }, {
	    key: 'getLengthSq',
	    value: function getLengthSq(c) {
	      return c.x * c.x + c.y * c.y + c.z * c.z;
	    }
	  }, {
	    key: 'clamp',
	    value: function clamp(value, min, max) {
	      return window.Math.max(min, window.Math.min(max, value));
	    }
	  }]);
	
	  return Math;
	}();
	
	exports.default = Math;

/***/ }),
/* 39 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _AStarPath2 = __webpack_require__(69);
	
	var _AStarPath3 = _interopRequireDefault(_AStarPath2);
	
	var _AStarVertex = __webpack_require__(40);
	
	var _AStarVertex2 = _interopRequireDefault(_AStarVertex);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var AStarConnectionPath = function (_AStarPath) {
	  _inherits(AStarConnectionPath, _AStarPath);
	
	  function AStarConnectionPath(connection, loader, reverse) {
	    _classCallCheck(this, AStarConnectionPath);
	
	    var _this = _possibleConstructorReturn(this, (AStarConnectionPath.__proto__ || Object.getPrototypeOf(AStarConnectionPath)).call(this));
	
	    _this._connection = connection;
	    if (!reverse) {
	      _this.from = new _AStarVertex2.default(connection.from, loader);
	      _this.to = new _AStarVertex2.default(connection.to, loader);
	    } else {
	      _this.from = new _AStarVertex2.default(connection.to, loader);
	      _this.to = new _AStarVertex2.default(connection.from, loader);
	    }
	    return _this;
	  }
	
	  _createClass(AStarConnectionPath, [{
	    key: 'connection',
	    get: function get() {
	      return this._connection;
	    }
	  }, {
	    key: 'weight',
	    get: function get() {
	      return this._connection.rank;
	    }
	  }, {
	    key: 'altitude',
	    get: function get() {
	      return this.to.vertex.altitude;
	    }
	  }]);
	
	  return AStarConnectionPath;
	}(_AStarPath3.default);
	
	exports.default = AStarConnectionPath;

/***/ }),
/* 40 */
/***/ (function(module, exports) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var AStarVertex = function () {
	  function AStarVertex(vertex, vertexLoader) {
	    _classCallCheck(this, AStarVertex);
	
	    this._vertex = vertex;
	    this._vertexLoader = vertexLoader;
	    this.needCalcExtraPath = false;
	    this.g = 0;
	    this.h = 0;
	  }
	
	  _createClass(AStarVertex, [{
	    key: "findPath",
	    value: function findPath(to) {
	      return this._paths.get(to.vertex.id);
	    }
	  }, {
	    key: "_loadPaths",
	    value: function _loadPaths() {
	      var _this = this;
	
	      if (!this._paths) {
	        this._paths = new Map();
	        this._vertexLoader.loadPaths(this.vertex, this.needCalcExtraPath).forEach(function (e) {
	          _this._paths.set(e.to.vertex.id, e);
	        });
	      }
	    }
	  }, {
	    key: "toString",
	    value: function toString() {
	      return this.vertex.toString();
	    }
	  }, {
	    key: "equals",
	    value: function equals(o) {
	      if (this === o) {
	        return true;
	      }
	
	      if (!o) {
	        return false;
	      }
	      return this.vertex.equals(o.vertex);
	    }
	  }, {
	    key: "parent",
	    get: function get() {
	      return this._parent;
	    },
	    set: function set(parent) {
	      this._parent = parent;
	    }
	  }, {
	    key: "vertex",
	    get: function get() {
	      return this._vertex;
	    }
	  }, {
	    key: "paths",
	    get: function get() {
	      this._loadPaths();
	      return this._paths.values();
	    }
	  }, {
	    key: "g",
	    get: function get() {
	      return this._g;
	    },
	    set: function set(g) {
	      this._g = g;
	    }
	  }, {
	    key: "h",
	    get: function get() {
	      return this._h;
	    },
	    set: function set(h) {
	      this._h = h;
	    }
	  }, {
	    key: "needCalcExtraPath",
	    get: function get() {
	      return this._needCalcExtraPath;
	    },
	    set: function set(needCalcExtraPath) {
	      this._needCalcExtraPath = needCalcExtraPath;
	    }
	  }], [{
	    key: "compareTo",
	    value: function compareTo(o1, o2) {
	      return o1.g + o1.h - o2.g - o2.h > 0 ? -1 : 1;
	    }
	  }]);
	
	  return AStarVertex;
	}();
	
	exports.default = AStarVertex;

/***/ }),
/* 41 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var inherits = __webpack_require__(3)
	  , EventEmitter = __webpack_require__(8).EventEmitter
	  ;
	
	var debug = function() {};
	if (true) {
	  debug = __webpack_require__(6)('sockjs-client:receiver:xhr');
	}
	
	function XhrReceiver(url, AjaxObject) {
	  debug(url);
	  EventEmitter.call(this);
	  var self = this;
	
	  this.bufferPosition = 0;
	
	  this.xo = new AjaxObject('POST', url, null);
	  this.xo.on('chunk', this._chunkHandler.bind(this));
	  this.xo.once('finish', function(status, text) {
	    debug('finish', status, text);
	    self._chunkHandler(status, text);
	    self.xo = null;
	    var reason = status === 200 ? 'network' : 'permanent';
	    debug('close', reason);
	    self.emit('close', null, reason);
	    self._cleanup();
	  });
	}
	
	inherits(XhrReceiver, EventEmitter);
	
	XhrReceiver.prototype._chunkHandler = function(status, text) {
	  debug('_chunkHandler', status);
	  if (status !== 200 || !text) {
	    return;
	  }
	
	  for (var idx = -1; ; this.bufferPosition += idx + 1) {
	    var buf = text.slice(this.bufferPosition);
	    idx = buf.indexOf('\n');
	    if (idx === -1) {
	      break;
	    }
	    var msg = buf.slice(0, idx);
	    if (msg) {
	      debug('message', msg);
	      this.emit('message', msg);
	    }
	  }
	};
	
	XhrReceiver.prototype._cleanup = function() {
	  debug('_cleanup');
	  this.removeAllListeners();
	};
	
	XhrReceiver.prototype.abort = function() {
	  debug('abort');
	  if (this.xo) {
	    this.xo.close();
	    debug('close');
	    this.emit('close', null, 'user');
	    this.xo = null;
	  }
	  this._cleanup();
	};
	
	module.exports = XhrReceiver;


/***/ }),
/* 42 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var inherits = __webpack_require__(3)
	  , XhrDriver = __webpack_require__(94)
	  ;
	
	function XHRCorsObject(method, url, payload, opts) {
	  XhrDriver.call(this, method, url, payload, opts);
	}
	
	inherits(XHRCorsObject, XhrDriver);
	
	XHRCorsObject.enabled = XhrDriver.enabled && XhrDriver.supportsCORS;
	
	module.exports = XHRCorsObject;


/***/ }),
/* 43 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _Layer2 = __webpack_require__(37);
	
	var _Layer3 = _interopRequireDefault(_Layer2);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	/**
	 * 图层组，用来装载其它图层。允许图层组也是一个图层。
	 * @extends {Layer}
	 * @memberOf NGR.layer
	 */
	var LayerGroup = function (_Layer) {
	  _inherits(LayerGroup, _Layer);
	
	  /**
	   * 构造方法。
	   * @param  {String} name 图层组的名称。
	   */
	  function LayerGroup(name) {
	    _classCallCheck(this, LayerGroup);
	
	    var _this = _possibleConstructorReturn(this, (LayerGroup.__proto__ || Object.getPrototypeOf(LayerGroup)).call(this, name));
	
	    _this._layers = {};
	    return _this;
	  }
	
	  /**
	   * 向图层组添加图层。
	   * @param {Layer} layer 被添加的图层对象。
	   * @return {undefined}
	   */
	
	
	  _createClass(LayerGroup, [{
	    key: 'addLayer',
	    value: function addLayer(layer) {
	      if (!this.has(layer)) {
	        if (layer.parent) {
	          console.warn('addLayer: Existed parent');
	
	          return;
	        }
	        layer.parent = this;
	        this._layers[layer.name] = layer;
	        this.emit('addToGroup', this, layer);
	      }
	
	      return;
	    }
	
	    /**
	     * 在图层组中删除图层。
	     * @param  {Layer} layer 被删除的图层对象。
	     * @return {undefined}
	     */
	
	  }, {
	    key: 'removeLayer',
	    value: function removeLayer(layer) {
	      if (this.has(layer)) {
	        layer.parent = null;
	        delete this._layers[layer.name];
	        this.emit('removeToGroup', this, layer);
	      }
	    }
	
	    /**
	     * 根据图层名称获取图层组中对应图层。
	     * @param  {String} name 图层名称。
	     * @return {Layer}       图层。
	     */
	
	  }, {
	    key: 'getLayer',
	    value: function getLayer(name) {
	      return this._layers[name];
	    }
	
	    /**
	     * 遍历图层组内的图层。
	     * @param  {Function} fn 回调。
	     * @return {undefined}
	     */
	
	  }, {
	    key: 'foreach',
	    value: function foreach(fn) {
	      for (var name in this._layers) {
	        fn(name, this._layers[name]);
	      }
	    }
	
	    /**
	     * 检测图层组内是否包含某特定图层。
	     * @param  {Layer} layer 需要查找的特定图层对象。
	     * @return {Boolean}     存在则返回true，否则返回false。
	     */
	
	  }, {
	    key: 'has',
	    value: function has(layer) {
	      return !!layer && layer.name in this._layers;
	    }
	  }, {
	    key: 'searchFeature',
	    value: function searchFeature(layerId, featureId) {
	      for (var layerName in this._layers) {
	        var layer = this._layers[layerName];
	        var feature = null;
	
	        if (layer instanceof LayerGroup) {
	          feature = layer.searchFeature(layerId, featureId);
	        } else if (layer.id === layerId) {
	          feature = layer.searchById(featureId);
	        }
	
	        if (feature) {
	          return feature;
	        }
	      }
	
	      return null;
	    }
	  }]);
	
	  return LayerGroup;
	}(_Layer3.default);
	
	exports.default = LayerGroup;

/***/ }),
/* 44 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _AStarPath2 = __webpack_require__(69);
	
	var _AStarPath3 = _interopRequireDefault(_AStarPath2);
	
	var _AStarVertex = __webpack_require__(40);
	
	var _AStarVertex2 = _interopRequireDefault(_AStarVertex);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var AStarLanePath = function (_AStarPath) {
	  _inherits(AStarLanePath, _AStarPath);
	
	  function AStarLanePath(path, vertexLoader, reverse) {
	    _classCallCheck(this, AStarLanePath);
	
	    var _this = _possibleConstructorReturn(this, (AStarLanePath.__proto__ || Object.getPrototypeOf(AStarLanePath)).call(this));
	
	    _this._path = path;
	    _this._reverse = reverse;
	    if (!reverse) {
	      _this.from = new _AStarVertex2.default(path.from, vertexLoader);
	      _this.to = new _AStarVertex2.default(path.to, vertexLoader);
	    } else {
	      _this.from = new _AStarVertex2.default(path.to, vertexLoader);
	      _this.to = new _AStarVertex2.default(path.from, vertexLoader);
	    }
	    return _this;
	  }
	
	  _createClass(AStarLanePath, [{
	    key: 'path',
	    get: function get() {
	      return this._path;
	    }
	  }, {
	    key: 'reverse',
	    get: function get() {
	      return this._reverse;
	    }
	  }, {
	    key: 'weight',
	    get: function get() {
	      return this._path.shape.getLength() * (this._path.rank + 1);
	    }
	  }, {
	    key: 'altitude',
	    get: function get() {
	      return this._path.altitude;
	    }
	  }]);
	
	  return AStarLanePath;
	}(_AStarPath3.default);
	
	exports.default = AStarLanePath;

/***/ }),
/* 45 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _assign = __webpack_require__(1);
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _JTSParser = __webpack_require__(67);
	
	var _JTSParser2 = _interopRequireDefault(_JTSParser);
	
	var _AStar = __webpack_require__(172);
	
	var _AStar2 = _interopRequireDefault(_AStar);
	
	var _DefaultG = __webpack_require__(70);
	
	var _DefaultG2 = _interopRequireDefault(_DefaultG);
	
	var _DefaultH = __webpack_require__(175);
	
	var _DefaultH2 = _interopRequireDefault(_DefaultH);
	
	var _VertexLoader = __webpack_require__(178);
	
	var _VertexLoader2 = _interopRequireDefault(_VertexLoader);
	
	var _PathService = __webpack_require__(72);
	
	var _PathService2 = _interopRequireDefault(_PathService);
	
	var _AStarConnectionPath = __webpack_require__(39);
	
	var _AStarConnectionPath2 = _interopRequireDefault(_AStarConnectionPath);
	
	var _JTSUtils = __webpack_require__(12);
	
	var _JTSUtils2 = _interopRequireDefault(_JTSUtils);
	
	var _jsts = __webpack_require__(5);
	
	var _lang = __webpack_require__(4);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var _Promise = typeof Promise === 'undefined' ? __webpack_require__(20).Promise : Promise;
	// import AStarLanePath from './AStarLanePath';
	
	
	var naviIndex = 1;
	
	/**
	 * 导航控制类，用于获取导航数据以进行导航路线规划。配合蓝牙或Wi-Fi定位数据，能够实现自动标注起始位置，最优路线规划等功能。配合控件类功能，可查看路线附近的公共设施。
	 * @memberOf NGR.navi
	 */
	
	var NavigateManager = function () {
	  /**
	   * 构造方法。
	   * @param  {NGR.data.DataSource} dataSource 数据源，包含各类请求。
	   * @param  {Object}              [options]  导航选项。
	   */
	  function NavigateManager(dataSource, options) {
	    _classCallCheck(this, NavigateManager);
	
	    this._dataSource = dataSource;
	    this._options = _assign({}, options || {});
	    var _options = this._options,
	        vertex = _options.vertex,
	        path = _options.path,
	        connection = _options.connection,
	        g = _options.g,
	        h = _options.h;
	
	    if (vertex && path && connection) {
	      var pathService = new _PathService2.default(vertex, path, connection);
	
	      this._astar = new _AStar2.default(g || new _DefaultG2.default(), h || new _DefaultH2.default(), new _VertexLoader2.default(pathService));
	      this._offLine = true;
	    }
	  }
	
	  /**
	   * 获取导航所需的数据，计算一个定位点到另一个定位点的路线。
	   * @param {Object} params 导航参数。
	   * @param {Number} params.from_x            起点x坐标。
	   * @param {Number} params.from_y            起点y坐标。
	   * @param {Number} params.from_planar_graph 起点所在的楼层id。
	   * @param {Number} params.to_x              终点x坐标。
	   * @param {Number} params.to_y              终点y坐标。
	   * @param {Number} params.to_planar_graph   终点所在的楼层id。
	   * @param {Array<Number>} params.planarGraphIdList   包含所有楼层id的列表。
	   * @return {Promise}                        通过Promise形式返回的导航数据。
	   */
	
	
	  _createClass(NavigateManager, [{
	    key: 'navigate',
	    value: function navigate(params) {
	      var _this = this;
	
	      if (this._offLine) {
	        return new _Promise(function (resolve, reject) {
	          try {
	            var from = _JTSUtils2.default.getFactory().createPoint(new _jsts.geom.Coordinate(params.from_x, params.from_y));
	            var to = _JTSUtils2.default.getFactory().createPoint(new _jsts.geom.Coordinate(params.to_x, params.to_y));
	            var aStarPaths = _this._astar.astar(from, params.from_planar_graph, to, params.to_planar_graph, params.planarGraphIdList || null);
	            var featureCollection = {};
	            var conectionPaths = [];
	            // const aStarConnectionPaths =aStarPaths.filter((e) => {
	            //   if (e instanceof AStarConnectionPath) {
	            //     return true;
	            //   }
	            //   return false;
	            // });
	            // const aStarLanePaths = aStarPaths.filter((e) => {
	            //   if (e instanceof AStarLanePath) {
	            //     return true;
	            //   }
	            //   return false;
	            // });
	
	            featureCollection.type = 'FeatureCollection';
	            featureCollection.features = [];
	            for (var index in aStarPaths) {
	              var path = aStarPaths[index];
	              var feature = {};
	
	              if (path instanceof _AStarConnectionPath2.default) {
	                conectionPaths.push(path);
	                continue;
	              }
	              feature.type = 'Feature';
	              feature.properties = {
	                planar_graph: path.from.vertex.planarGraphId,
	                hasTransitPoint: false,
	                poi: null
	              };
	              if (conectionPaths.length > 0) {
	                var prePath = featureCollection.features.pop();
	
	                if (prePath) {
	                  prePath.properties.poi = conectionPaths[0].connection.fromLocationId;
	                  featureCollection.features.push(prePath);
	                }
	                feature.properties.poi = conectionPaths.pop().connection.toLocationId;
	                conectionPaths = [];
	              }
	
	              var shape = path.path.shape;
	
	              if (path.reverse) {
	                var coordinates = shape.getCoordinates().map(function (_ref) {
	                  var x = _ref.x,
	                      y = _ref.y,
	                      z = _ref.z;
	                  return new _jsts.geom.Coordinate(x, y, z);
	                });
	
	                coordinates.reverse();
	                shape = new _jsts.geom.LineString(_JTSUtils2.default.getFactory().getCoordinateSequenceFactory().create(coordinates), _JTSUtils2.default.getFactory());
	              }
	              feature.geometry = _JTSUtils2.default.getGeoWriter().write(shape);
	              featureCollection.features.push(feature);
	            }
	            _this._rawNavigates = featureCollection;
	            _this._parseNavi(featureCollection);
	            resolve(_this._navigates);
	          } catch (e) {
	            reject(e);
	          }
	        });
	      }
	      return this._dataSource.requestNavigation(params).then(function (response) {
	        if ((0, _lang.isBoolean)(response)) {
	          return null;
	        }
	
	        _this._rawNavigates = response;
	        _this._parseNavi(response);
	
	        return _this._navigates;
	      });
	    }
	
	    /**
	     * 包含经停点信息的导航路线规划。
	     * @param  {Point[]} data 经停点列表，每个对象都包括x，y，planarGraphId属性，
	     *                        坐标要在WGS84 墨卡托投影坐标系内。
	     * @return {Promise}      通过Promise形式返回经停点导航数据。
	     */
	
	  }, {
	    key: 'transit',
	    value: function transit(data) {
	      var _this2 = this;
	
	      return this._dataSource.requestTransitNavigation(data).then(function (response) {
	        _this2._parseNavi(response);
	
	        return _this2._navigates;
	      });
	    }
	
	    // Navigate is a verb...
	    /**
	     * 获取指定楼层上的导航线数据。
	     * @param  {Number} planarGraph         楼层ID。
	     * @return {NGR.data.FeatureCollection} 导航线数据。
	     */
	
	  }, {
	    key: 'getNavigateByPlanarGraph',
	    value: function getNavigateByPlanarGraph(planarGraph) {
	      if (this._navigates) {
	        return this._navigates[planarGraph].copy();
	      }
	
	      return null;
	    }
	
	    /**
	     * 获取导航线上距离指定坐标点最近的点列表。可用于绘制导航线起点或重新规划导航路线。
	     * @param  {Number} planarGraphId  平面图id。
	     * @param  {Number} x              坐标点x轴坐标。
	     * @param  {Number} y              坐标点y轴坐标。
	     * @return {NGR.geom.Coordinate[]} 最近点列表。
	     */
	
	  }, {
	    key: 'getClosestPoints',
	    value: function getClosestPoints(planarGraphId, x, y) {
	      var factory = _JTSUtils2.default.getFactory();
	      var point = factory.createPoint(new _jsts.geom.Coordinate(x, y));
	      var routes = this._navigates[planarGraphId].features;
	      var lineStrings = routes.map(function (route) {
	        return route.geometry;
	      });
	      var multiLineString = factory.createMultiLineString(lineStrings);
	      var distanceOp = new _jsts.operation.distance.DistanceOp(multiLineString, point);
	      var points = distanceOp.nearestPoints();
	
	      // the last point is the input point itself
	      points.pop();
	
	      // modification of points will result in effect of LineString, so get the copy of points here
	      return points.map(function (coord) {
	        return coord.copy();
	      });
	    }
	
	    /**
	     * Get distance between 2 points.
	     * @ignore
	     * @param  {NGR.geom.Coordinate} p1 Point 1.
	     * @param  {NGR.geom.Coordinate} p2 Point 2.
	     * @return {Number}                 Distance.
	     */
	
	  }, {
	    key: '_getDistance',
	    value: function _getDistance(p1, p2) {
	      var distance = 0;
	
	      // To be compatible with Chrome 37.
	      if (Math.hypot) {
	        distance = Math.hypot(p2.x - p1.x, p2.y - p1.y);
	      } else {
	        distance = Math.sqrt(Math.pow(p2.x - p1.x, 2) + Math.pow(p2.y - p1.y, 2));
	      }
	
	      return distance;
	    }
	
	    /**
	     * Get distance between 2 points denoted with arrays.
	     * @ignore
	     * @param  {Array<Number>} a1 Point denoted with an 2-length-array.
	     * @param  {Array<Number>} a2 Point denoted with an 2-length-array.
	     * @return {Nubmer}           Distance.
	     */
	
	  }, {
	    key: '_getArrayPointsDistance',
	    value: function _getArrayPointsDistance(a1, a2) {
	      if (!a1 || !a2) {
	        return null;
	      }
	
	      var p1 = new _jsts.geom.Coordinate(a1[0], a1[1]);
	      var p2 = new _jsts.geom.Coordinate(a2[0], a2[1]);
	
	      return this._getDistance(p1, p2);
	    }
	
	    /**
	     * 获取导航线的总长度。
	     * @return {Number} 长度，单位米。
	     */
	
	  }, {
	    key: 'getWholeDistance',
	    value: function getWholeDistance() {
	      // let sum = 0;
	
	      // if (this._navigates) {
	      //   for (const planarGraphId in this._navigates) {
	      //     const distances = this.getDistancesByPlanarGraph(planarGraphId);
	      //     for (const distance of distances) {
	      //       sum += distance;
	      //     }
	      //   }
	      // }
	
	      // return sum;
	      var distances = this._distances;
	      var sum = 0;
	
	      if (distances) {
	        for (var PG in distances) {
	          var distance = distances[PG];
	
	          for (var _iterator = distance, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
	            var _ref2;
	
	            if (_isArray) {
	              if (_i >= _iterator.length) break;
	              _ref2 = _iterator[_i++];
	            } else {
	              _i = _iterator.next();
	              if (_i.done) break;
	              _ref2 = _i.value;
	            }
	
	            var d = _ref2;
	
	            sum += d;
	          }
	        }
	      }
	
	      return sum;
	    }
	
	    /**
	     * 获取指定楼层的每段导航线长度列表。
	     * @param  {Number} planarGraphId 楼层id。
	     * @return {Number[]}             长度列表。
	     */
	
	  }, {
	    key: 'getDistancesByPlanarGraph',
	    value: function getDistancesByPlanarGraph(planarGraphId) {
	      return this._distances ? this._distances[planarGraphId] : null;
	    }
	
	    /**
	     * 获取导航线经过楼层顺序的列表。
	     * @return {String[]|Number[]} 楼层顺序列表。
	     */
	
	  }, {
	    key: 'getPlanarGraphOrder',
	    value: function getPlanarGraphOrder() {
	      return this._naviOrder;
	    }
	
	    /**
	     * 获取指定楼层上经停点的导航数据。
	     * @param  {Number} planarGraph         楼层id。
	     * @return {NGR.data.FeatureCollection} FeatureCollection对象。
	     */
	
	  }, {
	    key: 'getTransitByPlanarGraph',
	    value: function getTransitByPlanarGraph(planarGraph) {
	      if (this._transit) {
	        return this._transit[planarGraph].copy();
	      }
	
	      return null;
	    }
	
	    /**
	     * 获取导航线经过的连通设施的信息。
	     * @return {Object} 连通设施的信息。
	     */
	
	  }, {
	    key: 'getConnectionInfo',
	    value: function getConnectionInfo() {
	      return this._connectionInfo;
	    }
	
	    /**
	     * 获取指定楼层的连通设施信息。
	     * @param  {Number} planarGraph 楼层Id。
	     * @return {Object}             连通设施的信息。
	     */
	
	  }, {
	    key: 'getConnectionInfoByPlanarGraph',
	    value: function getConnectionInfoByPlanarGraph(planarGraph) {
	      if (this._connectionInfo) {
	        return this._connectionInfo[planarGraph];
	      }
	
	      return null;
	    }
	  }, {
	    key: 'getRawFC',
	    value: function getRawFC() {
	      return this._rawNavigates;
	    }
	
	    /**
	     * Parse the raw navigation response text.
	     * @private
	     * @param  {Object} response Raw response JSON.
	     * @return {undefined}
	     */
	
	  }, {
	    key: '_parseNavi',
	    value: function _parseNavi(response) {
	      var tempNavigates = {};
	      var tempTransit = {};
	      var features = response.features;
	      var curPlanar = -1;
	      var curFeature = void 0;
	      var curDistance = 0;
	
	      this._navigates = {};
	      this._transit = {};
	      this._naviOrder = [];
	      this._connectionInfo = {};
	      this._distances = {};
	
	      for (var _iterator2 = features, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator]();;) {
	        var _ref3;
	
	        if (_isArray2) {
	          if (_i2 >= _iterator2.length) break;
	          _ref3 = _iterator2[_i2++];
	        } else {
	          _i2 = _iterator2.next();
	          if (_i2.done) break;
	          _ref3 = _i2.value;
	        }
	
	        var feature = _ref3;
	        var properties = feature.properties,
	            coordinates = feature.geometry.coordinates;
	        var hasTransitPoint = properties.hasTransitPoint,
	            poi = properties.poi,
	            planarGraphId = properties.planar_graph;
	
	        var oldPlanarGraphthis = this._naviOrder[this._naviOrder.length - 1];
	
	        if (oldPlanarGraphthis !== planarGraphId) {
	          this._naviOrder.push(planarGraphId);
	          this._connectionInfo[planarGraphId] = [];
	          this._distances[planarGraphId] = [];
	          if (this._distances[oldPlanarGraphthis]) {
	            this._distances[oldPlanarGraphthis].push(curDistance);
	          }
	          curDistance = 0;
	        }
	        if (planarGraphId) {
	          var featureCollection = this._createFs(planarGraphId, tempNavigates);
	
	          curFeature = this._createF(featureCollection, curFeature, planarGraphId, curPlanar, 'LineString', poi);
	          for (var _iterator3 = coordinates, _isArray3 = Array.isArray(_iterator3), _i3 = 0, _iterator3 = _isArray3 ? _iterator3 : _iterator3[Symbol.iterator]();;) {
	            var _ref4;
	
	            if (_isArray3) {
	              if (_i3 >= _iterator3.length) break;
	              _ref4 = _iterator3[_i3++];
	            } else {
	              _i3 = _iterator3.next();
	              if (_i3.done) break;
	              _ref4 = _i3.value;
	            }
	
	            var coordinate = _ref4;
	
	            var tempCoord = curFeature.geometry.coordinates[curFeature.geometry.coordinates.length - 1];
	            var tempDistance = this._getArrayPointsDistance(tempCoord, coordinate);
	
	            if (tempCoord && tempDistance < 0.01) {
	              continue;
	            }
	            curFeature.geometry.coordinates.push(coordinate.concat());
	            curDistance += tempDistance;
	          }
	        }
	        if (hasTransitPoint) {
	          var _featureCollection = this._createFs(planarGraphId, tempTransit);
	          var tempFeature = this._createF(_featureCollection, null, planarGraphId, -1, 'Point');
	          var _coordinate = coordinates[coordinates.length - 1];
	
	          delete tempFeature.properties.poi;
	          tempFeature.geometry.coordinates.push(_coordinate.concat());
	        }
	        if (poi) {
	          this._connectionInfo[planarGraphId].push(_assign({}, properties));
	        }
	        curPlanar = planarGraphId;
	      }
	      this._distances[curPlanar].push(curDistance);
	      for (var navigate in tempNavigates) {
	        this._navigates[navigate] = _JTSParser2.default.parse(navigate, tempNavigates[navigate]);
	      }
	      for (var _navigate in tempTransit) {
	        this._transit[_navigate] = _JTSParser2.default.parse(_navigate, tempTransit[_navigate]);
	      }
	    }
	  }, {
	    key: '_createFs',
	    value: function _createFs(flag, navigates) {
	      var featureCollection = navigates[flag];
	
	      if (!featureCollection) {
	        featureCollection = {
	          type: 'FeatureCollection',
	          features: []
	        };
	        navigates[flag] = featureCollection;
	      }
	
	      return featureCollection;
	    }
	
	    /**
	     * Create a feature for navigation line. Id and poi will be assigned in this funciton.
	     * @private
	     * @param  {NGR.data.FeatureCollection} featureCollection FeatureCollection.
	     * @param  {NGR.data.Feature}           feature           Feature.
	     * @param  {Number}                     flag1             Flag to determine feture structure.
	     * @param  {Number}                     flag2             Flag to determine feture structure.
	     * @param  {String}                     type              Feature type.
	     * @param  {Number|String}              poi               Poi id.
	     * @return {NGR.data.Feature}                             Feature.
	     */
	
	  }, {
	    key: '_createF',
	    value: function _createF(featureCollection, feature, flag1, flag2, type, poi) {
	      var temp = feature;
	
	      if (flag1 !== flag2) {
	        temp = {
	          type: 'Feature',
	          properties: {
	            id: naviIndex++,
	            poi: [poi]
	          },
	          geometry: {
	            type: type,
	            coordinates: []
	          }
	        };
	        featureCollection.features.push(temp);
	      } else {
	        temp.properties.poi[1] = poi;
	      }
	
	      return temp;
	    }
	  }]);
	
	  return NavigateManager;
	}();
	
	exports.default = NavigateManager;

/***/ }),
/* 46 */
/***/ (function(module, exports) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	/**
	 * 样式生成器。
	 * @ignore
	 */
	var StyleGenerator = function () {
	  function StyleGenerator() {
	    _classCallCheck(this, StyleGenerator);
	  }
	
	  _createClass(StyleGenerator, [{
	    key: "generator",
	
	    /**
	     * 生成样式。
	     * @ignore
	     * @param  {NGR.layer.Layer} layer 数据层
	     * @return {Renderer}              渲染器。
	     */
	    value: function generator(layer) {
	      console.log("Please set StyleGenerator to " + layer.name + " Layer");
	    }
	  }]);
	
	  return StyleGenerator;
	}();
	
	exports.default = StyleGenerator;

/***/ }),
/* 47 */
/***/ (function(module, exports) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var Touch = function () {
	  function Touch() {
	    _classCallCheck(this, Touch);
	
	    this.clientX = this.clientY = this.pageX = this.pageY = 0;
	  }
	
	  _createClass(Touch, [{
	    key: "clientX",
	    get: function get() {
	      return this._clientX;
	    },
	    set: function set(clientX) {
	      this._clientX = clientX;
	    }
	  }, {
	    key: "clientY",
	    get: function get() {
	      return this._clientY;
	    },
	    set: function set(clientY) {
	      this._clientY = clientY;
	    }
	  }, {
	    key: "pageX",
	    get: function get() {
	      return this._pageX;
	    },
	    set: function set(pageX) {
	      this._pageX = pageX;
	    }
	  }, {
	    key: "pageY",
	    get: function get() {
	      return this._pageY;
	    },
	    set: function set(pageY) {
	      this._pageY = pageY;
	    }
	  }, {
	    key: "screenX",
	    get: function get() {
	      return this._screenX;
	    },
	    set: function set(screenX) {
	      this._screenX = screenX;
	    }
	  }, {
	    key: "screenY",
	    get: function get() {
	      return this._screenY;
	    },
	    set: function set(screenY) {
	      this._screenY = screenY;
	    }
	  }, {
	    key: "detail",
	    get: function get() {
	      return this._detail;
	    },
	    set: function set(detail) {
	      this._detail = detail;
	    }
	  }]);
	
	  return Touch;
	}();
	
	exports.default = Touch;

/***/ }),
/* 48 */
/***/ (function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var TouchEvent = function () {
	  function TouchEvent() {
	    _classCallCheck(this, TouchEvent);
	
	    this.touches = [];
	    this.type = 'none';
	    this.rotate = this.scale = 0;
	  }
	
	  _createClass(TouchEvent, [{
	    key: 'touches',
	    get: function get() {
	      return this._touchs;
	    },
	    set: function set(touches) {
	      this._touchs = touches;
	    }
	  }, {
	    key: 'type',
	    get: function get() {
	      return this._type;
	    },
	    set: function set(type) {
	      this._type = type;
	    }
	  }, {
	    key: 'rotate',
	    get: function get() {
	      return this._rotate;
	    },
	    set: function set(rotate) {
	      this._rotate = rotate;
	    }
	  }, {
	    key: 'scale',
	    get: function get() {
	      return this._scale;
	    },
	    set: function set(scale) {
	      this._scale = scale;
	    }
	  }, {
	    key: 'target',
	    get: function get() {
	      return this._target;
	    },
	    set: function set(target) {
	      this._target = target;
	    }
	  }]);
	
	  return TouchEvent;
	}();
	
	exports.default = TouchEvent;

/***/ }),
/* 49 */
/***/ (function(module, exports) {

	module.exports = {
		"name": "nagrand-webgl",
		"version": "2.17.8",
		"description": "",
		"main": "index.js",
		"scripts": {
			"webpack-dev": "webpack-dev-server --port 8080 --config ./scripts/webpack.config.babel.js --progress --display-error-details",
			"webpack-build": " webpack --progress --config ./scripts/webpack.config.babel.js",
			"start": "NODE_ENV=development BUILD_ENV=standard npm run webpack-dev",
			"build": "NODE_ENV=development BUILD_ENV=standard npm run webpack-build",
			"build-lite": "NODE_ENV=production BUILD_ENV=lite npm run webpack-build",
			"start:win": "set NODE_ENV=development&& set BUILD_ENV=standard&& npm run webpack-dev",
			"build:win": "set NODE_ENV=development&& set BUILD_ENV=standard&& npm run webpack-build",
			"build-lite:win": "set NODE_ENV=development&& set BUILD_ENV=lite&& npm run webpack-build",
			"prebuild": "npm run clean",
			"prebuild:win": "npm run clean",
			"clean": "rimraf ./build",
			"test": "mocha ./test/**/*.spec.js",
			"build-examples": "metalsmith",
			"jsdoc": "rimraf ./docs && jsdoc src lib/three-ext/planeLine lib/three-ext/tube -R src/README.md -r -c ./conf.json -d docs"
		},
		"config": {
			"commitizen": {
				"path": "cz-conventional-changelog"
			}
		},
		"author": "Palmap.Inc <sdk@palmaplus.com>",
		"license": "UNLICENSED",
		"devDependencies": {
			"babel-cli": "^6.10.1",
			"babel-eslint": "^6.1.2",
			"babel-loader": "^6.2.4",
			"babel-preset-es2015": "^6.24.0",
			"babel-preset-stage-3": "^6.11.0",
			"babel-plugin-transform-es2015-for-of": "^6.23.0",
			"babel-plugin-es6-promise": "^1.1.1",
			"babel-plugin-transform-object-rest-spread": "^6.23.0",
			"babel-polyfill": "^6.23.0",
			"babel-plugin-transform-class-properties": "^6.23.0",
			"chai": "^3.5.0",
			"css-loader": "^0.23.1",
			"cz-conventional-changelog": "^1.1.6",
			"debug": "^2.6.0",
			"docdash": "^0.4.0",
			"es6-promise": "^4.0.5",
			"eslint": "^3.3.1",
			"eslint-loader": "^1.4.1",
			"eslint-plugin-flow-vars": "^0.4.0",
			"extract-text-webpack-plugin": "^1.0.1",
			"file-loader": "^0.9.0",
			"handlebars": "^4.0.2",
			"html-loader": "^0.4.3",
			"html-webpack-plugin": "^2.22.0",
			"image-webpack-loader": "^2.0.0",
			"jsdoc": "^3.4.3",
			"json-loader": "^0.5.4",
			"metalsmith": "^2.3.0",
			"metalsmith-layouts": "1.8.0",
			"mocha": "^2.5.3",
			"postcss-loader": "^0.9.1",
			"rimraf": "^2.5.3",
			"style-loader": "^0.13.1",
			"url-loader": "^0.5.7",
			"webpack": "^1.13.1",
			"webpack-dev-server": "^1.14.1",
			"worker-loader": "^0.7.1"
		},
		"dependencies": {
			"object-assign": "^4.1.0",
			"rbush": "^2.0.1",
			"hammerjs": "^2.0.8",
			"string-hash": "^1.1.0",
			"priorityqueuejs": "^1.0.0",
			"tween.js": "~16.6.0",
			"polyline-normals": "^2.0.0",
			"three-line-2d": "^1.1.6",
			"as-number": "^1.0.0",
			"@hughsk/fulltilt": "^0.7.1"
		}
	};

/***/ }),
/* 50 */
/***/ (function(module, exports) {

	// shim for using process in browser
	var process = module.exports = {};
	
	// cached from whatever global is present so that test runners that stub it
	// don't break things.  But we need to wrap it in a try catch in case it is
	// wrapped in strict mode code which doesn't define any globals.  It's inside a
	// function because try/catches deoptimize in certain engines.
	
	var cachedSetTimeout;
	var cachedClearTimeout;
	
	function defaultSetTimout() {
	    throw new Error('setTimeout has not been defined');
	}
	function defaultClearTimeout () {
	    throw new Error('clearTimeout has not been defined');
	}
	(function () {
	    try {
	        if (typeof setTimeout === 'function') {
	            cachedSetTimeout = setTimeout;
	        } else {
	            cachedSetTimeout = defaultSetTimout;
	        }
	    } catch (e) {
	        cachedSetTimeout = defaultSetTimout;
	    }
	    try {
	        if (typeof clearTimeout === 'function') {
	            cachedClearTimeout = clearTimeout;
	        } else {
	            cachedClearTimeout = defaultClearTimeout;
	        }
	    } catch (e) {
	        cachedClearTimeout = defaultClearTimeout;
	    }
	} ())
	function runTimeout(fun) {
	    if (cachedSetTimeout === setTimeout) {
	        //normal enviroments in sane situations
	        return setTimeout(fun, 0);
	    }
	    // if setTimeout wasn't available but was latter defined
	    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
	        cachedSetTimeout = setTimeout;
	        return setTimeout(fun, 0);
	    }
	    try {
	        // when when somebody has screwed with setTimeout but no I.E. maddness
	        return cachedSetTimeout(fun, 0);
	    } catch(e){
	        try {
	            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
	            return cachedSetTimeout.call(null, fun, 0);
	        } catch(e){
	            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
	            return cachedSetTimeout.call(this, fun, 0);
	        }
	    }
	
	
	}
	function runClearTimeout(marker) {
	    if (cachedClearTimeout === clearTimeout) {
	        //normal enviroments in sane situations
	        return clearTimeout(marker);
	    }
	    // if clearTimeout wasn't available but was latter defined
	    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
	        cachedClearTimeout = clearTimeout;
	        return clearTimeout(marker);
	    }
	    try {
	        // when when somebody has screwed with setTimeout but no I.E. maddness
	        return cachedClearTimeout(marker);
	    } catch (e){
	        try {
	            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
	            return cachedClearTimeout.call(null, marker);
	        } catch (e){
	            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
	            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
	            return cachedClearTimeout.call(this, marker);
	        }
	    }
	
	
	
	}
	var queue = [];
	var draining = false;
	var currentQueue;
	var queueIndex = -1;
	
	function cleanUpNextTick() {
	    if (!draining || !currentQueue) {
	        return;
	    }
	    draining = false;
	    if (currentQueue.length) {
	        queue = currentQueue.concat(queue);
	    } else {
	        queueIndex = -1;
	    }
	    if (queue.length) {
	        drainQueue();
	    }
	}
	
	function drainQueue() {
	    if (draining) {
	        return;
	    }
	    var timeout = runTimeout(cleanUpNextTick);
	    draining = true;
	
	    var len = queue.length;
	    while(len) {
	        currentQueue = queue;
	        queue = [];
	        while (++queueIndex < len) {
	            if (currentQueue) {
	                currentQueue[queueIndex].run();
	            }
	        }
	        queueIndex = -1;
	        len = queue.length;
	    }
	    currentQueue = null;
	    draining = false;
	    runClearTimeout(timeout);
	}
	
	process.nextTick = function (fun) {
	    var args = new Array(arguments.length - 1);
	    if (arguments.length > 1) {
	        for (var i = 1; i < arguments.length; i++) {
	            args[i - 1] = arguments[i];
	        }
	    }
	    queue.push(new Item(fun, args));
	    if (queue.length === 1 && !draining) {
	        runTimeout(drainQueue);
	    }
	};
	
	// v8 likes predictible objects
	function Item(fun, array) {
	    this.fun = fun;
	    this.array = array;
	}
	Item.prototype.run = function () {
	    this.fun.apply(null, this.array);
	};
	process.title = 'browser';
	process.browser = true;
	process.env = {};
	process.argv = [];
	process.version = ''; // empty string to avoid regexp issues
	process.versions = {};
	
	function noop() {}
	
	process.on = noop;
	process.addListener = noop;
	process.once = noop;
	process.off = noop;
	process.removeListener = noop;
	process.removeAllListeners = noop;
	process.emit = noop;
	process.prependListener = noop;
	process.prependOnceListener = noop;
	
	process.listeners = function (name) { return [] }
	
	process.binding = function (name) {
	    throw new Error('process.binding is not supported');
	};
	
	process.cwd = function () { return '/' };
	process.chdir = function (dir) {
	    throw new Error('process.chdir is not supported');
	};
	process.umask = function() { return 0; };


/***/ }),
/* 51 */
/***/ (function(module, exports) {

	'use strict';
	
	function Event(eventType) {
	  this.type = eventType;
	}
	
	Event.prototype.initEvent = function(eventType, canBubble, cancelable) {
	  this.type = eventType;
	  this.bubbles = canBubble;
	  this.cancelable = cancelable;
	  this.timeStamp = +new Date();
	  return this;
	};
	
	Event.prototype.stopPropagation = function() {};
	Event.prototype.preventDefault = function() {};
	
	Event.CAPTURING_PHASE = 1;
	Event.AT_TARGET = 2;
	Event.BUBBLING_PHASE = 3;
	
	module.exports = Event;


/***/ }),
/* 52 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {'use strict';
	
	var inherits = __webpack_require__(3)
	  , IframeTransport = __webpack_require__(98)
	  , objectUtils = __webpack_require__(54)
	  ;
	
	module.exports = function(transport) {
	
	  function IframeWrapTransport(transUrl, baseUrl) {
	    IframeTransport.call(this, transport.transportName, transUrl, baseUrl);
	  }
	
	  inherits(IframeWrapTransport, IframeTransport);
	
	  IframeWrapTransport.enabled = function(url, info) {
	    if (!global.document) {
	      return false;
	    }
	
	    var iframeInfo = objectUtils.extend({}, info);
	    iframeInfo.sameOrigin = true;
	    return transport.enabled(iframeInfo) && IframeTransport.enabled();
	  };
	
	  IframeWrapTransport.transportName = 'iframe-' + transport.transportName;
	  IframeWrapTransport.needBody = true;
	  IframeWrapTransport.roundTrips = IframeTransport.roundTrips + transport.roundTrips - 1; // html, javascript (2) + transport - no CORS (1)
	
	  IframeWrapTransport.facadeTransport = transport;
	
	  return IframeWrapTransport;
	};
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ }),
/* 53 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {'use strict';
	
	var EventEmitter = __webpack_require__(8).EventEmitter
	  , inherits = __webpack_require__(3)
	  , eventUtils = __webpack_require__(17)
	  , browser = __webpack_require__(28)
	  , urlUtils = __webpack_require__(10)
	  ;
	
	var debug = function() {};
	if (true) {
	  debug = __webpack_require__(6)('sockjs-client:sender:xdr');
	}
	
	// References:
	//   http://ajaxian.com/archives/100-line-ajax-wrapper
	//   http://msdn.microsoft.com/en-us/library/cc288060(v=VS.85).aspx
	
	function XDRObject(method, url, payload) {
	  debug(method, url);
	  var self = this;
	  EventEmitter.call(this);
	
	  setTimeout(function() {
	    self._start(method, url, payload);
	  }, 0);
	}
	
	inherits(XDRObject, EventEmitter);
	
	XDRObject.prototype._start = function(method, url, payload) {
	  debug('_start');
	  var self = this;
	  var xdr = new global.XDomainRequest();
	  // IE caches even POSTs
	  url = urlUtils.addQuery(url, 't=' + (+new Date()));
	
	  xdr.onerror = function() {
	    debug('onerror');
	    self._error();
	  };
	  xdr.ontimeout = function() {
	    debug('ontimeout');
	    self._error();
	  };
	  xdr.onprogress = function() {
	    debug('progress', xdr.responseText);
	    self.emit('chunk', 200, xdr.responseText);
	  };
	  xdr.onload = function() {
	    debug('load');
	    self.emit('finish', 200, xdr.responseText);
	    self._cleanup(false);
	  };
	  this.xdr = xdr;
	  this.unloadRef = eventUtils.unloadAdd(function() {
	    self._cleanup(true);
	  });
	  try {
	    // Fails with AccessDenied if port number is bogus
	    this.xdr.open(method, url);
	    if (this.timeout) {
	      this.xdr.timeout = this.timeout;
	    }
	    this.xdr.send(payload);
	  } catch (x) {
	    this._error();
	  }
	};
	
	XDRObject.prototype._error = function() {
	  this.emit('finish', 0, '');
	  this._cleanup(false);
	};
	
	XDRObject.prototype._cleanup = function(abort) {
	  debug('cleanup', abort);
	  if (!this.xdr) {
	    return;
	  }
	  this.removeAllListeners();
	  eventUtils.unloadDel(this.unloadRef);
	
	  this.xdr.ontimeout = this.xdr.onerror = this.xdr.onprogress = this.xdr.onload = null;
	  if (abort) {
	    try {
	      this.xdr.abort();
	    } catch (x) {
	      // intentionally empty
	    }
	  }
	  this.unloadRef = this.xdr = null;
	};
	
	XDRObject.prototype.close = function() {
	  debug('close');
	  this._cleanup(true);
	};
	
	// IE 8/9 if the request target uses the same scheme - #79
	XDRObject.enabled = !!(global.XDomainRequest && browser.hasDomain());
	
	module.exports = XDRObject;
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ }),
/* 54 */
/***/ (function(module, exports) {

	'use strict';
	
	module.exports = {
	  isObject: function(obj) {
	    var type = typeof obj;
	    return type === 'function' || type === 'object' && !!obj;
	  }
	
	, extend: function(obj) {
	    if (!this.isObject(obj)) {
	      return obj;
	    }
	    var source, prop;
	    for (var i = 1, length = arguments.length; i < length; i++) {
	      source = arguments[i];
	      for (prop in source) {
	        if (Object.prototype.hasOwnProperty.call(source, prop)) {
	          obj[prop] = source[prop];
	        }
	      }
	    }
	    return obj;
	  }
	};


/***/ }),
/* 55 */
/***/ (function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var Emitter = function () {
	  function Emitter() {
	    _classCallCheck(this, Emitter);
	
	    this._callbacks = {};
	  }
	
	  /**
	   * Bind specified event
	   *
	   * @param {String} event The event name
	   * @param {Function} fn The callback
	   * @return {Emitter} emitter
	   */
	
	
	  _createClass(Emitter, [{
	    key: 'on',
	    value: function on(event, fn) {
	      var _callbacks = this._callbacks;
	      _callbacks[event] = _callbacks[event] || [];
	      _callbacks[event].push(fn);
	      return this;
	    }
	
	    /**
	     * Bind event and this event will be invoked a single time
	     *
	     * @param {String} event The event name
	     * @param {Function} fn The callback
	     * @return {Emitter} emitter
	     */
	
	  }, {
	    key: 'once',
	    value: function once(event, fn) {
	      var _this = this;
	
	      var on = function on() {
	        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	          args[_key] = arguments[_key];
	        }
	
	        _this.off(event, on);
	        fn.apply(_this, args);
	      };
	
	      on.fn = fn;
	      this.on(event, on);
	      return this;
	    }
	
	    /**
	     * Unbind specified event
	     *
	     * @param {String} event The event name
	     * @param {Function} fn The callback
	     * @return {Emitter} emitter
	     */
	
	  }, {
	    key: 'off',
	    value: function off(event, fn) {
	      var _callbacks = this._callbacks;
	
	      // Remove all binding events
	      if (typeof event === 'undefined') {
	        _callbacks = {};
	        return this;
	      }
	
	      // Do nothing when the event didn't binding
	      var callbacks = _callbacks[event];
	
	      if (!callbacks) {
	        return this;
	      }
	
	      // Remove specified event
	      if (typeof fn === 'undefined') {
	        delete _callbacks[event];
	        return this;
	      }
	
	      // Remove handler
	      for (var i = 0, len = callbacks.length; i < len; i++) {
	        var cb = callbacks[i];
	        if (cb === fn || cb.fn === fn) {
	          callbacks.splice(i, 1);
	          break;
	        }
	      }
	
	      return this;
	    }
	
	    /**
	     * Fire specified event
	     *
	     * @param {String} event The event name
	     * @param {Object} options The data should be
	     * @return {Emitter} emitter
	     */
	
	  }, {
	    key: 'emit',
	    value: function emit(event) {
	      var callbacks = this._callbacks[event];
	      var len = callbacks && callbacks.length;
	
	      if (len) {
	        for (var _len2 = arguments.length, options = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
	          options[_key2 - 1] = arguments[_key2];
	        }
	
	        for (var i = 0; i < len; i++) {
	          callbacks[i].apply(this, options);
	        }
	      }
	
	      return this;
	    }
	
	    /**
	     * Handlers for given event
	     *
	     * @param {String} event The event name
	     * @return {Array} return listeners by given event name
	     */
	
	  }, {
	    key: 'listeners',
	    value: function listeners(event) {
	      return this._callbacks[event] || [];
	    }
	
	    /**
	     * Check if the given event has handlers
	     *
	     * @param {String} event The event name
	     * @return {Boolean} checked result
	     */
	
	  }, {
	    key: 'hasListeners',
	    value: function hasListeners(event) {
	      return !!this.listeners(event).length;
	    }
	  }]);
	
	  return Emitter;
	}();
	
	exports.default = Emitter;

/***/ }),
/* 56 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var _Promise = typeof Promise === 'undefined' ? __webpack_require__(20).Promise : Promise;
	
	/* eslint-disable consistent-return */
	// https://fetch.spec.whatwg.org/#body-mixin
	
	var types = {
	  string: 'text/plain;charset=UTF-8',
	  json: 'application/json',
	  urlencoded: 'application/x-www-form-urlencoded;charset=UTF-8'
	};
	
	var supportBlob = 'FileReader' in self && 'Blob' in self;
	var supportFormData = 'FormData' in self;
	var supportArrayBuffer = 'ArrayBuffer' in self;
	var supportSearchParams = 'URLSearchParams' in self;
	
	function invokeReaderHandler(reader) {
	  return new _Promise(function (resolve, reject) {
	    reader.onloaded = function () {
	      return resolve(reader.result);
	    };
	    reader.onerror = function () {
	      return reject(reader.error);
	    };
	  });
	}
	
	function readBlobAsArrayBuffer(blob) {
	  var reader = new FileReader();
	  reader.readAsArrayBuffer(blob);
	  return invokeReaderHandler(reader);
	}
	
	function readBlobAsText(blob) {
	  var reader = new FileReader();
	  reader.readAsText(blob);
	  return invokeReaderHandler(reader);
	}
	
	function decode(body) {
	  var formData = new FormData();
	
	  body.trim().split('&').forEach(function (bytes) {
	    if (bytes) {
	      var split = bytes.split('=');
	      var name = split.shift().replace(/\+/g, ' ');
	      var value = split.join('=').replace(/\+/g, ' ');
	      formData.append(decodeURIComponent(name), decodeURIComponent(value));
	    }
	  });
	
	  return formData;
	}
	
	// https://fetch.spec.whatwg.org/#concept-body-consume-body
	function consumeBody(thisArg) {
	  if (thisArg.bodyUsed) {
	    return _Promise.reject(new TypeError('Body locked yet'));
	  }
	
	  thisArg.bodyUsed = true;
	}
	
	var Body = function () {
	  function Body() {
	    _classCallCheck(this, Body);
	
	    this.bodyUsed = false;
	  }
	
	  _createClass(Body, [{
	    key: '_initBody',
	    value: function _initBody(body) {
	      this._bodyInit = body;
	
	      if (typeof body === 'string') {
	        this._bodyText = body;
	      } else if (supportBlob && Blob.prototype.isPrototypeOf(body)) {
	        this._bodyBlob = body;
	      } else if (supportArrayBuffer && ArrayBuffer.prototype.isPrototypeOf(body)) {
	        // ...
	      } else if (supportFormData && FormData.prototype.isPrototypeOf(body)) {
	        this._bodyFormData = body;
	      } else if (supportSearchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
	        this._bodyText = body.toString();
	      } else if (!body) {
	        this._bodyText = '';
	      } else {
	        throw new Error('Unsupported body type');
	      }
	
	      if (!this.headers.get('Content-Type')) {
	        if (typeof body === 'string') {
	          try {
	            JSON.parse(body);
	            this.headers.set('Content-Type', types.json);
	          } catch (e) {
	            this.headers.set('Content-Type', types.string);
	          }
	        } else if (this._bodyBlob && this._bodyBlob.type) {
	          this.headers.set('Content-Type', this._bodyBlob.type);
	        } else if (supportSearchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
	          this.headers.set('Content-Type', types.urlencoded);
	        }
	      }
	    }
	  }, {
	    key: 'blob',
	    value: function blob() {
	      var rejected = consumeBody(this);
	
	      if (rejected) {
	        return rejected;
	      }
	
	      if (supportBlob) {
	        if (this._bodyBlob) {
	          return _Promise.resolve(this._bodyBlob);
	        } else if (this._bodyFormData) {
	          throw new Error('could not read formData body as blob');
	        } else {
	          return _Promise.resolve(new Blob([this._bodyText]));
	        }
	      }
	    }
	  }, {
	    key: 'arrayBuffer',
	    value: function arrayBuffer() {
	      return this.blob().then(readBlobAsArrayBuffer);
	    }
	  }, {
	    key: 'formData',
	    value: function formData() {
	      if (supportFormData) {
	        return this.text().then(decode);
	      }
	    }
	  }, {
	    key: 'json',
	    value: function json() {
	      return this.text().then(JSON.parse);
	    }
	  }, {
	    key: 'text',
	    value: function text() {
	      var rejected = consumeBody(this);
	
	      if (rejected) {
	        return rejected;
	      }
	
	      if (supportBlob) {
	        if (this._bodyBlob) {
	          return readBlobAsText(this._bodyBlob);
	        } else if (this._bodyFormData) {
	          throw new Error('could not read formData body as text');
	        }
	      }
	
	      return _Promise.resolve(this._bodyText);
	    }
	  }]);
	
	  return Body;
	}();
	/* eslint-enable consistent-return */
	
	
	exports.default = Body;

/***/ }),
/* 57 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _assign = __webpack_require__(1);
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };
	
	var _Body2 = __webpack_require__(56);
	
	var _Body3 = _interopRequireDefault(_Body2);
	
	var _Headers = __webpack_require__(31);
	
	var _Headers2 = _interopRequireDefault(_Headers);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	// https://fetch.spec.whatwg.org/#dom-request
	
	// https://fetch.spec.whatwg.org/#concept-method
	var methods = ['DELETE', 'GET', 'HEAD', 'OPTIONS', 'POST', 'PUT'];
	
	function normalizeMethod(method) {
	  var normalziedMethod = method.toUpperCase();
	
	  if (methods.indexOf(normalziedMethod) !== -1) {
	    return normalziedMethod;
	  }
	
	  throw new Error('invalid method name');
	}
	
	var initOptions = {
	  mode: 'cors',
	  method: 'GET',
	  credientials: 'omit'
	};
	
	var Request = function (_Body) {
	  _inherits(Request, _Body);
	
	  function Request(input, init) {
	    _classCallCheck(this, Request);
	
	    var _this = _possibleConstructorReturn(this, (Request.__proto__ || Object.getPrototypeOf(Request)).call(this));
	
	    var options = _assign({}, initOptions, init);
	
	    var body = init.body;
	
	    // this usage is probably only useful in ServiceWorkers.
	    if (Request.prototype.isPrototypeOf(input)) {
	      if (input.bodyUsed) {
	        throw new TypeError('Body already locked');
	      }
	
	      if (!body) {
	        body = input.body;
	        input.bodyUsed = true;
	      }
	
	      if (!options.headers) {
	        _this.headers = new _Headers2.default(input.headers);
	      }
	
	      _this.url = input.url;
	      _this.mode = input.mode;
	      _this.method = input.method;
	      _this.credientials = input.credientials;
	    } else {
	      _this.url = input;
	    }
	
	    _this.method = normalizeMethod(options.method || _this.method);
	
	    if (options.headers || !_this.headers) {
	      _this.headers = new _Headers2.default(options.headers);
	    }
	
	    _this.mode = options.mode || _this.mode;
	    _this.credientials = options.credientials || _this.credientials;
	    _this.referrer = null;
	
	    if ((_this.method === 'GET' || _this.method === 'HEAD') && body) {
	      throw new TypeError('Body not allowed for GET or HEAD requests');
	    }
	
	    _get(Request.prototype.__proto__ || Object.getPrototypeOf(Request.prototype), '_initBody', _this).call(_this, body);
	    return _this;
	  }
	
	  _createClass(Request, [{
	    key: 'clone',
	    value: function clone() {
	      return new Request(this);
	    }
	  }]);
	
	  return Request;
	}(_Body3.default);
	
	exports.default = Request;
	// export default self.Request ? self.Request : Request;

/***/ }),
/* 58 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } }; // https://fetch.spec.whatwg.org/#dom-response
	
	var _Body2 = __webpack_require__(56);
	
	var _Body3 = _interopRequireDefault(_Body2);
	
	var _Headers = __webpack_require__(31);
	
	var _Headers2 = _interopRequireDefault(_Headers);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	// https://fetch.spec.whatwg.org/#redirect-status
	var redirectStatus = [301, 302, 303, 307, 308];
	
	var responseInit = {
	  status: 200,
	  statusText: 'OK',
	  body: null,
	  type: 'default'
	};
	
	var Response = function (_Body) {
	  _inherits(Response, _Body);
	
	  function Response(body) {
	    var init = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : responseInit;
	
	    _classCallCheck(this, Response);
	
	    var _this = _possibleConstructorReturn(this, (Response.__proto__ || Object.getPrototypeOf(Response)).call(this));
	
	    if (init.status < 200 || init.status >= 599) {
	      throw new RangeError('Invalid response status code');
	    }
	
	    var status = init.status,
	        statusText = init.statusText,
	        headers = init.headers,
	        url = init.url;
	
	
	    _this.status = status;
	
	    // https://fetch.spec.whatwg.org/#ok-status
	    _this.ok = status >= 200 && _this.status < 300;
	    _this.statusText = statusText;
	    _this.headers = headers instanceof _Headers2.default ? headers : new _Headers2.default(headers);
	    _this.url = url;
	
	    _get(Response.prototype.__proto__ || Object.getPrototypeOf(Response.prototype), '_initBody', _this).call(_this, body);
	    return _this;
	  }
	
	  // Creates a clone of a Response object.
	
	
	  _createClass(Response, [{
	    key: 'clone',
	    value: function clone() {
	      var status = this.status,
	          statusText = this.statusText,
	          headers = this.headers,
	          url = this.url;
	
	      return new Response(this, {
	        status: status,
	        statusText: statusText,
	        headers: new _Headers2.default(headers),
	        url: url
	      });
	    }
	
	    // Returns a new Response object associated with a network error.
	    // https://fetch.spec.whatwg.org/#concept-network-error
	
	  }], [{
	    key: 'error',
	    value: function error() {
	      var response = new Response(null, {
	        status: 0,
	        statusText: ''
	      });
	
	      response.type = 'error';
	      return response;
	    }
	
	    // Creates a new response with a different URL.
	
	  }, {
	    key: 'redirect',
	    value: function redirect(url, status) {
	      if (redirectStatus.indexOf(status) === -1) {
	        throw new RangeError('Invalid redirect status code');
	      }
	
	      return new Response(null, {
	        status: status,
	        headers: {
	          location: url
	        }
	      });
	    }
	  }]);
	
	  return Response;
	}(_Body3.default);
	
	exports.default = Response;
	// export default self.Response ? self.Response : Response;

/***/ }),
/* 59 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _three = __webpack_require__(2);
	
	var THREE = _interopRequireWildcard(_three);
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	exports.default = {
	  center: new THREE.Vector2(0, 0),
	  left: new THREE.Vector2(1, 0),
	  topLeft: new THREE.Vector2(1, -1),
	  topRight: new THREE.Vector2(-1, -1),
	  right: new THREE.Vector2(-1, 0),
	  bottomLeft: new THREE.Vector2(1, 1),
	  bottomRight: new THREE.Vector2(-1, 1)
	};

/***/ }),
/* 60 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _assign = __webpack_require__(1);
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };
	
	var _Control2 = __webpack_require__(16);
	
	var _Control3 = _interopRequireDefault(_Control2);
	
	var _dom = __webpack_require__(11);
	
	var _lang = __webpack_require__(4);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	/**
	 * 楼层控件,用于选择和显示不同楼层。点击该控件后会展开所有可用楼层的楼层号。
	 * @eimits NGR.control.FloorControl#change
	 * @extends {NGR.control.Control}
	 * @memberOf NGR.control
	 */
	var FloorControl = function (_Control) {
	  _inherits(FloorControl, _Control);
	
	  /**
	   * 构造方法。
	   * @param  {Object}     [options]           控件选项,即构成控件的一些配置元素。
	   * @param  {HTMLElment} [options.element]   控件的DOM元素。
	   * @param  {String}     [options.name]      控件的名字，比如设置此参数为'name'，控件的名字为'floor-name'。
	   * @param  {String}     [options.className] 控件DOM元素的类名。
	   */
	  function FloorControl() {
	    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
	
	    _classCallCheck(this, FloorControl);
	
	    var name = options.name ? 'floor-' + options.name : 'floor';
	    var customClassName = options.className ? ' ' + options.className : '';
	
	    var _this = _possibleConstructorReturn(this, (FloorControl.__proto__ || Object.getPrototypeOf(FloorControl)).call(this, name, _assign({
	      position: 'bottomright'
	    }, options)));
	
	    if (_this._element) {
	      console.warn('FloorControl: Element will be overrided');
	    }
	
	    _this.floorMap = {};
	    _this.defaultFloor = null;
	    _this._element = _dom.DOMUtils.createElement('div', 'ngr-floor-switcher ngr-bar' + customClassName);
	
	    _this._onItemClick = _this._onItemClick.bind(_this);
	    return _this;
	  }
	
	  /**
	   * @override
	   */
	
	
	  _createClass(FloorControl, [{
	    key: '_onAdd',
	    value: function _onAdd(mapView) {
	      _get(FloorControl.prototype.__proto__ || Object.getPrototypeOf(FloorControl.prototype), '_onAdd', this).call(this, mapView);
	      this._setFloorList();
	      this._setCurrentFloor();
	
	      return this;
	    }
	
	    /**
	     * 设置楼层列表。
	     * @param {Floor[]} floorList         楼层列表。每一个楼层对象都需包含id和address属性。
	     * @return {NGR.control.FloorControl} this。
	     */
	
	  }, {
	    key: 'setFloorList',
	    value: function setFloorList(floorList) {
	      this.floorList = floorList;
	      this._setFloorList();
	
	      return this;
	    }
	  }, {
	    key: '_onItemClick',
	    value: function _onItemClick(e) {
	      e.preventDefault();
	      e.stopPropagation();
	
	      if (_dom.DOMUtils.hasClass(e.target, 'ngr-disabled')) {
	        return this;
	      }
	
	      /**
	       * 楼层切换事件。
	       * @event NGR.control.FloorControl#change
	       * @type {Object}
	       * @property {String|Number}            from          当前楼层。
	       * @property {String|Number}            to            目标楼层。
	       * @property {NGR.control.FloorControl} targetControl 触发事件的控件。
	       */
	      this.fire('change', {
	        from: this.currentFloor,
	        to: e.target.floor,
	        targetControl: this
	      });
	
	      return this;
	    }
	
	    /**
	     * Create items in element and make mapping.
	     * @private
	     * @return {NGR.control.FloorControl} FloorControl.
	     */
	
	  }, {
	    key: '_setFloorList',
	    value: function _setFloorList() {
	      if (this._map && this.floorList) {
	        // clear
	        this.floorMap = {};
	        while (this._element.firstChild) {
	          this._element.firstChild.removeEventListener('click', this._onItemClick);
	          this._element.removeChild(this._element.firstChild);
	        }
	
	        // create item and mapping
	        for (var _iterator = this.floorList, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
	          var _ref;
	
	          if (_isArray) {
	            if (_i >= _iterator.length) break;
	            _ref = _iterator[_i++];
	          } else {
	            _i = _iterator.next();
	            if (_i.done) break;
	            _ref = _i.value;
	          }
	
	          var floor = _ref;
	
	          var item = _dom.DOMUtils.createElement('a', '', this._element);
	
	          item.innerHTML = floor.address;
	          item.href = '#';
	          item.floor = floor.id;
	          item.altitude = floor.altitude;
	          item.addEventListener('click', this._onItemClick);
	          this.floorMap[floor.id] = item;
	        }
	      }
	
	      return this;
	    }
	
	    /**
	     * 获取当前楼层信息。
	     * @return {String|Number} 当前楼层。
	     */
	
	  }, {
	    key: 'getCurrentFloor',
	    value: function getCurrentFloor() {
	      return this.currentFloor;
	    }
	  }, {
	    key: '_disable',
	    value: function _disable(floorId) {
	      var item = this.floorMap[floorId];
	
	      if (item) {
	        _dom.DOMUtils.addClass(item, 'ngr-disabled');
	      }
	    }
	  }, {
	    key: '_enable',
	    value: function _enable(floorId) {
	      var item = this.floorMap[floorId];
	
	      if (item) {
	        _dom.DOMUtils.removeClass(item, 'ngr-disabled');
	      }
	    }
	  }, {
	    key: 'disable',
	    value: function disable(floorId) {
	      if ((0, _lang.isBlank)(floorId)) {
	        for (var key in this.floorMap) {
	          this._disable(key);
	        }
	      } else {
	        this._disable(floorId);
	      }
	
	      return this;
	    }
	  }, {
	    key: 'enable',
	    value: function enable(floorId) {
	      if ((0, _lang.isBlank)(floorId)) {
	        for (var key in this.floorMap) {
	          this._enable(key);
	        }
	      } else {
	        this._enable(floorId);
	      }
	
	      return this;
	    }
	  }, {
	    key: 'handleClass',
	    value: function handleClass(keys, className, callback) {
	      if ((0, _lang.isBlank)(className)) {
	        return this;
	      }
	
	      var _keys = [];
	
	      if ((0, _lang.isBlank)(keys)) {
	        for (var key in this.floorMap) {
	          _keys.push(key);
	        }
	      } else if ((0, _lang.isArray)(keys)) {
	        _keys = keys;
	      }
	
	      for (var _iterator2 = _keys, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator]();;) {
	        var _ref2;
	
	        if (_isArray2) {
	          if (_i2 >= _iterator2.length) break;
	          _ref2 = _iterator2[_i2++];
	        } else {
	          _i2 = _iterator2.next();
	          if (_i2.done) break;
	          _ref2 = _i2.value;
	        }
	
	        var _key = _ref2;
	
	        var item = this.floorMap[_key];
	
	        if (item) {
	          callback(item, className);
	        }
	      }
	
	      return this;
	    }
	  }, {
	    key: 'addClass',
	    value: function addClass(keys, className) {
	      return this.handleClass(keys, className, _dom.DOMUtils.addClass);
	    }
	  }, {
	    key: 'removeClass',
	    value: function removeClass(keys, className) {
	      return this.handleClass(keys, className, _dom.DOMUtils.removeClass);
	    }
	
	    /**
	     * 设置当前楼层，使之关联控件和楼层信息,之后调用回调方法。
	     * @param {String|Number}   floor      当前楼层id。
	     * @param {Function}        [callback] 回调方法，参数为当前楼层id。
	     * @return {NGR.control.FloorControl}  this。
	     */
	
	  }, {
	    key: 'setCurrentFloor',
	    value: function setCurrentFloor(floor, callback) {
	      this.currentFloor = floor;
	      this._setCurrentFloor();
	      if ((0, _lang.isFunction)(callback)) {
	        callback(floor);
	      }
	
	      return this;
	    }
	
	    /**
	     * Move class name 'selected' to current floor.
	     * @private
	     * @return {NGR.control.FloorControl} FloorControl.
	     */
	
	  }, {
	    key: '_setCurrentFloor',
	    value: function _setCurrentFloor() {
	      if (!this._map || !this._element) {
	        return this;
	      }
	
	      var selectedItem = this.floorMap[this.currentFloor];
	
	      if (selectedItem) {
	        for (var key in this.floorMap) {
	          var item = this.floorMap[key];
	
	          _dom.DOMUtils.removeClass(item, 'selected');
	        }
	        _dom.DOMUtils.addClass(selectedItem, 'selected');
	      }
	
	      return this;
	    }
	  }]);
	
	  return FloorControl;
	}(_Control3.default);
	
	exports.default = FloorControl;

/***/ }),
/* 61 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.DimensionControl = exports.ToggleControl = exports.MultiFloorControl = exports.FacilityControl = exports.ZoomControl = exports.SliderControl = exports.ScaleControl = exports.FloorControl = exports.Control = exports.CompassControl = undefined;
	
	var _CompassControl = __webpack_require__(145);
	
	var _CompassControl2 = _interopRequireDefault(_CompassControl);
	
	var _Control = __webpack_require__(16);
	
	var _Control2 = _interopRequireDefault(_Control);
	
	var _FloorControl = __webpack_require__(60);
	
	var _FloorControl2 = _interopRequireDefault(_FloorControl);
	
	var _ScaleControl = __webpack_require__(149);
	
	var _ScaleControl2 = _interopRequireDefault(_ScaleControl);
	
	var _SliderControl = __webpack_require__(150);
	
	var _SliderControl2 = _interopRequireDefault(_SliderControl);
	
	var _ZoomControl = __webpack_require__(151);
	
	var _ZoomControl2 = _interopRequireDefault(_ZoomControl);
	
	var _FacilityControl = __webpack_require__(147);
	
	var _FacilityControl2 = _interopRequireDefault(_FacilityControl);
	
	var _MultiFloorControl = __webpack_require__(148);
	
	var _MultiFloorControl2 = _interopRequireDefault(_MultiFloorControl);
	
	var _ToggleControl = __webpack_require__(33);
	
	var _ToggleControl2 = _interopRequireDefault(_ToggleControl);
	
	var _DimensionControl = __webpack_require__(146);
	
	var _DimensionControl2 = _interopRequireDefault(_DimensionControl);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.CompassControl = _CompassControl2.default;
	exports.Control = _Control2.default;
	exports.FloorControl = _FloorControl2.default;
	exports.ScaleControl = _ScaleControl2.default;
	exports.SliderControl = _SliderControl2.default;
	exports.ZoomControl = _ZoomControl2.default;
	exports.FacilityControl = _FacilityControl2.default;
	exports.MultiFloorControl = _MultiFloorControl2.default;
	exports.ToggleControl = _ToggleControl2.default;
	exports.DimensionControl = _DimensionControl2.default;

/***/ }),
/* 62 */
/***/ (function(module, exports) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	// import IdGenerator from './IdGenerator';
	// import NGRObject from './NGRObject';
	
	var CoordType = {
	  Screen: 1,
	  World: 2,
	  WGS84: 3
	};
	
	exports.CoordType = CoordType;

/***/ }),
/* 63 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _Feature = __webpack_require__(34);
	
	var _Feature2 = _interopRequireDefault(_Feature);
	
	var _FeatureCollection = __webpack_require__(23);
	
	var _FeatureCollection2 = _interopRequireDefault(_FeatureCollection);
	
	var _Layer = __webpack_require__(37);
	
	var _Layer2 = _interopRequireDefault(_Layer);
	
	var _Math = __webpack_require__(38);
	
	var _Math2 = _interopRequireDefault(_Math);
	
	var _jsts = __webpack_require__(5);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	/**
	 * 数据工具类,是有关数据操作便利的方法，用于获取数据、搜索信息等。
	 * @memberOf NGR.data
	 */
	var DataUtil = function () {
	  function DataUtil() {
	    _classCallCheck(this, DataUtil);
	  }
	
	  _createClass(DataUtil, null, [{
	    key: 'featurePolygon2Point',
	
	    /**
	     * 通过传入一个geometry属性为Polygon的feature对象，返回一个geometry属性为Point的feature对象。
	     * Point的坐标为Polygon的内部点。
	     * @static
	     * @ignore
	     * @param  {Feature} optFeature Feature对象。
	     * @param  {Boolean} interiorPoint 是否启用计算interiorPoint。
	     * @return {Feature}            Feature。
	     */
	    value: function featurePolygon2Point(optFeature) {
	      var interiorPoint = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
	
	      if (!(optFeature instanceof _Feature2.default)) {
	        console.warn('Invalid Feature');
	
	        return null;
	      }
	      var type = optFeature.geometry.getGeometryType();
	
	      if (type !== 'Polygon' && type !== 'MultiPolygon') {
	        console.warn('Invalid Geometry');
	
	        return null;
	      }
	
	      var properties = {};
	      var geometry = optFeature.geometry;
	
	      if (interiorPoint) {
	        geometry = geometry.getInteriorPoint();
	      } else {
	        var envelope = geometry.getEnvelopeInternal();
	
	        geometry = geometry.factory.createPoint(new _jsts.geom.Coordinate(envelope.minx + (envelope.maxx - envelope.minx) / 2, envelope.miny + (envelope.maxy - envelope.miny) / 2, 0));
	      }
	
	      for (var key in optFeature.properties) {
	        properties[key] = optFeature.properties[key];
	      }
	
	      return new _Feature2.default(geometry, properties);
	    }
	
	    /**
	     * 通过传入一个feature对象的geometry属性都为Polygon的featureCollection对象，返回一个feature对象
	     * 的geometry属性均为Point的featureCollection对象。Point的坐标都为对应Polygon的内部点。
	     * @static
	     * @ignore
	     * @param  {FeatureCollection} optFeatureCollection FeatureCollection对象。
	     * @param  {Boolean} interiorPoint 是否启用计算interiorPoint。
	     * @return {FeatureCollection}                      FeatureCollection。
	     */
	
	  }, {
	    key: 'featureCollectionPolygon2Point',
	    value: function featureCollectionPolygon2Point(optFeatureCollection) {
	      var interiorPoint = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
	
	      if (!(optFeatureCollection instanceof _FeatureCollection2.default)) {
	        console.warn('Invalid FeatureCollection');
	        return null;
	      }
	
	      var featureCollection = new _FeatureCollection2.default(optFeatureCollection.name);
	      var features = [];
	      var optFeature = void 0,
	          feature = void 0;
	
	      for (var _iterator = optFeatureCollection.features, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
	        if (_isArray) {
	          if (_i >= _iterator.length) break;
	          optFeature = _iterator[_i++];
	        } else {
	          _i = _iterator.next();
	          if (_i.done) break;
	          optFeature = _i.value;
	        }
	
	        feature = DataUtil.featurePolygon2Point(optFeature, interiorPoint);
	        if (feature) {
	          features.push(feature);
	        }
	      }
	      featureCollection.features = features;
	
	      return featureCollection;
	    }
	
	    // fzz you motherfucker
	
	  }, {
	    key: 'fuckYouBitch',
	    value: function fuckYouBitch(feature, fuckingHeight) {
	      var interiorPoint = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
	
	      if (!(feature instanceof _Feature2.default)) {
	        console.warn('f__k off');
	        return null;
	      }
	      var type = feature.geometry.getGeometryType();
	      var properties = {};
	      var geometry = feature.geometry;
	
	      if (type !== 'Polygon' && type !== 'MultiPolygon') {
	        console.warn('f__k off');
	        return null;
	      }
	
	      if (interiorPoint) {
	        geometry = geometry.getInteriorPoint();
	
	        var coord = geometry.getCoordinate();
	
	        coord.z = fuckingHeight || 0;
	      } else {
	        var envelope = geometry.getEnvelopeInternal();
	
	        geometry = geometry.factory.createPoint(new _jsts.geom.Coordinate(envelope.minx + (envelope.maxx - envelope.minx) / 2, envelope.miny + (envelope.maxy - envelope.miny) / 2, fuckingHeight || 0));
	      }
	
	      for (var key in feature.properties) {
	        properties[key] = feature.properties[key];
	      }
	
	      return new _Feature2.default(geometry, properties);
	    }
	
	    // fzz you motherfucker
	
	  }, {
	    key: 'kickYourAss',
	    value: function kickYourAss(featureCollection, fuckingLayer) {
	      var interiorPoint = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
	
	      if (!(featureCollection instanceof _FeatureCollection2.default) || !(fuckingLayer instanceof _Layer2.default)) {
	        console.warn('f__k off');
	        return null;
	      }
	
	      var newFeatureCollection = new _FeatureCollection2.default(fuckingLayer.features.name);
	      var features = [];
	
	      fuckingLayer.visit(function (fukingFeature, style) {
	        var feature = featureCollection.getFeatureById(fukingFeature.id);
	        var newFeature = DataUtil.fuckYouBitch(feature, style.height, interiorPoint);
	
	        if (newFeature) {
	          features.push(newFeature);
	        }
	      });
	
	      newFeatureCollection.features = features;
	
	      return newFeatureCollection;
	    }
	
	    /**
	     * 获取关键字位于源字符串中的位置下标。如果有多个位置，则返回多个索引。
	     * 如关键字“上、图”在字符串“上海图聚智能上”的位置，返回的下标为[0, 1, 2, 3, 6, 7]。每两个数字表示一个关键字在这个字符串中的位置。
	     * @param  {String[]} src     源字符串列表,用以表示搜索范围。
	     * @param  {String[]} keyword 关键词列表。
	     * @return {Array[]}          下标列表。
	     */
	
	  }, {
	    key: 'getHightLightOffset',
	    value: function getHightLightOffset(src, keyword) {
	      var result = [];
	
	      if (!(src instanceof Array && keyword instanceof Array && src.length > 0 && keyword.length > 0)) {
	        return result;
	      }
	      for (var _iterator2 = keyword, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator]();;) {
	        var _ref;
	
	        if (_isArray2) {
	          if (_i2 >= _iterator2.length) break;
	          _ref = _iterator2[_i2++];
	        } else {
	          _i2 = _iterator2.next();
	          if (_i2.done) break;
	          _ref = _i2.value;
	        }
	
	        var k = _ref;
	
	        if (typeof k !== 'string') {
	          return result;
	        }
	      }
	      for (var _iterator3 = src, _isArray3 = Array.isArray(_iterator3), _i3 = 0, _iterator3 = _isArray3 ? _iterator3 : _iterator3[Symbol.iterator]();;) {
	        var _ref2;
	
	        if (_isArray3) {
	          if (_i3 >= _iterator3.length) break;
	          _ref2 = _iterator3[_i3++];
	        } else {
	          _i3 = _iterator3.next();
	          if (_i3.done) break;
	          _ref2 = _i3.value;
	        }
	
	        var s = _ref2;
	
	        if (typeof s !== 'string') {
	          return result;
	        }
	        var offset = [];
	        result.push(offset);
	        for (var _iterator4 = keyword, _isArray4 = Array.isArray(_iterator4), _i4 = 0, _iterator4 = _isArray4 ? _iterator4 : _iterator4[Symbol.iterator]();;) {
	          var _ref3;
	
	          if (_isArray4) {
	            if (_i4 >= _iterator4.length) break;
	            _ref3 = _iterator4[_i4++];
	          } else {
	            _i4 = _iterator4.next();
	            if (_i4.done) break;
	            _ref3 = _i4.value;
	          }
	
	          var _k = _ref3;
	
	          var preOffset = 0;
	          var subOffset = 0;
	          while (preOffset >= 0) {
	            preOffset = s.indexOf(_k, subOffset);
	            subOffset = preOffset + _k.length;
	            if (preOffset >= 0) {
	              offset.push(preOffset, subOffset);
	            }
	          }
	        }
	      }
	      return result;
	    }
	
	    /**
	     * 获取地图的默认旋转角度，即地图正北方向与地图显示画面正上方顺时针夹角。
	     * @static
	     * @param  {String} mapData JSON格式的地图数据。
	     * @return {Number}         角度。
	     */
	
	  }, {
	    key: 'getMapAngle',
	    value: function getMapAngle(mapData) {
	      var angle = 0;
	
	      if (mapData && mapData.angle_line) {
	        var angleLine = mapData.angle_line;
	        var from = new _jsts.geom.Coordinate(0, 1, 0);
	        var to = new _jsts.geom.Coordinate(angleLine.coordinates[1][0] - angleLine.coordinates[0][0], angleLine.coordinates[1][1] - angleLine.coordinates[0][1], 0);
	
	        angle = _Math2.default.getAngle(from, to);
	        angle *= 180 / window.Math.PI;
	      }
	
	      return angle;
	    }
	  }]);
	
	  return DataUtil;
	}();
	
	exports.default = DataUtil;

/***/ }),
/* 64 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.PlanarGraph = exports.FeatureCollection = exports.Feature = exports.DataUtil = exports.DataSource = undefined;
	
	var _DataSource = __webpack_require__(153);
	
	var _DataSource2 = _interopRequireDefault(_DataSource);
	
	var _DataUtil = __webpack_require__(63);
	
	var _DataUtil2 = _interopRequireDefault(_DataUtil);
	
	var _Feature = __webpack_require__(34);
	
	var _Feature2 = _interopRequireDefault(_Feature);
	
	var _FeatureCollection = __webpack_require__(23);
	
	var _FeatureCollection2 = _interopRequireDefault(_FeatureCollection);
	
	var _PlanarGraph = __webpack_require__(154);
	
	var _PlanarGraph2 = _interopRequireDefault(_PlanarGraph);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.DataSource = _DataSource2.default;
	exports.DataUtil = _DataUtil2.default;
	exports.Feature = _Feature2.default;
	exports.FeatureCollection = _FeatureCollection2.default;
	exports.PlanarGraph = _PlanarGraph2.default;

/***/ }),
/* 65 */
/***/ (function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	var _skipEvents = {};
	
	var _fakeStop = function _fakeStop(e) {
	  // fakes stopPropagation by setting a special event flag, checked/reset with L.DomEvent._skipped(e)
	  _skipEvents[e.type] = true;
	};
	
	var _skipped = function _skipped(e) {
	  var skipped = _skipEvents[e.type];
	
	  // reset when checking, as it's only used in map container and propagates outside of the map
	  _skipEvents[e.type] = false;
	
	  return skipped;
	};
	
	var _getClass = function _getClass(element) {
	  return typeof element.className.baseVal === 'undefined' ? element.className : element.className.baseVal;
	};
	
	var _setClass = function _setClass(element, name) {
	  if (typeof element.className.baseVal === 'undefined') {
	    element.className = name;
	  } else {
	    element.className.baseVal = name;
	  }
	};
	
	/**
	 * 创建DOM元素，用于JavaScript与HTML页面的交互。
	 * @memberOf NGR.dom.DOMUtils
	 * @param  {String}      tagName   标签名字。
	 * @param  {String}      className Class名。
	 * @param  {HTMLElement} container 父元素。
	 * @return {HTMLElement}           HTML元素。
	 */
	var createElement = function createElement(tagName, className, container) {
	  var element = document.createElement(tagName);
	
	  element.className = className;
	  if (container) {
	    container.appendChild(element);
	  }
	
	  return element;
	};
	
	/**
	 * 判断DOM元素是否包含某个class属性。
	 * @memberOf NGR.dom.DOMUtils
	 * @param  {HTMLElement}  element HTML元素。
	 * @param  {String}       name    Class名。
	 * @return {Boolean}              若包含则返回true，否则返回false。
	 */
	var hasClass = function hasClass(element, name) {
	  if (typeof element.classList !== 'undefined') {
	    return element.classList.contains(name);
	  }
	
	  var className = _getClass(element);
	
	  return className.length > 0 && new RegExp('(^|\\s)' + name + '(\\s|$)').test(className);
	};
	
	/**
	 * 为DOM元素添加class属性。
	 * @memberOf NGR.dom.DOMUtils
	 * @param {HTMLElement} element HTML元素。
	 * @param {String}      name    Class名。
	 * @return {undefined}
	 */
	var addClass = function addClass(element, name) {
	  if (typeof element.classList !== 'undefined') {
	    var classes = name.trim().split(/\s+/);
	
	    for (var _iterator = classes, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
	      var _ref;
	
	      if (_isArray) {
	        if (_i >= _iterator.length) break;
	        _ref = _iterator[_i++];
	      } else {
	        _i = _iterator.next();
	        if (_i.done) break;
	        _ref = _i.value;
	      }
	
	      var className = _ref;
	
	      element.classList.add(className);
	    }
	  } else if (!hasClass(element, name)) {
	    var _className = _getClass(element);
	
	    _setClass(element, '' + (_className ? _className : ' ') + name);
	  }
	};
	
	/**
	 * 为DOM元素删除class属性。
	 * @memberOf NGR.dom.DOMUtils
	 * @param {HTMLElement} element HTML元素。
	 * @param {String}      name    Class名。
	 * @return {undefined}
	 */
	var removeClass = function removeClass(element, name) {
	  if (typeof element.classList !== 'undefined') {
	    element.classList.remove(name);
	  } else {
	    var className = _getClass(element);
	
	    className = (' ' + className + ' ').replace(' ' + name + ' ', ' ').trim();
	    _setClass(element, className);
	  }
	};
	
	/**
	 * 停止事件冒泡。
	 * @memberOf NGR.dom.DOMUtils
	 * @param  {Event} e 事件。
	 * @return {undefined}
	 */
	var stopPropagation = function stopPropagation(e) {
	  if (e.stopPropagation) {
	    e.stopPropagation();
	  } else {
	    e.cancelBubble();
	  }
	  _skipped(e);
	};
	
	var disableClickPropagation = function disableClickPropagation(el) {
	  var stop = stopPropagation;
	  var dragEvent = document.ontouchstart ? ['touchstart', 'mousedown'] : ['mousedown'];
	
	  for (var _iterator2 = dragEvent, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator]();;) {
	    var _ref2;
	
	    if (_isArray2) {
	      if (_i2 >= _iterator2.length) break;
	      _ref2 = _iterator2[_i2++];
	    } else {
	      _i2 = _iterator2.next();
	      if (_i2.done) break;
	      _ref2 = _i2.value;
	    }
	
	    var e = _ref2;
	
	    el.addEventListener(e, stop);
	  }
	
	  el.addEventListener('click', _fakeStop);
	  el.addEventListener('dblclick', stop);
	};
	
	/**
	 * 阻止浏览器对事件的默认操作。
	 * @memberOf NGR.dom.DOMUtils
	 * @param  {Event} e 事件。
	 * @return {undefined}
	 */
	var preventDefault = function preventDefault(e) {
	  if (e.preventDefault) {
	    e.preventDefault();
	  } else {
	    e.returnValue = false;
	  }
	};
	
	var stop = function stop(e) {
	  preventDefault(e);
	  stopPropagation(e);
	};
	
	exports.createElement = createElement;
	exports.hasClass = hasClass;
	exports.addClass = addClass;
	exports.removeClass = removeClass;
	exports.stopPropagation = stopPropagation;
	exports.disableClickPropagation = disableClickPropagation;
	exports.preventDefault = preventDefault;
	exports.stop = stop;

/***/ }),
/* 66 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };
	
	var _NGREngine2 = __webpack_require__(155);
	
	var _NGREngine3 = _interopRequireDefault(_NGREngine2);
	
	var _three = __webpack_require__(2);
	
	var THREE = _interopRequireWildcard(_three);
	
	var _CSS2DRenderer = __webpack_require__(120);
	
	var _CSS2DRenderer2 = _interopRequireDefault(_CSS2DRenderer);
	
	var _NGRSpritePlugin = __webpack_require__(126);
	
	var _NGRSpritePlugin2 = _interopRequireDefault(_NGRSpritePlugin);
	
	var _ParticleEngine = __webpack_require__(78);
	
	var _ParticleEngine2 = _interopRequireDefault(_ParticleEngine);
	
	var _ThreeSceneGenerator = __webpack_require__(206);
	
	var _ThreeSceneGenerator2 = _interopRequireDefault(_ThreeSceneGenerator);
	
	var _OverlayNode = __webpack_require__(198);
	
	var _ParticleNode = __webpack_require__(199);
	
	var _ThirdPersonControl = __webpack_require__(143);
	
	var _ThirdPersonControl2 = _interopRequireDefault(_ThirdPersonControl);
	
	var _AnimatorFactory = __webpack_require__(9);
	
	var _AnimatorFactory2 = _interopRequireDefault(_AnimatorFactory);
	
	var _TweenProvider = __webpack_require__(140);
	
	var _TweenProvider2 = _interopRequireDefault(_TweenProvider);
	
	var _GestureManager = __webpack_require__(216);
	
	var _GestureManager2 = _interopRequireDefault(_GestureManager);
	
	var _HammerGesture = __webpack_require__(217);
	
	var _HammerGesture2 = _interopRequireDefault(_HammerGesture);
	
	var _MouseGesture = __webpack_require__(218);
	
	var _MouseGesture2 = _interopRequireDefault(_MouseGesture);
	
	var _dom = __webpack_require__(11);
	
	var _RenderLoop = __webpack_require__(87);
	
	var _config = __webpack_require__(18);
	
	var _lang = __webpack_require__(4);
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	// attach method to THREE
	// eslint-disable-line no-unused-vars
	
	
	/**
	 * 3D引擎的管理类，继承自{@link NGREngine}的引擎管理类，用于以3D效果显示地图。
	 * @extends {NGREngine}
	 * @memberOf NGR.engine
	 */
	var ThreeEngine = function (_NGREngine) {
	  _inherits(ThreeEngine, _NGREngine);
	
	  function ThreeEngine() {
	    _classCallCheck(this, ThreeEngine);
	
	    // THREE.SpritePlugin = NGRSpritePlugin;
	    var _this = _possibleConstructorReturn(this, (ThreeEngine.__proto__ || Object.getPrototypeOf(ThreeEngine)).call(this));
	
	    _this._renderers = {};
	    _this._domRendererrs = {};
	    _AnimatorFactory2.default.getInstance().provider = new _TweenProvider2.default();
	    return _this;
	  }
	
	  _createClass(ThreeEngine, [{
	    key: '_createCorner',
	    value: function _createCorner(vSide, hSide, parent, map) {
	      var head = 'ngr-';
	      var key = '' + vSide + hSide;
	      var className = '' + head + vSide + ' ' + head + hSide;
	
	      map[key] = _dom.DOMUtils.createElement('div', className, parent);
	    }
	  }, {
	    key: '_creatControlContainer',
	    value: function _creatControlContainer() {
	      var container = _dom.DOMUtils.createElement('div', 'ngr-control-container');
	      var corners = {};
	
	      this._createCorner('top', 'left', container, corners);
	      this._createCorner('top', 'right', container, corners);
	      this._createCorner('bottom', 'left', container, corners);
	      this._createCorner('bottom', 'right', container, corners);
	
	      return { container: container, corners: corners };
	    }
	
	    /**
	     * 初始化{@link NGR.view.MapView}对象，设置各种自定义的参数，如地图的大小、背景颜色等。
	     * @param {NGR.view.MapView} mapView              构造一个地图对象MapView，并进行初始化。
	     * @param {Object}           [options]            设置自定义参数。
	     * @param {Number}           [options.height]     地图的高，单位为像素。
	     * @param {Number}           [options.width]      地图的宽，单位为像素。
	     * @param {Number}           [options.clearColor] 地图的背景颜色，使用16进制颜色码。
	     * @return {Boolean}                              如果初始化成功则返回true。
	     */
	
	  }, {
	    key: 'initMapView',
	    value: function initMapView(mapView) {
	      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
	
	      var flag = _get(ThreeEngine.prototype.__proto__ || Object.getPrototypeOf(ThreeEngine.prototype), 'initMapView', this).call(this, mapView, options);
	
	      if (flag && mapView) {
	        var container = null;
	
	        if ((0, _lang.isString)(mapView.name)) {
	          container = document.getElementById(mapView.name);
	          if (!container) {
	            container = document.querySelector(mapView.name);
	          }
	        } else if (mapView.name instanceof HTMLElement) {
	          container = mapView.name;
	        }
	        if (!container) {
	          throw new Error('Invalid mapView container');
	        }
	
	        var _options$devicePixelR = options.devicePixelRatio,
	            devicePixelRatio = _options$devicePixelR === undefined ? window.devicePixelRatio : _options$devicePixelR,
	            _options$width = options.width,
	            width = _options$width === undefined ? container.clientWidth : _options$width,
	            _options$height = options.height,
	            height = _options$height === undefined ? container.clientHeight : _options$height,
	            _options$clearColor = options.clearColor,
	            clearColor = _options$clearColor === undefined ? 0xdbdbdb : _options$clearColor,
	            _options$autoClear = options.autoClear,
	            autoClear = _options$autoClear === undefined ? true : _options$autoClear,
	            fps = options.fps,
	            clearImage = options.clearImage;
	
	
	        var sceneGenerator = new _ThreeSceneGenerator2.default();
	        var renderer = new THREE.WebGLRenderer({ antialias: true, preserveDrawingBuffer: autoClear, alpha: true, SpritePlugin: _NGRSpritePlugin2.default }); // 通过设置antialias打开或者关闭抗锯齿选项
	        var domRenderer = new THREE.CSS2DRenderer();
	
	        var _creatControlContaine = this._creatControlContainer(),
	            controlContainer = _creatControlContaine.container,
	            corners = _creatControlContaine.corners;
	
	        var gestureManager = new _GestureManager2.default();
	        var activeCamera = mapView.activeCamera;
	
	        mapView.changeMapViewLifeCycle(0);
	
	        // size
	        mapView.width = width;
	        mapView.height = height;
	
	        // renderer
	        mapView.engine = this;
	        mapView.sceneGenerator = sceneGenerator;
	        renderer.autoClear = !autoClear;
	        renderer.setPixelRatio(devicePixelRatio);
	        renderer.setSize(width, height);
	        domRenderer.setSize(width, height);
	        this._renderers[mapView.name] = renderer;
	        this._domRendererrs[mapView.name] = domRenderer;
	
	        // fps
	        if (fps && fps > 0 && fps < 60) {
	          mapView.renderLoop = new _RenderLoop.LockFPSRenderLoop({ fps: options.fps });
	        } else {
	          mapView.renderLoop = new _RenderLoop.AnimationFrameRenderLoop();
	        }
	
	        // dom
	        mapView.container = container;
	        mapView.targetDom = renderer.domElement;
	        mapView.controlDom = controlContainer;
	        mapView.controlCorners = corners;
	        mapView._overlayDom = domRenderer.domElement;
	        _dom.DOMUtils.addClass(renderer.domElement, 'ngr-target');
	        _dom.DOMUtils.addClass(mapView._overlayDom, 'ngr-overlay-container');
	        container.appendChild(controlContainer);
	        container.appendChild(renderer.domElement);
	        container.appendChild(mapView._overlayDom);
	
	        // background
	        if (clearImage) {
	          renderer.setClearColor(0x000000, 0);
	          _dom.DOMUtils.addClass(mapView.targetDom, 'clear-image');
	          mapView.targetDom.style.backgroundImage = 'url(' + clearImage + ')';
	        } else {
	          renderer.setClearColor(clearColor);
	        }
	
	        // Gesture
	        gestureManager.init(mapView);
	        gestureManager.addGesture(new _HammerGesture2.default());
	        gestureManager.addGesture(new _MouseGesture2.default());
	        mapView.gestureManager = gestureManager;
	
	        // Set Camera
	        if (activeCamera) {
	          var control = new _ThirdPersonControl2.default(activeCamera, mapView);
	
	          sceneGenerator._threeNode.add(activeCamera);
	          mapView.activeControl = control;
	          activeCamera.camera.aspect = width / height;
	          activeCamera.camera.updateProjectionMatrix();
	
	          // add Particle Engine
	          if (_config.supportParticle) {
	            var particleEngine = new _ParticleEngine2.default();
	            var particleNode = new _ParticleNode.ParticleNode(_ParticleNode.ParticleNodeId);
	
	            mapView.particleEngine = particleEngine;
	            sceneGenerator._threeNode.add(particleNode);
	          }
	
	          // add OverlayNode
	          var overlayNode = new _OverlayNode.OverlayNode(_OverlayNode.OverlayNodeId);
	
	          overlayNode.add(activeCamera);
	          mapView.sceneManager.add(overlayNode);
	        }
	
	        mapView.changeMapViewLifeCycle(1);
	      }
	      return flag;
	    }
	
	    /**
	     * @override
	     */
	
	  }, {
	    key: 'reSize',
	    value: function reSize(mapView, width, height) {
	      var renderer = this.getRenderer(mapView);
	      var domRenderer = this.getDomRenderer(mapView);
	
	      renderer.setSize(width, height);
	      domRenderer.setSize(width, height);
	      mapView.width = width;
	      mapView.height = height;
	    }
	
	    /**
	     * @override
	     */
	
	  }, {
	    key: 'remove',
	    value: function remove(mapView) {
	      var flag = _get(ThreeEngine.prototype.__proto__ || Object.getPrototypeOf(ThreeEngine.prototype), 'remove', this).call(this, mapView);
	
	      if (flag) {
	        var renderer = this._renderers[mapView.name];
	        // const domRenderer = this._domRendererrs[mapView.name];
	
	        mapView.destroy();
	
	        // renderer.domElement.addEventListener('dblclick', null, false);
	        // domRenderer.domElement.addEventListener('dblclick', null, false);
	
	        renderer.dispose();
	        this._empty(mapView.container);
	
	        delete this._renderers[mapView.name];
	        delete this._domRendererrs[mapView.name];
	      }
	
	      return flag;
	    }
	
	    /**
	     * Get renderer.
	     * @private
	     * @param  {NGR.view.MapView} mapView Mapview.
	     * @return {Renderer}                 Renderer.
	     */
	
	  }, {
	    key: 'getRenderer',
	    value: function getRenderer(mapView) {
	      return this._renderers[mapView.name];
	    }
	  }, {
	    key: 'getRenderInfo',
	    value: function getRenderInfo(mapView) {
	      var _renderers$mapView$na = this._renderers[mapView.name].info,
	          _renderers$mapView$na2 = _renderers$mapView$na.render,
	          faces = _renderers$mapView$na2.faces,
	          points = _renderers$mapView$na2.points,
	          vertices = _renderers$mapView$na2.vertices,
	          calls = _renderers$mapView$na2.calls,
	          geometries = _renderers$mapView$na.memory.geometries;
	
	
	      return {
	        faces: faces,
	        points: points,
	        vertices: vertices,
	        calls: calls,
	        geometries: geometries
	      };
	    }
	
	    /**
	     * Get DOM renderer.
	     * @private
	     * @param {NGR.view.MapView} mapView mapView
	     * @return {Renderer}                domRenderer
	     */
	
	  }, {
	    key: 'getDomRenderer',
	    value: function getDomRenderer(mapView) {
	      return this._domRendererrs[mapView.name];
	    }
	
	    /**
	     * @override
	     */
	
	  }, {
	    key: 'type',
	    value: function type() {
	      return 'three';
	    }
	
	    /**
	     * Make a element empty.
	     * @private
	     * @param {Element} elem Element.
	     * @return {undefined}
	     */
	
	  }, {
	    key: '_empty',
	    value: function _empty(elem) {
	      while (elem.lastChild) {
	        elem.removeChild(elem.lastChild);
	      }
	    }
	  }]);
	
	  return ThreeEngine;
	}(_NGREngine3.default);
	
	exports.default = ThreeEngine;

/***/ }),
/* 67 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _JTSUtils = __webpack_require__(12);
	
	var _JTSUtils2 = _interopRequireDefault(_JTSUtils);
	
	var _jsts = __webpack_require__(5);
	
	var _FeatureCollection = __webpack_require__(23);
	
	var _FeatureCollection2 = _interopRequireDefault(_FeatureCollection);
	
	var _Feature = __webpack_require__(34);
	
	var _Feature2 = _interopRequireDefault(_Feature);
	
	var _lang = __webpack_require__(4);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var JTSParser = function () {
	  function JTSParser() {
	    _classCallCheck(this, JTSParser);
	  }
	
	  _createClass(JTSParser, null, [{
	    key: 'parse',
	    value: function parse(name, strOrObj) {
	      if ((0, _lang.isString)(strOrObj)) {
	
	        return JTSParser.parseByStr(name, strOrObj);
	      } else if ((typeof strOrObj === 'undefined' ? 'undefined' : _typeof(strOrObj)) === 'object') {
	
	        return JTSParser.parseByObj(name, strOrObj);
	      }
	
	      return null;
	    }
	  }, {
	    key: 'parseByStr',
	    value: function parseByStr(name, str) {
	      return JTSParser.parseByObj(name, JSON.parse(str));
	    }
	  }, {
	    key: 'parseByObj',
	    value: function parseByObj(name, obj) {
	      var featureCollection = new _FeatureCollection2.default(name);
	
	      for (var _iterator = obj.features, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
	        var _ref;
	
	        if (_isArray) {
	          if (_i >= _iterator.length) break;
	          _ref = _iterator[_i++];
	        } else {
	          _i = _iterator.next();
	          if (_i.done) break;
	          _ref = _i.value;
	        }
	
	        var f = _ref;
	
	        featureCollection.addFeature(new _Feature2.default(_JTSUtils2.default.getGeoReader().read(f.geometry), f.properties));
	      }
	
	      return featureCollection;
	    }
	  }, {
	    key: 'parseLineString',
	    value: function parseLineString(name, coords, properties) {
	      var points = coords.map(function (coord) {
	        return new (Function.prototype.bind.apply(_jsts.geom.Coordinate, [null].concat(_toConsumableArray(coord))))();
	      });
	      var geometry = _JTSUtils2.default.getFactory().createLineString(points);
	      var featureCollection = new _FeatureCollection2.default(name);
	
	      featureCollection.addFeature(new _Feature2.default(geometry, properties));
	
	      return featureCollection;
	    }
	  }, {
	    key: 'parsePoints',
	    value: function parsePoints(name, coords, properties) {
	      var featureCollection = new _FeatureCollection2.default(name);
	
	      for (var _iterator2 = coords, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator]();;) {
	        var _ref2;
	
	        if (_isArray2) {
	          if (_i2 >= _iterator2.length) break;
	          _ref2 = _iterator2[_i2++];
	        } else {
	          _i2 = _iterator2.next();
	          if (_i2.done) break;
	          _ref2 = _i2.value;
	        }
	
	        var coord = _ref2;
	
	        var point = new (Function.prototype.bind.apply(_jsts.geom.Coordinate, [null].concat(_toConsumableArray(coord))))();
	        var geometry = _JTSUtils2.default.getFactory().createLinePoint(point);
	
	        if (properties && properties.id) {
	          properties.id++;
	        }
	        featureCollection.addFeature(new _Feature2.default(geometry, properties));
	      }
	
	      return featureCollection;
	    }
	  }]);
	
	  return JTSParser;
	}();
	
	exports.default = JTSParser;

/***/ }),
/* 68 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.SBLocationProvider = exports.LocationStatus = exports.LocationType = exports.WiFiLocationManager = exports.BleWorkerManager = exports.BluetoothLocationManager = undefined;
	
	var _BluetoothLocationManager = __webpack_require__(165);
	
	var _BluetoothLocationManager2 = _interopRequireDefault(_BluetoothLocationManager);
	
	var _BleWorkerManager = __webpack_require__(164);
	
	var _BleWorkerManager2 = _interopRequireDefault(_BleWorkerManager);
	
	var _WiFiLocationManager = __webpack_require__(168);
	
	var _SBLocationProvider = __webpack_require__(167);
	
	var _SBLocationProvider2 = _interopRequireDefault(_SBLocationProvider);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.BluetoothLocationManager = _BluetoothLocationManager2.default;
	exports.BleWorkerManager = _BleWorkerManager2.default;
	exports.WiFiLocationManager = _WiFiLocationManager.WiFiLocationManager;
	exports.LocationType = _WiFiLocationManager.LocationType;
	exports.LocationStatus = _WiFiLocationManager.LocationStatus;
	exports.SBLocationProvider = _SBLocationProvider2.default;

/***/ }),
/* 69 */
/***/ (function(module, exports) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var AStarPath = function () {
	  function AStarPath() {
	    _classCallCheck(this, AStarPath);
	  }
	
	  _createClass(AStarPath, [{
	    key: "weight",
	    get: function get() {}
	  }, {
	    key: "altitude",
	    get: function get() {}
	  }, {
	    key: "from",
	    get: function get() {
	      return this._from;
	    },
	    set: function set(from) {
	      this._from = from;
	    }
	  }, {
	    key: "to",
	    get: function get() {
	      return this._to;
	    },
	    set: function set(to) {
	      this._to = to;
	    }
	  }]);
	
	  return AStarPath;
	}();
	
	exports.default = AStarPath;

/***/ }),
/* 70 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _G2 = __webpack_require__(176);
	
	var _G3 = _interopRequireDefault(_G2);
	
	var _AStarLanePath = __webpack_require__(44);
	
	var _AStarLanePath2 = _interopRequireDefault(_AStarLanePath);
	
	var _AStarConnectionPath = __webpack_require__(39);
	
	var _AStarConnectionPath2 = _interopRequireDefault(_AStarConnectionPath);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var DefaultG = function (_G) {
	  _inherits(DefaultG, _G);
	
	  function DefaultG() {
	    _classCallCheck(this, DefaultG);
	
	    return _possibleConstructorReturn(this, (DefaultG.__proto__ || Object.getPrototypeOf(DefaultG)).apply(this, arguments));
	  }
	
	  _createClass(DefaultG, [{
	    key: 'g',
	    value: function g(current, path, floorDiff) {
	      if (path instanceof _AStarLanePath2.default) {
	        return path.weight;
	      } else if (path instanceof _AStarConnectionPath2.default) {
	        if (floorDiff === 0) {
	          return 10000;
	        }
	        if (floorDiff > 2) {
	          var cIdStr = path.connection.categoryId ? path.connection.categoryId.toString() : null;
	          if (/2409[2-9]000/.test(cIdStr) || path.connection.categoryId === 13164000) {
	            return 10000;
	          }
	        } else {
	          var _cIdStr = path.connection.categoryId ? path.connection.categoryId.toString() : null;
	          if (/2409[7-9]000/.test(_cIdStr) || path.connection.categoryId === 13164000) {
	            return 10000;
	          }
	          if (path.connection.categoryId === 24091000 || path.connection.categoryId === 24092000) {
	            var lastPath = current.parent.findPath(current);
	            if (lastPath instanceof _AStarConnectionPath2.default && (lastPath.connection.categoryId === 24091000 || path.connection.categoryId === 24092000)) {
	              return 30;
	            }
	            return 190;
	          }
	        }
	        return 60;
	      }
	      return 0;
	    }
	    //   if (path instanceof AStarLanePath) {
	    //     return path.weight;
	    //   } else if (path instanceof AStarConnectionPath) {
	    //     if (floorDiff === 0) {
	    //       return 40;
	    //     }
	    //     return 20;
	    //   }
	    //   return 0;
	    // }
	
	  }]);
	
	  return DefaultG;
	}(_G3.default);
	
	exports.default = DefaultG;

/***/ }),
/* 71 */
/***/ (function(module, exports) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var Path = function () {
	  function Path(mapId, rank, direction, shape, planarGraphId, pathId, altitude) {
	    _classCallCheck(this, Path);
	
	    this.mapId = mapId;
	    this.rank = rank;
	    this.direction = direction;
	    this.shape = shape;
	    this.planarGraphId = planarGraphId;
	    this.pathId = pathId;
	    this.altitude = altitude;
	  }
	
	  _createClass(Path, [{
	    key: "toString",
	    value: function toString() {
	      return 31 * this.id + this.planarGraphId;
	    }
	  }, {
	    key: "equals",
	    value: function equals(o) {
	      if (this === o) {
	        return true;
	      }
	
	      if (!o) {
	        return false;
	      }
	
	      if (this.id !== o.id) {
	        return false;
	      }
	
	      return this.planarGraphId === o.planarGraphId;
	    }
	  }, {
	    key: "id",
	    get: function get() {
	      return this._id;
	    },
	    set: function set(id) {
	      this._id = id;
	    }
	  }, {
	    key: "mapId",
	    get: function get() {
	      return this._mapId;
	    },
	    set: function set(mapId) {
	      this._mapId = mapId;
	    }
	  }, {
	    key: "rank",
	    get: function get() {
	      return this._rank;
	    },
	    set: function set(rank) {
	      this._rank = rank;
	    }
	  }, {
	    key: "direction",
	    get: function get() {
	      return this._direction;
	    },
	    set: function set(direction) {
	      this._direction = direction;
	    }
	  }, {
	    key: "shape",
	    get: function get() {
	      return this._shape;
	    },
	    set: function set(shape) {
	      this._shape = shape;
	    }
	  }, {
	    key: "from",
	    get: function get() {
	      return this._from;
	    },
	    set: function set(from) {
	      this._from = from;
	    }
	  }, {
	    key: "to",
	    get: function get() {
	      return this._to;
	    },
	    set: function set(to) {
	      this._to = to;
	    }
	  }, {
	    key: "planarGraphId",
	    get: function get() {
	      return this._planarGraphId;
	    },
	    set: function set(planarGraphId) {
	      this._planarGraphId = planarGraphId;
	    }
	  }, {
	    key: "pathId",
	    get: function get() {
	      return this._pathId;
	    },
	    set: function set(pathId) {
	      this._pathId = pathId;
	    }
	  }, {
	    key: "altitude",
	    get: function get() {
	      return this._altitude;
	    },
	    set: function set(altitude) {
	      this._altitude = altitude;
	    }
	  }]);
	
	  return Path;
	}();
	
	exports.default = Path;

/***/ }),
/* 72 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _Vertex = __webpack_require__(73);
	
	var _Vertex2 = _interopRequireDefault(_Vertex);
	
	var _Path = __webpack_require__(71);
	
	var _Path2 = _interopRequireDefault(_Path);
	
	var _Connection = __webpack_require__(173);
	
	var _Connection2 = _interopRequireDefault(_Connection);
	
	var _JTSUtils = __webpack_require__(12);
	
	var _JTSUtils2 = _interopRequireDefault(_JTSUtils);
	
	var _jsts = __webpack_require__(5);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	/**
	 * Path service.
	 * @ignore
	 * @memberOf NGR.navi
	 */
	var PathService = function () {
	  /**
	   * Constructor.
	   * @param  {String|Object} vertexes     Vertexes.
	   * @param  {String|Object} paths       Paths.
	   * @param  {String|Object} connections Connections.
	   */
	  function PathService(vertexes, paths, connections) {
	    _classCallCheck(this, PathService);
	
	    if (!vertexes || !paths || !connections) {
	      throw new Error('PathService: Invalid input');
	    }
	
	    var rawVertexes = typeof vertexes === 'string' ? JSON.parse(vertexes) : vertexes;
	    var rawPaths = typeof paths === 'string' ? JSON.parse(paths) : paths;
	    var rawConnections = typeof connections === 'string' ? JSON.parse(connections) : connections;
	    var reader = new _jsts.io.GeoJSONReader(_JTSUtils2.default.getFactory());
	
	    this._vertexes = {};
	    this._paths = {};
	    this._pathsMapping = {};
	    this._connections = {};
	    this._connectionsMapping = {};
	    this._quadtreeMapping = {};
	    for (var _iterator = rawVertexes, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
	      var _ref;
	
	      if (_isArray) {
	        if (_i >= _iterator.length) break;
	        _ref = _iterator[_i++];
	      } else {
	        _i = _iterator.next();
	        if (_i.done) break;
	        _ref = _i.value;
	      }
	
	      var rawVertex = _ref;
	
	      var vertex = new _Vertex2.default(rawVertex.mapId, reader.read(rawVertex.shape), rawVertex.planarGraphId, rawVertex.altitude);
	      vertex.id = rawVertex.id;
	      vertex.virtual = rawVertex.virtual;
	      this._vertexes[rawVertex.id] = vertex;
	    }
	    for (var planarGraphId in rawPaths) {
	      var planarGraphPaths = rawPaths[planarGraphId];
	      this._paths[planarGraphId] = {};
	      this._pathsMapping[planarGraphId] = {};
	      this._quadtreeMapping[planarGraphId] = new _jsts.index.quadtree.Quadtree();
	      for (var vertexId in planarGraphPaths) {
	        var vertexPaths = planarGraphPaths[vertexId];
	        this._pathsMapping[planarGraphId][vertexId] = [];
	        for (var _iterator2 = vertexPaths, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator]();;) {
	          var _ref2;
	
	          if (_isArray2) {
	            if (_i2 >= _iterator2.length) break;
	            _ref2 = _iterator2[_i2++];
	          } else {
	            _i2 = _iterator2.next();
	            if (_i2.done) break;
	            _ref2 = _i2.value;
	          }
	
	          var rawPath = _ref2;
	
	          if (!this._paths[planarGraphId][rawPath.id]) {
	            var path = new _Path2.default(rawPath.mapId, rawPath.rank, rawPath.direction, reader.read(rawPath.shape), rawPath.planarGraphId, rawPath.pathId, rawPath.altitude);
	            path.id = rawPath.id;
	            path.from = this._vertexes[rawPath.from];
	            path.to = this._vertexes[rawPath.to];
	            this._paths[planarGraphId][rawPath.id] = path;
	            this._quadtreeMapping[planarGraphId].insert(path.shape.getEnvelopeInternal(), path);
	          }
	          this._pathsMapping[planarGraphId][vertexId].push(this._paths[planarGraphId][rawPath.id]);
	        }
	      }
	    }
	    for (var _planarGraphId in rawConnections) {
	      var planarGraphConnections = rawConnections[_planarGraphId];
	      this._connections[_planarGraphId] = {};
	      this._connectionsMapping[_planarGraphId] = {};
	      for (var _vertexId in planarGraphConnections) {
	        var vertexConnections = planarGraphConnections[_vertexId];
	        this._connectionsMapping[_planarGraphId][_vertexId] = [];
	        for (var _iterator3 = vertexConnections, _isArray3 = Array.isArray(_iterator3), _i3 = 0, _iterator3 = _isArray3 ? _iterator3 : _iterator3[Symbol.iterator]();;) {
	          var _ref3;
	
	          if (_isArray3) {
	            if (_i3 >= _iterator3.length) break;
	            _ref3 = _iterator3[_i3++];
	          } else {
	            _i3 = _iterator3.next();
	            if (_i3.done) break;
	            _ref3 = _i3.value;
	          }
	
	          var rawConnection = _ref3;
	
	          if (!this._connections[_planarGraphId][rawConnection.id]) {
	            var connection = new _Connection2.default(rawConnection.mapId, rawConnection.direction, rawConnection.rank, rawConnection.fromLocationId, rawConnection.toLocationId);
	            connection.id = rawConnection.id;
	            connection.from = this._vertexes[rawConnection.from];
	            connection.to = this._vertexes[rawConnection.to];
	            connection.categoryId = rawConnection.categoryId;
	            this._connections[_planarGraphId][rawConnection.id] = connection;
	          }
	          this._connectionsMapping[_planarGraphId][_vertexId].push(this._connections[_planarGraphId][rawConnection.id]);
	        }
	      }
	    }
	  }
	
	  /**
	   * Query quadtree by planarGraphId.
	   * @param  {Number} planarGraphId PlanarGraphId.
	   * @return {io.quadtree.Quadtree}               Quadtree.
	   */
	
	
	  _createClass(PathService, [{
	    key: 'queryQuadTree',
	    value: function queryQuadTree(planarGraphId) {
	      return this._quadtreeMapping[planarGraphId];
	    }
	
	    /**
	     * Query paths by vertex.
	     * @param  {Vertex} vertex Vertex.
	     * @return {Array<Path>}        Paths list.
	     */
	
	  }, {
	    key: 'queryPathsByVertex',
	    value: function queryPathsByVertex(vertex) {
	      var paths = this._pathsMapping[vertex.planarGraphId];
	      return paths && paths[vertex.id] ? paths[vertex.id] : [];
	    }
	
	    /**
	     * Query connections by vertex.
	     * @param  {Vertex} vertex Vertex.
	     * @return {Array<Connection>}        Connections list.
	     */
	
	  }, {
	    key: 'queryConnectionsByVertex',
	    value: function queryConnectionsByVertex(vertex) {
	      var connections = this._connectionsMapping[vertex.planarGraphId];
	      return connections && connections[vertex.id] ? connections[vertex.id] : [];
	    }
	
	    /**
	     * Query all paths from quadtree by planarGraphId.
	     * @param  {Number} planarGraphId PlanarGraphId.
	     * @return {Array<Path>}               Paths list.
	     */
	
	  }, {
	    key: 'queryAllPathFromIndex',
	    value: function queryAllPathFromIndex(planarGraphId) {
	      var quadtree = this._quadtreeMapping[planarGraphId];
	      return quadtree ? quadtree.queryAll() : [];
	    }
	  }]);
	
	  return PathService;
	}();
	
	exports.default = PathService;

/***/ }),
/* 73 */
/***/ (function(module, exports) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var Vertex = function () {
	  function Vertex(mapId, shape, planarGraphId, altitude) {
	    _classCallCheck(this, Vertex);
	
	    this.mapId = mapId;
	    this.shape = shape;
	    this.planarGraphId = planarGraphId;
	    this.altitude = altitude;
	  }
	
	  _createClass(Vertex, [{
	    key: "toString",
	    value: function toString() {
	      return 31 * this.id + this.planarGraphId;
	    }
	  }, {
	    key: "equals",
	    value: function equals(o) {
	      if (this === o) {
	        return true;
	      }
	      if (!o) {
	        return false;
	      }
	
	      if (this.id !== o.id) {
	        return false;
	      }
	      return this.planarGraphId === o.planarGraphId;
	    }
	  }, {
	    key: "id",
	    get: function get() {
	      return this._id;
	    },
	    set: function set(id) {
	      this._id = id;
	    }
	  }, {
	    key: "mapId",
	    get: function get() {
	      return this._mapId;
	    },
	    set: function set(mapId) {
	      this._mapId = mapId;
	    }
	  }, {
	    key: "shape",
	    get: function get() {
	      return this._shape;
	    },
	    set: function set(shape) {
	      this._shape = shape;
	    }
	  }, {
	    key: "planarGraphId",
	    get: function get() {
	      return this._planarGraphId;
	    },
	    set: function set(planarGraphId) {
	      this._planarGraphId = planarGraphId;
	    }
	  }, {
	    key: "virtual",
	    get: function get() {
	      return this._virtual;
	    },
	    set: function set(virtual) {
	      this._virtual = virtual;
	    }
	  }, {
	    key: "altitude",
	    get: function get() {
	      return this._altitude;
	    },
	    set: function set(altitude) {
	      this._altitude = altitude;
	    }
	  }]);
	
	  return Vertex;
	}();
	
	exports.default = Vertex;

/***/ }),
/* 74 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _Trigger = __webpack_require__(188);
	
	var _Trigger2 = _interopRequireDefault(_Trigger);
	
	var _DefaultSegmentProvider = __webpack_require__(180);
	
	var _DefaultSegmentProvider2 = _interopRequireDefault(_DefaultSegmentProvider);
	
	var _DynamicNavigationRule = __webpack_require__(181);
	
	var _DynamicNavigationRule2 = _interopRequireDefault(_DynamicNavigationRule);
	
	var _three = __webpack_require__(2);
	
	var THREE = _interopRequireWildcard(_three);
	
	var _jsts = __webpack_require__(5);
	
	var _AnimatorFactory = __webpack_require__(9);
	
	var _AnimatorFactory2 = _interopRequireDefault(_AnimatorFactory);
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	/**
	 * 动态导航管理类，用于处理每个独立的导航线段的相机视角变化、导航信息提示等。
	 * @memberOf NGR.navi
	 */
	var DynamicNavigation = function () {
	  /**
	   * 构造方法。
	   * @param  {NGR.view.MapView}         mapView 需要导航的地图。
	   * @param  {NGR.navi.navigateManager} navigateManager 需要应用动态导航的导航管理对象。
	   * @param  {Object}                   [messageOptions]  导航提示选项。needAudio表示启用语音导航，autoplay表示在检测到导航线段切换的时候自动播放提示语音，endThreshold表示提示到达终点时距离终点的距离。
	   * @param  {Object}                   [cameraOptions]  相机选项。autoMove表示在检测到导航线段切换的时候自动转动相机视角。
	   * @param  {Object}                   [locationOptions]  定位点选项。autoPullToEnd表示在检测到定位点距离当前导航线段终点距离小于pullThreshold时，自动将定位点移到线段终点。
	   */
	  function DynamicNavigation(mapView, navigateManager) {
	    var messageOptions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : { needAudio: false, autoplay: false, endThreshold: 8 };
	    var cameraOptions = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : { autoMove: false };
	    var locationOptions = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : { autoPullToEnd: false, pullThreshold: 5 };
	
	    _classCallCheck(this, DynamicNavigation);
	
	    this._mapView = mapView;
	    this._navigateManager = navigateManager;
	    this._messageOptions = messageOptions;
	    this._cameraOptions = cameraOptions;
	    this._locationOptions = locationOptions;
	    this._trigger = new _Trigger2.default(new _DefaultSegmentProvider2.default(), messageOptions.needAudio);
	    this._dynamicNavigationRule = new _DynamicNavigationRule2.default();
	    this._dynamicNavigationRule.trigger = this._trigger;
	    this._isArrived = false;
	
	    this._onSegmentChange = this._onSegmentChange.bind(this);
	    this._dynamicNavigationRule.on('onSegmentChange', this._onSegmentChange);
	    this._onLocationChange = this._onLocationChange.bind(this);
	    this._dynamicNavigationRule.on('onLocationChange', this._onLocationChange);
	    this._onArriveSegEnd = this._onArriveSegEnd.bind(this);
	    this._dynamicNavigationRule.on('onArriveSegEnd', this._onArriveSegEnd);
	
	    this._crtPlanarGraphId = null;
	    this._onSegChangeCallback = null;
	    this._onLocChangeCallback = null;
	  }
	
	  /**
	   * 设置需要动态导航管理的完整导航线信息。
	   * @type {NGR.data.FeatureCollection}
	   * @param  {NGR.data.FeatureCollection} featureCollection 导航线对象。
	   */
	
	
	  _createClass(DynamicNavigation, [{
	    key: 'clearFeatureCollection',
	
	
	    /**
	     * 清空当前动态导航路径信息。
	     * @return {undefined}
	     */
	    value: function clearFeatureCollection() {
	      this._trigger._audioProvider.audioElmt.pause();
	      this._trigger._segments = [];
	      this._dynamicNavigationRule.reset();
	      this._crtPlanarGraphId = null;
	      this._isArrived = false;
	    }
	  }, {
	    key: 'addSegment',
	
	
	    /**
	     * 添加导航线段。
	     * @param  {Segment} segment 需要添加进动态导航管理的线段。
	     * @return  {DynamicNavigation} this。
	     */
	    value: function addSegment(segment) {
	      this._trigger.addSegment(segment);
	      return this;
	    }
	
	    /**
	     * 删除导航线段。
	     * @param  {Number} index 需要从动态导航管理中删除的线段。
	     * @return  {DynamicNavigation} this。
	     */
	
	  }, {
	    key: 'removeSegment',
	    value: function removeSegment(index) {
	      this._trigger.removeSegment(index);
	      return this;
	    }
	
	    /**
	     * 上一次调用findNearestSegment方法之后找到的导航线上的点的地理坐标。
	     * @return {NGR.geom.Coordinate} crtLocation
	     */
	
	  }, {
	    key: 'start',
	    value: function start(x, y) {
	      this._dynamicNavigationRule.start(x, y);
	    }
	
	    /**
	     * 通过坐标点与最近导航线段之间的距离来判断是否偏航。
	     * @param  {Number} x              坐标点x轴坐标。
	     * @param  {Number} y              坐标点y轴坐标。
	     * @param  {Number} threshold      判断是否偏航的距离大小的阈值。
	     * @param  {Number} planarGraphId  平面图id。默认为crtPlanarGraphId。
	     * @param  {Bool}   hasOffset      是否对坐标区域进行偏移,是则设置为true。
	     * @return {Bool}                  返回是否偏航。
	     */
	
	  }, {
	    key: 'isYawing',
	    value: function isYawing(x, y, threshold) {
	      var planarGraphId = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : this._crtPlanarGraphId;
	      var hasOffset = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : true;
	
	      if (hasOffset) {
	        return this.crtOffsetLocation.distance(new _jsts.geom.Coordinate(x, y)) > threshold;
	      }
	      return this.crtLocation.distance(new _jsts.geom.Coordinate(x, y)) > threshold;
	      // return this._navigateManager.getClosestPoints(planarGraphId, x, y)[0].distance(new geom.Coordinate(x, y)) > threshold;
	    }
	
	    /**
	     * 传入坐标信息来寻找该坐标所在的导航线段，或者离该坐标最近的导航的线段，如果寻找成功则返回true。
	     * 此方法用来作为更新crtLocation/crtIndex/crtSegment/crtPlanarGraphId的机制，以此来追踪定位点在动态导航中前进的信息。以上信息只有在传入的定位点在导航方向上前进时才会更新。
	     * @param  {Number} x              坐标点x轴坐标。
	     * @param  {Number} y              坐标点y轴坐标。
	     * @param  {Number} planarGraphId  平面图id。
	     * @param  {Bool}   measured       如果传入的坐标在导航线段上则为true，不确定是否在导航线上则为false。
	     * @param  {Bool}   hasOffset      是否对坐标区域进行偏移，是则设置为true。
	     * @return {Bool}                  返回是否成功找到导航线段。
	     */
	
	  }, {
	    key: 'findNearestSegment',
	    value: function findNearestSegment(x, y, planarGraphId) {
	      var measured = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
	      var hasOffset = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : true;
	
	      var offset = this._mapView.coordinateSystem.getOffset();
	      var coord = null;
	      this._crtPlanarGraphId = planarGraphId;
	
	      if (measured) {
	        coord = new _jsts.geom.Coordinate(x, y);
	        if (hasOffset) {
	          coord.x -= offset[0];
	          coord.y -= offset[1];
	        }
	      } else {
	        coord = this._navigateManager.getClosestPoints(planarGraphId, x, y)[0];
	      }
	
	      var _locationOptions = this._locationOptions,
	          autoPullToEnd = _locationOptions.autoPullToEnd,
	          pullThreshold = _locationOptions.pullThreshold;
	
	      return this._dynamicNavigationRule.findNearestSegment(coord.x, coord.y, planarGraphId, autoPullToEnd, pullThreshold);
	    }
	
	    /**
	     * 通过传入坐标信息来寻找该坐标所在的导航线段，或离该坐标最近的导航的线段。如果寻找成功则返回一个对象。该对象中包含寻找到的导航线段，以及包含该线段的导航线索引。
	     * 此方法不会更新crtLocation/crtIndex/crtSegment。
	     * @param  {Number} x              坐标点x轴坐标。
	     * @param  {Number} y              坐标点y轴坐标。
	     * @param  {Number} planarGraphId  平面图id。
	     * @param  {Bool}   measured       如果传入的坐标在导航线段上则为true，不确定是否在导航线上则为false。
	     * @param  {Bool}   hasOffset      是否对坐标区域进行偏移，是则设置为true。
	     * @return {Object}                返回的对象中包含一个index和一个segment。如果未寻找成功则index返回-1，segment返回null。
	     */
	
	  }, {
	    key: 'returnNearestSegment',
	    value: function returnNearestSegment(x, y, planarGraphId) {
	      var measured = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
	      var hasOffset = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : true;
	
	      var offset = this._mapView.coordinateSystem.getOffset();
	      var coord = new _jsts.geom.Coordinate(x, y);
	
	      if (measured) {
	        coord = new _jsts.geom.Coordinate(x, y);
	        if (hasOffset) {
	          coord.x -= offset[0];
	          coord.y -= offset[1];
	        }
	      } else {
	        coord = this._navigateManager.getClosestPoints(planarGraphId, x, y)[0];
	      }
	
	      return this._dynamicNavigationRule.returnNearestSegment(coord.x, coord.y, planarGraphId);
	    }
	
	    /**
	     * 销毁动态导航控制对象。
	     * @return {undefined}
	     */
	
	  }, {
	    key: 'destroy',
	    value: function destroy() {
	      this._dynamicNavigationRule.reset();
	      this._dynamicNavigationRule.off('onSegmentChange', this._onSegmentChange);
	      this._dynamicNavigationRule.off('onLocationChange', this._onLocationChange);
	      this._dynamicNavigationRule.off('onArriveSegEnd', this._onArriveSegEnd);
	
	      this._mapView = null;
	      this._navigateManager = null;
	      this._trigger._audioProvider.audioElmt.pause();
	      this._trigger._audioProvider.audioElmt.parentNode.removeChild(this._trigger._audioProvider.audioElmt);
	      this._trigger = null;
	      this._dynamicNavigationRule = null;
	
	      this._messageOptions = null;
	      this._crtPlanarGraphId = null;
	      this._isArrived = false;
	      this._onSegChangeCallback = null;
	      this._onLocChangeCallback = null;
	    }
	
	    /**
	     * 将相机视角的中心点移动到传入的坐标点，并且（可选）旋转视角使之与传入的segment方向一致。此方法用于在动态导航中实现跟随模式导航。
	     * @param  {NGR.geom.Coordinate} center         即传入的坐标点，默认为crtOffsetLocation。
	     * @param  {Segment}             segment        旋转相机方向参照的segment。默认为crtSegment。
	     * @param  {Bool}                needToRotate   是否需要旋转相机视角，默认为true。
	     * @param  {NGR.geom.Coordinate} screenCoord    屏幕坐标。如果不想将传入的center移动到屏幕中心，而是移动某个屏幕坐标，启用该参数。
	     * @param  {Bool}                needCollision  是否启用碰撞检测，默认为true。
	     * @return {undefined}
	     */
	
	  }, {
	    key: 'moveToSegment',
	    value: function moveToSegment() {
	      var center = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.crtOffsetLocation;
	      var segment = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.crtSegment;
	      var needToRotate = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
	
	      var _this = this;
	
	      var screenCoord = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
	      var needCollision = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : true;
	
	      // this._mapView.activeControl.zoomByFocalLength(50);
	      // this._mapView.activeControl.moveToPoint(center.x, center.y, null, true, true, false);
	      var _mapView$activeContro = this._mapView.activeControl.target,
	          x = _mapView$activeContro.x,
	          y = _mapView$activeContro.y;
	
	      _AnimatorFactory2.default.getInstance().ofNumber(1, 0, 300).on('update', function (animator, target) {
	        var t = target.num;
	        _this._mapView.activeControl.zoomByFocalLength(50);
	        _this._mapView.activeControl.moveToPoint(x * t + (1 - t) * center.x, y * t + (1 - t) * center.y, null, true, needCollision, false);
	      }).on('start', function () {}).on('complete', function () {
	
	        if (needToRotate) {
	          var startPt = segment.spot.lineString.getCoordinate();
	          var endPt = segment.spot.nextLineSpot ? segment.spot.nextLineSpot.lineString.getCoordinate() : segment.spot.lineString.points.coordinates[1];
	          var dirVec = new THREE.Vector3(endPt.x - startPt.x, endPt.y - startPt.y, 0);
	          var crtAngle = _this._mapView.activeControl.getRotate();
	          var targetAngle = -(_this._mapView.activeControl._getAngle(dirVec) - 270);
	
	          if (crtAngle - targetAngle < -180) {
	            crtAngle += 360;
	          } else if (crtAngle - targetAngle > 180) {
	            targetAngle += 360;
	          }
	
	          _AnimatorFactory2.default.getInstance().ofNumber(crtAngle, targetAngle, 500).on('update', function (animator, target) {
	            _this._mapView.activeControl.moveToPoint(center.x, center.y, null, true, true, false);
	            _this._mapView.activeControl.zoomByFocalLength(50);
	            _this._mapView.activeControl.rotateTo(center.x, center.y, target.num, true, needCollision);
	          }).on('start', function () {}).on('complete', function () {
	            // if (screenCoord) {
	            //   const target = this._mapView.activeControl.target;
	            //   const targetRef = this._mapView.activeCamera.toCameraCoordinate(screenCoord.x, screenCoord.y, 0);
	            //   const newTarget = new THREE.Vector2(center.x, center.y).sub(targetRef.add(target));
	            //   this._mapView.activeControl.moveToPoint(newTarget.x, newTarget.y, null, true, needCollision, false);
	            // }
	            // this._mapView.activeControl.moveToPoint(center.x, center.y, null, true, true, false);
	          }).start();
	        }
	      }).start();
	    }
	
	    /**
	     * 计算导航线段上的某个点距离导航终点的距离。如果传入的坐标不在任何导航线段上，则计算离该坐标最近的导航线上的点距离导航终点的距离。
	     * 如果导航线段不存在则返回-1。
	     * @param  {Number} x              坐标点x轴坐标，默认为crtOffsetLocation.x。
	     * @param  {Number} y              坐标点y轴坐标，默认为crtOffsetLocation.y。
	     * @param  {Number} planarGraphId  平面图id。默认为crtPlanarGraphId。
	     * @param  {Bool}   measured       如果传入的坐标在导航线段上则为true，不确定是否在导航线上则为false
	     * @param  {Bool}   hasOffset      是否对坐标区域进行偏移，是则设置为true。
	     * @return {Number}                距离终点的距离。
	     */
	
	  }, {
	    key: 'distanceToEnd',
	    value: function distanceToEnd() {
	      var x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.crtOffsetLocation.x;
	      var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.crtOffsetLocation.y;
	      var planarGraphId = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this._crtPlanarGraphId;
	      var measured = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
	      var hasOffset = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : true;
	
	      if (this._trigger._segments.length === 0) {
	        return -1;
	      }
	      var nearestSegment = this.returnNearestSegment(x, y, planarGraphId, measured, hasOffset);
	      if (!nearestSegment.segment) {
	        // throw new Error('Input point not on segment');
	        return -1;
	      }
	      var segment = this._trigger._segments[nearestSegment.index];
	      var coord = new _jsts.geom.Coordinate(x, y);
	      if (hasOffset) {
	        var offset = this._mapView.coordinateSystem.getOffset();
	        coord.x -= offset[0];
	        coord.y -= offset[1];
	      }
	      return segment.state.distanceToEnd - segment.spot.lineString.getCoordinate().distance(coord);
	    }
	
	    /**
	     * 获取导航线段上的某个点的下一个连通设施的信息。如果传入的坐标不在任何导航线段上，则获取离该坐标最近的导航线上的点的下一个连通设施的信息。
	     * 如果导航线段不存在或者不再经过连通设施则返回null。
	     * @param  {Number} x              坐标点x轴坐标，默认为crtOffsetLocation.x。
	     * @param  {Number} y              坐标点y轴坐标，默认为crtOffsetLocation.y。
	     * @param  {Number} planarGraphId  平面图id。默认为crtPlanarGraphId。
	     * @param  {Bool}   measured       如果传入的坐标在导航线段上则为true，不确定是否在导航线上则为false
	     * @param  {Bool}   hasOffset      是否对坐标区域进行偏移，是则设置为true。
	     * @return {Object}                距离下一个最近的连通设施的信息。
	     */
	
	  }, {
	    key: 'getConnectionInfo',
	    value: function getConnectionInfo() {
	      var x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.crtOffsetLocation.x;
	      var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.crtOffsetLocation.y;
	      var planarGraphId = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this._crtPlanarGraphId;
	      var measured = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
	      var hasOffset = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : true;
	
	      if (this._trigger._segments.length === 0) {
	        return null;
	      }
	      var nearestSegment = this.returnNearestSegment(x, y, planarGraphId, measured, hasOffset);
	      if (!nearestSegment.segment) {
	        // throw new Error('Input point not on segment');
	        return null;
	      }
	      var segment = this._trigger._segments[nearestSegment.index];
	      var coord = new _jsts.geom.Coordinate(x, y);
	      if (hasOffset) {
	        var offset = this._mapView.coordinateSystem.getOffset();
	        coord.x -= offset[0];
	        coord.y -= offset[1];
	      }
	      var connectionDist = segment.state.distanceToConnection - segment.spot.lineString.getCoordinate().distance(coord);
	      if (!connectionDist) {
	        return null;
	      }
	      var targetFloor = void 0,
	          isUp = void 0;
	      var index = nearestSegment.index;
	      while (segment) {
	        if (segment.state && segment.state.targetFloor) {
	          targetFloor = segment.state.targetFloor;
	          isUp = segment.state.isUp;
	          break;
	        }
	        index++;
	        segment = this._trigger._segments[index];
	      }
	      return { connectionDist: connectionDist, targetFloor: targetFloor, isUp: isUp, index: index };
	    }
	
	    /**
	     * 计算导航线段上的某个点距离当前导航线段终点的距离，如果传入的坐标不在任何导航线段上，则计算离该坐标最近的导航线上的点距离当前导航线段终点的距离。
	     * 如果导航线段不存在则返回null。
	     * @param  {Number} x              坐标点x轴坐标，默认为crtOffsetLocation.x。
	     * @param  {Number} y              坐标点y轴坐标，默认为crtOffsetLocation.y。
	     * @param  {Number} planarGraphId  平面图id。默认为crtPlanarGraphId。
	     * @param  {Bool}   measured       如果传入的坐标在导航线段上则为true，不确定是否在导航线上则为false
	     * @param  {Bool}   hasOffset      是否对坐标区域进行偏移，是则设置为true。
	     * @return {Number}                距离导航线段终点的距离。
	     */
	
	  }, {
	    key: 'distanceToSegmentEnd',
	    value: function distanceToSegmentEnd() {
	      var x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.crtOffsetLocation.x;
	      var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.crtOffsetLocation.y;
	      var planarGraphId = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this._crtPlanarGraphId;
	      var measured = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
	      var hasOffset = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : true;
	
	      if (this._trigger._segments.length === 0) {
	        return null;
	      }
	      if (this._trigger._segments[this._dynamicNavigationRule.currentIndex + 1]) {
	        return this.distanceToEnd(x, y, planarGraphId, measured, hasOffset) - this._trigger._segments[this._dynamicNavigationRule.currentIndex + 1].state.distanceToEnd;
	      }
	      return this.distanceToEnd(x, y, planarGraphId, measured, hasOffset);
	    }
	
	    /**
	     * 计算导航线段上的某个点距离当前导航线段起点的距离，如果传入的坐标不在任何导航线段上，则计算离该坐标最近的导航线上的点距离当前导航线段起点的距离。
	     * 如果导航线段不存在则返回null。
	     * @param  {Number} x              坐标点x轴坐标，默认为crtOffsetLocation.x。
	     * @param  {Number} y              坐标点y轴坐标，默认为crtOffsetLocation.y。
	     * @param  {Number} planarGraphId  平面图id。默认为crtPlanarGraphId。
	     * @param  {Bool}   measured       如果传入的坐标在导航线段上则为true，不确定是否在导航线上则为false
	     * @param  {Bool}   hasOffset      是否对坐标区域进行偏移，是则设置为true。
	     * @return {Number}                距离导航线段起点的距离。
	     */
	
	  }, {
	    key: 'distanceToSegmentStart',
	    value: function distanceToSegmentStart() {
	      var x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.crtOffsetLocation.x;
	      var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.crtOffsetLocation.y;
	      var planarGraphId = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this._crtPlanarGraphId;
	      var measured = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
	      var hasOffset = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : true;
	
	      if (this._trigger._segments.length === 0) {
	        return null;
	      }
	      return this._trigger._segments[this._dynamicNavigationRule.currentIndex].state.distanceToEnd - this.distanceToEnd(x, y, planarGraphId, measured, hasOffset);
	    }
	
	    /**
	     * 返回导航当中当前导航线段的导航提示信息。如果导航线段不存在则返回null。
	     * @param  {Bool} mute 是否静音。如果不静音则播放语音提示。
	     * @return {String}    当前导航提示信息。
	     */
	
	  }, {
	    key: 'getMessageInNavi',
	    value: function getMessageInNavi() {
	      var mute = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
	
	      if (this._trigger._segments.length === 0) {
	        return null;
	      }
	      var crtSegment = this._trigger._segments[this._dynamicNavigationRule.currentIndex];
	      var center = this.crtLocation;
	      if (!center) {
	        return null;
	      }
	      if (!this._crtPlanarGraphId) {
	        if (!mute) {
	          this.playMessage('\u5F00\u59CB\u5BFC\u822A\uFF0C' + crtSegment.getMessageInNavi(0, mute));
	        }
	        return crtSegment.getMessageInNavi(0, true);
	      }
	
	      var connectionInfo = this.getConnectionInfo();
	      if (connectionInfo && connectionInfo.connectionDist < 10) {
	        return this.segments[connectionInfo.index].getMessageInNavi(100000, mute);
	      }
	      if (this.distanceToEnd() < this._messageOptions.endThreshold) {
	        if (this._messageOptions.endMessage) {
	          return this.playMessage(this._messageOptions.endMessage);
	        }
	        return this.segments[this.segments.length - 1].getMessageInNavi(100000, mute);
	      }
	      var passDist = crtSegment.state.distanceToEnd - this.distanceToEnd(center.x, center.y, this._crtPlanarGraphId, true, false);
	      // if (this.crtIndex === 0 && passDist < 0.1) {
	      //   passDist = 0.1;
	      // }
	      return crtSegment.getMessageInNavi(passDist, mute);
	    }
	
	    /**
	     * 返回整段导航路线的提示信息列表，如果导航线段不存在则返回空数组。
	     * @return {String[]}    导航提示信息列表。
	     */
	
	  }, {
	    key: 'getMessageInList',
	    value: function getMessageInList() {
	      var messageList = [];
	      if (this.segments) {
	        this.segments.forEach(function (segment) {
	          messageList.push(segment.getMessageInList());
	        });
	      }
	      return messageList;
	    }
	
	    /**
	     * 手动配置/播放语音信息。
	     * @param  {String} message 需要播放的信息。
	     * @return {String}         需要播放的信息。
	     */
	
	  }, {
	    key: 'playMessage',
	    value: function playMessage(message) {
	      if (this._trigger._audioProvider) {
	        this._trigger._audioProvider.playMessage(message);
	      }
	      return message;
	    }
	
	    /**
	     * 暂停语音信息。
	     * @return {undefined}
	     */
	
	  }, {
	    key: 'pauseMessage',
	    value: function pauseMessage() {
	      if (this._trigger._audioProvider) {
	        this._trigger._audioProvider.audioElmt.pause();
	      }
	    }
	
	    /**
	     * 设置导航线段切换事件触发的回调。
	     * @type {Function}
	     * @param  {Function} callback 回调函数。
	     */
	
	  }, {
	    key: '_onLocationChange',
	    value: function _onLocationChange(location) {
	      if (this._cameraOptions.autoMove) {
	        this.moveToSegment();
	      }
	      if (this._onLocChangeCallback) {
	        this._onLocChangeCallback(location);
	      }
	      if (this.distanceToEnd() <= this._messageOptions.endThreshold && this.distanceToEnd() >= 0 && this._messageOptions.needAudio && this._messageOptions.autoplay) {
	        this.getMessageInNavi(this._isArrived);
	        this._isArrived = true;
	      }
	    }
	  }, {
	    key: '_onSegmentChange',
	    value: function _onSegmentChange(segment) {
	      if (this._messageOptions.needAudio && this._messageOptions.autoplay) {
	        this.getMessageInNavi(this._isArrived);
	      }
	      // if (this._cameraOptions.autoMove) {
	      //   this.moveToSegment();
	      // }
	      if (this._onSegChangeCallback) {
	        this._onSegChangeCallback(segment);
	      }
	    }
	  }, {
	    key: '_onArriveSegEnd',
	    value: function _onArriveSegEnd() {
	      if (this._messageOptions.needAudio && this._messageOptions.autoplay) {
	        // this.crtSegment.getMessageInNavi(1000000, this._isArrived);
	      }
	    }
	  }, {
	    key: 'featureCollection',
	    set: function set(featureCollection) {
	      this._trigger.trigger(featureCollection);
	      this._dynamicNavigationRule.reset();
	      this._dynamicNavigationRule._center = this.crtSegment.spot.lineString.getCoordinate() || null;
	      this._crtPlanarGraphId = null;
	      this._isArrived = false;
	      this._dynamicNavigationRule._changeSegment(this.crtSegment, this.crtLocation);
	    }
	  }, {
	    key: 'trigger',
	    get: function get() {
	      return this._trigger;
	    }
	  }, {
	    key: 'dynamicNavigationRule',
	    get: function get() {
	      return this._dynamicNavigationRule;
	    }
	
	    /**
	     * 获取当前导航路径下面所有导航线段的信息。
	     * @return {Segment[]} 导航线段列表。
	     */
	
	  }, {
	    key: 'segments',
	    get: function get() {
	      return this._trigger._segments;
	    }
	  }, {
	    key: 'crtLocation',
	    get: function get() {
	      return this._dynamicNavigationRule.center;
	    }
	
	    /**
	     * 上一次调用findNearestSegment方法后找到的导航线上的点的地图坐标。
	     * @return {NGR.geom.Coordinate} crtLocation
	     */
	
	  }, {
	    key: 'crtOffsetLocation',
	    get: function get() {
	      var coord = this._dynamicNavigationRule.center.copy();
	      var offset = this._mapView.coordinateSystem.getOffset();
	      coord.x += offset[0];
	      coord.y += offset[1];
	      return coord;
	    }
	
	    /**
	     * 上一次调用findNearestSegment方法后找到的导航线段的索引。
	     * @return {Number} crtIndex
	     */
	
	  }, {
	    key: 'crtIndex',
	    get: function get() {
	      return this._dynamicNavigationRule.currentIndex;
	    }
	
	    /**
	     * 上一次调用findNearestSegment方法后找到的导航线段的索引。
	     * @return {Number} crtIndex
	     */
	
	  }, {
	    key: 'crtSegment',
	    get: function get() {
	      return this._trigger._segments[this._dynamicNavigationRule.currentIndex] || null;
	    }
	
	    /**
	     * 上一次调用findNearestSegment方法后更新的planerGraphId。
	     * @return {Number} crtPlanarGraphId
	     */
	
	  }, {
	    key: 'crtPlanarGraphId',
	    get: function get() {
	      return this._crtPlanarGraphId;
	    }
	  }, {
	    key: 'onSegmentChange',
	    set: function set(callback) {
	      this._onSegChangeCallback = callback;
	    }
	
	    /**
	     * 设置当前位置更新事件触发的回调。
	     * @type {Function}
	     * @param  {Function} callback 回调函数。
	     */
	
	  }, {
	    key: 'onLocationChange',
	    set: function set(callback) {
	      this._onLocChangeCallback = callback;
	    }
	  }]);
	
	  return DynamicNavigation;
	}();
	
	exports.default = DynamicNavigation;

/***/ }),
/* 75 */
/***/ (function(module, exports) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var StateMate = function () {
	  function StateMate() {
	    _classCallCheck(this, StateMate);
	  }
	
	  _createClass(StateMate, [{
	    key: "mate",
	    value: function mate(spot) {
	      // eslint-disable-line no-unused-vars
	      return null;
	    }
	  }]);
	
	  return StateMate;
	}();
	
	exports.default = StateMate;

/***/ }),
/* 76 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _assign = __webpack_require__(1);
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _NGRObject2 = __webpack_require__(7);
	
	var _NGRObject3 = _interopRequireDefault(_NGRObject2);
	
	var _jsts = __webpack_require__(5);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	/**
	 * 覆盖物类，用于在地图上添加各种标志、文字和图片。
	 * @extends {NGRObject}
	 * @memberOf NGR.overlay
	 */
	var Overlay = function (_NGRObject) {
	  _inherits(Overlay, _NGRObject);
	
	  /**
	   * 构造方法。
	   * @param  {HTMLElement} dom     HTML页面的DOM元素。
	   * @param  {Object}      options 覆盖物选项，如控制默认是否显示defaultDisplay。
	   */
	  function Overlay(dom, options) {
	    _classCallCheck(this, Overlay);
	
	    var _this = _possibleConstructorReturn(this, (Overlay.__proto__ || Object.getPrototypeOf(Overlay)).call(this));
	
	    _this.targetDom = dom;
	    _this._options = _assign({}, options);
	    if (!_this._options.defaultDisplay) {
	      _this._options.defaultDisplay = _this.targetDom && _this.targetDom.style.display ? _this.targetDom.style.display : 'inline';
	    }
	    _this._position = new _jsts.geom.Coordinate(0, 0, 0);
	    return _this;
	  }
	
	  _createClass(Overlay, [{
	    key: 'attach',
	    value: function attach(layer) {
	      this._layer = layer;
	    }
	  }, {
	    key: 'detach',
	    value: function detach(layer) {
	      // eslint-disable-line no-unused-vars
	      delete this._layer;
	    }
	  }, {
	    key: 'layer',
	    get: function get() {
	      return this._layer;
	    }
	  }, {
	    key: 'coordinateSystem',
	    get: function get() {
	      return this._coordinateSystem;
	    }
	
	    /**
	     * 给覆盖物设置坐标系。
	     * @type {NGR.view.CoordinateSystem}
	     * @param  {NGR.view.CoordinateSystem} coordinateSystem 坐标系。
	     */
	    ,
	    set: function set(coordinateSystem) {
	      this._coordinateSystem = coordinateSystem;
	    }
	  }, {
	    key: 'targetDom',
	    get: function get() {
	      return this._dom;
	    }
	
	    /**
	     * 目标DOM元素。
	     * @type {HTMLElement}
	     * @param  {HTMLElement} dom 用于存放覆盖物的DOM元素。
	     */
	    ,
	    set: function set(dom) {
	      this._dom = dom;
	      this.emit('valueChange', this, 'targetDom', dom);
	    }
	  }, {
	    key: 'position',
	    get: function get() {
	      return this._position;
	    }
	
	    /**
	     * 覆盖物出现的位置。
	     * @type {NGR.geom.Coordinate}
	     * @param  {NGR.geom.Coordinate} position 位置，以坐标表示。
	     */
	    ,
	    set: function set(position) {
	      var x = position.x;
	      var y = position.y;
	      if (this.coordinateSystem) {
	        var offset = this._coordinateSystem.getOffset();
	        x += offset[0];
	        y += offset[1];
	      }
	      this._position.x = x;
	      this._position.y = y;
	      this._position.z = position.z;
	      this.emit('valueChange', this, 'position', this._position);
	    }
	  }]);
	
	  return Overlay;
	}(_NGRObject3.default);
	
	exports.default = Overlay;

/***/ }),
/* 77 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.IconOverlay = exports.Overlay = undefined;
	
	var _Overlay = __webpack_require__(76);
	
	var _Overlay2 = _interopRequireDefault(_Overlay);
	
	var _IconOverlay = __webpack_require__(190);
	
	var _IconOverlay2 = _interopRequireDefault(_IconOverlay);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.Overlay = _Overlay2.default;
	exports.IconOverlay = _IconOverlay2.default;

/***/ }),
/* 78 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _NGRObject2 = __webpack_require__(7);
	
	var _NGRObject3 = _interopRequireDefault(_NGRObject2);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var ParticleEngine = function (_NGRObject) {
	  _inherits(ParticleEngine, _NGRObject);
	
	  function ParticleEngine() {
	    _classCallCheck(this, ParticleEngine);
	
	    var _this = _possibleConstructorReturn(this, (ParticleEngine.__proto__ || Object.getPrototypeOf(ParticleEngine)).call(this));
	
	    _this._particleGroups = {};
	    return _this;
	  }
	
	  _createClass(ParticleEngine, [{
	    key: 'addParticleGroup',
	    value: function addParticleGroup(particleGroup) {
	      if (!particleGroup && this.has(particleGroup)) {
	        return;
	      }
	      this._particleGroups[particleGroup.id] = particleGroup;
	      this.emit('addParticleGroup', particleGroup);
	    }
	  }, {
	    key: 'removeParticleGroup',
	    value: function removeParticleGroup(particleGroup) {
	      if (this.has(particleGroup)) {
	        delete this._particleGroups[particleGroup.id];
	        this.emit('removeParticleGroup', particleGroup);
	      }
	    }
	  }, {
	    key: 'has',
	    value: function has(particleGroup) {
	      return !!particleGroup && particleGroup.id in this._particleGroups;
	    }
	  }, {
	    key: 'destroy',
	    value: function destroy() {
	      for (var key in this._particleGroups) {
	        this.removeParticleGroup(this._particleGroups[key]);
	      }
	    }
	  }]);
	
	  return ParticleEngine;
	}(_NGRObject3.default);
	
	exports.default = ParticleEngine;

/***/ }),
/* 79 */
/***/ (function(module, exports) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var Renderer = function () {
	  function Renderer() {
	    _classCallCheck(this, Renderer);
	  }
	
	  _createClass(Renderer, [{
	    key: "getStyle",
	    value: function getStyle(feature) {
	      // eslint-disable-line no-unused-vars
	      return null;
	    }
	  }]);
	
	  return Renderer;
	}();
	
	exports.default = Renderer;

/***/ }),
/* 80 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _assign = __webpack_require__(1);
	
	var _Style = __webpack_require__(14);
	
	var _Style2 = _interopRequireDefault(_Style);
	
	var _StyleUtil = __webpack_require__(19);
	
	var _StyleUtil2 = _interopRequireDefault(_StyleUtil);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var defaultProps = {
	  /**
	   * 字体。
	   * @type {String}
	   * @memberof NGR.style.Annotation.prototype
	   */
	  font: '20px Arial',
	  /**
	   * 属性对应的字段。
	   * @type {String}
	   * @memberof NGR.style.Annotation.prototype
	   */
	  field: null,
	  /**
	   * 描边宽度。
	   * @type {Number}
	   * @memberof NGR.style.Annotation.prototype
	   */
	  outlineWidth: null,
	  shadowBlur: null,
	  /**
	   * 锚点,即文字旋转的时候的中心点,是一个百分比,表示这个点与文字长度的相对位置。如为50%,即表示锚点在文字的正中。
	   * @type {Number[]}
	   * @memberof NGR.style.Annotation.prototype
	   */
	  anchor: [0.5, 0.5],
	  /**
	   * 是否自动计算锚点位置。True表示自动计算,否则false。
	   * @type {Boolean}
	   * @memberof NGR.style.Annotation.prototype
	   */
	  anchorAuto: false,
	  /**
	   * 锚点样式，如图片、线条等。
	   * @type {NGR.style.Style}
	   * @memberof NGR.style.Annotation.prototype
	   */
	  anchorStyle: null,
	  /**
	   * 是否优化计算文字区域，true表示优化，否则false。
	   * @type {Boolean}
	   * @memberof NGR.style.Annotation.prototype
	   */
	  optTextRect: false,
	  /**
	   * 返回样式类型。
	   * @memberof NGR.style.Annotation.prototype
	   * @override
	   * @return {String} 样式类型。
	   */
	  type: function type() {
	    return 'Annotation';
	  }
	};
	
	/**
	 * 设置文字显示样式。
	 * @memberOf NGR.style
	 * @class Annotation
	 * @extends {NGR.style.Style}
	 */
	function Annotation() {
	  _assign(this, new _Style2.default(), defaultProps);
	}
	
	/**
	 * 颜色(16进制码的字符串)。
	 * @type {String}
	 * @name NGR.style.Annotation#color
	 */
	Object.defineProperty(Annotation.prototype, 'color', {
	  get: function get() {
	    return this._color;
	  },
	  set: function set(color) {
	    this._color = _StyleUtil2.default.converToSharp(color);
	  }
	});
	
	/**
	 * 描边颜色(16进制码的字符串)。
	 * @type {String}
	 * @name NGR.style.Annotation#outlineColor
	 */
	Object.defineProperty(Annotation.prototype, 'outlineColor', {
	  get: function get() {
	    return this._outlineColor;
	  },
	  set: function set(color) {
	    this._outlineColor = _StyleUtil2.default.converToSharp(color);
	  }
	});
	
	Object.defineProperty(Annotation.prototype, 'shadowColor', {
	  get: function get() {
	    return this._shadowColor;
	  },
	  set: function set(color) {
	    this._shadowColor = _StyleUtil2.default.converToSharp(color);
	  }
	});
	
	exports.default = Annotation;

/***/ }),
/* 81 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _assign = __webpack_require__(1);
	
	var _Style = __webpack_require__(14);
	
	var _Style2 = _interopRequireDefault(_Style);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var defaultProps = {
	  /**
	   * 锚点，即图片旋转时的中心点，是一个百分比，表示这个点与图片宽度的相对位置。如为50%，即表示锚点在图片的正中。
	   * @type {Number[]}
	   * @memberof NGR.style.Icon.prototype
	   */
	  anchor: [0.5, 0.5],
	  /**
	   * 纹理路径。若设置serverUrl和field，就不能设置texture。
	   * @type {String}
	   * @memberof NGR.style.Icon.prototype
	   */
	  field: null,
	  /**
	   * 纹理路径。若设置serverUrl和field，就不能设置texture。
	   * @type {String}
	   * @memberof NGR.style.Icon.prototype
	   */
	  serverUrl: null,
	  /**
	   * 图片高度，单位像素。
	   * @type {Number}
	   * @memberof NGR.style.Icon.prototype
	   */
	  height: null,
	  /**
	   * 图片宽度，单位像素。
	   * @type {Number}
	   * @memberof NGR.style.Icon.prototype
	   */
	  width: null,
	  /**
	   * 纹理路径。若设置texture，就不能设置serverUrl和field。
	   * @type {String}
	   * @memberof NGR.style.Icon.prototype
	   */
	  texture: null,
	  plane: null,
	  /**
	   * 返回样式类型。
	   * @memberof NGR.style.Icon.prototype
	   * @override
	   * @return {String} 样式类型。
	   */
	  type: function type() {
	    return 'Icon';
	  }
	};
	
	/**
	 * 设置图片显示样式。
	 * @memberOf NGR.style
	 * @class Icon
	 * @extends {NGR.style.Style}
	 */
	function Icon() {
	  _assign(this, new _Style2.default(), defaultProps);
	}
	
	exports.default = Icon;

/***/ }),
/* 82 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	var _assign = __webpack_require__(1);
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _StyleGenerator2 = __webpack_require__(46);
	
	var _StyleGenerator3 = _interopRequireDefault(_StyleGenerator2);
	
	var _Annotation = __webpack_require__(80);
	
	var _Annotation2 = _interopRequireDefault(_Annotation);
	
	var _Icon = __webpack_require__(81);
	
	var _Icon2 = _interopRequireDefault(_Icon);
	
	var _Polygon = __webpack_require__(85);
	
	var _Polygon2 = _interopRequireDefault(_Polygon);
	
	var _LineString = __webpack_require__(84);
	
	var _LineString2 = _interopRequireDefault(_LineString);
	
	var _Model = __webpack_require__(211);
	
	var _Model2 = _interopRequireDefault(_Model);
	
	var _Sphere = __webpack_require__(212);
	
	var _Sphere2 = _interopRequireDefault(_Sphere);
	
	var _Light = __webpack_require__(83);
	
	var _Light2 = _interopRequireDefault(_Light);
	
	var _SimpleRenderer = __webpack_require__(194);
	
	var _SimpleRenderer2 = _interopRequireDefault(_SimpleRenderer);
	
	var _UniqueRenderer = __webpack_require__(195);
	
	var _UniqueRenderer2 = _interopRequireDefault(_UniqueRenderer);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	/**
	 * JSON样式生成类。JSON文件用于存放对各种样式的配置信息。
	 * @extends {StyleGenerator}
	 * @memberOf NGR.style
	 */
	var JSONStyleGenerator = function (_StyleGenerator) {
	  _inherits(JSONStyleGenerator, _StyleGenerator);
	
	  /**
	   * 构造函数。
	   * @param  {Object} styleJson JSON样式对象。
	   */
	  function JSONStyleGenerator(styleJson) {
	    _classCallCheck(this, JSONStyleGenerator);
	
	    var _this = _possibleConstructorReturn(this, (JSONStyleGenerator.__proto__ || Object.getPrototypeOf(JSONStyleGenerator)).call(this));
	
	    _this._styleJson = styleJson;
	    return _this;
	  }
	
	  /**
	   * @override
	   */
	
	
	  _createClass(JSONStyleGenerator, [{
	    key: 'generator',
	    value: function generator(layer) {
	      // return renderer
	      if (!(this._styleJson.default && layer && this._styleJson.default[layer.name])) {
	        console.warn('Invalid Json or Layer');
	        return null;
	      }
	
	      var layerJson = this._styleJson.default[layer.name];
	      var renderer = null;
	
	      layer.height = layerJson.height || 0;
	
	      if (layerJson.renderer && layerJson.renderer.type === 'simple') {
	        renderer = new _SimpleRenderer2.default();
	        renderer.style = this._generator(layerJson.renderer.style);
	      } else if (layerJson.renderer && layerJson.renderer.type === 'unique') {
	        renderer = new _UniqueRenderer2.default();
	        renderer.defaultStyle = this._generator(layerJson.renderer.default);
	        for (var _iterator = layerJson.renderer.keys, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
	          var _ref;
	
	          if (_isArray) {
	            if (_i >= _iterator.length) break;
	            _ref = _iterator[_i++];
	          } else {
	            _i = _iterator.next();
	            if (_i.done) break;
	            _ref = _i.value;
	          }
	
	          var key = _ref;
	
	          renderer.addKey(key);
	        }
	        for (var value in layerJson.renderer.styles) {
	          renderer.addStyle(value, this._generator(layerJson.renderer.styles[value], renderer.defaultStyle));
	        }
	      } else {
	        console.warn('Invalid Renderer Type');
	      }
	
	      return renderer;
	    }
	  }, {
	    key: '_initialsToCapitals',
	    value: function _initialsToCapitals(str) {
	      return str.replace(/(\w)/, function (char) {
	        return char.toUpperCase();
	      });
	    }
	  }, {
	    key: '_parse',
	    value: function _parse(styleJson, style, defaultStyle) {
	      var checkSubStyle = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
	
	      if (defaultStyle) {
	        _assign(style, defaultStyle);
	      }
	      for (var key in styleJson) {
	        if (key === 'type') {
	          continue;
	        }
	
	        var value = styleJson[key];
	
	        if (checkSubStyle && this._hasStyle(value)) {
	          var subDefaultStyle = defaultStyle && defaultStyle[key] || {};
	
	          value = this._generator(value, subDefaultStyle);
	          if (style[key]) {
	            var subStyle = style[key];
	            var tempValue = this._generator({ type: value.type() });
	
	            value = _assign(tempValue, subStyle, value);
	          }
	        }
	        style[key] = value;
	      }
	    }
	  }, {
	    key: '_generator',
	    value: function _generator(styleJson, defaultStyle) {
	      var type = styleJson.type;
	      var style = void 0;
	
	      switch (type) {
	        case 'Polygon':
	          style = new _Polygon2.default();
	          this._parse(styleJson, style, defaultStyle);
	          for (var key in styleJson.face) {
	            style[key] = styleJson.face[key];
	          }
	          for (var _key in styleJson.outline) {
	            var outlineKey = 'outline' + this._initialsToCapitals(_key);
	
	            style[outlineKey] = styleJson.outline[_key];
	          }
	          break;
	        case 'Annotation':
	          style = new _Annotation2.default();
	          this._parse(styleJson, style, defaultStyle, true);
	          break;
	        case 'Icon':
	          style = new _Icon2.default();
	          this._parse(styleJson, style, defaultStyle);
	          break;
	        case 'LineString':
	          style = new _LineString2.default();
	          this._parse(styleJson, style, defaultStyle);
	          break;
	        case 'Light':
	          style = new _Light2.default();
	          this._parse(styleJson, style, defaultStyle);
	          break;
	        case 'Model':
	          style = new _Model2.default();
	          this._parse(styleJson, style, defaultStyle);
	          break;
	        case 'Sphere':
	          style = new _Sphere2.default();
	          this._parse(styleJson, style, defaultStyle);
	          break;
	        default:
	          console.warn('Invalid Style Type');
	      }
	
	      return style;
	    }
	  }, {
	    key: '_hasStyle',
	    value: function _hasStyle(options) {
	      return (typeof options === 'undefined' ? 'undefined' : _typeof(options)) === 'object' && !!options && 'type' in options;
	    }
	  }]);
	
	  return JSONStyleGenerator;
	}(_StyleGenerator3.default);
	
	exports.default = JSONStyleGenerator;

/***/ }),
/* 83 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _assign = __webpack_require__(1);
	
	var _Style = __webpack_require__(14);
	
	var _Style2 = _interopRequireDefault(_Style);
	
	var _StyleUtil = __webpack_require__(19);
	
	var _StyleUtil2 = _interopRequireDefault(_StyleUtil);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var defaultProps = {
	  /**
	   * 光照强度。必须设为正数。数字越大则强度越大。
	   * @type {number}
	   * @memberof NGR.style.Light.prototype
	   */
	  intensity: 1,
	  /**
	   * 光照类型。目前只支持一种“HemisphereLight”。
	   * @type {String}
	   * @memberof NGR.style.Light.prototype
	   */
	  lightType: 'HemisphereLight',
	  /**
	   * 返回样式类型。
	   * @memberof NGR.style.Light.prototype
	   * @override
	   * @return {String} 样式类型。
	   */
	  type: function type() {
	    return 'Light';
	  }
	};
	
	/**
	 * 用于设置光照效果。
	 * @memberOf NGR.style
	 * @class Light
	 * @extends {NGR.style.Style}
	 */
	function Light() {
	  _assign(this, new _Style2.default(), defaultProps);
	}
	
	/**
	 * 光照颜色。颜色(16进制码的字符串)
	 * @type {String}
	 * @name NGR.style.Light#color
	 */
	Object.defineProperty(Light.prototype, 'color', {
	  get: function get() {
	    return this._color;
	  },
	  set: function set(color) {
	    this._color = _StyleUtil2.default.parseColor(color);
	  }
	});
	
	/**
	 * 光照相关选项，如强度、类型、颜色等。
	 * @type {Object}
	 * @prop {String} groundColor 光照地面颜色。
	 * @name NGR.style.Light#options
	 */
	Object.defineProperty(Light.prototype, 'options', {
	  get: function get() {
	    return this._options;
	  },
	  set: function set(options) {
	    this._options = _assign({}, options);
	    if (options.groudColor) {
	      this._options.groudColor = _StyleUtil2.default.parseColor(options.groudColor);
	    }
	  }
	});
	
	exports.default = Light;

/***/ }),
/* 84 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _assign = __webpack_require__(1);
	
	var _Style = __webpack_require__(14);
	
	var _Style2 = _interopRequireDefault(_Style);
	
	var _StyleUtil = __webpack_require__(19);
	
	var _StyleUtil2 = _interopRequireDefault(_StyleUtil);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var defaultProps = {
	  /**
	   * 返回样式类型。
	   * @memberof NGR.style.LineString.prototype
	   * @override
	   * @return {String} 样式类型。
	   */
	  type: function type() {
	    return 'LineString';
	  }
	};
	
	/**
	 * 设置线的显示样式。
	 * @memberOf NGR.style
	 * @class LineString
	 * @extends {NGR.style.Style}
	 */
	function LineString() {
	  _assign(this, new _Style2.default(), defaultProps);
	}
	
	/**
	 * 颜色(16进制码的字符串)。
	 * @type {String}
	 * @name NGR.style.LineString#color
	 */
	Object.defineProperty(LineString.prototype, 'color', {
	  get: function get() {
	    return this._color;
	  },
	  set: function set(color) {
	    this._color = _StyleUtil2.default.parseColor(color);
	  }
	});
	
	/**
	 * 样式为虚线。
	 * @type {Number[]}
	 * @name NGR.style.LineString#dash
	 */
	Object.defineProperty(LineString.prototype, 'dash', {
	  get: function get() {
	    return this._dash;
	  },
	  set: function set(dash) {
	    if (dash instanceof Array && dash.length > 1) {
	      this._dash = [dash[0], dash[1]];
	    }
	  }
	});
	
	exports.default = LineString;

/***/ }),
/* 85 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _assign = __webpack_require__(1);
	
	var _Style = __webpack_require__(14);
	
	var _Style2 = _interopRequireDefault(_Style);
	
	var _StyleUtil = __webpack_require__(19);
	
	var _StyleUtil2 = _interopRequireDefault(_StyleUtil);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var defaultProps = {
	  /**
	   * 纹理路径。
	   * @type {String}
	   * @memberof NGR.style.Polygon.prototype
	   */
	  texture: null,
	  /**
	   * 高度，单位米。
	   * @type {Number}
	   * @memberof NGR.style.Polygon.prototype
	   */
	  height: 0,
	  z: 0,
	  /**
	   * 是否合并多边形。true为合并，false为不合并。
	   * @type {Boolean}
	   * @memberof NGR.style.Polygon.prototype
	   */
	  polygonMerge: false,
	  /**
	   * 是否合并边线。true为合并，false为不合并。。
	   * @type {Boolean}
	   * @memberof NGR.style.Polygon.prototype
	   */
	  outlineMerge: true,
	  /**
	   * 是否启用边线混合。true为合并，false为不合并。。
	   * @type {Boolean}
	   * @memberof NGR.style.Polygon.prototype
	   */
	  outlineBlending: true,
	  /**
	   * 是否可以点击。
	   * @type {Boolean}
	   * @memberof NGR.style.Polygon.prototype
	   */
	  clickable: true,
	  /**
	   * 返回样式类型。
	   * @memberof NGR.style.Polygon.prototype
	   * @override
	   * @return {String} 样式类型
	   */
	  type: function type() {
	    return 'Polygon';
	  }
	};
	
	/**
	 * 多边形的显示样式。
	 * @memberOf NGR.style
	 * @class Polygon
	 * @extends {NGR.style.Style}
	 */
	function Polygon() {
	  _assign(this, new _Style2.default(), defaultProps);
	}
	
	/**
	 * 多边形的颜色(16进制码的字符串)。
	 * @type {String}
	 * @name NGR.style.Polygon#color
	 */
	Object.defineProperty(Polygon.prototype, 'color', {
	  get: function get() {
	    return this._color;
	  },
	  set: function set(color) {
	    this._color = _StyleUtil2.default.parseColor(color);
	  }
	});
	
	/**
	 * 边线颜色(16进制码的字符串)。
	 * @type {String}
	 * @name NGR.style.Polygon#outlineColor
	 */
	Object.defineProperty(Polygon.prototype, 'outlineColor', {
	  get: function get() {
	    return this._outlineColor;
	  },
	  set: function set(color) {
	    this._outlineColor = _StyleUtil2.default.parseColor(color);
	  }
	});
	
	exports.default = Polygon;

/***/ }),
/* 86 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _lang = __webpack_require__(4);
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	/**
	 * 为地图创建包含偏移量的坐标系统。该坐标系可以是世界坐标也可以是屏幕坐标。需保证相同地图使用统一的坐标系统。
	 * @memberOf NGR.view
	 */
	var CoordinateSystem = function () {
	  function CoordinateSystem() {
	    _classCallCheck(this, CoordinateSystem);
	  }
	
	  _createClass(CoordinateSystem, [{
	    key: 'offset',
	    value: function offset(x, y) {
	      return [x - this._offset[0], y - this._offset[1]];
	    }
	
	    /**
	     * 为坐标系统设置偏移量。
	     * @param {Array} offset               偏移量。
	     * @return {NGR.view.CoordinateSystem} 坐标系统.
	     */
	
	  }, {
	    key: 'setOffset',
	    value: function setOffset(offset) {
	      if (!((0, _lang.isArray)(offset) && offset.length === 2)) {
	        console.warn('Invalid Offset');
	
	        return this;
	      }
	      this._offset = offset;
	
	      return this;
	    }
	
	    /**
	     * 获取坐标系统的偏移量。偏移量会根据选择的不同坐标系而有所不同。
	     * @return {Array} 偏移量。
	     */
	
	  }, {
	    key: 'getOffset',
	    value: function getOffset() {
	      return this._offset;
	    }
	  }], [{
	    key: 'getExtentCenter',
	
	    /**
	     * 获取指定区域的中心点。
	     * @param  {Number[]} rect 指定的区域。使用矩形四个顶点的坐标来表示。
	     * @return {Array}        中心点坐标。
	     */
	    value: function getExtentCenter(rect) {
	      var minx = rect[0];
	      var miny = rect[1];
	      var maxx = rect[2];
	      var maxy = rect[3];
	      return [(minx + maxx) / 2, (miny + maxy) / 2];
	    }
	  }]);
	
	  return CoordinateSystem;
	}();
	
	exports.default = CoordinateSystem;

/***/ }),
/* 87 */
/***/ (function(module, exports) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var RenderLoop = function () {
	  function RenderLoop() {
	    _classCallCheck(this, RenderLoop);
	
	    this._running = false;
	  }
	
	  _createClass(RenderLoop, [{
	    key: "loop",
	    value: function loop(loopCallback) {
	      if (this._running) {
	        return;
	      }
	      this._running = true;
	      this._onLoop(loopCallback);
	    }
	  }, {
	    key: "hasRunning",
	    value: function hasRunning() {
	      return this._running;
	    }
	  }, {
	    key: "stop",
	    value: function stop() {
	      this._running = false;
	    }
	  }, {
	    key: "_onLoop",
	    value: function _onLoop(loopCallback) {// eslint-disable-line no-unused-vars
	    }
	  }]);
	
	  return RenderLoop;
	}();
	
	var AnimationFrameRenderLoop = function (_RenderLoop) {
	  _inherits(AnimationFrameRenderLoop, _RenderLoop);
	
	  function AnimationFrameRenderLoop() {
	    _classCallCheck(this, AnimationFrameRenderLoop);
	
	    return _possibleConstructorReturn(this, (AnimationFrameRenderLoop.__proto__ || Object.getPrototypeOf(AnimationFrameRenderLoop)).apply(this, arguments));
	  }
	
	  _createClass(AnimationFrameRenderLoop, [{
	    key: "_onLoop",
	    value: function _onLoop(loopCallback) {
	      var _this2 = this;
	
	      var temp = function temp(timestamp) {
	        if (_this2._running) {
	          window.requestAnimationFrame(temp);
	          loopCallback(timestamp);
	        }
	      };
	      window.requestAnimationFrame(temp);
	    }
	  }]);
	
	  return AnimationFrameRenderLoop;
	}(RenderLoop);
	
	var LockFPSRenderLoop = function (_RenderLoop2) {
	  _inherits(LockFPSRenderLoop, _RenderLoop2);
	
	  function LockFPSRenderLoop() {
	    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
	        _ref$fps = _ref.fps,
	        fps = _ref$fps === undefined ? 60 : _ref$fps;
	
	    _classCallCheck(this, LockFPSRenderLoop);
	
	    var _this3 = _possibleConstructorReturn(this, (LockFPSRenderLoop.__proto__ || Object.getPrototypeOf(LockFPSRenderLoop)).call(this));
	
	    _this3._fps = fps;
	    _this3._interval = null;
	    return _this3;
	  }
	
	  _createClass(LockFPSRenderLoop, [{
	    key: "_onLoop",
	    value: function _onLoop(loopCallback) {
	      var _this4 = this;
	
	      var temp = function temp() {
	        if (_this4._running) {
	          window.requestAnimationFrame(loopCallback);
	        }
	      };
	      this._interval = setInterval(temp, 1000 / this._fps);
	    }
	  }, {
	    key: "stop",
	    value: function stop() {
	      if (this._interval) {
	        clearInterval(this._interval);
	      }
	      _get(LockFPSRenderLoop.prototype.__proto__ || Object.getPrototypeOf(LockFPSRenderLoop.prototype), "stop", this).call(this);
	    }
	  }]);
	
	  return LockFPSRenderLoop;
	}(RenderLoop);
	
	exports.RenderLoop = RenderLoop;
	exports.AnimationFrameRenderLoop = AnimationFrameRenderLoop;
	exports.LockFPSRenderLoop = LockFPSRenderLoop;

/***/ }),
/* 88 */
/***/ (function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var Gestrue = function () {
	  function Gestrue() {
	    _classCallCheck(this, Gestrue);
	  }
	
	  _createClass(Gestrue, [{
	    key: 'onAdd',
	    value: function onAdd(gestureManager) {
	      this._gestureManager = gestureManager;
	    }
	  }, {
	    key: 'onRemove',
	    value: function onRemove() /* gestureManager*/{
	      this._gestureManager = null;
	    }
	  }, {
	    key: 'providerEvent',
	    value: function providerEvent() {
	      return null;
	    }
	  }, {
	    key: 'type',
	    value: function type() {
	      return 'none';
	    }
	  }]);
	
	  return Gestrue;
	}();
	
	exports.default = Gestrue;

/***/ }),
/* 89 */
/***/ (function(module, exports) {

	/**
	 * Expose `PriorityQueue`.
	 */
	module.exports = PriorityQueue;
	
	/**
	 * Initializes a new empty `PriorityQueue` with the given `comparator(a, b)`
	 * function, uses `.DEFAULT_COMPARATOR()` when no function is provided.
	 *
	 * The comparator function must return a positive number when `a > b`, 0 when
	 * `a == b` and a negative number when `a < b`.
	 *
	 * @param {Function}
	 * @return {PriorityQueue}
	 * @api public
	 */
	function PriorityQueue(comparator) {
	  this._comparator = comparator || PriorityQueue.DEFAULT_COMPARATOR;
	  this._elements = [];
	}
	
	/**
	 * Compares `a` and `b`, when `a > b` it returns a positive number, when
	 * it returns 0 and when `a < b` it returns a negative number.
	 *
	 * @param {String|Number} a
	 * @param {String|Number} b
	 * @return {Number}
	 * @api public
	 */
	PriorityQueue.DEFAULT_COMPARATOR = function(a, b) {
	  if (typeof a === 'number' && typeof b === 'number') {
	    return a - b;
	  } else {
	    a = a.toString();
	    b = b.toString();
	
	    if (a == b) return 0;
	
	    return (a > b) ? 1 : -1;
	  }
	};
	
	/**
	 * Returns whether the priority queue is empty or not.
	 *
	 * @return {Boolean}
	 * @api public
	 */
	PriorityQueue.prototype.isEmpty = function() {
	  return this.size() === 0;
	};
	
	/**
	 * Peeks at the top element of the priority queue.
	 *
	 * @return {Object}
	 * @throws {Error} when the queue is empty.
	 * @api public
	 */
	PriorityQueue.prototype.peek = function() {
	  if (this.isEmpty()) throw new Error('PriorityQueue is empty');
	
	  return this._elements[0];
	};
	
	/**
	 * Dequeues the top element of the priority queue.
	 *
	 * @return {Object}
	 * @throws {Error} when the queue is empty.
	 * @api public
	 */
	PriorityQueue.prototype.deq = function() {
	  var first = this.peek();
	  var last = this._elements.pop();
	  var size = this.size();
	
	  if (size === 0) return first;
	
	  this._elements[0] = last;
	  var current = 0;
	
	  while (current < size) {
	    var largest = current;
	    var left = (2 * current) + 1;
	    var right = (2 * current) + 2;
	
	    if (left < size && this._compare(left, largest) >= 0) {
	      largest = left;
	    }
	
	    if (right < size && this._compare(right, largest) >= 0) {
	      largest = right;
	    }
	
	    if (largest === current) break;
	
	    this._swap(largest, current);
	    current = largest;
	  }
	
	  return first;
	};
	
	/**
	 * Enqueues the `element` at the priority queue and returns its new size.
	 *
	 * @param {Object} element
	 * @return {Number}
	 * @api public
	 */
	PriorityQueue.prototype.enq = function(element) {
	  var size = this._elements.push(element);
	  var current = size - 1;
	
	  while (current > 0) {
	    var parent = Math.floor((current - 1) / 2);
	
	    if (this._compare(current, parent) <= 0) break;
	
	    this._swap(parent, current);
	    current = parent;
	  }
	
	  return size;
	};
	
	/**
	 * Returns the size of the priority queue.
	 *
	 * @return {Number}
	 * @api public
	 */
	PriorityQueue.prototype.size = function() {
	  return this._elements.length;
	};
	
	/**
	 *  Iterates over queue elements
	 *
	 *  @param {Function} fn
	 */
	PriorityQueue.prototype.forEach = function(fn) {
	  return this._elements.forEach(fn);
	};
	
	/**
	 * Compares the values at position `a` and `b` in the priority queue using its
	 * comparator function.
	 *
	 * @param {Number} a
	 * @param {Number} b
	 * @return {Number}
	 * @api private
	 */
	PriorityQueue.prototype._compare = function(a, b) {
	  return this._comparator(this._elements[a], this._elements[b]);
	};
	
	/**
	 * Swaps the values at position `a` and `b` in the priority queue.
	 *
	 * @param {Number} a
	 * @param {Number} b
	 * @api private
	 */
	PriorityQueue.prototype._swap = function(a, b) {
	  var aux = this._elements[a];
	  this._elements[a] = this._elements[b];
	  this._elements[b] = aux;
	};


/***/ }),
/* 90 */
/***/ (function(module, exports) {

	'use strict';
	
	/* Simplified implementation of DOM2 EventTarget.
	 *   http://www.w3.org/TR/DOM-Level-2-Events/events.html#Events-EventTarget
	 */
	
	function EventTarget() {
	  this._listeners = {};
	}
	
	EventTarget.prototype.addEventListener = function(eventType, listener) {
	  if (!(eventType in this._listeners)) {
	    this._listeners[eventType] = [];
	  }
	  var arr = this._listeners[eventType];
	  // #4
	  if (arr.indexOf(listener) === -1) {
	    // Make a copy so as not to interfere with a current dispatchEvent.
	    arr = arr.concat([listener]);
	  }
	  this._listeners[eventType] = arr;
	};
	
	EventTarget.prototype.removeEventListener = function(eventType, listener) {
	  var arr = this._listeners[eventType];
	  if (!arr) {
	    return;
	  }
	  var idx = arr.indexOf(listener);
	  if (idx !== -1) {
	    if (arr.length > 1) {
	      // Make a copy so as not to interfere with a current dispatchEvent.
	      this._listeners[eventType] = arr.slice(0, idx).concat(arr.slice(idx + 1));
	    } else {
	      delete this._listeners[eventType];
	    }
	    return;
	  }
	};
	
	EventTarget.prototype.dispatchEvent = function() {
	  var event = arguments[0];
	  var t = event.type;
	  // equivalent of Array.prototype.slice.call(arguments, 0);
	  var args = arguments.length === 1 ? [event] : Array.apply(null, arguments);
	  // TODO: This doesn't match the real behavior; per spec, onfoo get
	  // their place in line from the /first/ time they're set from
	  // non-null. Although WebKit bumps it to the end every time it's
	  // set.
	  if (this['on' + t]) {
	    this['on' + t].apply(this, args);
	  }
	  if (t in this._listeners) {
	    // Grab a reference to the listeners list. removeEventListener may alter the list.
	    var listeners = this._listeners[t];
	    for (var i = 0; i < listeners.length; i++) {
	      listeners[i].apply(this, args);
	    }
	  }
	};
	
	module.exports = EventTarget;


/***/ }),
/* 91 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var EventEmitter = __webpack_require__(8).EventEmitter
	  , inherits = __webpack_require__(3)
	  , JSON3 = __webpack_require__(15)
	  , objectUtils = __webpack_require__(54)
	  ;
	
	var debug = function() {};
	if (true) {
	  debug = __webpack_require__(6)('sockjs-client:info-ajax');
	}
	
	function InfoAjax(url, AjaxObject) {
	  EventEmitter.call(this);
	
	  var self = this;
	  var t0 = +new Date();
	  this.xo = new AjaxObject('GET', url);
	
	  this.xo.once('finish', function(status, text) {
	    var info, rtt;
	    if (status === 200) {
	      rtt = (+new Date()) - t0;
	      if (text) {
	        try {
	          info = JSON3.parse(text);
	        } catch (e) {
	          debug('bad json', text);
	        }
	      }
	
	      if (!objectUtils.isObject(info)) {
	        info = {};
	      }
	    }
	    self.emit('finish', info, rtt);
	    self.removeAllListeners();
	  });
	}
	
	inherits(InfoAjax, EventEmitter);
	
	InfoAjax.prototype.close = function() {
	  this.removeAllListeners();
	  this.xo.close();
	};
	
	module.exports = InfoAjax;


/***/ }),
/* 92 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var inherits = __webpack_require__(3)
	  , EventEmitter = __webpack_require__(8).EventEmitter
	  , JSON3 = __webpack_require__(15)
	  , XHRLocalObject = __webpack_require__(27)
	  , InfoAjax = __webpack_require__(91)
	  ;
	
	function InfoReceiverIframe(transUrl) {
	  var self = this;
	  EventEmitter.call(this);
	
	  this.ir = new InfoAjax(transUrl, XHRLocalObject);
	  this.ir.once('finish', function(info, rtt) {
	    self.ir = null;
	    self.emit('message', JSON3.stringify([info, rtt]));
	  });
	}
	
	inherits(InfoReceiverIframe, EventEmitter);
	
	InfoReceiverIframe.transportName = 'iframe-info-receiver';
	
	InfoReceiverIframe.prototype.close = function() {
	  if (this.ir) {
	    this.ir.close();
	    this.ir = null;
	  }
	  this.removeAllListeners();
	};
	
	module.exports = InfoReceiverIframe;


/***/ }),
/* 93 */
/***/ (function(module, exports) {

	/* WEBPACK VAR INJECTION */(function(global) {'use strict';
	
	module.exports = global.location || {
	  origin: 'http://localhost:80'
	, protocol: 'http'
	, host: 'localhost'
	, port: 80
	, href: 'http://localhost/'
	, hash: ''
	};
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ }),
/* 94 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {'use strict';
	
	var EventEmitter = __webpack_require__(8).EventEmitter
	  , inherits = __webpack_require__(3)
	  , utils = __webpack_require__(17)
	  , urlUtils = __webpack_require__(10)
	  , XHR = global.XMLHttpRequest
	  ;
	
	var debug = function() {};
	if (true) {
	  debug = __webpack_require__(6)('sockjs-client:browser:xhr');
	}
	
	function AbstractXHRObject(method, url, payload, opts) {
	  debug(method, url);
	  var self = this;
	  EventEmitter.call(this);
	
	  setTimeout(function () {
	    self._start(method, url, payload, opts);
	  }, 0);
	}
	
	inherits(AbstractXHRObject, EventEmitter);
	
	AbstractXHRObject.prototype._start = function(method, url, payload, opts) {
	  var self = this;
	
	  try {
	    this.xhr = new XHR();
	  } catch (x) {
	    // intentionally empty
	  }
	
	  if (!this.xhr) {
	    debug('no xhr');
	    this.emit('finish', 0, 'no xhr support');
	    this._cleanup();
	    return;
	  }
	
	  // several browsers cache POSTs
	  url = urlUtils.addQuery(url, 't=' + (+new Date()));
	
	  // Explorer tends to keep connection open, even after the
	  // tab gets closed: http://bugs.jquery.com/ticket/5280
	  this.unloadRef = utils.unloadAdd(function() {
	    debug('unload cleanup');
	    self._cleanup(true);
	  });
	  try {
	    this.xhr.open(method, url, true);
	    if (this.timeout && 'timeout' in this.xhr) {
	      this.xhr.timeout = this.timeout;
	      this.xhr.ontimeout = function() {
	        debug('xhr timeout');
	        self.emit('finish', 0, '');
	        self._cleanup(false);
	      };
	    }
	  } catch (e) {
	    debug('exception', e);
	    // IE raises an exception on wrong port.
	    this.emit('finish', 0, '');
	    this._cleanup(false);
	    return;
	  }
	
	  if ((!opts || !opts.noCredentials) && AbstractXHRObject.supportsCORS) {
	    debug('withCredentials');
	    // Mozilla docs says https://developer.mozilla.org/en/XMLHttpRequest :
	    // "This never affects same-site requests."
	
	    this.xhr.withCredentials = 'true';
	  }
	  if (opts && opts.headers) {
	    for (var key in opts.headers) {
	      this.xhr.setRequestHeader(key, opts.headers[key]);
	    }
	  }
	
	  this.xhr.onreadystatechange = function() {
	    if (self.xhr) {
	      var x = self.xhr;
	      var text, status;
	      debug('readyState', x.readyState);
	      switch (x.readyState) {
	      case 3:
	        // IE doesn't like peeking into responseText or status
	        // on Microsoft.XMLHTTP and readystate=3
	        try {
	          status = x.status;
	          text = x.responseText;
	        } catch (e) {
	          // intentionally empty
	        }
	        debug('status', status);
	        // IE returns 1223 for 204: http://bugs.jquery.com/ticket/1450
	        if (status === 1223) {
	          status = 204;
	        }
	
	        // IE does return readystate == 3 for 404 answers.
	        if (status === 200 && text && text.length > 0) {
	          debug('chunk');
	          self.emit('chunk', status, text);
	        }
	        break;
	      case 4:
	        status = x.status;
	        debug('status', status);
	        // IE returns 1223 for 204: http://bugs.jquery.com/ticket/1450
	        if (status === 1223) {
	          status = 204;
	        }
	        // IE returns this for a bad port
	        // http://msdn.microsoft.com/en-us/library/windows/desktop/aa383770(v=vs.85).aspx
	        if (status === 12005 || status === 12029) {
	          status = 0;
	        }
	
	        debug('finish', status, x.responseText);
	        self.emit('finish', status, x.responseText);
	        self._cleanup(false);
	        break;
	      }
	    }
	  };
	
	  try {
	    self.xhr.send(payload);
	  } catch (e) {
	    self.emit('finish', 0, '');
	    self._cleanup(false);
	  }
	};
	
	AbstractXHRObject.prototype._cleanup = function(abort) {
	  debug('cleanup');
	  if (!this.xhr) {
	    return;
	  }
	  this.removeAllListeners();
	  utils.unloadDel(this.unloadRef);
	
	  // IE needs this field to be a function
	  this.xhr.onreadystatechange = function() {};
	  if (this.xhr.ontimeout) {
	    this.xhr.ontimeout = null;
	  }
	
	  if (abort) {
	    try {
	      this.xhr.abort();
	    } catch (x) {
	      // intentionally empty
	    }
	  }
	  this.unloadRef = this.xhr = null;
	};
	
	AbstractXHRObject.prototype.close = function() {
	  debug('close');
	  this._cleanup(true);
	};
	
	AbstractXHRObject.enabled = !!XHR;
	// override XMLHttpRequest for IE6/7
	// obfuscate to avoid firewalls
	var axo = ['Active'].concat('Object').join('X');
	if (!AbstractXHRObject.enabled && (axo in global)) {
	  debug('overriding xmlhttprequest');
	  XHR = function() {
	    try {
	      return new global[axo]('Microsoft.XMLHTTP');
	    } catch (e) {
	      return null;
	    }
	  };
	  AbstractXHRObject.enabled = !!new XHR();
	}
	
	var cors = false;
	try {
	  cors = 'withCredentials' in new XHR();
	} catch (ignored) {
	  // intentionally empty
	}
	
	AbstractXHRObject.supportsCORS = cors;
	
	module.exports = AbstractXHRObject;
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ }),
/* 95 */
/***/ (function(module, exports) {

	/* WEBPACK VAR INJECTION */(function(global) {module.exports = global.EventSource;
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ }),
/* 96 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var inherits = __webpack_require__(3)
	  , AjaxBasedTransport = __webpack_require__(21)
	  , EventSourceReceiver = __webpack_require__(266)
	  , XHRCorsObject = __webpack_require__(42)
	  , EventSourceDriver = __webpack_require__(95)
	  ;
	
	function EventSourceTransport(transUrl) {
	  if (!EventSourceTransport.enabled()) {
	    throw new Error('Transport created when disabled');
	  }
	
	  AjaxBasedTransport.call(this, transUrl, '/eventsource', EventSourceReceiver, XHRCorsObject);
	}
	
	inherits(EventSourceTransport, AjaxBasedTransport);
	
	EventSourceTransport.enabled = function() {
	  return !!EventSourceDriver;
	};
	
	EventSourceTransport.transportName = 'eventsource';
	EventSourceTransport.roundTrips = 2;
	
	module.exports = EventSourceTransport;


/***/ }),
/* 97 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var inherits = __webpack_require__(3)
	  , HtmlfileReceiver = __webpack_require__(267)
	  , XHRLocalObject = __webpack_require__(27)
	  , AjaxBasedTransport = __webpack_require__(21)
	  ;
	
	function HtmlFileTransport(transUrl) {
	  if (!HtmlfileReceiver.enabled) {
	    throw new Error('Transport created when disabled');
	  }
	  AjaxBasedTransport.call(this, transUrl, '/htmlfile', HtmlfileReceiver, XHRLocalObject);
	}
	
	inherits(HtmlFileTransport, AjaxBasedTransport);
	
	HtmlFileTransport.enabled = function(info) {
	  return HtmlfileReceiver.enabled && info.sameOrigin;
	};
	
	HtmlFileTransport.transportName = 'htmlfile';
	HtmlFileTransport.roundTrips = 2;
	
	module.exports = HtmlFileTransport;


/***/ }),
/* 98 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	// Few cool transports do work only for same-origin. In order to make
	// them work cross-domain we shall use iframe, served from the
	// remote domain. New browsers have capabilities to communicate with
	// cross domain iframe using postMessage(). In IE it was implemented
	// from IE 8+, but of course, IE got some details wrong:
	//    http://msdn.microsoft.com/en-us/library/cc197015(v=VS.85).aspx
	//    http://stevesouders.com/misc/test-postmessage.php
	
	var inherits = __webpack_require__(3)
	  , JSON3 = __webpack_require__(15)
	  , EventEmitter = __webpack_require__(8).EventEmitter
	  , version = __webpack_require__(102)
	  , urlUtils = __webpack_require__(10)
	  , iframeUtils = __webpack_require__(29)
	  , eventUtils = __webpack_require__(17)
	  , random = __webpack_require__(22)
	  ;
	
	var debug = function() {};
	if (true) {
	  debug = __webpack_require__(6)('sockjs-client:transport:iframe');
	}
	
	function IframeTransport(transport, transUrl, baseUrl) {
	  if (!IframeTransport.enabled()) {
	    throw new Error('Transport created when disabled');
	  }
	  EventEmitter.call(this);
	
	  var self = this;
	  this.origin = urlUtils.getOrigin(baseUrl);
	  this.baseUrl = baseUrl;
	  this.transUrl = transUrl;
	  this.transport = transport;
	  this.windowId = random.string(8);
	
	  var iframeUrl = urlUtils.addPath(baseUrl, '/iframe.html') + '#' + this.windowId;
	  debug(transport, transUrl, iframeUrl);
	
	  this.iframeObj = iframeUtils.createIframe(iframeUrl, function(r) {
	    debug('err callback');
	    self.emit('close', 1006, 'Unable to load an iframe (' + r + ')');
	    self.close();
	  });
	
	  this.onmessageCallback = this._message.bind(this);
	  eventUtils.attachEvent('message', this.onmessageCallback);
	}
	
	inherits(IframeTransport, EventEmitter);
	
	IframeTransport.prototype.close = function() {
	  debug('close');
	  this.removeAllListeners();
	  if (this.iframeObj) {
	    eventUtils.detachEvent('message', this.onmessageCallback);
	    try {
	      // When the iframe is not loaded, IE raises an exception
	      // on 'contentWindow'.
	      this.postMessage('c');
	    } catch (x) {
	      // intentionally empty
	    }
	    this.iframeObj.cleanup();
	    this.iframeObj = null;
	    this.onmessageCallback = this.iframeObj = null;
	  }
	};
	
	IframeTransport.prototype._message = function(e) {
	  debug('message', e.data);
	  if (!urlUtils.isOriginEqual(e.origin, this.origin)) {
	    debug('not same origin', e.origin, this.origin);
	    return;
	  }
	
	  var iframeMessage;
	  try {
	    iframeMessage = JSON3.parse(e.data);
	  } catch (ignored) {
	    debug('bad json', e.data);
	    return;
	  }
	
	  if (iframeMessage.windowId !== this.windowId) {
	    debug('mismatched window id', iframeMessage.windowId, this.windowId);
	    return;
	  }
	
	  switch (iframeMessage.type) {
	  case 's':
	    this.iframeObj.loaded();
	    // window global dependency
	    this.postMessage('s', JSON3.stringify([
	      version
	    , this.transport
	    , this.transUrl
	    , this.baseUrl
	    ]));
	    break;
	  case 't':
	    this.emit('message', iframeMessage.data);
	    break;
	  case 'c':
	    var cdata;
	    try {
	      cdata = JSON3.parse(iframeMessage.data);
	    } catch (ignored) {
	      debug('bad json', iframeMessage.data);
	      return;
	    }
	    this.emit('close', cdata[0], cdata[1]);
	    this.close();
	    break;
	  }
	};
	
	IframeTransport.prototype.postMessage = function(type, data) {
	  debug('postMessage', type, data);
	  this.iframeObj.post(JSON3.stringify({
	    windowId: this.windowId
	  , type: type
	  , data: data || ''
	  }), this.origin);
	};
	
	IframeTransport.prototype.send = function(message) {
	  debug('send', message);
	  this.postMessage('m', message);
	};
	
	IframeTransport.enabled = function() {
	  return iframeUtils.iframeEnabled;
	};
	
	IframeTransport.transportName = 'iframe';
	IframeTransport.roundTrips = 2;
	
	module.exports = IframeTransport;


/***/ }),
/* 99 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var inherits = __webpack_require__(3)
	  , urlUtils = __webpack_require__(10)
	  , BufferedSender = __webpack_require__(264)
	  , Polling = __webpack_require__(265)
	  ;
	
	var debug = function() {};
	if (true) {
	  debug = __webpack_require__(6)('sockjs-client:sender-receiver');
	}
	
	function SenderReceiver(transUrl, urlSuffix, senderFunc, Receiver, AjaxObject) {
	  var pollUrl = urlUtils.addPath(transUrl, urlSuffix);
	  debug(pollUrl);
	  var self = this;
	  BufferedSender.call(this, transUrl, senderFunc);
	
	  this.poll = new Polling(Receiver, pollUrl, AjaxObject);
	  this.poll.on('message', function(msg) {
	    debug('poll message', msg);
	    self.emit('message', msg);
	  });
	  this.poll.once('close', function(code, reason) {
	    debug('poll close', code, reason);
	    self.poll = null;
	    self.emit('close', code, reason);
	    self.close();
	  });
	}
	
	inherits(SenderReceiver, BufferedSender);
	
	SenderReceiver.prototype.close = function() {
	  BufferedSender.prototype.close.call(this);
	  debug('close');
	  this.removeAllListeners();
	  if (this.poll) {
	    this.poll.abort();
	    this.poll = null;
	  }
	};
	
	module.exports = SenderReceiver;


/***/ }),
/* 100 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var inherits = __webpack_require__(3)
	  , AjaxBasedTransport = __webpack_require__(21)
	  , XhrReceiver = __webpack_require__(41)
	  , XDRObject = __webpack_require__(53)
	  ;
	
	// According to:
	//   http://stackoverflow.com/questions/1641507/detect-browser-support-for-cross-domain-xmlhttprequests
	//   http://hacks.mozilla.org/2009/07/cross-site-xmlhttprequest-with-cors/
	
	function XdrStreamingTransport(transUrl) {
	  if (!XDRObject.enabled) {
	    throw new Error('Transport created when disabled');
	  }
	  AjaxBasedTransport.call(this, transUrl, '/xhr_streaming', XhrReceiver, XDRObject);
	}
	
	inherits(XdrStreamingTransport, AjaxBasedTransport);
	
	XdrStreamingTransport.enabled = function(info) {
	  if (info.cookie_needed || info.nullOrigin) {
	    return false;
	  }
	  return XDRObject.enabled && info.sameScheme;
	};
	
	XdrStreamingTransport.transportName = 'xdr-streaming';
	XdrStreamingTransport.roundTrips = 2; // preflight, ajax
	
	module.exports = XdrStreamingTransport;


/***/ }),
/* 101 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var inherits = __webpack_require__(3)
	  , AjaxBasedTransport = __webpack_require__(21)
	  , XhrReceiver = __webpack_require__(41)
	  , XHRCorsObject = __webpack_require__(42)
	  , XHRLocalObject = __webpack_require__(27)
	  ;
	
	function XhrPollingTransport(transUrl) {
	  if (!XHRLocalObject.enabled && !XHRCorsObject.enabled) {
	    throw new Error('Transport created when disabled');
	  }
	  AjaxBasedTransport.call(this, transUrl, '/xhr', XhrReceiver, XHRCorsObject);
	}
	
	inherits(XhrPollingTransport, AjaxBasedTransport);
	
	XhrPollingTransport.enabled = function(info) {
	  if (info.nullOrigin) {
	    return false;
	  }
	
	  if (XHRLocalObject.enabled && info.sameOrigin) {
	    return true;
	  }
	  return XHRCorsObject.enabled;
	};
	
	XhrPollingTransport.transportName = 'xhr-polling';
	XhrPollingTransport.roundTrips = 2; // preflight, ajax
	
	module.exports = XhrPollingTransport;


/***/ }),
/* 102 */
/***/ (function(module, exports) {

	module.exports = '1.1.4';


/***/ }),
/* 103 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Tween.js - Licensed under the MIT license
	 * https://github.com/tweenjs/tween.js
	 * ----------------------------------------------
	 *
	 * See https://github.com/tweenjs/tween.js/graphs/contributors for the full list of contributors.
	 * Thank you all, you're awesome!
	 */
	
	var TWEEN = TWEEN || (function () {
	
		var _tweens = [];
	
		return {
	
			getAll: function () {
	
				return _tweens;
	
			},
	
			removeAll: function () {
	
				_tweens = [];
	
			},
	
			add: function (tween) {
	
				_tweens.push(tween);
	
			},
	
			remove: function (tween) {
	
				var i = _tweens.indexOf(tween);
	
				if (i !== -1) {
					_tweens.splice(i, 1);
				}
	
			},
	
			update: function (time, preserve) {
	
				if (_tweens.length === 0) {
					return false;
				}
	
				var i = 0;
	
				time = time !== undefined ? time : TWEEN.now();
	
				while (i < _tweens.length) {
	
					if (_tweens[i].update(time) || preserve) {
						i++;
					} else {
						_tweens.splice(i, 1);
					}
	
				}
	
				return true;
	
			}
		};
	
	})();
	
	
	// Include a performance.now polyfill.
	// In node.js, use process.hrtime.
	if (typeof (window) === 'undefined' && typeof (process) !== 'undefined') {
		TWEEN.now = function () {
			var time = process.hrtime();
	
			// Convert [seconds, nanoseconds] to milliseconds.
			return time[0] * 1000 + time[1] / 1000000;
		};
	}
	// In a browser, use window.performance.now if it is available.
	else if (typeof (window) !== 'undefined' &&
	         window.performance !== undefined &&
			 window.performance.now !== undefined) {
		// This must be bound, because directly assigning this function
		// leads to an invocation exception in Chrome.
		TWEEN.now = window.performance.now.bind(window.performance);
	}
	// Use Date.now if it is available.
	else if (Date.now !== undefined) {
		TWEEN.now = Date.now;
	}
	// Otherwise, use 'new Date().getTime()'.
	else {
		TWEEN.now = function () {
			return new Date().getTime();
		};
	}
	
	
	TWEEN.Tween = function (object) {
	
		var _object = object;
		var _valuesStart = {};
		var _valuesEnd = {};
		var _valuesStartRepeat = {};
		var _duration = 1000;
		var _repeat = 0;
		var _repeatDelayTime;
		var _yoyo = false;
		var _isPlaying = false;
		var _reversed = false;
		var _delayTime = 0;
		var _startTime = null;
		var _easingFunction = TWEEN.Easing.Linear.None;
		var _interpolationFunction = TWEEN.Interpolation.Linear;
		var _chainedTweens = [];
		var _onStartCallback = null;
		var _onStartCallbackFired = false;
		var _onUpdateCallback = null;
		var _onCompleteCallback = null;
		var _onStopCallback = null;
	
		this.to = function (properties, duration) {
	
			_valuesEnd = properties;
	
			if (duration !== undefined) {
				_duration = duration;
			}
	
			return this;
	
		};
	
		this.start = function (time) {
	
			TWEEN.add(this);
	
			_isPlaying = true;
	
			_onStartCallbackFired = false;
	
			_startTime = time !== undefined ? time : TWEEN.now();
			_startTime += _delayTime;
	
			for (var property in _valuesEnd) {
	
				// Check if an Array was provided as property value
				if (_valuesEnd[property] instanceof Array) {
	
					if (_valuesEnd[property].length === 0) {
						continue;
					}
	
					// Create a local copy of the Array with the start value at the front
					_valuesEnd[property] = [_object[property]].concat(_valuesEnd[property]);
	
				}
	
				// If `to()` specifies a property that doesn't exist in the source object,
				// we should not set that property in the object
				if (_object[property] === undefined) {
					continue;
				}
	
				// Save the starting value.
				_valuesStart[property] = _object[property];
	
				if ((_valuesStart[property] instanceof Array) === false) {
					_valuesStart[property] *= 1.0; // Ensures we're using numbers, not strings
				}
	
				_valuesStartRepeat[property] = _valuesStart[property] || 0;
	
			}
	
			return this;
	
		};
	
		this.stop = function () {
	
			if (!_isPlaying) {
				return this;
			}
	
			TWEEN.remove(this);
			_isPlaying = false;
	
			if (_onStopCallback !== null) {
				_onStopCallback.call(_object, _object);
			}
	
			this.stopChainedTweens();
			return this;
	
		};
	
		this.end = function () {
	
			this.update(_startTime + _duration);
			return this;
	
		};
	
		this.stopChainedTweens = function () {
	
			for (var i = 0, numChainedTweens = _chainedTweens.length; i < numChainedTweens; i++) {
				_chainedTweens[i].stop();
			}
	
		};
	
		this.delay = function (amount) {
	
			_delayTime = amount;
			return this;
	
		};
	
		this.repeat = function (times) {
	
			_repeat = times;
			return this;
	
		};
	
		this.repeatDelay = function (amount) {
	
			_repeatDelayTime = amount;
			return this;
	
		};
	
		this.yoyo = function (yoyo) {
	
			_yoyo = yoyo;
			return this;
	
		};
	
	
		this.easing = function (easing) {
	
			_easingFunction = easing;
			return this;
	
		};
	
		this.interpolation = function (interpolation) {
	
			_interpolationFunction = interpolation;
			return this;
	
		};
	
		this.chain = function () {
	
			_chainedTweens = arguments;
			return this;
	
		};
	
		this.onStart = function (callback) {
	
			_onStartCallback = callback;
			return this;
	
		};
	
		this.onUpdate = function (callback) {
	
			_onUpdateCallback = callback;
			return this;
	
		};
	
		this.onComplete = function (callback) {
	
			_onCompleteCallback = callback;
			return this;
	
		};
	
		this.onStop = function (callback) {
	
			_onStopCallback = callback;
			return this;
	
		};
	
		this.update = function (time) {
	
			var property;
			var elapsed;
			var value;
	
			if (time < _startTime) {
				return true;
			}
	
			if (_onStartCallbackFired === false) {
	
				if (_onStartCallback !== null) {
					_onStartCallback.call(_object, _object);
				}
	
				_onStartCallbackFired = true;
			}
	
			elapsed = (time - _startTime) / _duration;
			elapsed = elapsed > 1 ? 1 : elapsed;
	
			value = _easingFunction(elapsed);
	
			for (property in _valuesEnd) {
	
				// Don't update properties that do not exist in the source object
				if (_valuesStart[property] === undefined) {
					continue;
				}
	
				var start = _valuesStart[property] || 0;
				var end = _valuesEnd[property];
	
				if (end instanceof Array) {
	
					_object[property] = _interpolationFunction(end, value);
	
				} else {
	
					// Parses relative end values with start as base (e.g.: +10, -3)
					if (typeof (end) === 'string') {
	
						if (end.charAt(0) === '+' || end.charAt(0) === '-') {
							end = start + parseFloat(end);
						} else {
							end = parseFloat(end);
						}
					}
	
					// Protect against non numeric properties.
					if (typeof (end) === 'number') {
						_object[property] = start + (end - start) * value;
					}
	
				}
	
			}
	
			if (_onUpdateCallback !== null) {
				_onUpdateCallback.call(_object, value);
			}
	
			if (elapsed === 1) {
	
				if (_repeat > 0) {
	
					if (isFinite(_repeat)) {
						_repeat--;
					}
	
					// Reassign starting values, restart by making startTime = now
					for (property in _valuesStartRepeat) {
	
						if (typeof (_valuesEnd[property]) === 'string') {
							_valuesStartRepeat[property] = _valuesStartRepeat[property] + parseFloat(_valuesEnd[property]);
						}
	
						if (_yoyo) {
							var tmp = _valuesStartRepeat[property];
	
							_valuesStartRepeat[property] = _valuesEnd[property];
							_valuesEnd[property] = tmp;
						}
	
						_valuesStart[property] = _valuesStartRepeat[property];
	
					}
	
					if (_yoyo) {
						_reversed = !_reversed;
					}
	
					if (_repeatDelayTime !== undefined) {
						_startTime = time + _repeatDelayTime;
					} else {
						_startTime = time + _delayTime;
					}
	
					return true;
	
				} else {
	
					if (_onCompleteCallback !== null) {
	
						_onCompleteCallback.call(_object, _object);
					}
	
					for (var i = 0, numChainedTweens = _chainedTweens.length; i < numChainedTweens; i++) {
						// Make the chained tweens start exactly at the time they should,
						// even if the `update()` method was called way past the duration of the tween
						_chainedTweens[i].start(_startTime + _duration);
					}
	
					return false;
	
				}
	
			}
	
			return true;
	
		};
	
	};
	
	
	TWEEN.Easing = {
	
		Linear: {
	
			None: function (k) {
	
				return k;
	
			}
	
		},
	
		Quadratic: {
	
			In: function (k) {
	
				return k * k;
	
			},
	
			Out: function (k) {
	
				return k * (2 - k);
	
			},
	
			InOut: function (k) {
	
				if ((k *= 2) < 1) {
					return 0.5 * k * k;
				}
	
				return - 0.5 * (--k * (k - 2) - 1);
	
			}
	
		},
	
		Cubic: {
	
			In: function (k) {
	
				return k * k * k;
	
			},
	
			Out: function (k) {
	
				return --k * k * k + 1;
	
			},
	
			InOut: function (k) {
	
				if ((k *= 2) < 1) {
					return 0.5 * k * k * k;
				}
	
				return 0.5 * ((k -= 2) * k * k + 2);
	
			}
	
		},
	
		Quartic: {
	
			In: function (k) {
	
				return k * k * k * k;
	
			},
	
			Out: function (k) {
	
				return 1 - (--k * k * k * k);
	
			},
	
			InOut: function (k) {
	
				if ((k *= 2) < 1) {
					return 0.5 * k * k * k * k;
				}
	
				return - 0.5 * ((k -= 2) * k * k * k - 2);
	
			}
	
		},
	
		Quintic: {
	
			In: function (k) {
	
				return k * k * k * k * k;
	
			},
	
			Out: function (k) {
	
				return --k * k * k * k * k + 1;
	
			},
	
			InOut: function (k) {
	
				if ((k *= 2) < 1) {
					return 0.5 * k * k * k * k * k;
				}
	
				return 0.5 * ((k -= 2) * k * k * k * k + 2);
	
			}
	
		},
	
		Sinusoidal: {
	
			In: function (k) {
	
				return 1 - Math.cos(k * Math.PI / 2);
	
			},
	
			Out: function (k) {
	
				return Math.sin(k * Math.PI / 2);
	
			},
	
			InOut: function (k) {
	
				return 0.5 * (1 - Math.cos(Math.PI * k));
	
			}
	
		},
	
		Exponential: {
	
			In: function (k) {
	
				return k === 0 ? 0 : Math.pow(1024, k - 1);
	
			},
	
			Out: function (k) {
	
				return k === 1 ? 1 : 1 - Math.pow(2, - 10 * k);
	
			},
	
			InOut: function (k) {
	
				if (k === 0) {
					return 0;
				}
	
				if (k === 1) {
					return 1;
				}
	
				if ((k *= 2) < 1) {
					return 0.5 * Math.pow(1024, k - 1);
				}
	
				return 0.5 * (- Math.pow(2, - 10 * (k - 1)) + 2);
	
			}
	
		},
	
		Circular: {
	
			In: function (k) {
	
				return 1 - Math.sqrt(1 - k * k);
	
			},
	
			Out: function (k) {
	
				return Math.sqrt(1 - (--k * k));
	
			},
	
			InOut: function (k) {
	
				if ((k *= 2) < 1) {
					return - 0.5 * (Math.sqrt(1 - k * k) - 1);
				}
	
				return 0.5 * (Math.sqrt(1 - (k -= 2) * k) + 1);
	
			}
	
		},
	
		Elastic: {
	
			In: function (k) {
	
				if (k === 0) {
					return 0;
				}
	
				if (k === 1) {
					return 1;
				}
	
				return -Math.pow(2, 10 * (k - 1)) * Math.sin((k - 1.1) * 5 * Math.PI);
	
			},
	
			Out: function (k) {
	
				if (k === 0) {
					return 0;
				}
	
				if (k === 1) {
					return 1;
				}
	
				return Math.pow(2, -10 * k) * Math.sin((k - 0.1) * 5 * Math.PI) + 1;
	
			},
	
			InOut: function (k) {
	
				if (k === 0) {
					return 0;
				}
	
				if (k === 1) {
					return 1;
				}
	
				k *= 2;
	
				if (k < 1) {
					return -0.5 * Math.pow(2, 10 * (k - 1)) * Math.sin((k - 1.1) * 5 * Math.PI);
				}
	
				return 0.5 * Math.pow(2, -10 * (k - 1)) * Math.sin((k - 1.1) * 5 * Math.PI) + 1;
	
			}
	
		},
	
		Back: {
	
			In: function (k) {
	
				var s = 1.70158;
	
				return k * k * ((s + 1) * k - s);
	
			},
	
			Out: function (k) {
	
				var s = 1.70158;
	
				return --k * k * ((s + 1) * k + s) + 1;
	
			},
	
			InOut: function (k) {
	
				var s = 1.70158 * 1.525;
	
				if ((k *= 2) < 1) {
					return 0.5 * (k * k * ((s + 1) * k - s));
				}
	
				return 0.5 * ((k -= 2) * k * ((s + 1) * k + s) + 2);
	
			}
	
		},
	
		Bounce: {
	
			In: function (k) {
	
				return 1 - TWEEN.Easing.Bounce.Out(1 - k);
	
			},
	
			Out: function (k) {
	
				if (k < (1 / 2.75)) {
					return 7.5625 * k * k;
				} else if (k < (2 / 2.75)) {
					return 7.5625 * (k -= (1.5 / 2.75)) * k + 0.75;
				} else if (k < (2.5 / 2.75)) {
					return 7.5625 * (k -= (2.25 / 2.75)) * k + 0.9375;
				} else {
					return 7.5625 * (k -= (2.625 / 2.75)) * k + 0.984375;
				}
	
			},
	
			InOut: function (k) {
	
				if (k < 0.5) {
					return TWEEN.Easing.Bounce.In(k * 2) * 0.5;
				}
	
				return TWEEN.Easing.Bounce.Out(k * 2 - 1) * 0.5 + 0.5;
	
			}
	
		}
	
	};
	
	TWEEN.Interpolation = {
	
		Linear: function (v, k) {
	
			var m = v.length - 1;
			var f = m * k;
			var i = Math.floor(f);
			var fn = TWEEN.Interpolation.Utils.Linear;
	
			if (k < 0) {
				return fn(v[0], v[1], f);
			}
	
			if (k > 1) {
				return fn(v[m], v[m - 1], m - f);
			}
	
			return fn(v[i], v[i + 1 > m ? m : i + 1], f - i);
	
		},
	
		Bezier: function (v, k) {
	
			var b = 0;
			var n = v.length - 1;
			var pw = Math.pow;
			var bn = TWEEN.Interpolation.Utils.Bernstein;
	
			for (var i = 0; i <= n; i++) {
				b += pw(1 - k, n - i) * pw(k, i) * v[i] * bn(n, i);
			}
	
			return b;
	
		},
	
		CatmullRom: function (v, k) {
	
			var m = v.length - 1;
			var f = m * k;
			var i = Math.floor(f);
			var fn = TWEEN.Interpolation.Utils.CatmullRom;
	
			if (v[0] === v[m]) {
	
				if (k < 0) {
					i = Math.floor(f = m * (1 + k));
				}
	
				return fn(v[(i - 1 + m) % m], v[i], v[(i + 1) % m], v[(i + 2) % m], f - i);
	
			} else {
	
				if (k < 0) {
					return v[0] - (fn(v[0], v[0], v[1], v[1], -f) - v[0]);
				}
	
				if (k > 1) {
					return v[m] - (fn(v[m], v[m], v[m - 1], v[m - 1], f - m) - v[m]);
				}
	
				return fn(v[i ? i - 1 : 0], v[i], v[m < i + 1 ? m : i + 1], v[m < i + 2 ? m : i + 2], f - i);
	
			}
	
		},
	
		Utils: {
	
			Linear: function (p0, p1, t) {
	
				return (p1 - p0) * t + p0;
	
			},
	
			Bernstein: function (n, i) {
	
				var fc = TWEEN.Interpolation.Utils.Factorial;
	
				return fc(n) / fc(i) / fc(n - i);
	
			},
	
			Factorial: (function () {
	
				var a = [1];
	
				return function (n) {
	
					var s = 1;
	
					if (a[n]) {
						return a[n];
					}
	
					for (var i = n; i > 1; i--) {
						s *= i;
					}
	
					a[n] = s;
					return s;
	
				};
	
			})(),
	
			CatmullRom: function (p0, p1, p2, p3, t) {
	
				var v0 = (p2 - p0) * 0.5;
				var v1 = (p3 - p1) * 0.5;
				var t2 = t * t;
				var t3 = t * t2;
	
				return (2 * p1 - 2 * p2 + v0 + v1) * t3 + (- 3 * p1 + 3 * p2 - 2 * v0 - v1) * t2 + v0 * t + p1;
	
			}
	
		}
	
	};
	
	// UMD (Universal Module Definition)
	(function (root) {
	
		if (true) {
	
			// AMD
			!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function () {
				return TWEEN;
			}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	
		} else if (typeof module !== 'undefined' && typeof exports === 'object') {
	
			// Node.js
			module.exports = TWEEN;
	
		} else if (root !== undefined) {
	
			// Global variable
			root.TWEEN = TWEEN;
	
		}
	
	})(this);
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(50)))

/***/ }),
/* 104 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {'use strict';
	
	var required = __webpack_require__(251)
	  , qs = __webpack_require__(248)
	  , protocolre = /^([a-z][a-z0-9.+-]*:)?(\/\/)?([\S\s]*)/i
	  , slashes = /^[A-Za-z][A-Za-z0-9+-.]*:\/\//;
	
	/**
	 * These are the parse rules for the URL parser, it informs the parser
	 * about:
	 *
	 * 0. The char it Needs to parse, if it's a string it should be done using
	 *    indexOf, RegExp using exec and NaN means set as current value.
	 * 1. The property we should set when parsing this value.
	 * 2. Indication if it's backwards or forward parsing, when set as number it's
	 *    the value of extra chars that should be split off.
	 * 3. Inherit from location if non existing in the parser.
	 * 4. `toLowerCase` the resulting value.
	 */
	var rules = [
	  ['#', 'hash'],                        // Extract from the back.
	  ['?', 'query'],                       // Extract from the back.
	  ['/', 'pathname'],                    // Extract from the back.
	  ['@', 'auth', 1],                     // Extract from the front.
	  [NaN, 'host', undefined, 1, 1],       // Set left over value.
	  [/:(\d+)$/, 'port', undefined, 1],    // RegExp the back.
	  [NaN, 'hostname', undefined, 1, 1]    // Set left over.
	];
	
	/**
	 * These properties should not be copied or inherited from. This is only needed
	 * for all non blob URL's as a blob URL does not include a hash, only the
	 * origin.
	 *
	 * @type {Object}
	 * @private
	 */
	var ignore = { hash: 1, query: 1 };
	
	/**
	 * The location object differs when your code is loaded through a normal page,
	 * Worker or through a worker using a blob. And with the blobble begins the
	 * trouble as the location object will contain the URL of the blob, not the
	 * location of the page where our code is loaded in. The actual origin is
	 * encoded in the `pathname` so we can thankfully generate a good "default"
	 * location from it so we can generate proper relative URL's again.
	 *
	 * @param {Object|String} loc Optional default location object.
	 * @returns {Object} lolcation object.
	 * @api public
	 */
	function lolcation(loc) {
	  loc = loc || global.location || {};
	
	  var finaldestination = {}
	    , type = typeof loc
	    , key;
	
	  if ('blob:' === loc.protocol) {
	    finaldestination = new URL(unescape(loc.pathname), {});
	  } else if ('string' === type) {
	    finaldestination = new URL(loc, {});
	    for (key in ignore) delete finaldestination[key];
	  } else if ('object' === type) {
	    for (key in loc) {
	      if (key in ignore) continue;
	      finaldestination[key] = loc[key];
	    }
	
	    if (finaldestination.slashes === undefined) {
	      finaldestination.slashes = slashes.test(loc.href);
	    }
	  }
	
	  return finaldestination;
	}
	
	/**
	 * @typedef ProtocolExtract
	 * @type Object
	 * @property {String} protocol Protocol matched in the URL, in lowercase.
	 * @property {Boolean} slashes `true` if protocol is followed by "//", else `false`.
	 * @property {String} rest Rest of the URL that is not part of the protocol.
	 */
	
	/**
	 * Extract protocol information from a URL with/without double slash ("//").
	 *
	 * @param {String} address URL we want to extract from.
	 * @return {ProtocolExtract} Extracted information.
	 * @api private
	 */
	function extractProtocol(address) {
	  var match = protocolre.exec(address);
	
	  return {
	    protocol: match[1] ? match[1].toLowerCase() : '',
	    slashes: !!match[2],
	    rest: match[3]
	  };
	}
	
	/**
	 * Resolve a relative URL pathname against a base URL pathname.
	 *
	 * @param {String} relative Pathname of the relative URL.
	 * @param {String} base Pathname of the base URL.
	 * @return {String} Resolved pathname.
	 * @api private
	 */
	function resolve(relative, base) {
	  var path = (base || '/').split('/').slice(0, -1).concat(relative.split('/'))
	    , i = path.length
	    , last = path[i - 1]
	    , unshift = false
	    , up = 0;
	
	  while (i--) {
	    if (path[i] === '.') {
	      path.splice(i, 1);
	    } else if (path[i] === '..') {
	      path.splice(i, 1);
	      up++;
	    } else if (up) {
	      if (i === 0) unshift = true;
	      path.splice(i, 1);
	      up--;
	    }
	  }
	
	  if (unshift) path.unshift('');
	  if (last === '.' || last === '..') path.push('');
	
	  return path.join('/');
	}
	
	/**
	 * The actual URL instance. Instead of returning an object we've opted-in to
	 * create an actual constructor as it's much more memory efficient and
	 * faster and it pleases my OCD.
	 *
	 * @constructor
	 * @param {String} address URL we want to parse.
	 * @param {Object|String} location Location defaults for relative paths.
	 * @param {Boolean|Function} parser Parser for the query string.
	 * @api public
	 */
	function URL(address, location, parser) {
	  if (!(this instanceof URL)) {
	    return new URL(address, location, parser);
	  }
	
	  var relative, extracted, parse, instruction, index, key
	    , instructions = rules.slice()
	    , type = typeof location
	    , url = this
	    , i = 0;
	
	  //
	  // The following if statements allows this module two have compatibility with
	  // 2 different API:
	  //
	  // 1. Node.js's `url.parse` api which accepts a URL, boolean as arguments
	  //    where the boolean indicates that the query string should also be parsed.
	  //
	  // 2. The `URL` interface of the browser which accepts a URL, object as
	  //    arguments. The supplied object will be used as default values / fall-back
	  //    for relative paths.
	  //
	  if ('object' !== type && 'string' !== type) {
	    parser = location;
	    location = null;
	  }
	
	  if (parser && 'function' !== typeof parser) parser = qs.parse;
	
	  location = lolcation(location);
	
	  //
	  // Extract protocol information before running the instructions.
	  //
	  extracted = extractProtocol(address || '');
	  relative = !extracted.protocol && !extracted.slashes;
	  url.slashes = extracted.slashes || relative && location.slashes;
	  url.protocol = extracted.protocol || location.protocol || '';
	  address = extracted.rest;
	
	  //
	  // When the authority component is absent the URL starts with a path
	  // component.
	  //
	  if (!extracted.slashes) instructions[2] = [/(.*)/, 'pathname'];
	
	  for (; i < instructions.length; i++) {
	    instruction = instructions[i];
	    parse = instruction[0];
	    key = instruction[1];
	
	    if (parse !== parse) {
	      url[key] = address;
	    } else if ('string' === typeof parse) {
	      if (~(index = address.indexOf(parse))) {
	        if ('number' === typeof instruction[2]) {
	          url[key] = address.slice(0, index);
	          address = address.slice(index + instruction[2]);
	        } else {
	          url[key] = address.slice(index);
	          address = address.slice(0, index);
	        }
	      }
	    } else if ((index = parse.exec(address))) {
	      url[key] = index[1];
	      address = address.slice(0, index.index);
	    }
	
	    url[key] = url[key] || (
	      relative && instruction[3] ? location[key] || '' : ''
	    );
	
	    //
	    // Hostname, host and protocol should be lowercased so they can be used to
	    // create a proper `origin`.
	    //
	    if (instruction[4]) url[key] = url[key].toLowerCase();
	  }
	
	  //
	  // Also parse the supplied query string in to an object. If we're supplied
	  // with a custom parser as function use that instead of the default build-in
	  // parser.
	  //
	  if (parser) url.query = parser(url.query);
	
	  //
	  // If the URL is relative, resolve the pathname against the base URL.
	  //
	  if (
	      relative
	    && location.slashes
	    && url.pathname.charAt(0) !== '/'
	    && (url.pathname !== '' || location.pathname !== '')
	  ) {
	    url.pathname = resolve(url.pathname, location.pathname);
	  }
	
	  //
	  // We should not add port numbers if they are already the default port number
	  // for a given protocol. As the host also contains the port number we're going
	  // override it with the hostname which contains no port number.
	  //
	  if (!required(url.port, url.protocol)) {
	    url.host = url.hostname;
	    url.port = '';
	  }
	
	  //
	  // Parse down the `auth` for the username and password.
	  //
	  url.username = url.password = '';
	  if (url.auth) {
	    instruction = url.auth.split(':');
	    url.username = instruction[0] || '';
	    url.password = instruction[1] || '';
	  }
	
	  url.origin = url.protocol && url.host && url.protocol !== 'file:'
	    ? url.protocol +'//'+ url.host
	    : 'null';
	
	  //
	  // The href is just the compiled result.
	  //
	  url.href = url.toString();
	}
	
	/**
	 * This is convenience method for changing properties in the URL instance to
	 * insure that they all propagate correctly.
	 *
	 * @param {String} part          Property we need to adjust.
	 * @param {Mixed} value          The newly assigned value.
	 * @param {Boolean|Function} fn  When setting the query, it will be the function
	 *                               used to parse the query.
	 *                               When setting the protocol, double slash will be
	 *                               removed from the final url if it is true.
	 * @returns {URL}
	 * @api public
	 */
	function set(part, value, fn) {
	  var url = this;
	
	  switch (part) {
	    case 'query':
	      if ('string' === typeof value && value.length) {
	        value = (fn || qs.parse)(value);
	      }
	
	      url[part] = value;
	      break;
	
	    case 'port':
	      url[part] = value;
	
	      if (!required(value, url.protocol)) {
	        url.host = url.hostname;
	        url[part] = '';
	      } else if (value) {
	        url.host = url.hostname +':'+ value;
	      }
	
	      break;
	
	    case 'hostname':
	      url[part] = value;
	
	      if (url.port) value += ':'+ url.port;
	      url.host = value;
	      break;
	
	    case 'host':
	      url[part] = value;
	
	      if (/:\d+$/.test(value)) {
	        value = value.split(':');
	        url.port = value.pop();
	        url.hostname = value.join(':');
	      } else {
	        url.hostname = value;
	        url.port = '';
	      }
	
	      break;
	
	    case 'protocol':
	      url.protocol = value.toLowerCase();
	      url.slashes = !fn;
	      break;
	
	    case 'pathname':
	      url.pathname = value.length && value.charAt(0) !== '/' ? '/' + value : value;
	
	      break;
	
	    default:
	      url[part] = value;
	  }
	
	  for (var i = 0; i < rules.length; i++) {
	    var ins = rules[i];
	
	    if (ins[4]) url[ins[1]] = url[ins[1]].toLowerCase();
	  }
	
	  url.origin = url.protocol && url.host && url.protocol !== 'file:'
	    ? url.protocol +'//'+ url.host
	    : 'null';
	
	  url.href = url.toString();
	
	  return url;
	}
	
	/**
	 * Transform the properties back in to a valid and full URL string.
	 *
	 * @param {Function} stringify Optional query stringify function.
	 * @returns {String}
	 * @api public
	 */
	function toString(stringify) {
	  if (!stringify || 'function' !== typeof stringify) stringify = qs.stringify;
	
	  var query
	    , url = this
	    , protocol = url.protocol;
	
	  if (protocol && protocol.charAt(protocol.length - 1) !== ':') protocol += ':';
	
	  var result = protocol + (url.slashes ? '//' : '');
	
	  if (url.username) {
	    result += url.username;
	    if (url.password) result += ':'+ url.password;
	    result += '@';
	  }
	
	  result += url.host + url.pathname;
	
	  query = 'object' === typeof url.query ? stringify(url.query) : url.query;
	  if (query) result += '?' !== query.charAt(0) ? '?'+ query : query;
	
	  if (url.hash) result += url.hash;
	
	  return result;
	}
	
	URL.prototype = { set: set, toString: toString };
	
	//
	// Expose the URL parser and some additional properties that might be useful for
	// others or testing.
	//
	URL.extractProtocol = extractProtocol;
	URL.location = lolcation;
	URL.qs = qs;
	
	module.exports = URL;
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ }),
/* 105 */
/***/ (function(module, exports) {

	/**
	 *
	 * FULL TILT
	 * http://github.com/richtr/Full-Tilt
	 *
	 * A standalone DeviceOrientation + DeviceMotion JavaScript library that
	 * normalises orientation sensor input, applies relevant screen orientation
	 * transforms, returns Euler Angle, Quaternion and Rotation
	 * Matrix representations back to web developers and provides conversion
	 * between all supported orientation representation types.
	 *
	 * Copyright: 2014 Rich Tibbett
	 * License:   MIT
	 *
	 */
	
	(function ( window ) {
	
	// Only initialize the FULLTILT API if it is not already attached to the DOM
	if ( window.FULLTILT !== undefined && window.FULLTILT !== null ) {
		return;
	}
	
	var M_PI   = Math.PI;
	var M_PI_2 = M_PI / 2;
	var M_2_PI = 2 * M_PI;
	
	// Degree to Radian conversion
	var degToRad = M_PI / 180;
	var radToDeg = 180 / M_PI;
	
	// Internal device orientation + motion variables
	var sensors = {
		"orientation": {
			active:    false,
			callbacks: [],
			data:      undefined
		},
		"motion": {
			active:    false,
			callbacks: [],
			data:      undefined
		}
	};
	var screenActive = false;
	
	// Internal screen orientation variables
	var hasScreenOrientationAPI = window.screen && window.screen.orientation && window.screen.orientation.angle !== undefined && window.screen.orientation.angle !== null ? true : false;
	var screenOrientationAngle = ( hasScreenOrientationAPI ? window.screen.orientation.angle : ( window.orientation || 0 ) ) * degToRad;
	
	var SCREEN_ROTATION_0        = 0,
	    SCREEN_ROTATION_90       = M_PI_2,
	    SCREEN_ROTATION_180      = M_PI,
	    SCREEN_ROTATION_270      = M_2_PI / 3,
	    SCREEN_ROTATION_MINUS_90 = - M_PI_2;
	
	// Math.sign polyfill
	function sign(x) {
		x = +x; // convert to a number
		if (x === 0 || isNaN(x))
			return x;
		return x > 0 ? 1 : -1;
	}
	
	///// Promise-based Sensor Data checker //////
	
	function SensorCheck(sensorRootObj) {
	
		var promise = new Promise(function(resolve, reject) {
	
			var runCheck = function (tries) {
	
				setTimeout(function() {
	
					if (sensorRootObj && sensorRootObj.data) {
	
						resolve();
	
					} else if (tries >= 20) {
	
						reject();
	
					} else {
	
						runCheck(++tries);
	
					}
	
				}, 50);
	
			};
	
			runCheck(0);
	
		});
	
		return promise;
	
	}
	
	////// Internal Event Handlers //////
	
	function handleScreenOrientationChange () {
	
		if ( hasScreenOrientationAPI ) {
	
			screenOrientationAngle = ( window.screen.orientation.angle || 0 ) * degToRad;
	
		} else {
	
			screenOrientationAngle = ( window.orientation || 0 ) * degToRad;
	
		}
	
	}
	
	function handleDeviceOrientationChange ( event ) {
	
		sensors.orientation.data = event;
	
		// Fire every callback function each time deviceorientation is updated
		for ( var i in sensors.orientation.callbacks ) {
	
			sensors.orientation.callbacks[ i ].call( this );
	
		}
	
	}
	
	function handleDeviceMotionChange ( event ) {
	
		sensors.motion.data = event;
	
		// Fire every callback function each time devicemotion is updated
		for ( var i in sensors.motion.callbacks ) {
	
			sensors.motion.callbacks[ i ].call( this );
	
		}
	
	}
	
	///// FULLTILT API Root Object /////
	
	var FULLTILT = {};
	
	FULLTILT.version = "0.5.3";
	
	///// FULLTILT API Root Methods /////
	
	FULLTILT.getDeviceOrientation = function(options) {
	
		var promise = new Promise(function(resolve, reject) {
	
			var control = new FULLTILT.DeviceOrientation(options);
	
			control.start();
	
			var orientationSensorCheck = new SensorCheck(sensors.orientation);
	
			orientationSensorCheck.then(function() {
	
				resolve(control);
	
			}).catch(function() {
	
				control.stop();
				reject('DeviceOrientation is not supported');
	
			});
	
		});
	
		return promise;
	
	};
	
	FULLTILT.getDeviceMotion = function(options) {
	
		var promise = new Promise(function(resolve, reject) {
	
			var control = new FULLTILT.DeviceMotion(options);
	
			control.start();
	
			var motionSensorCheck = new SensorCheck(sensors.motion);
	
			motionSensorCheck.then(function() {
	
				resolve(control);
	
			}).catch(function() {
	
				control.stop();
				reject('DeviceMotion is not supported');
	
			});
	
		});
	
		return promise;
	
	};
	
	
	////// FULLTILT.Quaternion //////
	
	FULLTILT.Quaternion = function ( x, y, z, w ) {
	
		var quat, outQuat;
	
		this.set = function ( x, y, z, w ) {
	
			this.x = x || 0;
			this.y = y || 0;
			this.z = z || 0;
			this.w = w || 1;
	
		};
	
		this.copy = function ( quaternion ) {
	
			this.x = quaternion.x;
			this.y = quaternion.y;
			this.z = quaternion.z;
			this.w = quaternion.w;
	
		};
	
		this.setFromEuler = (function () {
	
			var _x, _y, _z;
			var _x_2, _y_2, _z_2;
			var cX, cY, cZ, sX, sY, sZ;
	
			return function ( euler ) {
	
				euler = euler || {};
	
				_z = ( euler.alpha || 0 ) * degToRad;
				_x = ( euler.beta || 0 ) * degToRad;
				_y = ( euler.gamma || 0 ) * degToRad;
	
				_z_2 = _z / 2;
				_x_2 = _x / 2;
				_y_2 = _y / 2;
	
				cX = Math.cos( _x_2 );
				cY = Math.cos( _y_2 );
				cZ = Math.cos( _z_2 );
				sX = Math.sin( _x_2 );
				sY = Math.sin( _y_2 );
				sZ = Math.sin( _z_2 );
	
				this.set(
					sX * cY * cZ - cX * sY * sZ, // x
					cX * sY * cZ + sX * cY * sZ, // y
					cX * cY * sZ + sX * sY * cZ, // z
					cX * cY * cZ - sX * sY * sZ  // w
				);
	
				this.normalize();
	
				return this;
	
			};
	
		})();
	
		this.setFromRotationMatrix = (function () {
	
			var R;
	
			return function( matrix ) {
	
				R = matrix.elements;
	
				this.set(
					0.5 * Math.sqrt( 1 + R[0] - R[4] - R[8] ) * sign( R[7] - R[5] ), // x
					0.5 * Math.sqrt( 1 - R[0] + R[4] - R[8] ) * sign( R[2] - R[6] ), // y
					0.5 * Math.sqrt( 1 - R[0] - R[4] + R[8] ) * sign( R[3] - R[1] ), // z
					0.5 * Math.sqrt( 1 + R[0] + R[4] + R[8] )                        // w
				);
	
				return this;
	
			};
	
		})();
	
		this.multiply = function ( quaternion ) {
	
			outQuat = FULLTILT.Quaternion.prototype.multiplyQuaternions( this, quaternion );
			this.copy( outQuat );
	
			return this;
	
		};
	
		this.rotateX = function ( angle ) {
	
			outQuat = FULLTILT.Quaternion.prototype.rotateByAxisAngle( this, [ 1, 0, 0 ], angle );
			this.copy( outQuat );
	
			return this;
	
		};
	
		this.rotateY = function ( angle ) {
	
			outQuat = FULLTILT.Quaternion.prototype.rotateByAxisAngle( this, [ 0, 1, 0 ], angle );
			this.copy( outQuat );
	
			return this;
	
		};
	
		this.rotateZ = function ( angle ) {
	
			outQuat = FULLTILT.Quaternion.prototype.rotateByAxisAngle( this, [ 0, 0, 1 ], angle );
			this.copy( outQuat );
	
			return this;
	
		};
	
		this.normalize = function () {
	
			return FULLTILT.Quaternion.prototype.normalize( this );
	
		};
	
		// Initialize object values
		this.set( x, y, z, w );
	
	};
	
	FULLTILT.Quaternion.prototype = {
	
		constructor: FULLTILT.Quaternion,
	
		multiplyQuaternions: function () {
	
			var multipliedQuat = new FULLTILT.Quaternion();
	
			return function ( a, b ) {
	
				var qax = a.x, qay = a.y, qaz = a.z, qaw = a.w;
				var qbx = b.x, qby = b.y, qbz = b.z, qbw = b.w;
	
				multipliedQuat.set(
					qax * qbw + qaw * qbx + qay * qbz - qaz * qby, // x
					qay * qbw + qaw * qby + qaz * qbx - qax * qbz, // y
					qaz * qbw + qaw * qbz + qax * qby - qay * qbx, // z
					qaw * qbw - qax * qbx - qay * qby - qaz * qbz  // w
				);
	
				return multipliedQuat;
	
			};
	
		}(),
	
		normalize: function( q ) {
	
			var len = Math.sqrt( q.x * q.x + q.y * q.y + q.z * q.z + q.w * q.w );
	
			if ( len === 0 ) {
	
				q.x = 0;
				q.y = 0;
				q.z = 0;
				q.w = 1;
	
			} else {
	
				len = 1 / len;
	
				q.x *= len;
				q.y *= len;
				q.z *= len;
				q.w *= len;
	
			}
	
			return q;
	
		},
	
		rotateByAxisAngle: function () {
	
			var outputQuaternion = new FULLTILT.Quaternion();
			var transformQuaternion = new FULLTILT.Quaternion();
	
			var halfAngle, sA;
	
			return function ( targetQuaternion, axis, angle ) {
	
				halfAngle = ( angle || 0 ) / 2;
				sA = Math.sin( halfAngle );
	
				transformQuaternion.set(
					( axis[ 0 ] || 0 ) * sA, // x
					( axis[ 1 ] || 0 ) * sA, // y
					( axis[ 2 ] || 0 ) * sA, // z
					Math.cos( halfAngle )    // w
				);
	
				// Multiply quaternion by q
				outputQuaternion = FULLTILT.Quaternion.prototype.multiplyQuaternions( targetQuaternion, transformQuaternion );
	
				return FULLTILT.Quaternion.prototype.normalize( outputQuaternion );
	
			};
	
		}()
	
	};
	
	////// FULLTILT.RotationMatrix //////
	
	FULLTILT.RotationMatrix = function ( m11, m12, m13, m21, m22, m23, m31, m32, m33 ) {
	
		var outMatrix;
	
		this.elements = new Float32Array( 9 );
	
		this.identity = function () {
	
			this.set(
				1, 0, 0,
				0, 1, 0,
				0, 0, 1
			);
	
			return this;
	
		};
	
		this.set = function ( m11, m12, m13, m21, m22, m23, m31, m32, m33 ) {
	
			this.elements[ 0 ] = m11 || 1;
			this.elements[ 1 ] = m12 || 0;
			this.elements[ 2 ] = m13 || 0;
			this.elements[ 3 ] = m21 || 0;
			this.elements[ 4 ] = m22 || 1;
			this.elements[ 5 ] = m23 || 0;
			this.elements[ 6 ] = m31 || 0;
			this.elements[ 7 ] = m32 || 0;
			this.elements[ 8 ] = m33 || 1;
	
		};
	
		this.copy = function ( matrix ) {
	
			this.elements[ 0 ] = matrix.elements[ 0 ];
			this.elements[ 1 ] = matrix.elements[ 1 ];
			this.elements[ 2 ] = matrix.elements[ 2 ];
			this.elements[ 3 ] = matrix.elements[ 3 ];
			this.elements[ 4 ] = matrix.elements[ 4 ];
			this.elements[ 5 ] = matrix.elements[ 5 ];
			this.elements[ 6 ] = matrix.elements[ 6 ];
			this.elements[ 7 ] = matrix.elements[ 7 ];
			this.elements[ 8 ] = matrix.elements[ 8 ];
	
		};
	
		this.setFromEuler = (function() {
	
			var _x, _y, _z;
			var cX, cY, cZ, sX, sY, sZ;
	
			return function ( euler ) {
	
				euler = euler || {};
	
				_z = ( euler.alpha || 0 ) * degToRad;
				_x = ( euler.beta || 0 ) * degToRad;
				_y = ( euler.gamma || 0 ) * degToRad;
	
				cX = Math.cos( _x );
				cY = Math.cos( _y );
				cZ = Math.cos( _z );
				sX = Math.sin( _x );
				sY = Math.sin( _y );
				sZ = Math.sin( _z );
	
				//
				// ZXY-ordered rotation matrix construction.
				//
	
				this.set(
					cZ * cY - sZ * sX * sY, // 1,1
					- cX * sZ,              // 1,2
					cY * sZ * sX + cZ * sY, // 1,3
	
					cY * sZ + cZ * sX * sY, // 2,1
					cZ * cX,                // 2,2
					sZ * sY - cZ * cY * sX, // 2,3
	
					- cX * sY,              // 3,1
					sX,                     // 3,2
					cX * cY                 // 3,3
				);
	
				this.normalize();
	
				return this;
	
			};
	
		})();
	
		this.setFromQuaternion = (function() {
	
			var sqw, sqx, sqy, sqz;
	
			return function( q ) {
	
				sqw = q.w * q.w;
				sqx = q.x * q.x;
				sqy = q.y * q.y;
				sqz = q.z * q.z;
	
				this.set(
					sqw + sqx - sqy - sqz,       // 1,1
					2 * (q.x * q.y - q.w * q.z), // 1,2
					2 * (q.x * q.z + q.w * q.y), // 1,3
	
					2 * (q.x * q.y + q.w * q.z), // 2,1
					sqw - sqx + sqy - sqz,       // 2,2
					2 * (q.y * q.z - q.w * q.x), // 2,3
	
					2 * (q.x * q.z - q.w * q.y), // 3,1
					2 * (q.y * q.z + q.w * q.x), // 3,2
					sqw - sqx - sqy + sqz        // 3,3
				);
	
				return this;
	
			};
	
		})();
	
		this.multiply = function ( m ) {
	
			outMatrix = FULLTILT.RotationMatrix.prototype.multiplyMatrices( this, m );
			this.copy( outMatrix );
	
			return this;
	
		};
	
		this.rotateX = function ( angle ) {
	
			outMatrix = FULLTILT.RotationMatrix.prototype.rotateByAxisAngle( this, [ 1, 0, 0 ], angle );
			this.copy( outMatrix );
	
			return this;
	
		};
	
		this.rotateY = function ( angle ) {
	
			outMatrix = FULLTILT.RotationMatrix.prototype.rotateByAxisAngle( this, [ 0, 1, 0 ], angle );
			this.copy( outMatrix );
	
			return this;
	
		};
	
		this.rotateZ = function ( angle ) {
	
			outMatrix = FULLTILT.RotationMatrix.prototype.rotateByAxisAngle( this, [ 0, 0, 1 ], angle );
			this.copy( outMatrix );
	
			return this;
	
		};
	
		this.normalize = function () {
	
			return FULLTILT.RotationMatrix.prototype.normalize( this );
	
		};
	
		// Initialize object values
		this.set( m11, m12, m13, m21, m22, m23, m31, m32, m33 );
	
	};
	
	FULLTILT.RotationMatrix.prototype = {
	
		constructor: FULLTILT.RotationMatrix,
	
		multiplyMatrices: function () {
	
			var matrix = new FULLTILT.RotationMatrix();
	
			var aE, bE;
	
			return function ( a, b ) {
	
				aE = a.elements;
				bE = b.elements;
	
				matrix.set(
					aE[0] * bE[0] + aE[1] * bE[3] + aE[2] * bE[6],
					aE[0] * bE[1] + aE[1] * bE[4] + aE[2] * bE[7],
					aE[0] * bE[2] + aE[1] * bE[5] + aE[2] * bE[8],
	
					aE[3] * bE[0] + aE[4] * bE[3] + aE[5] * bE[6],
					aE[3] * bE[1] + aE[4] * bE[4] + aE[5] * bE[7],
					aE[3] * bE[2] + aE[4] * bE[5] + aE[5] * bE[8],
	
					aE[6] * bE[0] + aE[7] * bE[3] + aE[8] * bE[6],
					aE[6] * bE[1] + aE[7] * bE[4] + aE[8] * bE[7],
					aE[6] * bE[2] + aE[7] * bE[5] + aE[8] * bE[8]
				);
	
				return matrix;
	
			};
	
		}(),
	
		normalize: function( matrix ) {
	
			var R = matrix.elements;
	
			// Calculate matrix determinant
			var determinant = R[0] * R[4] * R[8] - R[0] * R[5] * R[7] - R[1] * R[3] * R[8] + R[1] * R[5] * R[6] + R[2] * R[3] * R[7] - R[2] * R[4] * R[6];
	
			// Normalize matrix values
			R[0] /= determinant;
			R[1] /= determinant;
			R[2] /= determinant;
			R[3] /= determinant;
			R[4] /= determinant;
			R[5] /= determinant;
			R[6] /= determinant;
			R[7] /= determinant;
			R[8] /= determinant;
	
			matrix.elements = R;
	
			return matrix;
	
		},
	
		rotateByAxisAngle: function () {
	
			var outputMatrix = new FULLTILT.RotationMatrix();
			var transformMatrix = new FULLTILT.RotationMatrix();
	
			var sA, cA;
			var validAxis = false;
	
			return function ( targetRotationMatrix, axis, angle ) {
	
				transformMatrix.identity(); // reset transform matrix
	
				validAxis = false;
	
				sA = Math.sin( angle );
				cA = Math.cos( angle );
	
				if ( axis[ 0 ] === 1 && axis[ 1 ] === 0 && axis[ 2 ] === 0 ) { // x
	
					validAxis = true;
	
					transformMatrix.elements[4] = cA;
					transformMatrix.elements[5] = -sA;
					transformMatrix.elements[7] = sA;
					transformMatrix.elements[8] = cA;
	
		 		} else if ( axis[ 1 ] === 1 && axis[ 0 ] === 0 && axis[ 2 ] === 0 ) { // y
	
					validAxis = true;
	
					transformMatrix.elements[0] = cA;
					transformMatrix.elements[2] = sA;
					transformMatrix.elements[6] = -sA;
					transformMatrix.elements[8] = cA;
	
		 		} else if ( axis[ 2 ] === 1 && axis[ 0 ] === 0 && axis[ 1 ] === 0 ) { // z
	
					validAxis = true;
	
					transformMatrix.elements[0] = cA;
					transformMatrix.elements[1] = -sA;
					transformMatrix.elements[3] = sA;
					transformMatrix.elements[4] = cA;
	
		 		}
	
				if ( validAxis ) {
	
					outputMatrix = FULLTILT.RotationMatrix.prototype.multiplyMatrices( targetRotationMatrix, transformMatrix );
	
					outputMatrix = FULLTILT.RotationMatrix.prototype.normalize( outputMatrix );
	
				} else {
	
					outputMatrix = targetRotationMatrix;
	
				}
	
				return outputMatrix;
	
			};
	
		}()
	
	};
	
	////// FULLTILT.Euler //////
	
	FULLTILT.Euler = function ( alpha, beta, gamma ) {
	
		this.set = function ( alpha, beta, gamma ) {
	
			this.alpha = alpha || 0;
			this.beta  = beta  || 0;
			this.gamma = gamma || 0;
	
		};
	
		this.copy = function ( inEuler ) {
	
			this.alpha = inEuler.alpha;
			this.beta  = inEuler.beta;
			this.gamma = inEuler.gamma;
	
		};
	
		this.setFromRotationMatrix = (function () {
	
			var R, _alpha, _beta, _gamma;
	
			return function ( matrix ) {
	
				R = matrix.elements;
	
				if (R[8] > 0) { // cos(beta) > 0
	
					_alpha = Math.atan2(-R[1], R[4]);
					_beta  = Math.asin(R[7]); // beta (-pi/2, pi/2)
					_gamma = Math.atan2(-R[6], R[8]); // gamma (-pi/2, pi/2)
	
				} else if (R[8] < 0) {  // cos(beta) < 0
	
					_alpha = Math.atan2(R[1], -R[4]);
					_beta  = -Math.asin(R[7]);
					_beta  += (_beta >= 0) ? - M_PI : M_PI; // beta [-pi,-pi/2) U (pi/2,pi)
					_gamma = Math.atan2(R[6], -R[8]); // gamma (-pi/2, pi/2)
	
				} else { // R[8] == 0
	
					if (R[6] > 0) {  // cos(gamma) == 0, cos(beta) > 0
	
						_alpha = Math.atan2(-R[1], R[4]);
						_beta  = Math.asin(R[7]); // beta [-pi/2, pi/2]
						_gamma = - M_PI_2; // gamma = -pi/2
	
					} else if (R[6] < 0) { // cos(gamma) == 0, cos(beta) < 0
	
						_alpha = Math.atan2(R[1], -R[4]);
						_beta  = -Math.asin(R[7]);
						_beta  += (_beta >= 0) ? - M_PI : M_PI; // beta [-pi,-pi/2) U (pi/2,pi)
						_gamma = - M_PI_2; // gamma = -pi/2
	
					} else { // R[6] == 0, cos(beta) == 0
	
						// gimbal lock discontinuity
						_alpha = Math.atan2(R[3], R[0]);
						_beta  = (R[7] > 0) ? M_PI_2 : - M_PI_2; // beta = +-pi/2
						_gamma = 0; // gamma = 0
	
					}
	
				}
	
				// alpha is in [-pi, pi], make sure it is in [0, 2*pi).
				if (_alpha < 0) {
					_alpha += M_2_PI; // alpha [0, 2*pi)
				}
	
				// Convert to degrees
				_alpha *= radToDeg;
				_beta  *= radToDeg;
				_gamma *= radToDeg;
	
				// apply derived euler angles to current object
				this.set( _alpha, _beta, _gamma );
	
			};
	
		})();
	
		this.setFromQuaternion = (function () {
	
			var _alpha, _beta, _gamma;
	
			return function ( q ) {
	
				var sqw = q.w * q.w;
				var sqx = q.x * q.x;
				var sqy = q.y * q.y;
				var sqz = q.z * q.z;
	
				var unitLength = sqw + sqx + sqy + sqz; // Normalised == 1, otherwise correction divisor.
				var wxyz = q.w * q.x + q.y * q.z;
				var epsilon = 1e-6; // rounding factor
	
				if (wxyz > (0.5 - epsilon) * unitLength) {
	
					_alpha = 2 * Math.atan2(q.y, q.w);
					_beta = M_PI_2;
					_gamma = 0;
	
				} else if (wxyz < (-0.5 + epsilon) * unitLength) {
	
					_alpha = -2 * Math.atan2(q.y, q.w);
					_beta = -M_PI_2;
					_gamma = 0;
	
				} else {
	
					var aX = sqw - sqx + sqy - sqz;
					var aY = 2 * (q.w * q.z - q.x * q.y);
	
					var gX = sqw - sqx - sqy + sqz;
					var gY = 2 * (q.w * q.y - q.x * q.z);
	
					if (gX > 0) {
	
						_alpha = Math.atan2(aY, aX);
						_beta  = Math.asin(2 * wxyz / unitLength);
						_gamma = Math.atan2(gY, gX);
	
					} else {
	
						_alpha = Math.atan2(-aY, -aX);
						_beta  = -Math.asin(2 * wxyz / unitLength);
						_beta  += _beta < 0 ? M_PI : - M_PI;
						_gamma = Math.atan2(-gY, -gX);
	
					}
	
				}
	
				// alpha is in [-pi, pi], make sure it is in [0, 2*pi).
				if (_alpha < 0) {
					_alpha += M_2_PI; // alpha [0, 2*pi)
				}
	
				// Convert to degrees
				_alpha *= radToDeg;
				_beta  *= radToDeg;
				_gamma *= radToDeg;
	
				// apply derived euler angles to current object
				this.set( _alpha, _beta, _gamma );
	
			};
	
		})();
	
		this.rotateX = function ( angle ) {
	
			FULLTILT.Euler.prototype.rotateByAxisAngle( this, [ 1, 0, 0 ], angle );
	
			return this;
	
		};
	
		this.rotateY = function ( angle ) {
	
			FULLTILT.Euler.prototype.rotateByAxisAngle( this, [ 0, 1, 0 ], angle );
	
			return this;
	
		};
	
		this.rotateZ = function ( angle ) {
	
			FULLTILT.Euler.prototype.rotateByAxisAngle( this, [ 0, 0, 1 ], angle );
	
			return this;
	
		};
	
		// Initialize object values
		this.set( alpha, beta, gamma );
	
	};
	
	FULLTILT.Euler.prototype = {
	
		constructor: FULLTILT.Euler,
	
		rotateByAxisAngle: function () {
	
			var _matrix = new FULLTILT.RotationMatrix();
			var outEuler;
	
			return function ( targetEuler, axis, angle ) {
	
				_matrix.setFromEuler( targetEuler );
	
				_matrix = FULLTILT.RotationMatrix.prototype.rotateByAxisAngle( _matrix, axis, angle );
	
				targetEuler.setFromRotationMatrix( _matrix );
	
				return targetEuler;
	
			};
	
		}()
	
	};
	
	///// FULLTILT.DeviceOrientation //////
	
	FULLTILT.DeviceOrientation = function (options) {
	
		this.options = options || {}; // by default use UA deviceorientation 'type' ("game" on iOS, "world" on Android)
	
		var tries = 0;
		var maxTries = 200;
		var successCount = 0;
		var successThreshold = 10;
	
		this.alphaOffsetScreen = 0;
		this.alphaOffsetDevice = undefined;
	
		// Create a game-based deviceorientation object (initial alpha === 0 degrees)
		if (this.options.type === "game") {
	
			var setGameAlphaOffset = function(evt) {
	
				if (evt.alpha !== null) { // do regardless of whether 'evt.absolute' is also true
					this.alphaOffsetDevice = new FULLTILT.Euler(evt.alpha, 0, 0);
					this.alphaOffsetDevice.rotateZ( -screenOrientationAngle );
	
					// Discard first {successThreshold} responses while a better compass lock is found by UA
					if(++successCount >= successThreshold) {
						window.removeEventListener( 'deviceorientation', setGameAlphaOffset, false );
						return;
					}
				}
	
				if(++tries >= maxTries) {
					window.removeEventListener( 'deviceorientation', setGameAlphaOffset, false );
				}
	
			}.bind(this);
	
			window.addEventListener( 'deviceorientation', setGameAlphaOffset, false );
	
		// Create a compass-based deviceorientation object (initial alpha === compass degrees)
		} else if (this.options.type === "world") {
	
			var setCompassAlphaOffset = function(evt) {
	
				if (evt.absolute !== true && evt.webkitCompassAccuracy !== undefined && evt.webkitCompassAccuracy !== null && +evt.webkitCompassAccuracy >= 0 && +evt.webkitCompassAccuracy < 50) {
					this.alphaOffsetDevice = new FULLTILT.Euler(evt.webkitCompassHeading, 0, 0);
					this.alphaOffsetDevice.rotateZ( screenOrientationAngle );
					this.alphaOffsetScreen = screenOrientationAngle;
	
					// Discard first {successThreshold} responses while a better compass lock is found by UA
					if(++successCount >= successThreshold) {
						window.removeEventListener( 'deviceorientation', setCompassAlphaOffset, false );
						return;
					}
				}
	
				if(++tries >= maxTries) {
					window.removeEventListener( 'deviceorientation', setCompassAlphaOffset, false );
				}
	
			}.bind(this);
	
			window.addEventListener( 'deviceorientation', setCompassAlphaOffset, false );
	
		} // else... use whatever orientation system the UA provides ("game" on iOS, "world" on Android)
	
	};
	
	FULLTILT.DeviceOrientation.prototype = {
	
		constructor: FULLTILT.DeviceOrientation,
	
		start: function ( callback ) {
	
			if ( callback && Object.prototype.toString.call( callback ) == '[object Function]' ) {
	
				sensors.orientation.callbacks.push( callback );
	
			}
	
			if( !screenActive ) {
	
				if ( hasScreenOrientationAPI ) {
	
				window.screen.orientation.addEventListener( 'change', handleScreenOrientationChange, false );
	
				} else {
	
					window.addEventListener( 'orientationchange', handleScreenOrientationChange, false );
	
				}
	
			}
	
			if ( !sensors.orientation.active ) {
	
				window.addEventListener( 'deviceorientation', handleDeviceOrientationChange, false );
	
				sensors.orientation.active = true;
	
			}
	
		},
	
		stop: function () {
	
			if ( sensors.orientation.active ) {
	
				window.removeEventListener( 'deviceorientation', handleDeviceOrientationChange, false );
	
				sensors.orientation.active = false;
	
			}
	
		},
	
		listen: function( callback ) {
	
			this.start( callback );
	
		},
	
		getFixedFrameQuaternion: (function () {
	
			var euler = new FULLTILT.Euler();
			var matrix = new FULLTILT.RotationMatrix();
			var quaternion = new FULLTILT.Quaternion();
	
			return function() {
	
				var orientationData = sensors.orientation.data || { alpha: 0, beta: 0, gamma: 0 };
	
				var adjustedAlpha = orientationData.alpha;
	
				if (this.alphaOffsetDevice) {
					matrix.setFromEuler( this.alphaOffsetDevice );
					matrix.rotateZ( - this.alphaOffsetScreen );
					euler.setFromRotationMatrix( matrix );
	
					if (euler.alpha < 0) {
						euler.alpha += 360;
					}
	
					euler.alpha %= 360;
	
					adjustedAlpha -= euler.alpha;
				}
	
				euler.set(
					adjustedAlpha,
					orientationData.beta,
					orientationData.gamma
				);
	
				quaternion.setFromEuler( euler );
	
				return quaternion;
	
			};
	
		})(),
	
		getScreenAdjustedQuaternion: (function () {
	
			var quaternion;
	
			return function() {
	
				quaternion = this.getFixedFrameQuaternion();
	
				// Automatically apply screen orientation transform
				quaternion.rotateZ( - screenOrientationAngle );
	
				return quaternion;
	
			};
	
		})(),
	
		getFixedFrameMatrix: (function () {
	
			var euler = new FULLTILT.Euler();
			var matrix = new FULLTILT.RotationMatrix();
	
			return function () {
	
				var orientationData = sensors.orientation.data || { alpha: 0, beta: 0, gamma: 0 };
	
				var adjustedAlpha = orientationData.alpha;
	
				if (this.alphaOffsetDevice) {
					matrix.setFromEuler( this.alphaOffsetDevice );
					matrix.rotateZ( - this.alphaOffsetScreen );
					euler.setFromRotationMatrix( matrix );
	
					if (euler.alpha < 0) {
						euler.alpha += 360;
					}
	
					euler.alpha %= 360;
	
					adjustedAlpha -= euler.alpha;
				}
	
				euler.set(
					adjustedAlpha,
					orientationData.beta,
					orientationData.gamma
				);
	
				matrix.setFromEuler( euler );
	
				return matrix;
	
			};
	
		})(),
	
		getScreenAdjustedMatrix: (function () {
	
			var matrix;
	
			return function () {
	
				matrix = this.getFixedFrameMatrix();
	
				// Automatically apply screen orientation transform
				matrix.rotateZ( - screenOrientationAngle );
	
				return matrix;
	
			};
	
		})(),
	
		getFixedFrameEuler: (function () {
	
			var euler = new FULLTILT.Euler();
			var matrix;
	
			return function () {
	
				matrix = this.getFixedFrameMatrix();
	
				euler.setFromRotationMatrix( matrix );
	
				return euler;
	
			};
	
		})(),
	
		getScreenAdjustedEuler: (function () {
	
			var euler = new FULLTILT.Euler();
			var matrix;
	
			return function () {
	
				matrix = this.getScreenAdjustedMatrix();
	
				euler.setFromRotationMatrix( matrix );
	
				return euler;
	
			};
	
		})(),
	
		isAbsolute: function () {
	
			if ( sensors.orientation.data && sensors.orientation.data.absolute === true ) {
				return true;
			}
	
			return false;
	
		},
	
		getLastRawEventData: function () {
	
			return sensors.orientation.data || {};
	
		},
	
		ALPHA: 'alpha',
		BETA: 'beta',
		GAMMA: 'gamma'
	
	};
	
	
	///// FULLTILT.DeviceMotion //////
	
	FULLTILT.DeviceMotion = function (options) {
	
		this.options = options || {}; // placeholder object since no options are currently supported
	
	};
	
	FULLTILT.DeviceMotion.prototype = {
	
		constructor: FULLTILT.DeviceMotion,
	
		start: function ( callback ) {
	
			if ( callback && Object.prototype.toString.call( callback ) == '[object Function]' ) {
	
				sensors.motion.callbacks.push( callback );
	
			}
	
			if( !screenActive ) {
	
				if ( hasScreenOrientationAPI ) {
	
					window.screen.orientation.addEventListener( 'change', handleScreenOrientationChange, false );
	
				} else {
	
					window.addEventListener( 'orientationchange', handleScreenOrientationChange, false );
	
				}
	
			}
	
			if ( !sensors.motion.active ) {
	
				window.addEventListener( 'devicemotion', handleDeviceMotionChange, false );
	
				sensors.motion.active = true;
	
			}
	
		},
	
		stop: function () {
	
			if ( sensors.motion.active ) {
	
				window.removeEventListener( 'devicemotion', handleDeviceMotionChange, false );
	
				sensors.motion.active = false;
	
			}
	
		},
	
		listen: function( callback ) {
	
			this.start( callback );
	
		},
	
		getScreenAdjustedAcceleration: function () {
	
			var accData = sensors.motion.data && sensors.motion.data.acceleration ? sensors.motion.data.acceleration : { x: 0, y: 0, z: 0 };
			var screenAccData = {};
	
			switch ( screenOrientationAngle ) {
				case SCREEN_ROTATION_90:
					screenAccData.x = - accData.y;
					screenAccData.y =   accData.x;
					break;
				case SCREEN_ROTATION_180:
					screenAccData.x = - accData.x;
					screenAccData.y = - accData.y;
					break;
				case SCREEN_ROTATION_270:
				case SCREEN_ROTATION_MINUS_90:
					screenAccData.x =   accData.y;
					screenAccData.y = - accData.x;
					break;
				default: // SCREEN_ROTATION_0
					screenAccData.x =   accData.x;
					screenAccData.y =   accData.y;
					break;
			}
	
			screenAccData.z = accData.z;
	
			return screenAccData;
	
		},
	
		getScreenAdjustedAccelerationIncludingGravity: function () {
	
			var accGData = sensors.motion.data && sensors.motion.data.accelerationIncludingGravity ? sensors.motion.data.accelerationIncludingGravity : { x: 0, y: 0, z: 0 };
			var screenAccGData = {};
	
			switch ( screenOrientationAngle ) {
				case SCREEN_ROTATION_90:
					screenAccGData.x = - accGData.y;
					screenAccGData.y =   accGData.x;
					break;
				case SCREEN_ROTATION_180:
					screenAccGData.x = - accGData.x;
					screenAccGData.y = - accGData.y;
					break;
				case SCREEN_ROTATION_270:
				case SCREEN_ROTATION_MINUS_90:
					screenAccGData.x =   accGData.y;
					screenAccGData.y = - accGData.x;
					break;
				default: // SCREEN_ROTATION_0
					screenAccGData.x =   accGData.x;
					screenAccGData.y =   accGData.y;
					break;
			}
	
			screenAccGData.z = accGData.z;
	
			return screenAccGData;
	
		},
	
		getScreenAdjustedRotationRate: function () {
	
			var rotRateData = sensors.motion.data && sensors.motion.data.rotationRate ? sensors.motion.data.rotationRate : { alpha: 0, beta: 0, gamma: 0 };
			var screenRotRateData = {};
	
			switch ( screenOrientationAngle ) {
				case SCREEN_ROTATION_90:
					screenRotRateData.beta  = - rotRateData.gamma;
					screenRotRateData.gamma =   rotRateData.beta;
					break;
				case SCREEN_ROTATION_180:
					screenRotRateData.beta  = - rotRateData.beta;
					screenRotRateData.gamma = - rotRateData.gamma;
					break;
				case SCREEN_ROTATION_270:
				case SCREEN_ROTATION_MINUS_90:
					screenRotRateData.beta  =   rotRateData.gamma;
					screenRotRateData.gamma = - rotRateData.beta;
					break;
				default: // SCREEN_ROTATION_0
					screenRotRateData.beta  =   rotRateData.beta;
					screenRotRateData.gamma =   rotRateData.gamma;
					break;
			}
	
			screenRotRateData.alpha = rotRateData.alpha;
	
			return screenRotRateData;
	
		},
	
		getLastRawEventData: function () {
	
			return sensors.motion.data || {};
	
		}
	
	};
	
	
	////// Attach FULLTILT to root DOM element //////
	
	window.FULLTILT = FULLTILT;
	
	})( window );

/***/ }),
/* 106 */
/***/ (function(module, exports) {

	'use strict';
	module.exports = function () {
		return /[\u001b\u009b][[()#;?]*(?:[0-9]{1,4}(?:;[0-9]{0,4})*)?[0-9A-PRZcf-nqry=><]/g;
	};


/***/ }),
/* 107 */
/***/ (function(module, exports) {

	module.exports = function numtype(num, def) {
		return typeof num === 'number'
			? num 
			: (typeof def === 'number' ? def : 0)
	}

/***/ }),
/* 108 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; /* eslint-disable */
	
	
	var _three = __webpack_require__(2);
	
	var THREE = _interopRequireWildcard(_three);
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	/* shader-particle-engine 1.0.6
	 * 
	 * (c) 2015 Luke Moody (http://www.github.com/squarefeet)
	 *     Originally based on Lee Stemkoski's original work (https://github.com/stemkoski/stemkoski.github.com/blob/master/Three.js/js/ParticleEngine.js).
	 *
	 * shader-particle-engine may be freely distributed under the MIT license (See LICENSE at root of this repository.)
	 */
	/**
	 * @typedef {Number} distribution
	 * @property {Number} SPE.distributions.BOX Values will be distributed within a box.
	 * @property {Number} SPE.distributions.SPHERE Values will be distributed within a sphere.
	 * @property {Number} SPE.distributions.DISC Values will be distributed within a 2D disc.
	 */
	
	/**
	 * Namespace for Shader Particle Engine.
	 *
	 * All SPE-related code sits under this namespace.
	 *
	 * @type {Object}
	 * @namespace
	 */
	var SPE = {
	
	    /**
	     * A map of supported distribution types used
	     * by SPE.Emitter instances.
	     *
	     * These distribution types can be applied to
	     * an emitter globally, which will affect the
	     * `position`, `velocity`, and `acceleration`
	     * value calculations for an emitter, or they
	     * can be applied on a per-property basis.
	     *
	     * @enum {Number}
	     */
	    distributions: {
	        /**
	         * Values will be distributed within a box.
	         * @type {Number}
	         */
	        BOX: 1,
	
	        /**
	         * Values will be distributed on a sphere.
	         * @type {Number}
	         */
	        SPHERE: 2,
	
	        /**
	         * Values will be distributed on a 2d-disc shape.
	         * @type {Number}
	         */
	        DISC: 3
	    },
	
	    /**
	     * Set this value to however many 'steps' you
	     * want value-over-lifetime properties to have.
	     *
	     * It's adjustable to fix an interpolation problem:
	     *
	     * Assuming you specify an opacity value as [0, 1, 0]
	     *      and the `valueOverLifetimeLength` is 4, then the
	     *      opacity value array will be reinterpolated to
	     *      be [0, 0.66, 0.66, 0].
	     *   This isn't ideal, as particles would never reach
	     *   full opacity.
	     *
	     * NOTE:
	     *     This property affects the length of ALL
	     *       value-over-lifetime properties for ALL
	     *       emitters and ALL groups.
	     *
	     *     Only values >= 3 && <= 4 are allowed.
	     *
	     * @type {Number}
	     */
	    valueOverLifetimeLength: 4
	};
	
	// Module loader support:
	if (true) {
	    !(__WEBPACK_AMD_DEFINE_FACTORY__ = (SPE), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	} else if (typeof exports !== 'undefined' && typeof module !== 'undefined') {
	    module.exports = SPE;
	}
	
	/**
	 * A helper class for TypedArrays.
	 *
	 * Allows for easy resizing, assignment of various component-based
	 * types (Vector2s, Vector3s, Vector4s, Mat3s, Mat4s),
	 * as well as Colors (where components are `r`, `g`, `b`),
	 * Numbers, and setting from other TypedArrays.
	 *
	 * @author Luke Moody
	 * @constructor
	 * @param {Function} TypedArrayConstructor The constructor to use (Float32Array, Uint8Array, etc.)
	 * @param {Number} size                 The size of the array to create
	 * @param {Number} componentSize        The number of components per-value (ie. 3 for a vec3, 9 for a Mat3, etc.)
	 * @param {Number} indexOffset          The index in the array from which to start assigning values. Default `0` if none provided
	 */
	SPE.TypedArrayHelper = function (TypedArrayConstructor, size, componentSize, indexOffset) {
	    'use strict';
	
	    this.componentSize = componentSize || 1;
	    this.size = size || 1;
	    this.TypedArrayConstructor = TypedArrayConstructor || Float32Array;
	    this.array = new TypedArrayConstructor(size * this.componentSize);
	    this.indexOffset = indexOffset || 0;
	};
	
	SPE.TypedArrayHelper.constructor = SPE.TypedArrayHelper;
	
	/**
	 * Sets the size of the internal array.
	 *
	 * Delegates to `this.shrink` or `this.grow` depending on size
	 * argument's relation to the current size of the internal array.
	 *
	 * Note that if the array is to be shrunk, data will be lost.
	 *
	 * @param {Number} size The new size of the array.
	 */
	SPE.TypedArrayHelper.prototype.setSize = function (size, noComponentMultiply) {
	    'use strict';
	
	    var currentArraySize = this.array.length;
	
	    if (!noComponentMultiply) {
	        size = size * this.componentSize;
	    }
	
	    if (size < currentArraySize) {
	        return this.shrink(size);
	    } else if (size > currentArraySize) {
	        return this.grow(size);
	    } else {
	        console.info('TypedArray is already of size:', size + '.', 'Will not resize.');
	    }
	};
	
	/**
	 * Shrinks the internal array.
	 *
	 * @param  {Number} size The new size of the typed array. Must be smaller than `this.array.length`.
	 * @return {SPE.TypedArrayHelper}      Instance of this class.
	 */
	SPE.TypedArrayHelper.prototype.shrink = function (size) {
	    'use strict';
	
	    this.array = this.array.subarray(0, size);
	    this.size = size;
	    return this;
	};
	
	/**
	 * Grows the internal array.
	 * @param  {Number} size The new size of the typed array. Must be larger than `this.array.length`.
	 * @return {SPE.TypedArrayHelper}      Instance of this class.
	 */
	SPE.TypedArrayHelper.prototype.grow = function (size) {
	    'use strict';
	
	    var existingArray = this.array,
	        newArray = new this.TypedArrayConstructor(size);
	
	    newArray.set(existingArray);
	    this.array = newArray;
	    this.size = size;
	
	    return this;
	};
	
	/**
	 * Perform a splice operation on this array's buffer.
	 * @param  {Number} start The start index of the splice. Will be multiplied by the number of components for this attribute.
	 * @param  {Number} end The end index of the splice. Will be multiplied by the number of components for this attribute.
	 * @returns {Object} The SPE.TypedArrayHelper instance.
	 */
	SPE.TypedArrayHelper.prototype.splice = function (start, end) {
	    'use strict';
	
	    start *= this.componentSize;
	    end *= this.componentSize;
	
	    var data = [],
	        array = this.array,
	        size = array.length;
	
	    for (var i = 0; i < size; ++i) {
	        if (i < start || i >= end) {
	            data.push(array[i]);
	        }
	        // array[ i ] = 0;
	    }
	
	    this.setFromArray(0, data);
	
	    return this;
	};
	
	/**
	 * Copies from the given TypedArray into this one, using the index argument
	 * as the start position. Alias for `TypedArray.set`. Will automatically resize
	 * if the given source array is of a larger size than the internal array.
	 *
	 * @param {Number} index      The start position from which to copy into this array.
	 * @param {TypedArray} array The array from which to copy; the source array.
	 * @return {SPE.TypedArrayHelper} Instance of this class.
	 */
	SPE.TypedArrayHelper.prototype.setFromArray = function (index, array) {
	    'use strict';
	
	    var sourceArraySize = array.length,
	        newSize = index + sourceArraySize;
	
	    if (newSize > this.array.length) {
	        this.grow(newSize);
	    } else if (newSize < this.array.length) {
	        this.shrink(newSize);
	    }
	
	    this.array.set(array, this.indexOffset + index);
	
	    return this;
	};
	
	/**
	 * Set a Vector2 value at `index`.
	 *
	 * @param {Number} index The index at which to set the vec2 values from.
	 * @param {Vector2} vec2  Any object that has `x` and `y` properties.
	 * @return {SPE.TypedArrayHelper} Instance of this class.
	 */
	SPE.TypedArrayHelper.prototype.setVec2 = function (index, vec2) {
	    'use strict';
	
	    return this.setVec2Components(index, vec2.x, vec2.y);
	};
	
	/**
	 * Set a Vector2 value using raw components.
	 *
	 * @param {Number} index The index at which to set the vec2 values from.
	 * @param {Number} x     The Vec2's `x` component.
	 * @param {Number} y     The Vec2's `y` component.
	 * @return {SPE.TypedArrayHelper} Instance of this class.
	 */
	SPE.TypedArrayHelper.prototype.setVec2Components = function (index, x, y) {
	    'use strict';
	
	    var array = this.array,
	        i = this.indexOffset + index * this.componentSize;
	
	    array[i] = x;
	    array[i + 1] = y;
	    return this;
	};
	
	/**
	 * Set a Vector3 value at `index`.
	 *
	 * @param {Number} index The index at which to set the vec3 values from.
	 * @param {Vector3} vec2  Any object that has `x`, `y`, and `z` properties.
	 * @return {SPE.TypedArrayHelper} Instance of this class.
	 */
	SPE.TypedArrayHelper.prototype.setVec3 = function (index, vec3) {
	    'use strict';
	
	    return this.setVec3Components(index, vec3.x, vec3.y, vec3.z);
	};
	
	/**
	 * Set a Vector3 value using raw components.
	 *
	 * @param {Number} index The index at which to set the vec3 values from.
	 * @param {Number} x     The Vec3's `x` component.
	 * @param {Number} y     The Vec3's `y` component.
	 * @param {Number} z     The Vec3's `z` component.
	 * @return {SPE.TypedArrayHelper} Instance of this class.
	 */
	SPE.TypedArrayHelper.prototype.setVec3Components = function (index, x, y, z) {
	    'use strict';
	
	    var array = this.array,
	        i = this.indexOffset + index * this.componentSize;
	
	    array[i] = x;
	    array[i + 1] = y;
	    array[i + 2] = z;
	    return this;
	};
	
	/**
	 * Set a Vector4 value at `index`.
	 *
	 * @param {Number} index The index at which to set the vec4 values from.
	 * @param {Vector4} vec2  Any object that has `x`, `y`, `z`, and `w` properties.
	 * @return {SPE.TypedArrayHelper} Instance of this class.
	 */
	SPE.TypedArrayHelper.prototype.setVec4 = function (index, vec4) {
	    'use strict';
	
	    return this.setVec4Components(index, vec4.x, vec4.y, vec4.z, vec4.w);
	};
	
	/**
	 * Set a Vector4 value using raw components.
	 *
	 * @param {Number} index The index at which to set the vec4 values from.
	 * @param {Number} x     The Vec4's `x` component.
	 * @param {Number} y     The Vec4's `y` component.
	 * @param {Number} z     The Vec4's `z` component.
	 * @param {Number} w     The Vec4's `w` component.
	 * @return {SPE.TypedArrayHelper} Instance of this class.
	 */
	SPE.TypedArrayHelper.prototype.setVec4Components = function (index, x, y, z, w) {
	    'use strict';
	
	    var array = this.array,
	        i = this.indexOffset + index * this.componentSize;
	
	    array[i] = x;
	    array[i + 1] = y;
	    array[i + 2] = z;
	    array[i + 3] = w;
	    return this;
	};
	
	/**
	 * Set a Matrix3 value at `index`.
	 *
	 * @param {Number} index The index at which to set the matrix values from.
	 * @param {Matrix3} mat3 The 3x3 matrix to set from. Must have a TypedArray property named `elements` to copy from.
	 * @return {SPE.TypedArrayHelper} Instance of this class.
	 */
	SPE.TypedArrayHelper.prototype.setMat3 = function (index, mat3) {
	    'use strict';
	
	    return this.setFromArray(this.indexOffset + index * this.componentSize, mat3.elements);
	};
	
	/**
	 * Set a Matrix4 value at `index`.
	 *
	 * @param {Number} index The index at which to set the matrix values from.
	 * @param {Matrix4} mat3 The 4x4 matrix to set from. Must have a TypedArray property named `elements` to copy from.
	 * @return {SPE.TypedArrayHelper} Instance of this class.
	 */
	SPE.TypedArrayHelper.prototype.setMat4 = function (index, mat4) {
	    'use strict';
	
	    return this.setFromArray(this.indexOffset + index * this.componentSize, mat4.elements);
	};
	
	/**
	 * Set a Color value at `index`.
	 *
	 * @param {Number} index The index at which to set the vec3 values from.
	 * @param {Color} color  Any object that has `r`, `g`, and `b` properties.
	 * @return {SPE.TypedArrayHelper} Instance of this class.
	 */
	SPE.TypedArrayHelper.prototype.setColor = function (index, color) {
	    'use strict';
	
	    return this.setVec3Components(index, color.r, color.g, color.b);
	};
	
	/**
	 * Set a Number value at `index`.
	 *
	 * @param {Number} index The index at which to set the vec3 values from.
	 * @param {Number} numericValue  The number to assign to this index in the array.
	 * @return {SPE.TypedArrayHelper} Instance of this class.
	 */
	SPE.TypedArrayHelper.prototype.setNumber = function (index, numericValue) {
	    'use strict';
	
	    this.array[this.indexOffset + index * this.componentSize] = numericValue;
	    return this;
	};
	
	/**
	 * Returns the value of the array at the given index, taking into account
	 * the `indexOffset` property of this class.
	 *
	 * Note that this function ignores the component size and will just return a
	 * single value.
	 *
	 * @param  {Number} index The index in the array to fetch.
	 * @return {Number}       The value at the given index.
	 */
	SPE.TypedArrayHelper.prototype.getValueAtIndex = function (index) {
	    'use strict';
	
	    return this.array[this.indexOffset + index];
	};
	
	/**
	 * Returns the component value of the array at the given index, taking into account
	 * the `indexOffset` property of this class.
	 *
	 * If the componentSize is set to 3, then it will return a new TypedArray
	 * of length 3.
	 *
	 * @param  {Number} index The index in the array to fetch.
	 * @return {TypedArray}       The component value at the given index.
	 */
	SPE.TypedArrayHelper.prototype.getComponentValueAtIndex = function (index) {
	    'use strict';
	
	    return this.array.subarray(this.indexOffset + index * this.componentSize);
	};
	
	/**
	 * A helper to handle creating and updating a THREE.BufferAttribute instance.
	 *
	 * @author  Luke Moody
	 * @constructor
	 * @param {String} type          The buffer attribute type. See SPE.ShaderAttribute.typeSizeMap for valid values.
	 * @param {Boolean=} dynamicBuffer Whether this buffer attribute should be marked as dynamic or not.
	 * @param {Function=} arrayType     A reference to a TypedArray constructor. Defaults to Float32Array if none provided.
	 */
	SPE.ShaderAttribute = function (type, dynamicBuffer, arrayType) {
	    'use strict';
	
	    var typeMap = SPE.ShaderAttribute.typeSizeMap;
	
	    this.type = typeof type === 'string' && typeMap.hasOwnProperty(type) ? type : 'f';
	    this.componentSize = typeMap[this.type];
	    this.arrayType = arrayType || Float32Array;
	    this.typedArray = null;
	    this.bufferAttribute = null;
	    this.dynamicBuffer = !!dynamicBuffer;
	
	    this.updateMin = 0;
	    this.updateMax = 0;
	};
	
	SPE.ShaderAttribute.constructor = SPE.ShaderAttribute;
	
	/**
	 * A map of uniform types to their component size.
	 * @enum {Number}
	 */
	SPE.ShaderAttribute.typeSizeMap = {
	    /**
	     * Float
	     * @type {Number}
	     */
	    f: 1,
	
	    /**
	     * Vec2
	     * @type {Number}
	     */
	    v2: 2,
	
	    /**
	     * Vec3
	     * @type {Number}
	     */
	    v3: 3,
	
	    /**
	     * Vec4
	     * @type {Number}
	     */
	    v4: 4,
	
	    /**
	     * Color
	     * @type {Number}
	     */
	    c: 3,
	
	    /**
	     * Mat3
	     * @type {Number}
	     */
	    m3: 9,
	
	    /**
	     * Mat4
	     * @type {Number}
	     */
	    m4: 16
	};
	
	/**
	 * Calculate the minimum and maximum update range for this buffer attribute using
	 * component size independant min and max values.
	 *
	 * @param {Number} min The start of the range to mark as needing an update.
	 * @param {Number} max The end of the range to mark as needing an update.
	 */
	SPE.ShaderAttribute.prototype.setUpdateRange = function (min, max) {
	    'use strict';
	
	    this.updateMin = Math.min(min * this.componentSize, this.updateMin * this.componentSize);
	    this.updateMax = Math.max(max * this.componentSize, this.updateMax * this.componentSize);
	};
	
	/**
	 * Calculate the number of indices that this attribute should mark as needing
	 * updating. Also marks the attribute as needing an update.
	 */
	SPE.ShaderAttribute.prototype.flagUpdate = function () {
	    'use strict';
	
	    var attr = this.bufferAttribute,
	        range = attr.updateRange;
	
	    range.offset = this.updateMin;
	    range.count = Math.min(this.updateMax - this.updateMin + this.componentSize, this.typedArray.array.length);
	    // console.log( range.offset, range.count, this.typedArray.array.length );
	    // console.log( 'flagUpdate:', range.offset, range.count );
	    attr.needsUpdate = true;
	};
	
	/**
	 * Reset the index update counts for this attribute
	 */
	SPE.ShaderAttribute.prototype.resetUpdateRange = function () {
	    'use strict';
	
	    this.updateMin = 0;
	    this.updateMax = 0;
	};
	
	SPE.ShaderAttribute.prototype.resetDynamic = function () {
	    'use strict';
	
	    this.bufferAttribute.dynamic = this.dynamicBuffer;
	};
	
	/**
	 * Perform a splice operation on this attribute's buffer.
	 * @param  {Number} start The start index of the splice. Will be multiplied by the number of components for this attribute.
	 * @param  {Number} end The end index of the splice. Will be multiplied by the number of components for this attribute.
	 */
	SPE.ShaderAttribute.prototype.splice = function (start, end) {
	    'use strict';
	
	    this.typedArray.splice(start, end);
	
	    // Reset the reference to the attribute's typed array
	    // since it has probably changed.
	    this.forceUpdateAll();
	};
	
	SPE.ShaderAttribute.prototype.forceUpdateAll = function () {
	    'use strict';
	
	    this.bufferAttribute.array = this.typedArray.array;
	    this.bufferAttribute.updateRange.offset = 0;
	    this.bufferAttribute.updateRange.count = -1;
	    this.bufferAttribute.dynamic = false;
	    this.bufferAttribute.needsUpdate = true;
	};
	
	/**
	 * Make sure this attribute has a typed array associated with it.
	 *
	 * If it does, then it will ensure the typed array is of the correct size.
	 *
	 * If not, a new SPE.TypedArrayHelper instance will be created.
	 *
	 * @param  {Number} size The size of the typed array to create or update to.
	 */
	SPE.ShaderAttribute.prototype._ensureTypedArray = function (size) {
	    'use strict';
	
	    // Condition that's most likely to be true at the top: no change.
	
	    if (this.typedArray !== null && this.typedArray.size === size * this.componentSize) {
	        return;
	    }
	
	    // Resize the array if we need to, telling the TypedArrayHelper to
	    // ignore it's component size when evaluating size.
	    else if (this.typedArray !== null && this.typedArray.size !== size) {
	            this.typedArray.setSize(size);
	        }
	
	        // This condition should only occur once in an attribute's lifecycle.
	        else if (this.typedArray === null) {
	                this.typedArray = new SPE.TypedArrayHelper(this.arrayType, size, this.componentSize);
	            }
	};
	
	/**
	 * Creates a THREE.BufferAttribute instance if one doesn't exist already.
	 *
	 * Ensures a typed array is present by calling _ensureTypedArray() first.
	 *
	 * If a buffer attribute exists already, then it will be marked as needing an update.
	 *
	 * @param  {Number} size The size of the typed array to create if one doesn't exist, or resize existing array to.
	 */
	SPE.ShaderAttribute.prototype._createBufferAttribute = function (size) {
	    'use strict';
	
	    // Make sure the typedArray is present and correct.
	
	    this._ensureTypedArray(size);
	
	    // Don't create it if it already exists, but do
	    // flag that it needs updating on the next render
	    // cycle.
	    if (this.bufferAttribute !== null) {
	        this.bufferAttribute.array = this.typedArray.array;
	
	        // Since THREE.js version 81, dynamic count calculation was removed
	        // so I need to do it manually here.
	        //
	        // In the next minor release, I may well remove this check and force
	        // dependency on THREE r81+.
	        if (parseFloat(THREE.REVISION) >= 81) {
	            this.bufferAttribute.count = this.bufferAttribute.array.length / this.bufferAttribute.itemSize;
	        }
	
	        this.bufferAttribute.needsUpdate = true;
	        return;
	    }
	
	    this.bufferAttribute = new THREE.BufferAttribute(this.typedArray.array, this.componentSize);
	    this.bufferAttribute.dynamic = this.dynamicBuffer;
	};
	
	/**
	 * Returns the length of the typed array associated with this attribute.
	 * @return {Number} The length of the typed array. Will be 0 if no typed array has been created yet.
	 */
	SPE.ShaderAttribute.prototype.getLength = function () {
	    'use strict';
	
	    if (this.typedArray === null) {
	        return 0;
	    }
	
	    return this.typedArray.array.length;
	};
	
	SPE.shaderChunks = {
	    // Register color-packing define statements.
	    defines: ['#define PACKED_COLOR_SIZE 256.0', '#define PACKED_COLOR_DIVISOR 255.0'].join('\n'),
	
	    // All uniforms used by vertex / fragment shaders
	    uniforms: ['uniform float deltaTime;', 'uniform float runTime;', 'uniform sampler2D texture;', 'uniform vec4 textureAnimation;', 'uniform float scale;'].join('\n'),
	
	    // All attributes used by the vertex shader.
	    //
	    // Note that some attributes are squashed into other ones:
	    //
	    // * Drag is acceleration.w
	    attributes: ['attribute vec4 acceleration;', 'attribute vec3 velocity;', 'attribute vec4 rotation;', 'attribute vec3 rotationCenter;', 'attribute vec4 params;', 'attribute vec4 size;', 'attribute vec4 angle;', 'attribute vec4 color;', 'attribute vec4 opacity;'].join('\n'),
	
	    //
	    varyings: ['varying vec4 vColor;', '#ifdef SHOULD_ROTATE_TEXTURE', '    varying float vAngle;', '#endif', '#ifdef SHOULD_CALCULATE_SPRITE', '    varying vec4 vSpriteSheet;', '#endif'].join('\n'),
	
	    // Branch-avoiding comparison fns
	    // - http://theorangeduck.com/page/avoiding-shader-conditionals
	    branchAvoidanceFunctions: ['float when_gt(float x, float y) {', '    return max(sign(x - y), 0.0);', '}', 'float when_lt(float x, float y) {', '    return min( max(1.0 - sign(x - y), 0.0), 1.0 );', '}', 'float when_eq( float x, float y ) {', '    return 1.0 - abs( sign( x - y ) );', '}', 'float when_ge(float x, float y) {', '  return 1.0 - when_lt(x, y);', '}', 'float when_le(float x, float y) {', '  return 1.0 - when_gt(x, y);', '}',
	
	    // Branch-avoiding logical operators
	    // (to be used with above comparison fns)
	    'float and(float a, float b) {', '    return a * b;', '}', 'float or(float a, float b) {', '    return min(a + b, 1.0);', '}'].join('\n'),
	
	    // From:
	    // - http://stackoverflow.com/a/12553149
	    // - https://stackoverflow.com/questions/22895237/hexadecimal-to-rgb-values-in-webgl-shader
	    unpackColor: ['vec3 unpackColor( in float hex ) {', '   vec3 c = vec3( 0.0 );', '   float r = mod( (hex / PACKED_COLOR_SIZE / PACKED_COLOR_SIZE), PACKED_COLOR_SIZE );', '   float g = mod( (hex / PACKED_COLOR_SIZE), PACKED_COLOR_SIZE );', '   float b = mod( hex, PACKED_COLOR_SIZE );', '   c.r = r / PACKED_COLOR_DIVISOR;', '   c.g = g / PACKED_COLOR_DIVISOR;', '   c.b = b / PACKED_COLOR_DIVISOR;', '   return c;', '}'].join('\n'),
	
	    unpackRotationAxis: ['vec3 unpackRotationAxis( in float hex ) {', '   vec3 c = vec3( 0.0 );', '   float r = mod( (hex / PACKED_COLOR_SIZE / PACKED_COLOR_SIZE), PACKED_COLOR_SIZE );', '   float g = mod( (hex / PACKED_COLOR_SIZE), PACKED_COLOR_SIZE );', '   float b = mod( hex, PACKED_COLOR_SIZE );', '   c.r = r / PACKED_COLOR_DIVISOR;', '   c.g = g / PACKED_COLOR_DIVISOR;', '   c.b = b / PACKED_COLOR_DIVISOR;', '   c *= vec3( 2.0 );', '   c -= vec3( 1.0 );', '   return c;', '}'].join('\n'),
	
	    floatOverLifetime: ['float getFloatOverLifetime( in float positionInTime, in vec4 attr ) {', '    highp float value = 0.0;', '    float deltaAge = positionInTime * float( VALUE_OVER_LIFETIME_LENGTH - 1 );', '    float fIndex = 0.0;', '    float shouldApplyValue = 0.0;',
	
	    // This might look a little odd, but it's faster in the testing I've done than using branches.
	    // Uses basic maths to avoid branching.
	    //
	    // Take a look at the branch-avoidance functions defined above,
	    // and be sure to check out The Orange Duck site where I got this
	    // from (link above).
	
	    // Fix for static emitters (age is always zero).
	    '    value += attr[ 0 ] * when_eq( deltaAge, 0.0 );', '', '    for( int i = 0; i < VALUE_OVER_LIFETIME_LENGTH - 1; ++i ) {', '       fIndex = float( i );', '       shouldApplyValue = and( when_gt( deltaAge, fIndex ), when_le( deltaAge, fIndex + 1.0 ) );', '       value += shouldApplyValue * mix( attr[ i ], attr[ i + 1 ], deltaAge - fIndex );', '    }', '', '    return value;', '}'].join('\n'),
	
	    colorOverLifetime: ['vec3 getColorOverLifetime( in float positionInTime, in vec3 color1, in vec3 color2, in vec3 color3, in vec3 color4 ) {', '    vec3 value = vec3( 0.0 );', '    value.x = getFloatOverLifetime( positionInTime, vec4( color1.x, color2.x, color3.x, color4.x ) );', '    value.y = getFloatOverLifetime( positionInTime, vec4( color1.y, color2.y, color3.y, color4.y ) );', '    value.z = getFloatOverLifetime( positionInTime, vec4( color1.z, color2.z, color3.z, color4.z ) );', '    return value;', '}'].join('\n'),
	
	    paramFetchingFunctions: ['float getAlive() {', '   return params.x;', '}', 'float getAge() {', '   return params.y;', '}', 'float getMaxAge() {', '   return params.z;', '}', 'float getWiggle() {', '   return params.w;', '}'].join('\n'),
	
	    forceFetchingFunctions: ['vec4 getPosition( in float age ) {', '   return modelViewMatrix * vec4( position, 1.0 );', '}', 'vec3 getVelocity( in float age ) {', '   return velocity * age;', '}', 'vec3 getAcceleration( in float age ) {', '   return acceleration.xyz * age;', '}'].join('\n'),
	
	    rotationFunctions: [
	    // Huge thanks to:
	    // - http://www.neilmendoza.com/glsl-rotation-about-an-arbitrary-axis/
	    '#ifdef SHOULD_ROTATE_PARTICLES', '   mat4 getRotationMatrix( in vec3 axis, in float angle) {', '       axis = normalize(axis);', '       float s = sin(angle);', '       float c = cos(angle);', '       float oc = 1.0 - c;', '', '       return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,', '                   oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,', '                   oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,', '                   0.0,                                0.0,                                0.0,                                1.0);', '   }', '', '   vec3 getRotation( in vec3 pos, in float positionInTime ) {', '      if( rotation.y == 0.0 ) {', '           return pos;', '      }', '', '      vec3 axis = unpackRotationAxis( rotation.x );', '      vec3 center = rotationCenter;', '      vec3 translated;', '      mat4 rotationMatrix;', '      float angle = 0.0;', '      angle += when_eq( rotation.z, 0.0 ) * rotation.y;', '      angle += when_gt( rotation.z, 0.0 ) * mix( 0.0, rotation.y, positionInTime );', '      translated = rotationCenter - pos;', '      rotationMatrix = getRotationMatrix( axis, angle );', '      return center - vec3( rotationMatrix * vec4( translated, 0.0 ) );', '   }', '#endif'].join('\n'),
	
	    // Fragment chunks
	    rotateTexture: ['    vec2 vUv = vec2( gl_PointCoord.x, 1.0 - gl_PointCoord.y );', '', '    #ifdef SHOULD_ROTATE_TEXTURE', '       float x = gl_PointCoord.x - 0.5;', '       float y = 1.0 - gl_PointCoord.y - 0.5;', '       float c = cos( -vAngle );', '       float s = sin( -vAngle );', '       vUv = vec2( c * x + s * y + 0.5, c * y - s * x + 0.5 );', '    #endif', '',
	
	    // Spritesheets overwrite angle calculations.
	    '    #ifdef SHOULD_CALCULATE_SPRITE', '        float framesX = vSpriteSheet.x;', '        float framesY = vSpriteSheet.y;', '        float columnNorm = vSpriteSheet.z;', '        float rowNorm = vSpriteSheet.w;', '        vUv.x = gl_PointCoord.x * framesX + columnNorm;', '        vUv.y = 1.0 - (gl_PointCoord.y * framesY + rowNorm);', '    #endif', '', '    vec4 rotatedTexture = texture2D( texture, vUv );'].join('\n')
	};
	
	SPE.shaders = {
	    vertex: [SPE.shaderChunks.defines, SPE.shaderChunks.uniforms, SPE.shaderChunks.attributes, SPE.shaderChunks.varyings, THREE.ShaderChunk.common, THREE.ShaderChunk.logdepthbuf_pars_vertex, THREE.ShaderChunk.fog_pars_vertex, SPE.shaderChunks.branchAvoidanceFunctions, SPE.shaderChunks.unpackColor, SPE.shaderChunks.unpackRotationAxis, SPE.shaderChunks.floatOverLifetime, SPE.shaderChunks.colorOverLifetime, SPE.shaderChunks.paramFetchingFunctions, SPE.shaderChunks.forceFetchingFunctions, SPE.shaderChunks.rotationFunctions, 'void main() {',
	
	    //
	    // Setup...
	    //
	    '    highp float age = getAge();', '    highp float alive = getAlive();', '    highp float maxAge = getMaxAge();', '    highp float positionInTime = (age / maxAge);', '    highp float isAlive = when_gt( alive, 0.0 );', '    #ifdef SHOULD_WIGGLE_PARTICLES', '        float wiggleAmount = positionInTime * getWiggle();', '        float wiggleSin = isAlive * sin( wiggleAmount );', '        float wiggleCos = isAlive * cos( wiggleAmount );', '    #endif',
	
	    //
	    // Forces
	    //
	
	    // Get forces & position
	    '    vec3 vel = getVelocity( age );', '    vec3 accel = getAcceleration( age );', '    vec3 force = vec3( 0.0 );', '    vec3 pos = vec3( position );',
	
	    // Calculate the required drag to apply to the forces.
	    '    float drag = 1.0 - (positionInTime * 0.5) * acceleration.w;',
	
	    // Integrate forces...
	    '    force += vel;', '    force *= drag;', '    force += accel * age;', '    pos += force;',
	
	    // Wiggly wiggly wiggle!
	    '    #ifdef SHOULD_WIGGLE_PARTICLES', '        pos.x += wiggleSin;', '        pos.y += wiggleCos;', '        pos.z += wiggleSin;', '    #endif',
	
	    // Rotate the emitter around it's central point
	    '    #ifdef SHOULD_ROTATE_PARTICLES', '        pos = getRotation( pos, positionInTime );', '    #endif',
	
	    // Convert pos to a world-space value
	    '    vec4 mvPosition = modelViewMatrix * vec4( pos, 1.0 );',
	
	    // Determine point size.
	    '    highp float pointSize = getFloatOverLifetime( positionInTime, size ) * isAlive;',
	
	    // Determine perspective
	    '    #ifdef HAS_PERSPECTIVE', '        float perspective = scale / length( mvPosition.xyz );', '    #else', '        float perspective = 1.0;', '    #endif',
	
	    // Apply perpective to pointSize value
	    '    float pointSizePerspective = pointSize * perspective;',
	
	    //
	    // Appearance
	    //
	
	    // Determine color and opacity for this particle
	    '    #ifdef COLORIZE', '       vec3 c = isAlive * getColorOverLifetime(', '           positionInTime,', '           unpackColor( color.x ),', '           unpackColor( color.y ),', '           unpackColor( color.z ),', '           unpackColor( color.w )', '       );', '    #else', '       vec3 c = vec3(1.0);', '    #endif', '    float o = isAlive * getFloatOverLifetime( positionInTime, opacity );',
	
	    // Assign color to vColor varying.
	    '    vColor = vec4( c, o );',
	
	    // Determine angle
	    '    #ifdef SHOULD_ROTATE_TEXTURE', '        vAngle = isAlive * getFloatOverLifetime( positionInTime, angle );', '    #endif',
	
	    // If this particle is using a sprite-sheet as a texture, we'll have to figure out
	    // what frame of the texture the particle is using at it's current position in time.
	    '    #ifdef SHOULD_CALCULATE_SPRITE', '        float framesX = textureAnimation.x;', '        float framesY = textureAnimation.y;', '        float loopCount = textureAnimation.w;', '        float totalFrames = textureAnimation.z;', '        float frameNumber = mod( (positionInTime * loopCount) * totalFrames, totalFrames );', '        float column = floor(mod( frameNumber, framesX ));', '        float row = floor( (frameNumber - column) / framesX );', '        float columnNorm = column / framesX;', '        float rowNorm = row / framesY;', '        vSpriteSheet.x = 1.0 / framesX;', '        vSpriteSheet.y = 1.0 / framesY;', '        vSpriteSheet.z = columnNorm;', '        vSpriteSheet.w = rowNorm;', '    #endif',
	
	    //
	    // Write values
	    //
	
	    // Set PointSize according to size at current point in time.
	    '    gl_PointSize = pointSizePerspective;', '    gl_Position = projectionMatrix * mvPosition;', THREE.ShaderChunk.logdepthbuf_vertex, THREE.ShaderChunk.fog_vertex, '}'].join('\n'),
	
	    fragment: [SPE.shaderChunks.uniforms, THREE.ShaderChunk.common, THREE.ShaderChunk.fog_pars_fragment, THREE.ShaderChunk.logdepthbuf_pars_fragment, SPE.shaderChunks.varyings, SPE.shaderChunks.branchAvoidanceFunctions, 'void main() {', '    vec3 outgoingLight = vColor.xyz;', '    ', '    #ifdef ALPHATEST', '       if ( vColor.w < float(ALPHATEST) ) discard;', '    #endif', SPE.shaderChunks.rotateTexture, THREE.ShaderChunk.logdepthbuf_fragment, '    outgoingLight = vColor.xyz * rotatedTexture.xyz;', '    gl_FragColor = vec4( outgoingLight.xyz, rotatedTexture.w * vColor.w );', THREE.ShaderChunk.fog_fragment, '}'].join('\n')
	};
	
	/**
	 * A bunch of utility functions used throughout the library.
	 * @namespace
	 * @type {Object}
	 */
	SPE.utils = {
	    /**
	     * A map of types used by `SPE.utils.ensureTypedArg` and
	     * `SPE.utils.ensureArrayTypedArg` to compare types against.
	     *
	     * @enum {String}
	     */
	    types: {
	        /**
	         * Boolean type.
	         * @type {String}
	         */
	        BOOLEAN: 'boolean',
	
	        /**
	         * String type.
	         * @type {String}
	         */
	        STRING: 'string',
	
	        /**
	         * Number type.
	         * @type {String}
	         */
	        NUMBER: 'number',
	
	        /**
	         * Object type.
	         * @type {String}
	         */
	        OBJECT: 'object'
	    },
	
	    /**
	     * Given a value, a type, and a default value to fallback to,
	     * ensure the given argument adheres to the type requesting,
	     * returning the default value if type check is false.
	     *
	     * @param  {(boolean|string|number|object)} arg          The value to perform a type-check on.
	     * @param  {String} type         The type the `arg` argument should adhere to.
	     * @param  {(boolean|string|number|object)} defaultValue A default value to fallback on if the type check fails.
	     * @return {(boolean|string|number|object)}              The given value if type check passes, or the default value if it fails.
	     */
	    ensureTypedArg: function ensureTypedArg(arg, type, defaultValue) {
	        'use strict';
	
	        if ((typeof arg === 'undefined' ? 'undefined' : _typeof(arg)) === type) {
	            return arg;
	        } else {
	            return defaultValue;
	        }
	    },
	
	    /**
	     * Given an array of values, a type, and a default value,
	     * ensure the given array's contents ALL adhere to the provided type,
	     * returning the default value if type check fails.
	     *
	     * If the given value to check isn't an Array, delegates to SPE.utils.ensureTypedArg.
	     *
	     * @param  {Array|boolean|string|number|object} arg          The array of values to check type of.
	     * @param  {String} type         The type that should be adhered to.
	     * @param  {(boolean|string|number|object)} defaultValue A default fallback value.
	     * @return {(boolean|string|number|object)}              The given value if type check passes, or the default value if it fails.
	     */
	    ensureArrayTypedArg: function ensureArrayTypedArg(arg, type, defaultValue) {
	        'use strict';
	
	        // If the argument being checked is an array, loop through
	        // it and ensure all the values are of the correct type,
	        // falling back to the defaultValue if any aren't.
	
	        if (Array.isArray(arg)) {
	            for (var i = arg.length - 1; i >= 0; --i) {
	                if (_typeof(arg[i]) !== type) {
	                    return defaultValue;
	                }
	            }
	
	            return arg;
	        }
	
	        // If the arg isn't an array then just fallback to
	        // checking the type.
	        return this.ensureTypedArg(arg, type, defaultValue);
	    },
	
	    /**
	     * Ensures the given value is an instance of a constructor function.
	     *
	     * @param  {Object} arg          The value to check instance of.
	     * @param  {Function} instance     The constructor of the instance to check against.
	     * @param  {Object} defaultValue A default fallback value if instance check fails
	     * @return {Object}              The given value if type check passes, or the default value if it fails.
	     */
	    ensureInstanceOf: function ensureInstanceOf(arg, instance, defaultValue) {
	        'use strict';
	
	        if (instance !== undefined && arg instanceof instance) {
	            return arg;
	        } else {
	            return defaultValue;
	        }
	    },
	
	    /**
	     * Given an array of values, ensure the instances of all items in the array
	     * matches the given instance constructor falling back to a default value if
	     * the check fails.
	     *
	     * If given value isn't an Array, delegates to `SPE.utils.ensureInstanceOf`.
	     *
	     * @param  {Array|Object} arg          The value to perform the instanceof check on.
	     * @param  {Function} instance     The constructor of the instance to check against.
	     * @param  {Object} defaultValue A default fallback value if instance check fails
	     * @return {Object}              The given value if type check passes, or the default value if it fails.
	     */
	    ensureArrayInstanceOf: function ensureArrayInstanceOf(arg, instance, defaultValue) {
	        'use strict';
	
	        // If the argument being checked is an array, loop through
	        // it and ensure all the values are of the correct type,
	        // falling back to the defaultValue if any aren't.
	
	        if (Array.isArray(arg)) {
	            for (var i = arg.length - 1; i >= 0; --i) {
	                if (instance !== undefined && arg[i] instanceof instance === false) {
	                    return defaultValue;
	                }
	            }
	
	            return arg;
	        }
	
	        // If the arg isn't an array then just fallback to
	        // checking the type.
	        return this.ensureInstanceOf(arg, instance, defaultValue);
	    },
	
	    /**
	     * Ensures that any "value-over-lifetime" properties of an emitter are
	     * of the correct length (as dictated by `SPE.valueOverLifetimeLength`).
	     *
	     * Delegates to `SPE.utils.interpolateArray` for array resizing.
	     *
	     * If properties aren't arrays, then property values are put into one.
	     *
	     * @param  {Object} property  The property of an SPE.Emitter instance to check compliance of.
	     * @param  {Number} minLength The minimum length of the array to create.
	     * @param  {Number} maxLength The maximum length of the array to create.
	     */
	    ensureValueOverLifetimeCompliance: function ensureValueOverLifetimeCompliance(property, minLength, maxLength) {
	        'use strict';
	
	        minLength = minLength || 3;
	        maxLength = maxLength || 3;
	
	        // First, ensure both properties are arrays.
	        if (Array.isArray(property._value) === false) {
	            property._value = [property._value];
	        }
	
	        if (Array.isArray(property._spread) === false) {
	            property._spread = [property._spread];
	        }
	
	        var valueLength = this.clamp(property._value.length, minLength, maxLength),
	            spreadLength = this.clamp(property._spread.length, minLength, maxLength),
	            desiredLength = Math.max(valueLength, spreadLength);
	
	        if (property._value.length !== desiredLength) {
	            property._value = this.interpolateArray(property._value, desiredLength);
	        }
	
	        if (property._spread.length !== desiredLength) {
	            property._spread = this.interpolateArray(property._spread, desiredLength);
	        }
	    },
	
	    /**
	     * Performs linear interpolation (lerp) on an array.
	     *
	     * For example, lerping [1, 10], with a `newLength` of 10 will produce [1, 2, 3, 4, 5, 6, 7, 8, 9, 10].
	     *
	     * Delegates to `SPE.utils.lerpTypeAgnostic` to perform the actual
	     * interpolation.
	     *
	     * @param  {Array} srcArray  The array to lerp.
	     * @param  {Number} newLength The length the array should be interpolated to.
	     * @return {Array}           The interpolated array.
	     */
	    interpolateArray: function interpolateArray(srcArray, newLength) {
	        'use strict';
	
	        var sourceLength = srcArray.length,
	            newArray = [typeof srcArray[0].clone === 'function' ? srcArray[0].clone() : srcArray[0]],
	            factor = (sourceLength - 1) / (newLength - 1);
	
	        for (var i = 1; i < newLength - 1; ++i) {
	            var f = i * factor,
	                before = Math.floor(f),
	                after = Math.ceil(f),
	                delta = f - before;
	
	            newArray[i] = this.lerpTypeAgnostic(srcArray[before], srcArray[after], delta);
	        }
	
	        newArray.push(typeof srcArray[sourceLength - 1].clone === 'function' ? srcArray[sourceLength - 1].clone() : srcArray[sourceLength - 1]);
	
	        return newArray;
	    },
	
	    /**
	     * Clamp a number to between the given min and max values.
	     * @param  {Number} value The number to clamp.
	     * @param  {Number} min   The minimum value.
	     * @param  {Number} max   The maximum value.
	     * @return {Number}       The clamped number.
	     */
	    clamp: function clamp(value, min, max) {
	        'use strict';
	
	        return Math.max(min, Math.min(value, max));
	    },
	
	    /**
	     * If the given value is less than the epsilon value, then return
	     * a randomised epsilon value if specified, or just the epsilon value if not.
	     * Works for negative numbers as well as positive.
	     *
	     * @param  {Number} value     The value to perform the operation on.
	     * @param  {Boolean} randomise Whether the value should be randomised.
	     * @return {Number}           The result of the operation.
	     */
	    zeroToEpsilon: function zeroToEpsilon(value, randomise) {
	        'use strict';
	
	        var epsilon = 0.00001,
	            result = value;
	
	        result = randomise ? Math.random() * epsilon * 10 : epsilon;
	
	        if (value < 0 && value > -epsilon) {
	            result = -result;
	        }
	
	        // if ( value === 0 ) {
	        //     result = randomise ? Math.random() * epsilon * 10 : epsilon;
	        // }
	        // else if ( value > 0 && value < epsilon ) {
	        //     result = randomise ? Math.random() * epsilon * 10 : epsilon;
	        // }
	        // else if ( value < 0 && value > -epsilon ) {
	        //     result = -( randomise ? Math.random() * epsilon * 10 : epsilon );
	        // }
	
	        return result;
	    },
	
	    /**
	     * Linearly interpolates two values of various types. The given values
	     * must be of the same type for the interpolation to work.
	     * @param  {(number|Object)} start The start value of the lerp.
	     * @param  {(number|object)} end   The end value of the lerp.
	     * @param  {Number} delta The delta posiiton of the lerp operation. Ideally between 0 and 1 (inclusive).
	     * @return {(number|object|undefined)}       The result of the operation. Result will be undefined if
	     *                                               the start and end arguments aren't a supported type, or
	     *                                               if their types do not match.
	     */
	    lerpTypeAgnostic: function lerpTypeAgnostic(start, end, delta) {
	        'use strict';
	
	        var types = this.types,
	            out;
	
	        if ((typeof start === 'undefined' ? 'undefined' : _typeof(start)) === types.NUMBER && (typeof end === 'undefined' ? 'undefined' : _typeof(end)) === types.NUMBER) {
	            return start + (end - start) * delta;
	        } else if (start instanceof THREE.Vector2 && end instanceof THREE.Vector2) {
	            out = start.clone();
	            out.x = this.lerp(start.x, end.x, delta);
	            out.y = this.lerp(start.y, end.y, delta);
	            return out;
	        } else if (start instanceof THREE.Vector3 && end instanceof THREE.Vector3) {
	            out = start.clone();
	            out.x = this.lerp(start.x, end.x, delta);
	            out.y = this.lerp(start.y, end.y, delta);
	            out.z = this.lerp(start.z, end.z, delta);
	            return out;
	        } else if (start instanceof THREE.Vector4 && end instanceof THREE.Vector4) {
	            out = start.clone();
	            out.x = this.lerp(start.x, end.x, delta);
	            out.y = this.lerp(start.y, end.y, delta);
	            out.z = this.lerp(start.z, end.z, delta);
	            out.w = this.lerp(start.w, end.w, delta);
	            return out;
	        } else if (start instanceof THREE.Color && end instanceof THREE.Color) {
	            out = start.clone();
	            out.r = this.lerp(start.r, end.r, delta);
	            out.g = this.lerp(start.g, end.g, delta);
	            out.b = this.lerp(start.b, end.b, delta);
	            return out;
	        } else {
	            console.warn('Invalid argument types, or argument types do not match:', start, end);
	        }
	    },
	
	    /**
	     * Perform a linear interpolation operation on two numbers.
	     * @param  {Number} start The start value.
	     * @param  {Number} end   The end value.
	     * @param  {Number} delta The position to interpolate to.
	     * @return {Number}       The result of the lerp operation.
	     */
	    lerp: function lerp(start, end, delta) {
	        'use strict';
	
	        return start + (end - start) * delta;
	    },
	
	    /**
	     * Rounds a number to a nearest multiple.
	     *
	     * @param  {Number} n        The number to round.
	     * @param  {Number} multiple The multiple to round to.
	     * @return {Number}          The result of the round operation.
	     */
	    roundToNearestMultiple: function roundToNearestMultiple(n, multiple) {
	        'use strict';
	
	        var remainder = 0;
	
	        if (multiple === 0) {
	            return n;
	        }
	
	        remainder = Math.abs(n) % multiple;
	
	        if (remainder === 0) {
	            return n;
	        }
	
	        if (n < 0) {
	            return -(Math.abs(n) - remainder);
	        }
	
	        return n + multiple - remainder;
	    },
	
	    /**
	     * Check if all items in an array are equal. Uses strict equality.
	     *
	     * @param  {Array} array The array of values to check equality of.
	     * @return {Boolean}       Whether the array's values are all equal or not.
	     */
	    arrayValuesAreEqual: function arrayValuesAreEqual(array) {
	        'use strict';
	
	        for (var i = 0; i < array.length - 1; ++i) {
	            if (array[i] !== array[i + 1]) {
	                return false;
	            }
	        }
	
	        return true;
	    },
	
	    // colorsAreEqual: function() {
	    //     var colors = Array.prototype.slice.call( arguments ),
	    //         numColors = colors.length;
	
	    //     for ( var i = 0, color1, color2; i < numColors - 1; ++i ) {
	    //         color1 = colors[ i ];
	    //         color2 = colors[ i + 1 ];
	
	    //         if (
	    //             color1.r !== color2.r ||
	    //             color1.g !== color2.g ||
	    //             color1.b !== color2.b
	    //         ) {
	    //             return false
	    //         }
	    //     }
	
	    //     return true;
	    // },
	
	
	    /**
	     * Given a start value and a spread value, create and return a random
	     * number.
	     * @param  {Number} base   The start value.
	     * @param  {Number} spread The size of the random variance to apply.
	     * @return {Number}        A randomised number.
	     */
	    randomFloat: function randomFloat(base, spread) {
	        'use strict';
	
	        return base + spread * (Math.random() - 0.5);
	    },
	
	    /**
	     * Given an SPE.ShaderAttribute instance, and various other settings,
	     * assign values to the attribute's array in a `vec3` format.
	     *
	     * @param  {Object} attribute   The instance of SPE.ShaderAttribute to save the result to.
	     * @param  {Number} index       The offset in the attribute's TypedArray to save the result from.
	     * @param  {Object} base        THREE.Vector3 instance describing the start value.
	     * @param  {Object} spread      THREE.Vector3 instance describing the random variance to apply to the start value.
	     * @param  {Object} spreadClamp THREE.Vector3 instance describing the multiples to clamp the randomness to.
	     */
	    randomVector3: function randomVector3(attribute, index, base, spread, spreadClamp) {
	        'use strict';
	
	        var x = base.x + (Math.random() * spread.x - spread.x * 0.5),
	            y = base.y + (Math.random() * spread.y - spread.y * 0.5),
	            z = base.z + (Math.random() * spread.z - spread.z * 0.5);
	
	        // var x = this.randomFloat( base.x, spread.x ),
	        // y = this.randomFloat( base.y, spread.y ),
	        // z = this.randomFloat( base.z, spread.z );
	
	        if (spreadClamp) {
	            x = -spreadClamp.x * 0.5 + this.roundToNearestMultiple(x, spreadClamp.x);
	            y = -spreadClamp.y * 0.5 + this.roundToNearestMultiple(y, spreadClamp.y);
	            z = -spreadClamp.z * 0.5 + this.roundToNearestMultiple(z, spreadClamp.z);
	        }
	
	        attribute.typedArray.setVec3Components(index, x, y, z);
	    },
	
	    /**
	     * Given an SPE.Shader attribute instance, and various other settings,
	     * assign Color values to the attribute.
	     * @param  {Object} attribute The instance of SPE.ShaderAttribute to save the result to.
	     * @param  {Number} index     The offset in the attribute's TypedArray to save the result from.
	     * @param  {Object} base      THREE.Color instance describing the start color.
	     * @param  {Object} spread    THREE.Vector3 instance describing the random variance to apply to the start color.
	     */
	    randomColor: function randomColor(attribute, index, base, spread) {
	        'use strict';
	
	        var r = base.r + Math.random() * spread.x,
	            g = base.g + Math.random() * spread.y,
	            b = base.b + Math.random() * spread.z;
	
	        r = this.clamp(r, 0, 1);
	        g = this.clamp(g, 0, 1);
	        b = this.clamp(b, 0, 1);
	
	        attribute.typedArray.setVec3Components(index, r, g, b);
	    },
	
	    randomColorAsHex: function () {
	        'use strict';
	
	        var workingColor = new THREE.Color();
	
	        /**
	         * Assigns a random color value, encoded as a hex value in decimal
	         * format, to a SPE.ShaderAttribute instance.
	         * @param  {Object} attribute The instance of SPE.ShaderAttribute to save the result to.
	         * @param  {Number} index     The offset in the attribute's TypedArray to save the result from.
	         * @param  {Object} base      THREE.Color instance describing the start color.
	         * @param  {Object} spread    THREE.Vector3 instance describing the random variance to apply to the start color.
	         */
	        return function (attribute, index, base, spread) {
	            var numItems = base.length,
	                colors = [];
	
	            for (var i = 0; i < numItems; ++i) {
	                var spreadVector = spread[i];
	
	                workingColor.copy(base[i]);
	
	                workingColor.r += Math.random() * spreadVector.x - spreadVector.x * 0.5;
	                workingColor.g += Math.random() * spreadVector.y - spreadVector.y * 0.5;
	                workingColor.b += Math.random() * spreadVector.z - spreadVector.z * 0.5;
	
	                workingColor.r = this.clamp(workingColor.r, 0, 1);
	                workingColor.g = this.clamp(workingColor.g, 0, 1);
	                workingColor.b = this.clamp(workingColor.b, 0, 1);
	
	                colors.push(workingColor.getHex());
	            }
	
	            attribute.typedArray.setVec4Components(index, colors[0], colors[1], colors[2], colors[3]);
	        };
	    }(),
	
	    /**
	     * Assigns a random vector 3 value to an SPE.ShaderAttribute instance, projecting the
	     * given values onto a sphere.
	     *
	     * @param  {Object} attribute The instance of SPE.ShaderAttribute to save the result to.
	     * @param  {Number} index     The offset in the attribute's TypedArray to save the result from.
	     * @param  {Object} base              THREE.Vector3 instance describing the origin of the transform.
	     * @param  {Number} radius            The radius of the sphere to project onto.
	     * @param  {Number} radiusSpread      The amount of randomness to apply to the projection result
	     * @param  {Object} radiusScale       THREE.Vector3 instance describing the scale of each axis of the sphere.
	     * @param  {Number} radiusSpreadClamp What numeric multiple the projected value should be clamped to.
	     */
	    randomVector3OnSphere: function randomVector3OnSphere(attribute, index, base, radius, radiusSpread, radiusScale, radiusSpreadClamp, distributionClamp) {
	        'use strict';
	
	        var depth = 2 * Math.random() - 1,
	            t = 6.2832 * Math.random(),
	            r = Math.sqrt(1 - depth * depth),
	            rand = this.randomFloat(radius, radiusSpread),
	            x = 0,
	            y = 0,
	            z = 0;
	
	        if (radiusSpreadClamp) {
	            rand = Math.round(rand / radiusSpreadClamp) * radiusSpreadClamp;
	        }
	
	        // Set position on sphere
	        x = r * Math.cos(t) * rand;
	        y = r * Math.sin(t) * rand;
	        z = depth * rand;
	
	        // Apply radius scale to this position
	        x *= radiusScale.x;
	        y *= radiusScale.y;
	        z *= radiusScale.z;
	
	        // Translate to the base position.
	        x += base.x;
	        y += base.y;
	        z += base.z;
	
	        // Set the values in the typed array.
	        attribute.typedArray.setVec3Components(index, x, y, z);
	    },
	
	    seededRandom: function seededRandom(seed) {
	        var x = Math.sin(seed) * 10000;
	        return x - (x | 0);
	    },
	
	    /**
	     * Assigns a random vector 3 value to an SPE.ShaderAttribute instance, projecting the
	     * given values onto a 2d-disc.
	     *
	     * @param  {Object} attribute The instance of SPE.ShaderAttribute to save the result to.
	     * @param  {Number} index     The offset in the attribute's TypedArray to save the result from.
	     * @param  {Object} base              THREE.Vector3 instance describing the origin of the transform.
	     * @param  {Number} radius            The radius of the sphere to project onto.
	     * @param  {Number} radiusSpread      The amount of randomness to apply to the projection result
	     * @param  {Object} radiusScale       THREE.Vector3 instance describing the scale of each axis of the disc. The z-component is ignored.
	     * @param  {Number} radiusSpreadClamp What numeric multiple the projected value should be clamped to.
	     */
	    randomVector3OnDisc: function randomVector3OnDisc(attribute, index, base, radius, radiusSpread, radiusScale, radiusSpreadClamp) {
	        'use strict';
	
	        var t = 6.2832 * Math.random(),
	            rand = Math.abs(this.randomFloat(radius, radiusSpread)),
	            x = 0,
	            y = 0,
	            z = 0;
	
	        if (radiusSpreadClamp) {
	            rand = Math.round(rand / radiusSpreadClamp) * radiusSpreadClamp;
	        }
	
	        // Set position on sphere
	        x = Math.cos(t) * rand;
	        y = Math.sin(t) * rand;
	
	        // Apply radius scale to this position
	        x *= radiusScale.x;
	        y *= radiusScale.y;
	
	        // Translate to the base position.
	        x += base.x;
	        y += base.y;
	        z += base.z;
	
	        // Set the values in the typed array.
	        attribute.typedArray.setVec3Components(index, x, y, z);
	    },
	
	    randomDirectionVector3OnSphere: function () {
	        'use strict';
	
	        var v = new THREE.Vector3();
	
	        /**
	         * Given an SPE.ShaderAttribute instance, create a direction vector from the given
	         * position, using `speed` as the magnitude. Values are saved to the attribute.
	         *
	         * @param  {Object} attribute       The instance of SPE.ShaderAttribute to save the result to.
	         * @param  {Number} index           The offset in the attribute's TypedArray to save the result from.
	         * @param  {Number} posX            The particle's x coordinate.
	         * @param  {Number} posY            The particle's y coordinate.
	         * @param  {Number} posZ            The particle's z coordinate.
	         * @param  {Object} emitterPosition THREE.Vector3 instance describing the emitter's base position.
	         * @param  {Number} speed           The magnitude to apply to the vector.
	         * @param  {Number} speedSpread     The amount of randomness to apply to the magnitude.
	         */
	        return function (attribute, index, posX, posY, posZ, emitterPosition, speed, speedSpread) {
	            v.copy(emitterPosition);
	
	            v.x -= posX;
	            v.y -= posY;
	            v.z -= posZ;
	
	            v.normalize().multiplyScalar(-this.randomFloat(speed, speedSpread));
	
	            attribute.typedArray.setVec3Components(index, v.x, v.y, v.z);
	        };
	    }(),
	
	    randomDirectionVector3OnDisc: function () {
	        'use strict';
	
	        var v = new THREE.Vector3();
	
	        /**
	         * Given an SPE.ShaderAttribute instance, create a direction vector from the given
	         * position, using `speed` as the magnitude. Values are saved to the attribute.
	         *
	         * @param  {Object} attribute       The instance of SPE.ShaderAttribute to save the result to.
	         * @param  {Number} index           The offset in the attribute's TypedArray to save the result from.
	         * @param  {Number} posX            The particle's x coordinate.
	         * @param  {Number} posY            The particle's y coordinate.
	         * @param  {Number} posZ            The particle's z coordinate.
	         * @param  {Object} emitterPosition THREE.Vector3 instance describing the emitter's base position.
	         * @param  {Number} speed           The magnitude to apply to the vector.
	         * @param  {Number} speedSpread     The amount of randomness to apply to the magnitude.
	         */
	        return function (attribute, index, posX, posY, posZ, emitterPosition, speed, speedSpread) {
	            v.copy(emitterPosition);
	
	            v.x -= posX;
	            v.y -= posY;
	            v.z -= posZ;
	
	            v.normalize().multiplyScalar(-this.randomFloat(speed, speedSpread));
	
	            attribute.typedArray.setVec3Components(index, v.x, v.y, 0);
	        };
	    }(),
	
	    getPackedRotationAxis: function () {
	        'use strict';
	
	        var v = new THREE.Vector3(),
	            vSpread = new THREE.Vector3(),
	            c = new THREE.Color(),
	            addOne = new THREE.Vector3(1, 1, 1);
	
	        /**
	         * Given a rotation axis, and a rotation axis spread vector,
	         * calculate a randomised rotation axis, and pack it into
	         * a hexadecimal value represented in decimal form.
	         * @param  {Object} axis       THREE.Vector3 instance describing the rotation axis.
	         * @param  {Object} axisSpread THREE.Vector3 instance describing the amount of randomness to apply to the rotation axis.
	         * @return {Number}            The packed rotation axis, with randomness.
	         */
	        return function (axis, axisSpread) {
	            v.copy(axis).normalize();
	            vSpread.copy(axisSpread).normalize();
	
	            v.x += -axisSpread.x * 0.5 + Math.random() * axisSpread.x;
	            v.y += -axisSpread.y * 0.5 + Math.random() * axisSpread.y;
	            v.z += -axisSpread.z * 0.5 + Math.random() * axisSpread.z;
	
	            // v.x = Math.abs( v.x );
	            // v.y = Math.abs( v.y );
	            // v.z = Math.abs( v.z );
	
	            v.normalize().add(addOne).multiplyScalar(0.5);
	
	            c.setRGB(v.x, v.y, v.z);
	
	            return c.getHex();
	        };
	    }()
	};
	
	/**
	 * An SPE.Group instance.
	 * @typedef {Object} Group
	 * @see SPE.Group
	 */
	
	/**
	 * A map of options to configure an SPE.Group instance.
	 * @typedef {Object} GroupOptions
	 *
	 * @property {Object} texture An object describing the texture used by the group.
	 *
	 * @property {Object} texture.value An instance of THREE.Texture.
	 *
	 * @property {Object=} texture.frames A THREE.Vector2 instance describing the number
	 *                                    of frames on the x- and y-axis of the given texture.
	 *                                    If not provided, the texture will NOT be treated as
	 *                                    a sprite-sheet and as such will NOT be animated.
	 *
	 * @property {Number} [texture.frameCount=texture.frames.x * texture.frames.y] The total number of frames in the sprite-sheet.
	 *                                                                   Allows for sprite-sheets that don't fill the entire
	 *                                                                   texture.
	 *
	 * @property {Number} texture.loop The number of loops through the sprite-sheet that should
	 *                                 be performed over the course of a single particle's lifetime.
	 *
	 * @property {Number} fixedTimeStep If no `dt` (or `deltaTime`) value is passed to this group's
	 *                                  `tick()` function, this number will be used to move the particle
	 *                                  simulation forward. Value in SECONDS.
	 *
	 * @property {Boolean} hasPerspective Whether the distance a particle is from the camera should affect
	 *                                    the particle's size.
	 *
	 * @property {Boolean} colorize Whether the particles in this group should be rendered with color, or
	 *                              whether the only color of particles will come from the provided texture.
	 *
	 * @property {Number} blending One of Three.js's blending modes to apply to this group's `ShaderMaterial`.
	 *
	 * @property {Boolean} transparent Whether these particle's should be rendered with transparency.
	 *
	 * @property {Number} alphaTest Sets the alpha value to be used when running an alpha test on the `texture.value` property. Value between 0 and 1.
	 *
	 * @property {Boolean} depthWrite Whether rendering the group has any effect on the depth buffer.
	 *
	 * @property {Boolean} depthTest Whether to have depth test enabled when rendering this group.
	 *
	 * @property {Boolean} fog Whether this group's particles should be affected by their scene's fog.
	 *
	 * @property {Number} scale The scale factor to apply to this group's particle sizes. Useful for
	 *                          setting particle sizes to be relative to renderer size.
	 */
	
	/**
	 * The SPE.Group class. Creates a new group, containing a material, geometry, and mesh.
	 *
	 * @constructor
	 * @param {GroupOptions} options A map of options to configure the group instance.
	 */
	SPE.Group = function (options) {
	    'use strict';
	
	    var utils = SPE.utils,
	        types = utils.types;
	
	    // Ensure we have a map of options to play with
	    options = utils.ensureTypedArg(options, types.OBJECT, {});
	    options.texture = utils.ensureTypedArg(options.texture, types.OBJECT, {});
	
	    // Assign a UUID to this instance
	    this.uuid = THREE.Math.generateUUID();
	
	    // If no `deltaTime` value is passed to the `SPE.Group.tick` function,
	    // the value of this property will be used to advance the simulation.
	    this.fixedTimeStep = utils.ensureTypedArg(options.fixedTimeStep, types.NUMBER, 0.016);
	
	    // Set properties used in the uniforms map, starting with the
	    // texture stuff.
	    this.texture = utils.ensureInstanceOf(options.texture.value, THREE.Texture, null);
	    this.textureFrames = utils.ensureInstanceOf(options.texture.frames, THREE.Vector2, new THREE.Vector2(1, 1));
	    this.textureFrameCount = utils.ensureTypedArg(options.texture.frameCount, types.NUMBER, this.textureFrames.x * this.textureFrames.y);
	    this.textureLoop = utils.ensureTypedArg(options.texture.loop, types.NUMBER, 1);
	    this.textureFrames.max(new THREE.Vector2(1, 1));
	
	    this.hasPerspective = utils.ensureTypedArg(options.hasPerspective, types.BOOLEAN, true);
	    this.colorize = utils.ensureTypedArg(options.colorize, types.BOOLEAN, true);
	
	    this.maxParticleCount = utils.ensureTypedArg(options.maxParticleCount, types.NUMBER, null);
	
	    // Set properties used to define the ShaderMaterial's appearance.
	    this.blending = utils.ensureTypedArg(options.blending, types.NUMBER, THREE.AdditiveBlending);
	    this.transparent = utils.ensureTypedArg(options.transparent, types.BOOLEAN, true);
	    this.alphaTest = parseFloat(utils.ensureTypedArg(options.alphaTest, types.NUMBER, 0.0));
	    this.depthWrite = utils.ensureTypedArg(options.depthWrite, types.BOOLEAN, false);
	    this.depthTest = utils.ensureTypedArg(options.depthTest, types.BOOLEAN, true);
	    this.fog = utils.ensureTypedArg(options.fog, types.BOOLEAN, true);
	    this.scale = utils.ensureTypedArg(options.scale, types.NUMBER, 300);
	
	    // Where emitter's go to curl up in a warm blanket and live
	    // out their days.
	    this.emitters = [];
	    this.emitterIDs = [];
	
	    // Create properties for use by the emitter pooling functions.
	    this._pool = [];
	    this._poolCreationSettings = null;
	    this._createNewWhenPoolEmpty = 0;
	
	    // Whether all attributes should be forced to updated
	    // their entire buffer contents on the next tick.
	    //
	    // Used when an emitter is removed.
	    this._attributesNeedRefresh = false;
	    this._attributesNeedDynamicReset = false;
	
	    this.particleCount = 0;
	
	    // Map of uniforms to be applied to the ShaderMaterial instance.
	    this.uniforms = {
	        texture: {
	            type: 't',
	            value: this.texture
	        },
	        textureAnimation: {
	            type: 'v4',
	            value: new THREE.Vector4(this.textureFrames.x, this.textureFrames.y, this.textureFrameCount, Math.max(Math.abs(this.textureLoop), 1.0))
	        },
	        fogColor: {
	            type: 'c',
	            value: null
	        },
	        fogNear: {
	            type: 'f',
	            value: 10
	        },
	        fogFar: {
	            type: 'f',
	            value: 200
	        },
	        fogDensity: {
	            type: 'f',
	            value: 0.5
	        },
	        deltaTime: {
	            type: 'f',
	            value: 0
	        },
	        runTime: {
	            type: 'f',
	            value: 0
	        },
	        scale: {
	            type: 'f',
	            value: this.scale
	        }
	    };
	
	    // Add some defines into the mix...
	    this.defines = {
	        HAS_PERSPECTIVE: this.hasPerspective,
	        COLORIZE: this.colorize,
	        VALUE_OVER_LIFETIME_LENGTH: SPE.valueOverLifetimeLength,
	
	        SHOULD_ROTATE_TEXTURE: false,
	        SHOULD_ROTATE_PARTICLES: false,
	        SHOULD_WIGGLE_PARTICLES: false,
	
	        SHOULD_CALCULATE_SPRITE: this.textureFrames.x > 1 || this.textureFrames.y > 1
	    };
	
	    // Map of all attributes to be applied to the particles.
	    //
	    // See SPE.ShaderAttribute for a bit more info on this bit.
	    this.attributes = {
	        position: new SPE.ShaderAttribute('v3', true),
	        acceleration: new SPE.ShaderAttribute('v4', true), // w component is drag
	        velocity: new SPE.ShaderAttribute('v3', true),
	        rotation: new SPE.ShaderAttribute('v4', true),
	        rotationCenter: new SPE.ShaderAttribute('v3', true),
	        params: new SPE.ShaderAttribute('v4', true), // Holds (alive, age, delay, wiggle)
	        size: new SPE.ShaderAttribute('v4', true),
	        angle: new SPE.ShaderAttribute('v4', true),
	        color: new SPE.ShaderAttribute('v4', true),
	        opacity: new SPE.ShaderAttribute('v4', true)
	    };
	
	    this.attributeKeys = Object.keys(this.attributes);
	    this.attributeCount = this.attributeKeys.length;
	
	    // Create the ShaderMaterial instance that'll help render the
	    // particles.
	    this.material = new THREE.ShaderMaterial({
	        uniforms: this.uniforms,
	        vertexShader: SPE.shaders.vertex,
	        fragmentShader: SPE.shaders.fragment,
	        blending: this.blending,
	        transparent: this.transparent,
	        alphaTest: this.alphaTest,
	        depthWrite: this.depthWrite,
	        depthTest: this.depthTest,
	        defines: this.defines,
	        fog: this.fog
	    });
	
	    // Create the BufferGeometry and Points instances, ensuring
	    // the geometry and material are given to the latter.
	    this.geometry = new THREE.BufferGeometry();
	    this.mesh = new THREE.Points(this.geometry, this.material);
	
	    if (this.maxParticleCount === null) {
	        console.warn('SPE.Group: No maxParticleCount specified. Adding emitters after rendering will probably cause errors.');
	    }
	};
	
	SPE.Group.constructor = SPE.Group;
	
	SPE.Group.prototype._updateDefines = function () {
	    'use strict';
	
	    var emitters = this.emitters,
	        i = emitters.length - 1,
	        emitter,
	        defines = this.defines;
	
	    for (i; i >= 0; --i) {
	        emitter = emitters[i];
	
	        // Only do angle calculation if there's no spritesheet defined.
	        //
	        // Saves calculations being done and then overwritten in the shaders.
	        if (!defines.SHOULD_CALCULATE_SPRITE) {
	            defines.SHOULD_ROTATE_TEXTURE = defines.SHOULD_ROTATE_TEXTURE || !!Math.max(Math.max.apply(null, emitter.angle.value), Math.max.apply(null, emitter.angle.spread));
	        }
	
	        defines.SHOULD_ROTATE_PARTICLES = defines.SHOULD_ROTATE_PARTICLES || !!Math.max(emitter.rotation.angle, emitter.rotation.angleSpread);
	
	        defines.SHOULD_WIGGLE_PARTICLES = defines.SHOULD_WIGGLE_PARTICLES || !!Math.max(emitter.wiggle.value, emitter.wiggle.spread);
	    }
	
	    this.material.needsUpdate = true;
	};
	
	SPE.Group.prototype._applyAttributesToGeometry = function () {
	    'use strict';
	
	    var attributes = this.attributes,
	        geometry = this.geometry,
	        geometryAttributes = geometry.attributes,
	        attribute,
	        geometryAttribute;
	
	    // Loop through all the shader attributes and assign (or re-assign)
	    // typed array buffers to each one.
	    for (var attr in attributes) {
	        if (attributes.hasOwnProperty(attr)) {
	            attribute = attributes[attr];
	            geometryAttribute = geometryAttributes[attr];
	
	            // Update the array if this attribute exists on the geometry.
	            //
	            // This needs to be done because the attribute's typed array might have
	            // been resized and reinstantiated, and might now be looking at a
	            // different ArrayBuffer, so reference needs updating.
	            if (geometryAttribute) {
	                geometryAttribute.array = attribute.typedArray.array;
	            }
	
	            // // Add the attribute to the geometry if it doesn't already exist.
	            else {
	                    geometry.addAttribute(attr, attribute.bufferAttribute);
	                }
	
	            // Mark the attribute as needing an update the next time a frame is rendered.
	            attribute.bufferAttribute.needsUpdate = true;
	        }
	    }
	
	    // Mark the draw range on the geometry. This will ensure
	    // only the values in the attribute buffers that are
	    // associated with a particle will be used in THREE's
	    // render cycle.
	    this.geometry.setDrawRange(0, this.particleCount);
	};
	
	/**
	 * Adds an SPE.Emitter instance to this group, creating particle values and
	 * assigning them to this group's shader attributes.
	 *
	 * @param {Emitter} emitter The emitter to add to this group.
	 */
	SPE.Group.prototype.addEmitter = function (emitter) {
	    'use strict';
	
	    // Ensure an actual emitter instance is passed here.
	    //
	    // Decided not to throw here, just in case a scene's
	    // rendering would be paused. Logging an error instead
	    // of stopping execution if exceptions aren't caught.
	
	    if (emitter instanceof SPE.Emitter === false) {
	        console.error('`emitter` argument must be instance of SPE.Emitter. Was provided with:', emitter);
	        return;
	    }
	
	    // If the emitter already exists as a member of this group, then
	    // stop here, we don't want to add it again.
	    else if (this.emitterIDs.indexOf(emitter.uuid) > -1) {
	            console.error('Emitter already exists in this group. Will not add again.');
	            return;
	        }
	
	        // And finally, if the emitter is a member of another group,
	        // don't add it to this group.
	        else if (emitter.group !== null) {
	                console.error('Emitter already belongs to another group. Will not add to requested group.');
	                return;
	            }
	
	    var attributes = this.attributes,
	        start = this.particleCount,
	        end = start + emitter.particleCount;
	
	    // Update this group's particle count.
	    this.particleCount = end;
	
	    // Emit a warning if the emitter being added will exceed the buffer sizes specified.
	    if (this.maxParticleCount !== null && this.particleCount > this.maxParticleCount) {
	        console.warn('SPE.Group: maxParticleCount exceeded. Requesting', this.particleCount, 'particles, can support only', this.maxParticleCount);
	    }
	
	    // Set the `particlesPerSecond` value (PPS) on the emitter.
	    // It's used to determine how many particles to release
	    // on a per-frame basis.
	    emitter._calculatePPSValue(emitter.maxAge._value + emitter.maxAge._spread);
	    emitter._setBufferUpdateRanges(this.attributeKeys);
	
	    // Store the offset value in the TypedArray attributes for this emitter.
	    emitter._setAttributeOffset(start);
	
	    // Save a reference to this group on the emitter so it knows
	    // where it belongs.
	    emitter.group = this;
	
	    // Store reference to the attributes on the emitter for
	    // easier access during the emitter's tick function.
	    emitter.attributes = this.attributes;
	
	    // Ensure the attributes and their BufferAttributes exist, and their
	    // TypedArrays are of the correct size.
	    for (var attr in attributes) {
	        if (attributes.hasOwnProperty(attr)) {
	            // When creating a buffer, pass through the maxParticle count
	            // if one is specified.
	            attributes[attr]._createBufferAttribute(this.maxParticleCount !== null ? this.maxParticleCount : this.particleCount);
	        }
	    }
	
	    // Loop through each particle this emitter wants to have, and create the attributes values,
	    // storing them in the TypedArrays that each attribute holds.
	    for (var i = start; i < end; ++i) {
	        emitter._assignPositionValue(i);
	        emitter._assignForceValue(i, 'velocity');
	        emitter._assignForceValue(i, 'acceleration');
	        emitter._assignAbsLifetimeValue(i, 'opacity');
	        emitter._assignAbsLifetimeValue(i, 'size');
	        emitter._assignAngleValue(i);
	        emitter._assignRotationValue(i);
	        emitter._assignParamsValue(i);
	        emitter._assignColorValue(i);
	    }
	
	    // Update the geometry and make sure the attributes are referencing
	    // the typed arrays properly.
	    this._applyAttributesToGeometry();
	
	    // Store this emitter in this group's emitter's store.
	    this.emitters.push(emitter);
	    this.emitterIDs.push(emitter.uuid);
	
	    // Update certain flags to enable shader calculations only if they're necessary.
	    this._updateDefines(emitter);
	
	    // Update the material since defines might have changed
	    this.material.needsUpdate = true;
	    this.geometry.needsUpdate = true;
	    this._attributesNeedRefresh = true;
	
	    // Return the group to enable chaining.
	    return this;
	};
	
	/**
	 * Removes an SPE.Emitter instance from this group. When called,
	 * all particle's belonging to the given emitter will be instantly
	 * removed from the scene.
	 *
	 * @param {Emitter} emitter The emitter to add to this group.
	 */
	SPE.Group.prototype.removeEmitter = function (emitter) {
	    'use strict';
	
	    var emitterIndex = this.emitterIDs.indexOf(emitter.uuid);
	
	    // Ensure an actual emitter instance is passed here.
	    //
	    // Decided not to throw here, just in case a scene's
	    // rendering would be paused. Logging an error instead
	    // of stopping execution if exceptions aren't caught.
	    if (emitter instanceof SPE.Emitter === false) {
	        console.error('`emitter` argument must be instance of SPE.Emitter. Was provided with:', emitter);
	        return;
	    }
	
	    // Issue an error if the emitter isn't a member of this group.
	    else if (emitterIndex === -1) {
	            console.error('Emitter does not exist in this group. Will not remove.');
	            return;
	        }
	
	    // Kill all particles by marking them as dead
	    // and their age as 0.
	    var start = emitter.attributeOffset,
	        end = start + emitter.particleCount,
	        params = this.attributes.params.typedArray;
	
	    // Set alive and age to zero.
	    for (var i = start; i < end; ++i) {
	        params.array[i * 4] = 0.0;
	        params.array[i * 4 + 1] = 0.0;
	    }
	
	    // Remove the emitter from this group's "store".
	    this.emitters.splice(emitterIndex, 1);
	    this.emitterIDs.splice(emitterIndex, 1);
	
	    // Remove this emitter's attribute values from all shader attributes.
	    // The `.splice()` call here also marks each attribute's buffer
	    // as needing to update it's entire contents.
	    for (var attr in this.attributes) {
	        if (this.attributes.hasOwnProperty(attr)) {
	            this.attributes[attr].splice(start, end);
	        }
	    }
	
	    // Ensure this group's particle count is correct.
	    this.particleCount -= emitter.particleCount;
	
	    // Call the emitter's remove method.
	    emitter._onRemove();
	
	    // Set a flag to indicate that the attribute buffers should
	    // be updated in their entirety on the next frame.
	    this._attributesNeedRefresh = true;
	};
	
	/**
	 * Fetch a single emitter instance from the pool.
	 * If there are no objects in the pool, a new emitter will be
	 * created if specified.
	 *
	 * @return {Emitter|null}
	 */
	SPE.Group.prototype.getFromPool = function () {
	    'use strict';
	
	    var pool = this._pool,
	        createNew = this._createNewWhenPoolEmpty;
	
	    if (pool.length) {
	        return pool.pop();
	    } else if (createNew) {
	        var emitter = new SPE.Emitter(this._poolCreationSettings);
	
	        this.addEmitter(emitter);
	
	        return emitter;
	    }
	
	    return null;
	};
	
	/**
	 * Release an emitter into the pool.
	 *
	 * @param  {ShaderParticleEmitter} emitter
	 * @return {Group} This group instance.
	 */
	SPE.Group.prototype.releaseIntoPool = function (emitter) {
	    'use strict';
	
	    if (emitter instanceof SPE.Emitter === false) {
	        console.error('Argument is not instanceof SPE.Emitter:', emitter);
	        return;
	    }
	
	    emitter.reset();
	    this._pool.unshift(emitter);
	
	    return this;
	};
	
	/**
	 * Get the pool array
	 *
	 * @return {Array}
	 */
	SPE.Group.prototype.getPool = function () {
	    'use strict';
	
	    return this._pool;
	};
	
	/**
	 * Add a pool of emitters to this particle group
	 *
	 * @param {Number} numEmitters      The number of emitters to add to the pool.
	 * @param {EmitterOptions|Array} emitterOptions  An object, or array of objects, describing the options to pass to each emitter.
	 * @param {Boolean} createNew       Should a new emitter be created if the pool runs out?
	 * @return {Group} This group instance.
	 */
	SPE.Group.prototype.addPool = function (numEmitters, emitterOptions, createNew) {
	    'use strict';
	
	    var emitter;
	
	    // Save relevant settings and flags.
	    this._poolCreationSettings = emitterOptions;
	    this._createNewWhenPoolEmpty = !!createNew;
	
	    // Create the emitters, add them to this group and the pool.
	    for (var i = 0; i < numEmitters; ++i) {
	        if (Array.isArray(emitterOptions)) {
	            emitter = new SPE.Emitter(emitterOptions[i]);
	        } else {
	            emitter = new SPE.Emitter(emitterOptions);
	        }
	        this.addEmitter(emitter);
	        this.releaseIntoPool(emitter);
	    }
	
	    return this;
	};
	
	SPE.Group.prototype._triggerSingleEmitter = function (pos) {
	    'use strict';
	
	    var emitter = this.getFromPool(),
	        self = this;
	
	    if (emitter === null) {
	        console.log('SPE.Group pool ran out.');
	        return;
	    }
	
	    // TODO:
	    // - Make sure buffers are update with thus new position.
	    if (pos instanceof THREE.Vector3) {
	        emitter.position.value.copy(pos);
	
	        // Trigger the setter for this property to force an
	        // update to the emitter's position attribute.
	        emitter.position.value = emitter.position.value;
	    }
	
	    emitter.enable();
	
	    setTimeout(function () {
	        emitter.disable();
	        self.releaseIntoPool(emitter);
	    }, Math.max(emitter.duration, emitter.maxAge.value + emitter.maxAge.spread) * 1000);
	
	    return this;
	};
	
	/**
	 * Set a given number of emitters as alive, with an optional position
	 * vector3 to move them to.
	 *
	 * @param  {Number} numEmitters The number of emitters to activate
	 * @param  {Object} [position=undefined] A THREE.Vector3 instance describing the position to activate the emitter(s) at.
	 * @return {Group} This group instance.
	 */
	SPE.Group.prototype.triggerPoolEmitter = function (numEmitters, position) {
	    'use strict';
	
	    if (typeof numEmitters === 'number' && numEmitters > 1) {
	        for (var i = 0; i < numEmitters; ++i) {
	            this._triggerSingleEmitter(position);
	        }
	    } else {
	        this._triggerSingleEmitter(position);
	    }
	
	    return this;
	};
	
	SPE.Group.prototype._updateUniforms = function (dt) {
	    'use strict';
	
	    this.uniforms.runTime.value += dt;
	    this.uniforms.deltaTime.value = dt;
	};
	
	SPE.Group.prototype._resetBufferRanges = function () {
	    'use strict';
	
	    var keys = this.attributeKeys,
	        i = this.attributeCount - 1,
	        attrs = this.attributes;
	
	    for (i; i >= 0; --i) {
	        attrs[keys[i]].resetUpdateRange();
	    }
	};
	
	SPE.Group.prototype._updateBuffers = function (emitter) {
	    'use strict';
	
	    var keys = this.attributeKeys,
	        i = this.attributeCount - 1,
	        attrs = this.attributes,
	        emitterRanges = emitter.bufferUpdateRanges,
	        key,
	        emitterAttr,
	        attr;
	
	    for (i; i >= 0; --i) {
	        key = keys[i];
	        emitterAttr = emitterRanges[key];
	        attr = attrs[key];
	        attr.setUpdateRange(emitterAttr.min, emitterAttr.max);
	        attr.flagUpdate();
	    }
	};
	
	/**
	 * Simulate all the emitter's belonging to this group, updating
	 * attribute values along the way.
	 * @param  {Number} [dt=Group's `fixedTimeStep` value] The number of seconds to simulate the group's emitters for (deltaTime)
	 */
	SPE.Group.prototype.tick = function (dt) {
	    'use strict';
	
	    var emitters = this.emitters,
	        numEmitters = emitters.length,
	        deltaTime = dt || this.fixedTimeStep,
	        keys = this.attributeKeys,
	        i,
	        attrs = this.attributes;
	
	    // Update uniform values.
	    this._updateUniforms(deltaTime);
	
	    // Reset buffer update ranges on the shader attributes.
	    this._resetBufferRanges();
	
	    // If nothing needs updating, then stop here.
	    if (numEmitters === 0 && this._attributesNeedRefresh === false && this._attributesNeedDynamicReset === false) {
	        return;
	    }
	
	    // Loop through each emitter in this group and
	    // simulate it, then update the shader attribute
	    // buffers.
	    for (var i = 0, emitter; i < numEmitters; ++i) {
	        emitter = emitters[i];
	        emitter.tick(deltaTime);
	        this._updateBuffers(emitter);
	    }
	
	    // If the shader attributes have been refreshed,
	    // then the dynamic properties of each buffer
	    // attribute will need to be reset back to
	    // what they should be.
	    if (this._attributesNeedDynamicReset === true) {
	        i = this.attributeCount - 1;
	
	        for (i; i >= 0; --i) {
	            attrs[keys[i]].resetDynamic();
	        }
	
	        this._attributesNeedDynamicReset = false;
	    }
	
	    // If this group's shader attributes need a full refresh
	    // then mark each attribute's buffer attribute as
	    // needing so.
	    if (this._attributesNeedRefresh === true) {
	        i = this.attributeCount - 1;
	
	        for (i; i >= 0; --i) {
	            attrs[keys[i]].forceUpdateAll();
	        }
	
	        this._attributesNeedRefresh = false;
	        this._attributesNeedDynamicReset = true;
	    }
	};
	
	/**
	 * Dipose the geometry and material for the group.
	 *
	 * @return {Group} Group instance.
	 */
	SPE.Group.prototype.dispose = function () {
	    'use strict';
	
	    this.geometry.dispose();
	    this.material.dispose();
	    return this;
	};
	
	/**
	 * An SPE.Emitter instance.
	 * @typedef {Object} Emitter
	 * @see SPE.Emitter
	 */
	
	/**
	 * A map of options to configure an SPE.Emitter instance.
	 *
	 * @typedef {Object} EmitterOptions
	 *
	 * @property {distribution} [type=BOX] The default distribution this emitter should use to control
	 *                         its particle's spawn position and force behaviour.
	 *                         Must be an SPE.distributions.* value.
	 *
	 *
	 * @property {Number} [particleCount=100] The total number of particles this emitter will hold. NOTE: this is not the number
	 *                                  of particles emitted in a second, or anything like that. The number of particles
	 *                                  emitted per-second is calculated by particleCount / maxAge (approximately!)
	 *
	 * @property {Number|null} [duration=null] The duration in seconds that this emitter should live for. If not specified, the emitter
	 *                                         will emit particles indefinitely.
	 *                                         NOTE: When an emitter is older than a specified duration, the emitter is NOT removed from
	 *                                         it's group, but rather is just marked as dead, allowing it to be reanimated at a later time
	 *                                         using `SPE.Emitter.prototype.enable()`.
	 *
	 * @property {Boolean} [isStatic=false] Whether this emitter should be not be simulated (true).
	 * @property {Boolean} [activeMultiplier=1] A value between 0 and 1 describing what percentage of this emitter's particlesPerSecond should be
	 *                                          emitted, where 0 is 0%, and 1 is 100%.
	 *                                          For example, having an emitter with 100 particles, a maxAge of 2, yields a particlesPerSecond
	 *                                          value of 50. Setting `activeMultiplier` to 0.5, then, will only emit 25 particles per second (0.5 = 50%).
	 *                                          Values greater than 1 will emulate a burst of particles, causing the emitter to run out of particles
	 *                                          before it's next activation cycle.
	 *
	 * @property {Boolean} [direction=1] The direction of the emitter. If value is `1`, emitter will start at beginning of particle's lifecycle.
	 *                                   If value is `-1`, emitter will start at end of particle's lifecycle and work it's way backwards.
	 *
	 * @property {Object} [maxAge={}] An object describing the particle's maximum age in seconds.
	 * @property {Number} [maxAge.value=2] A number between 0 and 1 describing the amount of maxAge to apply to all particles.
	 * @property {Number} [maxAge.spread=0] A number describing the maxAge variance on a per-particle basis.
	 *
	 *
	 * @property {Object} [position={}] An object describing this emitter's position.
	 * @property {Object} [position.value=new THREE.Vector3()] A THREE.Vector3 instance describing this emitter's base position.
	 * @property {Object} [position.spread=new THREE.Vector3()] A THREE.Vector3 instance describing this emitter's position variance on a per-particle basis.
	 *                                                          Note that when using a SPHERE or DISC distribution, only the x-component
	 *                                                          of this vector is used.
	 * @property {Object} [position.spreadClamp=new THREE.Vector3()] A THREE.Vector3 instance describing the numeric multiples the particle's should
	 *                                                               be spread out over.
	 *                                                               Note that when using a SPHERE or DISC distribution, only the x-component
	 *                                                               of this vector is used.
	 * @property {Number} [position.radius=10] This emitter's base radius.
	 * @property {Object} [position.radiusScale=new THREE.Vector3()] A THREE.Vector3 instance describing the radius's scale in all three axes. Allows a SPHERE or DISC to be squashed or stretched.
	 * @property {distribution} [position.distribution=value of the `type` option.] A specific distribution to use when radiusing particles. Overrides the `type` option.
	 * @property {Boolean} [position.randomise=false] When a particle is re-spawned, whether it's position should be re-randomised or not. Can incur a performance hit.
	 *
	 *
	 * @property {Object} [velocity={}] An object describing this particle velocity.
	 * @property {Object} [velocity.value=new THREE.Vector3()] A THREE.Vector3 instance describing this emitter's base velocity.
	 * @property {Object} [velocity.spread=new THREE.Vector3()] A THREE.Vector3 instance describing this emitter's velocity variance on a per-particle basis.
	 *                                                          Note that when using a SPHERE or DISC distribution, only the x-component
	 *                                                          of this vector is used.
	 * @property {distribution} [velocity.distribution=value of the `type` option.] A specific distribution to use when calculating a particle's velocity. Overrides the `type` option.
	 * @property {Boolean} [velocity.randomise=false] When a particle is re-spawned, whether it's velocity should be re-randomised or not. Can incur a performance hit.
	 *
	 *
	 * @property {Object} [acceleration={}] An object describing this particle's acceleration.
	 * @property {Object} [acceleration.value=new THREE.Vector3()] A THREE.Vector3 instance describing this emitter's base acceleration.
	 * @property {Object} [acceleration.spread=new THREE.Vector3()] A THREE.Vector3 instance describing this emitter's acceleration variance on a per-particle basis.
	 *                           Note that when using a SPHERE or DISC distribution, only the x-component
	 *                           of this vector is used.
	 * @property {distribution} [acceleration.distribution=value of the `type` option.] A specific distribution to use when calculating a particle's acceleration. Overrides the `type` option.
	 * @property {Boolean} [acceleration.randomise=false] When a particle is re-spawned, whether it's acceleration should be re-randomised or not. Can incur a performance hit.
	 *
	 *
	 * @property {Object} [drag={}] An object describing this particle drag. Drag is applied to both velocity and acceleration values.
	 * @property {Number} [drag.value=0] A number between 0 and 1 describing the amount of drag to apply to all particles.
	 * @property {Number} [drag.spread=0] A number describing the drag variance on a per-particle basis.
	 * @property {Boolean} [drag.randomise=false] When a particle is re-spawned, whether it's drag should be re-randomised or not. Can incur a performance hit.
	 *
	 *
	 * @property {Object} [wiggle={}] This is quite a fun one! The values of this object will determine whether a particle will wiggle, or jiggle, or wave,
	 *                                or shimmy, or waggle, or... Well you get the idea. The wiggle is calculated over-time, meaning that a particle will
	 *                                start off with no wiggle, and end up wiggling about with the distance of the `value` specified by the time it dies.
	 *                                It's quite handy to simulate fire embers, or similar effects where the particle's position should slightly change over
	 *                                time, and such change isn't easily controlled by rotation, velocity, or acceleration. The wiggle is a combination of sin and cos calculations, so is circular in nature.
	 * @property {Number} [wiggle.value=0] A number describing the amount of wiggle to apply to all particles. It's measured in distance.
	 * @property {Number} [wiggle.spread=0] A number describing the wiggle variance on a per-particle basis.
	 *
	 *
	 * @property {Object} [rotation={}] An object describing this emitter's rotation. It can either be static, or set to rotate from 0radians to the value of `rotation.value`
	 *                                  over a particle's lifetime. Rotation values affect both a particle's position and the forces applied to it.
	 * @property {Object} [rotation.axis=new THREE.Vector3(0, 1, 0)] A THREE.Vector3 instance describing this emitter's axis of rotation.
	 * @property {Object} [rotation.axisSpread=new THREE.Vector3()] A THREE.Vector3 instance describing the amount of variance to apply to the axis of rotation on
	 *                                                              a per-particle basis.
	 * @property {Number} [rotation.angle=0] The angle of rotation, given in radians. If `rotation.static` is true, the emitter will start off rotated at this angle, and stay as such.
	 *                                       Otherwise, the particles will rotate from 0radians to this value over their lifetimes.
	 * @property {Number} [rotation.angleSpread=0] The amount of variance in each particle's rotation angle.
	 * @property {Boolean} [rotation.static=false] Whether the rotation should be static or not.
	 * @property {Object} [rotation.center=The value of `position.value`] A THREE.Vector3 instance describing the center point of rotation.
	 * @property {Boolean} [rotation.randomise=false] When a particle is re-spawned, whether it's rotation should be re-randomised or not. Can incur a performance hit.
	 *
	 *
	 * @property {Object} [color={}] An object describing a particle's color. This property is a "value-over-lifetime" property, meaning an array of values and spreads can be
	 *                               given to describe specific value changes over a particle's lifetime.
	 *                               Depending on the value of SPE.valueOverLifetimeLength, if arrays of THREE.Color instances are given, then the array will be interpolated to
	 *                               have a length matching the value of SPE.valueOverLifetimeLength.
	 * @property {Object} [color.value=new THREE.Color()] Either a single THREE.Color instance, or an array of THREE.Color instances to describe the color of a particle over it's lifetime.
	 * @property {Object} [color.spread=new THREE.Vector3()] Either a single THREE.Vector3 instance, or an array of THREE.Vector3 instances to describe the color variance of a particle over it's lifetime.
	 * @property {Boolean} [color.randomise=false] When a particle is re-spawned, whether it's color should be re-randomised or not. Can incur a performance hit.
	 *
	 *
	 * @property {Object} [opacity={}] An object describing a particle's opacity. This property is a "value-over-lifetime" property, meaning an array of values and spreads can be
	 *                               given to describe specific value changes over a particle's lifetime.
	 *                               Depending on the value of SPE.valueOverLifetimeLength, if arrays of numbers are given, then the array will be interpolated to
	 *                               have a length matching the value of SPE.valueOverLifetimeLength.
	 * @property {Number} [opacity.value=1] Either a single number, or an array of numbers to describe the opacity of a particle over it's lifetime.
	 * @property {Number} [opacity.spread=0] Either a single number, or an array of numbers to describe the opacity variance of a particle over it's lifetime.
	 * @property {Boolean} [opacity.randomise=false] When a particle is re-spawned, whether it's opacity should be re-randomised or not. Can incur a performance hit.
	 *
	 *
	 * @property {Object} [size={}] An object describing a particle's size. This property is a "value-over-lifetime" property, meaning an array of values and spreads can be
	 *                               given to describe specific value changes over a particle's lifetime.
	 *                               Depending on the value of SPE.valueOverLifetimeLength, if arrays of numbers are given, then the array will be interpolated to
	 *                               have a length matching the value of SPE.valueOverLifetimeLength.
	 * @property {Number} [size.value=1] Either a single number, or an array of numbers to describe the size of a particle over it's lifetime.
	 * @property {Number} [size.spread=0] Either a single number, or an array of numbers to describe the size variance of a particle over it's lifetime.
	 * @property {Boolean} [size.randomise=false] When a particle is re-spawned, whether it's size should be re-randomised or not. Can incur a performance hit.
	 *
	 *
	 * @property {Object} [angle={}] An object describing a particle's angle. The angle is a 2d-rotation, measured in radians, applied to the particle's texture.
	 *                               NOTE: if a particle's texture is a sprite-sheet, this value IS IGNORED.
	 *                               This property is a "value-over-lifetime" property, meaning an array of values and spreads can be
	 *                               given to describe specific value changes over a particle's lifetime.
	 *                               Depending on the value of SPE.valueOverLifetimeLength, if arrays of numbers are given, then the array will be interpolated to
	 *                               have a length matching the value of SPE.valueOverLifetimeLength.
	 * @property {Number} [angle.value=0] Either a single number, or an array of numbers to describe the angle of a particle over it's lifetime.
	 * @property {Number} [angle.spread=0] Either a single number, or an array of numbers to describe the angle variance of a particle over it's lifetime.
	 * @property {Boolean} [angle.randomise=false] When a particle is re-spawned, whether it's angle should be re-randomised or not. Can incur a performance hit.
	 *
	 */
	
	/**
	 * The SPE.Emitter class.
	 *
	 * @constructor
	 *
	 * @param {EmitterOptions} options A map of options to configure the emitter.
	 */
	SPE.Emitter = function (options) {
	    'use strict';
	
	    var utils = SPE.utils,
	        types = utils.types,
	        lifetimeLength = SPE.valueOverLifetimeLength;
	
	    // Ensure we have a map of options to play with,
	    // and that each option is in the correct format.
	    options = utils.ensureTypedArg(options, types.OBJECT, {});
	    options.position = utils.ensureTypedArg(options.position, types.OBJECT, {});
	    options.velocity = utils.ensureTypedArg(options.velocity, types.OBJECT, {});
	    options.acceleration = utils.ensureTypedArg(options.acceleration, types.OBJECT, {});
	    options.radius = utils.ensureTypedArg(options.radius, types.OBJECT, {});
	    options.drag = utils.ensureTypedArg(options.drag, types.OBJECT, {});
	    options.rotation = utils.ensureTypedArg(options.rotation, types.OBJECT, {});
	    options.color = utils.ensureTypedArg(options.color, types.OBJECT, {});
	    options.opacity = utils.ensureTypedArg(options.opacity, types.OBJECT, {});
	    options.size = utils.ensureTypedArg(options.size, types.OBJECT, {});
	    options.angle = utils.ensureTypedArg(options.angle, types.OBJECT, {});
	    options.wiggle = utils.ensureTypedArg(options.wiggle, types.OBJECT, {});
	    options.maxAge = utils.ensureTypedArg(options.maxAge, types.OBJECT, {});
	
	    if (options.onParticleSpawn) {
	        console.warn('onParticleSpawn has been removed. Please set properties directly to alter values at runtime.');
	    }
	
	    this.uuid = THREE.Math.generateUUID();
	
	    this.type = utils.ensureTypedArg(options.type, types.NUMBER, SPE.distributions.BOX);
	
	    // Start assigning properties...kicking it off with props that DON'T support values over
	    // lifetimes.
	    //
	    // Btw, values over lifetimes are just the new way of referring to *Start, *Middle, and *End.
	    this.position = {
	        _value: utils.ensureInstanceOf(options.position.value, THREE.Vector3, new THREE.Vector3()),
	        _spread: utils.ensureInstanceOf(options.position.spread, THREE.Vector3, new THREE.Vector3()),
	        _spreadClamp: utils.ensureInstanceOf(options.position.spreadClamp, THREE.Vector3, new THREE.Vector3()),
	        _distribution: utils.ensureTypedArg(options.position.distribution, types.NUMBER, this.type),
	        _randomise: utils.ensureTypedArg(options.position.randomise, types.BOOLEAN, false),
	        _radius: utils.ensureTypedArg(options.position.radius, types.NUMBER, 10),
	        _radiusScale: utils.ensureInstanceOf(options.position.radiusScale, THREE.Vector3, new THREE.Vector3(1, 1, 1)),
	        _distributionClamp: utils.ensureTypedArg(options.position.distributionClamp, types.NUMBER, 0)
	    };
	
	    this.velocity = {
	        _value: utils.ensureInstanceOf(options.velocity.value, THREE.Vector3, new THREE.Vector3()),
	        _spread: utils.ensureInstanceOf(options.velocity.spread, THREE.Vector3, new THREE.Vector3()),
	        _distribution: utils.ensureTypedArg(options.velocity.distribution, types.NUMBER, this.type),
	        _randomise: utils.ensureTypedArg(options.position.randomise, types.BOOLEAN, false)
	    };
	
	    this.acceleration = {
	        _value: utils.ensureInstanceOf(options.acceleration.value, THREE.Vector3, new THREE.Vector3()),
	        _spread: utils.ensureInstanceOf(options.acceleration.spread, THREE.Vector3, new THREE.Vector3()),
	        _distribution: utils.ensureTypedArg(options.acceleration.distribution, types.NUMBER, this.type),
	        _randomise: utils.ensureTypedArg(options.position.randomise, types.BOOLEAN, false)
	    };
	
	    this.drag = {
	        _value: utils.ensureTypedArg(options.drag.value, types.NUMBER, 0),
	        _spread: utils.ensureTypedArg(options.drag.spread, types.NUMBER, 0),
	        _randomise: utils.ensureTypedArg(options.position.randomise, types.BOOLEAN, false)
	    };
	
	    this.wiggle = {
	        _value: utils.ensureTypedArg(options.wiggle.value, types.NUMBER, 0),
	        _spread: utils.ensureTypedArg(options.wiggle.spread, types.NUMBER, 0)
	    };
	
	    this.rotation = {
	        _axis: utils.ensureInstanceOf(options.rotation.axis, THREE.Vector3, new THREE.Vector3(0.0, 1.0, 0.0)),
	        _axisSpread: utils.ensureInstanceOf(options.rotation.axisSpread, THREE.Vector3, new THREE.Vector3()),
	        _angle: utils.ensureTypedArg(options.rotation.angle, types.NUMBER, 0),
	        _angleSpread: utils.ensureTypedArg(options.rotation.angleSpread, types.NUMBER, 0),
	        _static: utils.ensureTypedArg(options.rotation.static, types.BOOLEAN, false),
	        _center: utils.ensureInstanceOf(options.rotation.center, THREE.Vector3, this.position._value.clone()),
	        _randomise: utils.ensureTypedArg(options.position.randomise, types.BOOLEAN, false)
	    };
	
	    this.maxAge = {
	        _value: utils.ensureTypedArg(options.maxAge.value, types.NUMBER, 2),
	        _spread: utils.ensureTypedArg(options.maxAge.spread, types.NUMBER, 0)
	    };
	
	    // The following properties can support either single values, or an array of values that change
	    // the property over a particle's lifetime (value over lifetime).
	    this.color = {
	        _value: utils.ensureArrayInstanceOf(options.color.value, THREE.Color, new THREE.Color()),
	        _spread: utils.ensureArrayInstanceOf(options.color.spread, THREE.Vector3, new THREE.Vector3()),
	        _randomise: utils.ensureTypedArg(options.position.randomise, types.BOOLEAN, false)
	    };
	
	    this.opacity = {
	        _value: utils.ensureArrayTypedArg(options.opacity.value, types.NUMBER, 1),
	        _spread: utils.ensureArrayTypedArg(options.opacity.spread, types.NUMBER, 0),
	        _randomise: utils.ensureTypedArg(options.position.randomise, types.BOOLEAN, false)
	    };
	
	    this.size = {
	        _value: utils.ensureArrayTypedArg(options.size.value, types.NUMBER, 1),
	        _spread: utils.ensureArrayTypedArg(options.size.spread, types.NUMBER, 0),
	        _randomise: utils.ensureTypedArg(options.position.randomise, types.BOOLEAN, false)
	    };
	
	    this.angle = {
	        _value: utils.ensureArrayTypedArg(options.angle.value, types.NUMBER, 0),
	        _spread: utils.ensureArrayTypedArg(options.angle.spread, types.NUMBER, 0),
	        _randomise: utils.ensureTypedArg(options.position.randomise, types.BOOLEAN, false)
	    };
	
	    // Assign renaining option values.
	    this.particleCount = utils.ensureTypedArg(options.particleCount, types.NUMBER, 100);
	    this.duration = utils.ensureTypedArg(options.duration, types.NUMBER, null);
	    this.isStatic = utils.ensureTypedArg(options.isStatic, types.BOOLEAN, false);
	    this.activeMultiplier = utils.ensureTypedArg(options.activeMultiplier, types.NUMBER, 1);
	    this.direction = utils.ensureTypedArg(options.direction, types.NUMBER, 1);
	
	    // Whether this emitter is alive or not.
	    this.alive = utils.ensureTypedArg(options.alive, types.BOOLEAN, true);
	
	    // The following properties are set internally and are not
	    // user-controllable.
	    this.particlesPerSecond = 0;
	
	    // The current particle index for which particles should
	    // be marked as active on the next update cycle.
	    this.activationIndex = 0;
	
	    // The offset in the typed arrays this emitter's
	    // particle's values will start at
	    this.attributeOffset = 0;
	
	    // The end of the range in the attribute buffers
	    this.attributeEnd = 0;
	
	    // Holds the time the emitter has been alive for.
	    this.age = 0.0;
	
	    // Holds the number of currently-alive particles
	    this.activeParticleCount = 0.0;
	
	    // Holds a reference to this emitter's group once
	    // it's added to one.
	    this.group = null;
	
	    // Holds a reference to this emitter's group's attributes object
	    // for easier access.
	    this.attributes = null;
	
	    // Holds a reference to the params attribute's typed array
	    // for quicker access.
	    this.paramsArray = null;
	
	    // A set of flags to determine whether particular properties
	    // should be re-randomised when a particle is reset.
	    //
	    // If a `randomise` property is given, this is preferred.
	    // Otherwise, it looks at whether a spread value has been
	    // given.
	    //
	    // It allows randomization to be turned off as desired. If
	    // all randomization is turned off, then I'd expect a performance
	    // boost as no attribute buffers (excluding the `params`)
	    // would have to be re-passed to the GPU each frame (since nothing
	    // except the `params` attribute would have changed).
	    this.resetFlags = {
	        // params: utils.ensureTypedArg( options.maxAge.randomise, types.BOOLEAN, !!options.maxAge.spread ) ||
	        //     utils.ensureTypedArg( options.wiggle.randomise, types.BOOLEAN, !!options.wiggle.spread ),
	        position: utils.ensureTypedArg(options.position.randomise, types.BOOLEAN, false) || utils.ensureTypedArg(options.radius.randomise, types.BOOLEAN, false),
	        velocity: utils.ensureTypedArg(options.velocity.randomise, types.BOOLEAN, false),
	        acceleration: utils.ensureTypedArg(options.acceleration.randomise, types.BOOLEAN, false) || utils.ensureTypedArg(options.drag.randomise, types.BOOLEAN, false),
	        rotation: utils.ensureTypedArg(options.rotation.randomise, types.BOOLEAN, false),
	        rotationCenter: utils.ensureTypedArg(options.rotation.randomise, types.BOOLEAN, false),
	        size: utils.ensureTypedArg(options.size.randomise, types.BOOLEAN, false),
	        color: utils.ensureTypedArg(options.color.randomise, types.BOOLEAN, false),
	        opacity: utils.ensureTypedArg(options.opacity.randomise, types.BOOLEAN, false),
	        angle: utils.ensureTypedArg(options.angle.randomise, types.BOOLEAN, false)
	    };
	
	    this.updateFlags = {};
	    this.updateCounts = {};
	
	    // A map to indicate which emitter parameters should update
	    // which attribute.
	    this.updateMap = {
	        maxAge: 'params',
	        position: 'position',
	        velocity: 'velocity',
	        acceleration: 'acceleration',
	        drag: 'acceleration',
	        wiggle: 'params',
	        rotation: 'rotation',
	        size: 'size',
	        color: 'color',
	        opacity: 'opacity',
	        angle: 'angle'
	    };
	
	    for (var i in this.updateMap) {
	        if (this.updateMap.hasOwnProperty(i)) {
	            this.updateCounts[this.updateMap[i]] = 0.0;
	            this.updateFlags[this.updateMap[i]] = false;
	            this._createGetterSetters(this[i], i);
	        }
	    }
	
	    this.bufferUpdateRanges = {};
	    this.attributeKeys = null;
	    this.attributeCount = 0;
	
	    // Ensure that the value-over-lifetime property objects above
	    // have value and spread properties that are of the same length.
	    //
	    // Also, for now, make sure they have a length of 3 (min/max arguments here).
	    utils.ensureValueOverLifetimeCompliance(this.color, lifetimeLength, lifetimeLength);
	    utils.ensureValueOverLifetimeCompliance(this.opacity, lifetimeLength, lifetimeLength);
	    utils.ensureValueOverLifetimeCompliance(this.size, lifetimeLength, lifetimeLength);
	    utils.ensureValueOverLifetimeCompliance(this.angle, lifetimeLength, lifetimeLength);
	};
	
	SPE.Emitter.constructor = SPE.Emitter;
	
	SPE.Emitter.prototype._createGetterSetters = function (propObj, propName) {
	    'use strict';
	
	    var self = this;
	
	    for (var i in propObj) {
	        if (propObj.hasOwnProperty(i)) {
	
	            var name = i.replace('_', '');
	
	            Object.defineProperty(propObj, name, {
	                get: function (prop) {
	                    return function () {
	                        return this[prop];
	                    };
	                }(i),
	
	                set: function (prop) {
	                    return function (value) {
	                        var mapName = self.updateMap[propName],
	                            prevValue = this[prop],
	                            length = SPE.valueOverLifetimeLength;
	
	                        if (prop === '_rotationCenter') {
	                            self.updateFlags.rotationCenter = true;
	                            self.updateCounts.rotationCenter = 0.0;
	                        } else if (prop === '_randomise') {
	                            self.resetFlags[mapName] = value;
	                        } else {
	                            self.updateFlags[mapName] = true;
	                            self.updateCounts[mapName] = 0.0;
	                        }
	
	                        self.group._updateDefines();
	
	                        this[prop] = value;
	
	                        // If the previous value was an array, then make
	                        // sure the provided value is interpolated correctly.
	                        if (Array.isArray(prevValue)) {
	                            SPE.utils.ensureValueOverLifetimeCompliance(self[propName], length, length);
	                        }
	                    };
	                }(i)
	            });
	        }
	    }
	};
	
	SPE.Emitter.prototype._setBufferUpdateRanges = function (keys) {
	    'use strict';
	
	    this.attributeKeys = keys;
	    this.attributeCount = keys.length;
	
	    for (var i = this.attributeCount - 1; i >= 0; --i) {
	        this.bufferUpdateRanges[keys[i]] = {
	            min: Number.POSITIVE_INFINITY,
	            max: Number.NEGATIVE_INFINITY
	        };
	    }
	};
	
	SPE.Emitter.prototype._calculatePPSValue = function (groupMaxAge) {
	    'use strict';
	
	    var particleCount = this.particleCount;
	
	    // Calculate the `particlesPerSecond` value for this emitter. It's used
	    // when determining which particles should die and which should live to
	    // see another day. Or be born, for that matter. The "God" property.
	    if (this.duration) {
	        this.particlesPerSecond = particleCount / (groupMaxAge < this.duration ? groupMaxAge : this.duration);
	    } else {
	        this.particlesPerSecond = particleCount / groupMaxAge;
	    }
	};
	
	SPE.Emitter.prototype._setAttributeOffset = function (startIndex) {
	    this.attributeOffset = startIndex;
	    this.activationIndex = startIndex;
	    this.activationEnd = startIndex + this.particleCount;
	};
	
	SPE.Emitter.prototype._assignValue = function (prop, index) {
	    'use strict';
	
	    switch (prop) {
	        case 'position':
	            this._assignPositionValue(index);
	            break;
	
	        case 'velocity':
	        case 'acceleration':
	            this._assignForceValue(index, prop);
	            break;
	
	        case 'size':
	        case 'opacity':
	            this._assignAbsLifetimeValue(index, prop);
	            break;
	
	        case 'angle':
	            this._assignAngleValue(index);
	            break;
	
	        case 'params':
	            this._assignParamsValue(index);
	            break;
	
	        case 'rotation':
	            this._assignRotationValue(index);
	            break;
	
	        case 'color':
	            this._assignColorValue(index);
	            break;
	    }
	};
	
	SPE.Emitter.prototype._assignPositionValue = function (index) {
	    'use strict';
	
	    var distributions = SPE.distributions,
	        utils = SPE.utils,
	        prop = this.position,
	        attr = this.attributes.position,
	        value = prop._value,
	        spread = prop._spread,
	        distribution = prop._distribution;
	
	    switch (distribution) {
	        case distributions.BOX:
	            utils.randomVector3(attr, index, value, spread, prop._spreadClamp);
	            break;
	
	        case distributions.SPHERE:
	            utils.randomVector3OnSphere(attr, index, value, prop._radius, prop._spread.x, prop._radiusScale, prop._spreadClamp.x, prop._distributionClamp || this.particleCount);
	            break;
	
	        case distributions.DISC:
	            utils.randomVector3OnDisc(attr, index, value, prop._radius, prop._spread.x, prop._radiusScale, prop._spreadClamp.x);
	            break;
	    }
	};
	
	SPE.Emitter.prototype._assignForceValue = function (index, attrName) {
	    'use strict';
	
	    var distributions = SPE.distributions,
	        utils = SPE.utils,
	        prop = this[attrName],
	        value = prop._value,
	        spread = prop._spread,
	        distribution = prop._distribution,
	        pos,
	        positionX,
	        positionY,
	        positionZ,
	        i;
	
	    switch (distribution) {
	        case distributions.BOX:
	            utils.randomVector3(this.attributes[attrName], index, value, spread);
	            break;
	
	        case distributions.SPHERE:
	            pos = this.attributes.position.typedArray.array;
	            i = index * 3;
	
	            // Ensure position values aren't zero, otherwise no force will be
	            // applied.
	            // positionX = utils.zeroToEpsilon( pos[ i ], true );
	            // positionY = utils.zeroToEpsilon( pos[ i + 1 ], true );
	            // positionZ = utils.zeroToEpsilon( pos[ i + 2 ], true );
	            positionX = pos[i];
	            positionY = pos[i + 1];
	            positionZ = pos[i + 2];
	
	            utils.randomDirectionVector3OnSphere(this.attributes[attrName], index, positionX, positionY, positionZ, this.position._value, prop._value.x, prop._spread.x);
	            break;
	
	        case distributions.DISC:
	            pos = this.attributes.position.typedArray.array;
	            i = index * 3;
	
	            // Ensure position values aren't zero, otherwise no force will be
	            // applied.
	            // positionX = utils.zeroToEpsilon( pos[ i ], true );
	            // positionY = utils.zeroToEpsilon( pos[ i + 1 ], true );
	            // positionZ = utils.zeroToEpsilon( pos[ i + 2 ], true );
	            positionX = pos[i];
	            positionY = pos[i + 1];
	            positionZ = pos[i + 2];
	
	            utils.randomDirectionVector3OnDisc(this.attributes[attrName], index, positionX, positionY, positionZ, this.position._value, prop._value.x, prop._spread.x);
	            break;
	    }
	
	    if (attrName === 'acceleration') {
	        var drag = utils.clamp(utils.randomFloat(this.drag._value, this.drag._spread), 0, 1);
	        this.attributes.acceleration.typedArray.array[index * 4 + 3] = drag;
	    }
	};
	
	SPE.Emitter.prototype._assignAbsLifetimeValue = function (index, propName) {
	    'use strict';
	
	    var array = this.attributes[propName].typedArray,
	        prop = this[propName],
	        utils = SPE.utils,
	        value;
	
	    if (utils.arrayValuesAreEqual(prop._value) && utils.arrayValuesAreEqual(prop._spread)) {
	        value = Math.abs(utils.randomFloat(prop._value[0], prop._spread[0]));
	        array.setVec4Components(index, value, value, value, value);
	    } else {
	        array.setVec4Components(index, Math.abs(utils.randomFloat(prop._value[0], prop._spread[0])), Math.abs(utils.randomFloat(prop._value[1], prop._spread[1])), Math.abs(utils.randomFloat(prop._value[2], prop._spread[2])), Math.abs(utils.randomFloat(prop._value[3], prop._spread[3])));
	    }
	};
	
	SPE.Emitter.prototype._assignAngleValue = function (index) {
	    'use strict';
	
	    var array = this.attributes.angle.typedArray,
	        prop = this.angle,
	        utils = SPE.utils,
	        value;
	
	    if (utils.arrayValuesAreEqual(prop._value) && utils.arrayValuesAreEqual(prop._spread)) {
	        value = utils.randomFloat(prop._value[0], prop._spread[0]);
	        array.setVec4Components(index, value, value, value, value);
	    } else {
	        array.setVec4Components(index, utils.randomFloat(prop._value[0], prop._spread[0]), utils.randomFloat(prop._value[1], prop._spread[1]), utils.randomFloat(prop._value[2], prop._spread[2]), utils.randomFloat(prop._value[3], prop._spread[3]));
	    }
	};
	
	SPE.Emitter.prototype._assignParamsValue = function (index) {
	    'use strict';
	
	    this.attributes.params.typedArray.setVec4Components(index, this.isStatic ? 1 : 0, 0.0, Math.abs(SPE.utils.randomFloat(this.maxAge._value, this.maxAge._spread)), SPE.utils.randomFloat(this.wiggle._value, this.wiggle._spread));
	};
	
	SPE.Emitter.prototype._assignRotationValue = function (index) {
	    'use strict';
	
	    this.attributes.rotation.typedArray.setVec3Components(index, SPE.utils.getPackedRotationAxis(this.rotation._axis, this.rotation._axisSpread), SPE.utils.randomFloat(this.rotation._angle, this.rotation._angleSpread), this.rotation._static ? 0 : 1);
	
	    this.attributes.rotationCenter.typedArray.setVec3(index, this.rotation._center);
	};
	
	SPE.Emitter.prototype._assignColorValue = function (index) {
	    'use strict';
	
	    SPE.utils.randomColorAsHex(this.attributes.color, index, this.color._value, this.color._spread);
	};
	
	SPE.Emitter.prototype._resetParticle = function (index) {
	    'use strict';
	
	    var resetFlags = this.resetFlags,
	        updateFlags = this.updateFlags,
	        updateCounts = this.updateCounts,
	        keys = this.attributeKeys,
	        key,
	        updateFlag;
	
	    for (var i = this.attributeCount - 1; i >= 0; --i) {
	        key = keys[i];
	        updateFlag = updateFlags[key];
	
	        if (resetFlags[key] === true || updateFlag === true) {
	            this._assignValue(key, index);
	            this._updateAttributeUpdateRange(key, index);
	
	            if (updateFlag === true && updateCounts[key] === this.particleCount) {
	                updateFlags[key] = false;
	                updateCounts[key] = 0.0;
	            } else if (updateFlag == true) {
	                ++updateCounts[key];
	            }
	        }
	    }
	};
	
	SPE.Emitter.prototype._updateAttributeUpdateRange = function (attr, i) {
	    'use strict';
	
	    var ranges = this.bufferUpdateRanges[attr];
	
	    ranges.min = Math.min(i, ranges.min);
	    ranges.max = Math.max(i, ranges.max);
	};
	
	SPE.Emitter.prototype._resetBufferRanges = function () {
	    'use strict';
	
	    var ranges = this.bufferUpdateRanges,
	        keys = this.bufferUpdateKeys,
	        i = this.bufferUpdateCount - 1,
	        key;
	
	    for (i; i >= 0; --i) {
	        key = keys[i];
	        ranges[key].min = Number.POSITIVE_INFINITY;
	        ranges[key].max = Number.NEGATIVE_INFINITY;
	    }
	};
	
	SPE.Emitter.prototype._onRemove = function () {
	    'use strict';
	    // Reset any properties of the emitter that were set by
	    // a group when it was added.
	
	    this.particlesPerSecond = 0;
	    this.attributeOffset = 0;
	    this.activationIndex = 0;
	    this.activeParticleCount = 0;
	    this.group = null;
	    this.attributes = null;
	    this.paramsArray = null;
	    this.age = 0.0;
	};
	
	SPE.Emitter.prototype._decrementParticleCount = function () {
	    'use strict';
	
	    --this.activeParticleCount;
	
	    // TODO:
	    //  - Trigger event if count === 0.
	};
	
	SPE.Emitter.prototype._incrementParticleCount = function () {
	    'use strict';
	
	    ++this.activeParticleCount;
	
	    // TODO:
	    //  - Trigger event if count === this.particleCount.
	};
	
	SPE.Emitter.prototype._checkParticleAges = function (start, end, params, dt) {
	    'use strict';
	
	    for (var i = end - 1, index, maxAge, age, alive; i >= start; --i) {
	        index = i * 4;
	
	        alive = params[index];
	
	        if (alive === 0.0) {
	            continue;
	        }
	
	        // Increment age
	        age = params[index + 1];
	        maxAge = params[index + 2];
	
	        if (this.direction === 1) {
	            age += dt;
	
	            if (age >= maxAge) {
	                age = 0.0;
	                alive = 0.0;
	                this._decrementParticleCount();
	            }
	        } else {
	            age -= dt;
	
	            if (age <= 0.0) {
	                age = maxAge;
	                alive = 0.0;
	                this._decrementParticleCount();
	            }
	        }
	
	        params[index] = alive;
	        params[index + 1] = age;
	
	        this._updateAttributeUpdateRange('params', i);
	    }
	};
	
	SPE.Emitter.prototype._activateParticles = function (activationStart, activationEnd, params, dtPerParticle) {
	    'use strict';
	
	    var direction = this.direction;
	
	    for (var i = activationStart, index, dtValue; i < activationEnd; ++i) {
	        index = i * 4;
	
	        // Don't re-activate particles that aren't dead yet.
	        // if ( params[ index ] !== 0.0 && ( this.particleCount !== 1 || this.activeMultiplier !== 1 ) ) {
	        //     continue;
	        // }
	
	        if (params[index] != 0.0 && this.particleCount !== 1) {
	            continue;
	        }
	
	        // Increment the active particle count.
	        this._incrementParticleCount();
	
	        // Mark the particle as alive.
	        params[index] = 1.0;
	
	        // Reset the particle
	        this._resetParticle(i);
	
	        // Move each particle being activated to
	        // it's actual position in time.
	        //
	        // This stops particles being 'clumped' together
	        // when frame rates are on the lower side of 60fps
	        // or not constant (a very real possibility!)
	        dtValue = dtPerParticle * (i - activationStart);
	        params[index + 1] = direction === -1 ? params[index + 2] - dtValue : dtValue;
	
	        this._updateAttributeUpdateRange('params', i);
	    }
	};
	
	/**
	 * Simulates one frame's worth of particles, updating particles
	 * that are already alive, and marking ones that are currently dead
	 * but should be alive as alive.
	 *
	 * If the emitter is marked as static, then this function will do nothing.
	 *
	 * @param  {Number} dt The number of seconds to simulate (deltaTime)
	 */
	SPE.Emitter.prototype.tick = function (dt) {
	    'use strict';
	
	    if (this.isStatic) {
	        return;
	    }
	
	    if (this.paramsArray === null) {
	        this.paramsArray = this.attributes.params.typedArray.array;
	    }
	
	    var start = this.attributeOffset,
	        end = start + this.particleCount,
	        params = this.paramsArray,
	        // vec3( alive, age, maxAge, wiggle )
	    ppsDt = this.particlesPerSecond * this.activeMultiplier * dt,
	        activationIndex = this.activationIndex;
	
	    // Reset the buffer update indices.
	    this._resetBufferRanges();
	
	    // Increment age for those particles that are alive,
	    // and kill off any particles whose age is over the limit.
	    this._checkParticleAges(start, end, params, dt);
	
	    // If the emitter is dead, reset the age of the emitter to zero,
	    // ready to go again if required
	    if (this.alive === false) {
	        this.age = 0.0;
	        return;
	    }
	
	    // If the emitter has a specified lifetime and we've exceeded it,
	    // mark the emitter as dead.
	    if (this.duration !== null && this.age > this.duration) {
	        this.alive = false;
	        this.age = 0.0;
	        return;
	    }
	
	    var activationStart = this.particleCount === 1 ? activationIndex : activationIndex | 0,
	        activationEnd = Math.min(activationStart + ppsDt, this.activationEnd),
	        activationCount = activationEnd - this.activationIndex | 0,
	        dtPerParticle = activationCount > 0 ? dt / activationCount : 0;
	
	    this._activateParticles(activationStart, activationEnd, params, dtPerParticle);
	
	    // Move the activation window forward, soldier.
	    this.activationIndex += ppsDt;
	
	    if (this.activationIndex > end) {
	        this.activationIndex = start;
	    }
	
	    // Increment the age of the emitter.
	    this.age += dt;
	};
	
	/**
	 * Resets all the emitter's particles to their start positions
	 * and marks the particles as dead if the `force` argument is
	 * true.
	 *
	 * @param  {Boolean} [force=undefined] If true, all particles will be marked as dead instantly.
	 * @return {Emitter}       This emitter instance.
	 */
	SPE.Emitter.prototype.reset = function (force) {
	    'use strict';
	
	    this.age = 0.0;
	    this.alive = false;
	
	    if (force === true) {
	        var start = this.attributeOffset,
	            end = start + this.particleCount,
	            array = this.paramsArray,
	            attr = this.attributes.params.bufferAttribute;
	
	        for (var i = end - 1, index; i >= start; --i) {
	            index = i * 4;
	
	            array[index] = 0.0;
	            array[index + 1] = 0.0;
	        }
	
	        attr.updateRange.offset = 0;
	        attr.updateRange.count = -1;
	        attr.needsUpdate = true;
	    }
	
	    return this;
	};
	
	/**
	 * Enables the emitter. If not already enabled, the emitter
	 * will start emitting particles.
	 *
	 * @return {Emitter} This emitter instance.
	 */
	SPE.Emitter.prototype.enable = function () {
	    'use strict';
	
	    this.alive = true;
	    return this;
	};
	
	/**
	 * Disables th emitter, but does not instantly remove it's
	 * particles fromt the scene. When called, the emitter will be
	 * 'switched off' and just stop emitting. Any particle's alive will
	 * be allowed to finish their lifecycle.
	 *
	 * @return {Emitter} This emitter instance.
	 */
	SPE.Emitter.prototype.disable = function () {
	    'use strict';
	
	    this.alive = false;
	    return this;
	};
	
	/**
	 * Remove this emitter from it's parent group (if it has been added to one).
	 * Delgates to SPE.group.prototype.removeEmitter().
	 *
	 * When called, all particle's belonging to this emitter will be instantly
	 * removed from the scene.
	 *
	 * @return {Emitter} This emitter instance.
	 *
	 * @see SPE.Group.prototype.removeEmitter
	 */
	SPE.Emitter.prototype.remove = function () {
	    'use strict';
	
	    if (this.group !== null) {
	        this.group.removeEmitter(this);
	    } else {
	        console.error('Emitter does not belong to a group, cannot remove.');
	    }
	
	    return this;
	};
	/* eslint-enable */

/***/ }),
/* 109 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _Request = __webpack_require__(57);
	
	var _Request2 = _interopRequireDefault(_Request);
	
	var _Response = __webpack_require__(58);
	
	var _Response2 = _interopRequireDefault(_Response);
	
	var _Headers = __webpack_require__(31);
	
	var _Headers2 = _interopRequireDefault(_Headers);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var _Promise = typeof Promise === 'undefined' ? __webpack_require__(20).Promise : Promise;
	
	function getHeaders(xhr) {
	  var headers = new _Headers2.default();
	  var pairs = xhr.getAllResponseHeaders().trim().split('\n');
	
	  pairs.forEach(function (header) {
	    var split = header.trim().split(':');
	    var key = split.shift().trim();
	    var value = split.join(':').trim();
	    if (key && 0 !== key.length) {
	      headers.append(key, value);
	    }
	  });
	
	  return headers;
	}
	
	var fetch = function fetch(input, init) {
	  var xhr = new XMLHttpRequest();
	
	  return new _Promise(function (resolve, reject) {
	    var request = void 0;
	
	    if (_Request2.default.prototype.isPrototypeOf(input) && !init) {
	      request = input;
	    } else {
	      request = new _Request2.default(input, init);
	    }
	
	    function responseUrl() {
	      if ('responseURL' in xhr) {
	        return xhr.responseURL;
	      }
	
	      if (/^X-Request-URL:/m.test(xhr.getAllResponseHeaders())) {
	        return xhr.getResponseHeader('X-Request-URL');
	      }
	
	      return null;
	    }
	
	    xhr.onload = function () {
	      var status = xhr.status,
	          statusText = xhr.statusText;
	
	      var options = {
	        status: status,
	        statusText: statusText,
	        headers: getHeaders(xhr),
	        url: responseUrl()
	      };
	
	      var body = 'response' in xhr ? xhr.response : xhr.responseText;
	
	      resolve(new _Response2.default(body, options));
	    };
	
	    xhr.onerror = function () {
	      reject(new TypeError('Network request failed'));
	    };
	
	    xhr.open(request.method, request.url, true);
	
	    // https://fetch.spec.whatwg.org/#cors-protocol-and-credentials
	    if (request.credientials === 'include') {
	      xhr.withCredientials = true;
	    }
	
	    request.headers.forEach(function (name, value) {
	      return xhr.setRequestHeader(name, value);
	    });
	    xhr.send(request._bodyInit ? request._bodyInit : null);
	  });
	};
	
	exports.default = fetch;
	// export default self.fetch ? self.fetch : fetch;

/***/ }),
/* 110 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _Promise = typeof Promise === 'undefined' ? __webpack_require__(20).Promise : Promise;
	
	var wait = function wait(ms) {
	  return new _Promise(function (resolve) {
	    return setTimeout(resolve, ms);
	  });
	};
	
	var timeout = function timeout(p, ms) {
	  return _Promise.race([p, wait(ms).then(function () {
	    throw new Error("Request Timeout after " + ms + " ms");
	  })]);
	};
	
	timeout.wait = wait;
	
	exports.default = timeout;

/***/ }),
/* 111 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	/* eslint-disable */
	var hash = __webpack_require__(278);
	
	module.exports = function HashSet(fEquals) {
	    if (!(this instanceof HashSet)) {
	        var hashset = new HashSet();
	        for (var i = 0; i < arguments.length; ++i) {
	            hashset.add(arguments[i]);
	        }return hashset;
	    }
	
	    var length = 0;
	    var map = Object.create(null);
	
	    // defines the length property as read-only
	    Object.defineProperty(this, 'length', {
	        get: function get() {
	            return length;
	        }
	    });
	    var that = this;
	    [].forEach.call(arguments, function (v) {
	        if (typeof v === 'function') {
	            that.fEquals = fEquals;
	        } else {
	            add(v);
	        }
	    });
	
	    // exporting public methods
	    this.contains = contains;
	    this.equals = equals;
	    this.add = add;
	    this.remove = remove;
	    this.toArray = toArray;
	    this.isSubSetOf = isSubSetOf;
	    this.isSuperSetOf = isSuperSetOf;
	    this.unionWith = unionWith;
	    this.intersectWith = intersectWith;
	
	    // helper functions
	    function contains(val) {
	        var type = toString.call(val);
	        if (map[type] === undefined) return false;
	
	        var key = hash('' + val);
	        if (map[type][key] === undefined) return false;
	
	        var arr = map[type][key];
	        for (var i = 0; i < arr.length; ++i) {
	            if (this.fEquals && this.fEquals(arr[i], val) || arr[i] === val) return true;
	        }
	
	        return false;
	    }
	
	    function add(val) {
	        var type = toString.call(val);
	        if (map[type] === undefined) {
	            map[type] = Object.create(null);
	        }
	
	        var key = hash('' + val);
	        if (map[type][key] === undefined) {
	            map[type][key] = [val];
	            length++;
	            return true;
	        } else {
	            var i = 0;
	            var pos = -1;
	            var arr = map[type][key];
	            for (; i < arr.length; ++i) {
	                if (this.fEquals && this.fEquals(arr[i], val) || arr[i] === val) return false;
	
	                if (arr[i] === undefined) pos = i;
	            }
	
	            if (pos >= 0) arr[pos] = val;else arr.push(val);
	
	            length++;
	            return true;
	        }
	    }
	
	    function remove(val) {
	        var type = toString.call(val);
	        if (map[type] === undefined) return false;
	
	        var key = hash('' + val);
	        if (map[type][key] === undefined) return false;
	
	        var arr = map[type][key];
	        for (var i = 0; i < arr.length; ++i) {
	            if (this.fEquals && this.fEquals(arr[i], val) || arr[i] === val) {
	                arr[i] = undefined;
	                length--;
	                return true;
	            }
	        }
	
	        return false;
	    }
	
	    function toArray() {
	        var subkeys;
	        var values = [];
	        var keys = Object.keys(map);
	
	        keys.forEach(function (key) {
	            subkeys = Object.keys(map[key]);
	            subkeys.forEach(function (subkey) {
	                var arr = map[key][subkey];
	                for (var i = 0; i < arr.length; ++i) {
	                    values.push(arr[i]);
	                }
	            });
	        });
	
	        return values;
	    }
	
	    function isSubSetOf(hashset) {
	        if (length < 1) return true;
	
	        if (hashset.length < 1) return false;
	
	        var values = toArray();
	        for (var i in values) {
	            if (!hashset.contains(values[i])) return false;
	        }
	
	        return true;
	    }
	
	    function isSuperSetOf(hashset) {
	        if (hashset.length === 0) return true;
	
	        if (this.length < hashset.length) return false;
	
	        var values = hashset.toArray();
	        for (var i in values) {
	            if (!contains(values[i])) return false;
	        }
	
	        return true;
	    }
	
	    function unionWith(hashset) {
	        var values = hashset.toArray();
	        values.forEach(function (v) {
	            add(v);
	        });
	    }
	
	    function equals(hashset) {
	        if (length !== hashset.length) return false;
	
	        var values = hashset.toArray();
	        for (var i in values) {
	            if (!contains(values[i])) return false;
	        }
	
	        return true;
	    }
	
	    function intersectWith(hashset) {
	        if (length === 0) return;
	
	        var values = toArray();
	        for (var i = 0; i < values.length; ++i) {
	            if (!hashset.contains(values[i])) remove(values[i]);
	        }
	    }
	};
	/* eslint-enable */

/***/ }),
/* 112 */
/***/ (function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	// Creates a new URL by combining the specified URLs
	var combineURL = function combineURL(baseUrl, path) {
	  return baseUrl.replace(/\/+$/, '') + '/' + path.replace(/^\/+/, '');
	};
	
	exports.default = combineURL;

/***/ }),
/* 113 */
/***/ (function(module, exports) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	// A URL is considered absolute if it begins with "<scheme>://" or "//" (protocol-relative URL).
	// RFC 3986 defines scheme name as a sequence of characters beginning with a letter and followed
	// by any combination of letters, digits, plus, period, or hyphen.
	// https://www.ietf.org/rfc/rfc3986.txt
	var isAbsoluteURL = function isAbsoluteURL(url) {
	  return (/^([a-z][a-z\d\+\-\.]*:)?\/\//i.test(url)
	  );
	};
	
	exports.default = isAbsoluteURL;

/***/ }),
/* 114 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _lang = __webpack_require__(4);
	
	var encode = function encode(value) {
	  return encodeURIComponent(value).replace(/%40/gi, '@').replace(/%3A/gi, ':').replace(/%24/g, '$').replace(/%2C/gi, ',').replace(/%20/g, '+').replace(/%5B/gi, '[').replace(/%5D/gi, ']');
	};
	
	// Encode a set of form elements as a string for submission.
	var serialize = function serialize(params) {
	  var ret = [];
	  Object.keys(params).forEach(function (key) {
	    var value = params[key];
	    if ((0, _lang.isPresent)(value)) {
	      ret.push(encode(key) + '=' + encode(value));
	    }
	  });
	
	  return ret.join('&');
	};
	
	exports.default = serialize;

/***/ }),
/* 115 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _request = __webpack_require__(116);
	
	var _request2 = _interopRequireDefault(_request);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	exports.default = _request2.default;

/***/ }),
/* 116 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _assign = __webpack_require__(1);
	
	var _extends = _assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
	
	var _fetch = __webpack_require__(13);
	
	var _fetch2 = _interopRequireDefault(_fetch);
	
	var _serialize = __webpack_require__(114);
	
	var _serialize2 = _interopRequireDefault(_serialize);
	
	var _combineURL = __webpack_require__(112);
	
	var _combineURL2 = _interopRequireDefault(_combineURL);
	
	var _isAbsoluteURL = __webpack_require__(113);
	
	var _isAbsoluteURL2 = _interopRequireDefault(_isAbsoluteURL);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }
	
	var _Promise = typeof Promise === 'undefined' ? __webpack_require__(20).Promise : Promise;
	
	var wait = function wait(ms) {
	  return new _Promise(function (resolve) {
	    return setTimeout(resolve, ms);
	  });
	};
	
	var timeout = function timeout(p, ms) {
	  return _Promise.race([p, wait(ms).then(function () {
	    var error = new Error('网络连接超时');
	    error.statusCode = 408;
	    throw error;
	  })]);
	};
	
	// Request factory
	function request(url, options, method) {
	  var _interceptRequest = interceptRequest(url, options, method),
	      endpoint = _interceptRequest.endpoint,
	      rest = _objectWithoutProperties(_interceptRequest, ['endpoint']);
	
	  var xhr = (0, _fetch2.default)(endpoint, rest).then(interceptResponse);
	  return timeout(xhr, request.defaults.timeout).catch(function (error) {
	    return _Promise.reject(error);
	  });
	}
	
	request.defaults = {
	  baseURL: 'https://api.ipalmap.com',
	  timeout: 10 * 1000,
	  headers: {
	    Accept: 'application/json'
	  },
	  params: {}
	};
	
	// Headers factory
	var createHeaders = function createHeaders() {
	  var headers = _extends({}, request.defaults.headers);
	  if (request.defaults.jwt) {
	    headers['Authorization'] = 'Bearer ' + request.defaults.jwt;
	  }
	  return headers;
	};
	
	// Request interceptor
	function interceptRequest(url) {
	  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
	  var method = arguments[2];
	
	  var endpoint = void 0;
	  if ((0, _isAbsoluteURL2.default)(url)) {
	    endpoint = url;
	  } else {
	    endpoint = (0, _combineURL2.default)(request.defaults.baseURL, url);
	  }
	
	  var data = {
	    method: method,
	    endpoint: endpoint,
	    headers: createHeaders()
	  };
	
	  data = _extends({}, data, options);
	
	  if (options.json) {
	    data.headers['Content-Type'] = 'application/json;charset=utf-8';
	    data.body = JSON.stringify(options.json);
	  }
	
	  if (options.form) {
	    data.headers['Content-Type'] = 'application/x-www-form-urlencoded;charset=utf-8';
	    data.body = (0, _serialize2.default)(options.form);
	  }
	
	  if (options.body) {
	    data.body = options.body;
	  }
	
	  if (options.params) {
	    endpoint += '?' + (0, _serialize2.default)(_extends({}, options.params, request.defaults.params));
	    data.endpoint = endpoint;
	  }
	
	  return data;
	}
	
	// Response interceptor
	/* eslint-disable consistent-return */
	function interceptResponse(response) {
	  return new _Promise(function (resolve, reject) {
	    var emptyCodes = [204, 205];
	
	    // Don't attempt to parse 204 & 205
	    if (emptyCodes.indexOf(response.status) !== -1) {
	      return resolve(response.ok);
	    }
	
	    if (response.ok) {
	      var contentType = response.headers.get('Content-Type');
	      if (contentType.indexOf('application/json') !== -1) {
	        resolve(response.json());
	      }
	
	      resolve(response);
	    }
	
	    var error = new Error(response.statusText);
	    try {
	      response.clone().json().then(function (result) {
	        error.body = result;
	        error.response = response;
	        reject(error);
	      });
	    } catch (e) {
	      error.response = response;
	      reject(error);
	    }
	  });
	}
	/* eslint-enable consistent-return */
	
	// suger
	request.get = function (url, options) {
	  return request(url, options, 'GET');
	};
	
	request.head = function (url, options) {
	  return request(url, options, 'HEAD');
	};
	
	request.options = function (url, options) {
	  return request(url, options, 'OPTIONS');
	};
	
	request.post = function (url, options) {
	  return request(url, options, 'POST');
	};
	
	request.put = function (url, options) {
	  return request(url, options, 'PUT');
	};
	
	request['delete'] = function (url, options) {
	  return request(url, options, 'DELETE');
	};
	
	request.del = request['delete'];
	
	exports.default = request;

/***/ }),
/* 117 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;/* WEBPACK VAR INJECTION */(function(module) {'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	/* eslint-disable */
	(function () {
	    function HashMap(other) {
	        this.clear();
	        switch (arguments.length) {
	            case 0:
	                break;
	            case 1:
	                this.copy(other);break;
	            default:
	                _multi(this, arguments);break;
	        }
	    };
	
	    var proto = HashMap.prototype = {
	        constructor: HashMap,
	
	        get: function get(key) {
	            var data = this._data[this.hash(key)];
	            return data && data[1];
	        },
	
	        put: function put(key, value) {
	            var hash = this.hash(key);
	            if (!(hash in this._data)) {
	                this._count++;
	            }
	            this._data[hash] = [key, value];
	        },
	
	        multi: function multi() {
	            _multi(this, arguments);
	        },
	
	        copy: function copy(other) {
	            for (var hash in other._data) {
	                if (!(hash in this._data)) {
	                    this._count++;
	                }
	                this._data[hash] = other._data[hash];
	            }
	        },
	
	        containsKey: function containsKey(key) {
	            var hash = this.hash(key);
	            var contains = hash in this._data;
	            return contains;
	        },
	
	        search: function search(value) {
	            for (var key in this._data) {
	                if (this._data[key][1] === value) {
	                    return this._data[key][0];
	                }
	            }
	            return null;
	        },
	
	        remove: function remove(key) {
	            var hash = this.hash(key);
	            if (hash in this._data) {
	                this._count--;
	                delete this._data[hash];
	            }
	        },
	
	        isEmpty: function isEmpty() {
	            return this._count == 0;
	        },
	
	        keyArray: function keyArray() {
	            var keys = [];
	            this.forEach(function (_, key) {
	                keys.push(key);
	            });
	            return keys;
	        },
	
	        values: function values() {
	            var values = [];
	            this.forEach(function (value) {
	                values.push(value);
	            });
	            return values;
	        },
	
	        size: function size() {
	            return this._count;
	        },
	
	        clear: function clear() {
	            this._data = {};
	            this._count = 0;
	        },
	
	        clone: function clone() {
	            return new HashMap(this);
	        },
	
	        hash: function hash(key) {
	            switch (hash_type(key)) {
	                case 'undefined':
	                case 'null':
	                case 'boolean':
	                case 'number':
	                case 'regexp':
	                    return key + '';
	                case 'date':
	                    return '♣' + key.getTime();
	                case 'string':
	                    return '♠' + key;
	                case 'array':
	                    var hashes = [];
	                    for (var i = 0; i < key.length; i++) {
	                        hashes[i] = this.hash(key[i]);
	                    }
	                    return '♥' + hashes.join('⁞');
	                default:
	                    if (!key.hasOwnProperty('_hmuid_')) {
	                        key._hmuid_ = ++HashMap.uid;
	                        hide(key, '_hmuid_');
	                    }
	                    return '♦' + key._hmuid_;
	            }
	        },
	
	        forEach: function forEach(func, ctx) {
	            for (var key in this._data) {
	                var data = this._data[key];
	                func.call(ctx || this, data[1], data[0]);
	            }
	        }
	    };
	
	    HashMap.uid = 0;
	
	    for (var method in proto) {
	        if (method === 'constructor' || !proto.hasOwnProperty(method)) {
	            continue;
	        }
	        var fn = proto[method];
	        if (fn.toString().indexOf('return ') === -1) {
	            proto[method] = chain(fn);
	        }
	    }
	
	    function hash_type(key) {
	        var str = Object.prototype.toString.call(key);
	        var type = str.slice(8, -1).toLowerCase();
	        if (type === 'domwindow' && !key) {
	            return key + '';
	        }
	        return type;
	    }
	
	    function _multi(map, args) {
	        for (var i = 0; i < args.length; i += 2) {
	            map.set(args[i], args[i + 1]);
	        }
	    }
	
	    function chain(fn) {
	        return function () {
	            fn.apply(this, arguments);
	            return this;
	        };
	    }
	
	    function hide(obj, prop) {
	        if (Object.defineProperty) {
	            Object.defineProperty(obj, prop, { enumerable: false });
	        }
	    }
	
	    function Point(x, y) {
	        this.x = x;
	        this.y = y;
	    }
	
	    Point.prototype.setPoint = function (x, y) {
	        this.x = x;
	        this.y = y;
	    };
	
	    function Points(firstPoint, secondPoint) {
	        this.firstPoint = firstPoint;
	        this.secondPoint = secondPoint;
	    }
	
	    Points.prototype.setPoints = function (firstPoint, secondPoint) {
	        this.firstPoint = firstPoint;
	        this.secondPoint = secondPoint;
	    };
	
	    Points.prototype.getRelation = function () {
	        var pointsRelationX = this.firstPoint.x == this.secondPoint.x ? 10 : 20;
	        var pointsRelationY = this.firstPoint.y == this.secondPoint.y ? 1 : 2;
	        var pointsRelation = pointsRelationX + pointsRelationY;
	        var pointsRelationValue = 0;
	        switch (pointsRelation) {
	            case 11:
	                pointsRelationValue = 1; //pointsEqual
	                break;
	            case 12:
	                pointsRelationValue = 2; //XEqual
	                break;
	            case 21:
	                pointsRelationValue = 3; //YEqual
	                break;
	            case 22:
	                pointsRelationValue = 4; //pointsNoEqual
	                break;
	            default:
	                break;
	        }
	        return pointsRelationValue;
	    };
	
	    Points.prototype.getDistance = function () {
	        return Math.sqrt((this.firstPoint.x - this.secondPoint.x) * (this.firstPoint.x - this.secondPoint.x) + (this.firstPoint.y - this.secondPoint.y) * (this.firstPoint.y - this.secondPoint.y));
	    };
	
	    function Line(scope, intercept) {
	        this.scope = scope;
	        this.intercept = intercept;
	    }
	
	    Line.prototype.setLine = function (scope, intercept) {
	        this.scope = scope;
	        this.intercept = intercept;
	    };
	
	    Line.prototype.lineGenerateByTwoPoints = function (firstPoint, secondPoint) {
	        this.scope = (firstPoint.y - secondPoint.y) / (firstPoint.x - secondPoint.x);
	        this.intercept = firstPoint.y - this.scope * firstPoint.x;
	    };
	
	    Line.prototype.lineGenerateByPointScope = function (point, scope) {
	        this.scope = scope;
	        this.intercept = point.y - scope * point.x;
	    };
	
	    function Lines(firstLine, secondLine) {
	        this.firstLine = firstLine;
	        this.secondLine = secondLine;
	    }
	
	    Lines.prototype.setLines = function (firstLine, secondLine) {
	        this.firstLine = firstLine;
	        this.secondLine = secondLine;
	    };
	
	    Lines.prototype.getRelation = function () {
	        var linesRelationScope = this.firstLine.scope == this.secondLine.scope ? 10 : 20;
	        var linesRelationIntercept = this.firstLine.intercept == this.secondLine.intercept ? 1 : 2;
	        var linesRelation = linesRelationScope + linesRelationIntercept;
	        var linesRelationValue = 0;
	        switch (linesRelation) {
	            case 11:
	                linesRelationValue = 1; //linesEqual
	                break;
	            case 12:
	                linesRelationValue = 2; //scopesEqual
	                break;
	            case 21:
	                linesRelationValue = 3; //interceptEqual
	                break;
	            case 22:
	                linesRelationValue = 4; //linesNoEqual
	                break;
	            default:
	                break;
	        }
	        return linesRelationValue;
	    };
	
	    Lines.prototype.insect = function () {
	        var linesRelation = this.getRelation();
	        var linesCrossPoint = Object.create(Point.prototype);
	        switch (linesRelation) {
	            case 3:
	                linesCrossPoint.setPoint(0, this.firstLine.intercept);
	                break;
	            case 4:
	                var crossPointX = (this.secondLine.intercept - this.firstLine.intercept) / (this.firstLine.scope - this.secondLine.scope);
	                var crossPointY = this.firstLine.scope * crossPointX + this.firstLine.intercept;
	                linesCrossPoint.setPoint(crossPointX, crossPointY);
	                break;
	            default:
	                console.log("no crossPoint between lines");
	                break;
	        }
	        return linesCrossPoint;
	    };
	
	    function Circle(center, radius) {
	        this.center = center;
	        this.radius = radius;
	    }
	
	    Circle.prototype.setCircle = function (center, radius) {
	        this.center = center;
	        this.radius = radius;
	    };
	
	    function Circles(firstCircle, secondCircle) {
	        this.firstCircle = firstCircle;
	        this.secondCircle = secondCircle;
	    }
	
	    Circles.prototype.setCircles = function (firstCircle, secondCircle) {
	        this.firstCircle = firstCircle;
	        this.secondCircle = secondCircle;
	    };
	
	    Circles.prototype.getRelation = function () {
	        var circlesRelationCenter = this.firstCircle.center == this.secondCircle.center ? 1 : 2;
	        var circlesRelationRadius = this.firstCircle.radius == this.secondCircle.radius ? 10 : 20;
	        var circlesRelation = circlesRelationCenter + circlesRelationRadius;
	        var circlesRelationValue = 0;
	        switch (circlesRelation) {
	            case 11:
	                circlesRelationValue = 1; //CirclesEqual
	                break;
	            case 12:
	                circlesRelationValue = 2; //CenterEqual
	                break;
	            case 21:
	                circlesRelationValue = 3; //RadiusEqual
	                break;
	            case 22:
	                circlesRelationValue = 4; //NoEqual
	                break;
	            default:
	                break;
	        }
	        return circlesRelationValue;
	    };
	
	    Circles.prototype.insect = function () {
	        var cirInsectNodes = Object.create(Array.prototype);
	        for (var i = 0; i < 2; i++) {
	            cirInsectNodes[i] = Object.create(Point.prototype);
	        }
	        var circleCenters = Object.create(Points.prototype);
	        circleCenters.setPoints(this.firstCircle.center, this.secondCircle.center);
	        var centersRelation = circleCenters.getRelation();
	
	        cirInsectNodes = this.locationOption(centersRelation);
	        return cirInsectNodes;
	    };
	
	    Circles.prototype.locationOption = function (centersRelation) {
	        switch (centersRelation) {
	            case 1:
	                return this.CenterXYEqual();
	                break;
	            case 2:
	                return this.CenterXEqual();
	                break;
	            case 3:
	                return this.CenterYEqual();
	                break;
	            case 4:
	                return this.CenterNoEqual();
	                break;
	            default:
	                return 1;
	                break;
	        }
	    };
	
	    Circles.prototype.CenterXYEqual = function () {
	        console.warn("the centers of the circle are the same!");
	        var cirInsectNodes = Object.create(Array.prototype);
	        for (var i = 0; i < 2; i++) {
	            cirInsectNodes[i] = Object.create(Point.prototype);
	        }
	        cirInsectNodes[0] = pointError;
	        cirInsectNodes[1] = pointError;
	        return cirInsectNodes;
	    };
	
	    Circles.prototype.CenterXEqual = function () {
	        var cirInsectNodes = Object.create(Array.prototype);
	        for (var i = 0; i < 2; i++) {
	            cirInsectNodes[i] = Object.create(Point.prototype);
	        }
	        var cosValue = 0;
	        var circleCenterDis = Math.abs(this.firstCircle.center.y - this.secondCircle.center.y);
	        if (this.firstCircle.center.y < this.secondCircle.center.y) {
	            cosValue = (Math.pow(circleCenterDis, 2) + Math.pow(this.firstCircle.radius, 2) - Math.pow(this.secondCircle.radius, 2)) / (2 * this.firstCircle.radius * circleCenterDis);
	            cirInsectNodes[0].y = this.firstCircle.center.y + this.firstCircle.radius * cosValue;
	            cirInsectNodes[1].y = cirInsectNodes[0].y;
	            cirInsectNodes[0].x = this.firstCircle.center.x + this.firstCircle.radius * Math.sqrt(1 - Math.pow(cosValue, 2));
	            cirInsectNodes[1].x = this.firstCircle.center.x - this.firstCircle.radius * Math.sqrt(1 - Math.pow(cosValue, 2));
	        } else {
	            cosValue = (Math.pow(circleCenterDis, 2) + Math.pow(this.secondCircle.radius, 2) - Math.pow(this.firstCircle.radius, 2)) / (2 * this.secondCircle.radius * circleCenterDis);
	            cirInsectNodes[0].y = this.secondCircle.center.y + this.secondCircle.radius * cosValue;
	            cirInsectNodes[1].y = cirInsectNodes[0].y;
	            cirInsectNodes[0].x = this.secondCircle.center.x + this.secondCircle.radius * Math.sqrt(1 - Math.pow(cosValue, 2));
	            cirInsectNodes[1].x = this.secondCircle.center.x - this.secondCircle.radius * Math.sqrt(1 - Math.pow(cosValue, 2));
	        }
	        return cirInsectNodes;
	    };
	
	    Circles.prototype.CenterYEqual = function () {
	        var cirInsectNodes = Object.create(Array.prototype);
	        for (var i = 0; i < 3; i++) {
	            cirInsectNodes[i] = Object.create(Point.prototype);
	        }
	        var cosValue = 0;
	        var circleCenterDis = Math.abs(this.firstCircle.center.x - this.secondCircle.center.x);
	        if (this.firstCircle.center.x < this.secondCircle.center.x) {
	            cosValue = (Math.pow(circleCenterDis, 2) + Math.pow(this.firstCircle.radius, 2) - Math.pow(this.secondCircle.radius, 2)) / (2 * this.firstCircle.radius * circleCenterDis);
	            cirInsectNodes[0].x = this.firstCircle.center.x + this.firstCircle.radius * cosValue;
	            cirInsectNodes[1].x = cirInsectNodes[0].x;
	            cirInsectNodes[0].y = this.firstCircle.center.y + this.firstCircle.radius * Math.sqrt(1 - Math.pow(cosValue, 2));
	            cirInsectNodes[1].y = this.firstCircle.center.y - this.firstCircle.radius * Math.sqrt(1 - Math.pow(cosValue, 2));
	        } else {
	            cosValue = (Math.pow(circleCenterDis, 2) + Math.pow(this.secondCircle.radius, 2) - Math.pow(this.firstCircle.radius, 2)) / (2 * this.secondCircle.radius * circleCenterDis);
	            cirInsectNodes[0].x = this.secondCircle.center.x + this.secondCircle.radius * cosValue;
	            cirInsectNodes[1].x = cirInsectNodes[0].x;
	            cirInsectNodes[0].y = this.secondCircle.center.y + this.secondCircle.radius * Math.sqrt(1 - Math.pow(cosValue, 2));
	            cirInsectNodes[1].y = this.secondCircle.center.y - this.secondCircle.radius * Math.sqrt(1 - Math.pow(cosValue, 2));
	        }
	        return cirInsectNodes;
	    };
	
	    Circles.prototype.CenterNoEqual = function () {
	        var cirInsectNodes = Object.create(Array.prototype);
	        for (var i = 0; i < 2; i++) {
	            cirInsectNodes[i] = Object.create(Point.prototype);
	        }
	        var a, b, c, p, q, r;
	        var cosValue = Object.create(Array.prototype);
	        var sinValue = Object.create(Array.prototype);
	        var pointsArray = Object.create(Array.prototype);
	        var bleToolObj = Object.create(BleTools.prototype);
	        for (i = 0; i < 3; i++) {
	            pointsArray[i] = Object.create(Points.prototype);
	        }
	        pointsArray[0].setPoints(this.firstCircle.center, this.secondCircle.center);
	
	        a = 2.0 * this.firstCircle.radius * (this.firstCircle.center.x - this.secondCircle.center.x);
	        b = 2.0 * this.firstCircle.radius * (this.firstCircle.center.y - this.secondCircle.center.y);
	        c = this.secondCircle.radius * this.secondCircle.radius - this.firstCircle.radius * this.firstCircle.radius - pointsArray[0].getDistance() * pointsArray[0].getDistance();
	        p = a * a + b * b;
	        q = -2.0 * a * c;
	        r = c * c - b * b;
	
	        cosValue[0] = (Math.sqrt(q * q - 4.0 * p * r) - q) / (p * 2.0);
	        cosValue[1] = (-Math.sqrt(q * q - 4.0 * p * r) - q) / (p * 2.0);
	        sinValue[0] = Math.sqrt(1 - cosValue[0] * cosValue[0]);
	        sinValue[1] = Math.sqrt(1 - cosValue[1] * cosValue[1]);
	
	        cirInsectNodes[0].x = this.firstCircle.radius * cosValue[0] + this.firstCircle.center.x;
	        cirInsectNodes[1].x = this.firstCircle.radius * cosValue[1] + this.firstCircle.center.x;
	        cirInsectNodes[0].y = this.firstCircle.radius * sinValue[0] + this.firstCircle.center.y;
	        cirInsectNodes[1].y = this.firstCircle.radius * sinValue[1] + this.firstCircle.center.y;
	        pointsArray[1].setPoints(cirInsectNodes[0], this.secondCircle.center);
	        pointsArray[2].setPoints(cirInsectNodes[1], this.secondCircle.center);
	        if (!bleToolObj.varEquals(pointsArray[1].getDistance(), this.secondCircle.radius)) {
	            cirInsectNodes[0].y = this.firstCircle.center.y - this.firstCircle.radius * sinValue[0];
	        }
	
	        if (!bleToolObj.varEquals(pointsArray[2].getDistance(), this.secondCircle.radius)) {
	            cirInsectNodes[1].y = this.firstCircle.center.y - this.firstCircle.radius * sinValue[1];
	        }
	
	        if (bleToolObj.varEquals(cirInsectNodes[0].y, cirInsectNodes[1].y) && bleToolObj.varEquals(cirInsectNodes[0].x, cirInsectNodes[1].x)) {
	            if (cirInsectNodes[0].y > 0) {
	                cirInsectNodes[1].y = -cirInsectNodes[1].y;
	            } else {
	                cirInsectNodes[0].y = -cirInsectNodes[0].y;
	            }
	        }
	        return cirInsectNodes;
	    };
	
	    function BeaconCfgClass(beaconId, mapId, sceneId, floorId, uuid, major, minor, x, y, atten, lossCoe) {
	        this.beaconId = beaconId;
	        this.mapId = mapId;
	        this.sceneId = sceneId;
	        this.floorId = floorId;
	        this.uuid = uuid;
	        this.major = major;
	        this.minor = minor;
	        this.x = x;
	        this.y = y;
	        this.atten = atten;
	        this.lossCoe = lossCoe;
	    }
	
	    function BeaconClass(uuid, major, minor, distance) {
	        this.uuid = uuid;
	        this.major = major;
	        this.minor = minor;
	        this.distance = distance;
	    }
	
	    function BleTools() {}
	
	    BleTools.prototype.varEquals = function (firstFigure, secondFigure) {
	        var zero = 0.001;
	        if (firstFigure.constructor == Number && secondFigure.constructor == Number) {
	            return Math.abs(firstFigure - secondFigure) < zero;
	        } else {
	            console.log("type error!");
	            return -1;
	        }
	    };
	
	    BleTools.prototype.sortRule = function (firstFigure, secondFigure) {
	        return firstFigure - secondFigure;
	    };
	
	    BleTools.prototype.calcDistByRssi = function (rssi, attenuationValue, lossCoefficient) {
	        //attenuationValue:发射端和接收端相隔1米时的信号强度
	        //lossCoefficient:环境衰减因子
	        var iRssi = Math.abs(rssi);
	        var attenValue = Math.abs(attenuationValue);
	        var power = (iRssi - attenValue) / (10 * lossCoefficient);
	        return Math.pow(10, power);
	    };
	
	    function BleFilter(boundary) {
	        this.rssiBoundary = boundary && boundary.rssiBoundary ? boundary.rssiBoundary : 10;
	        this.distBoundary = boundary && boundary.distBoundary ? boundary.distBoundary : 6;
	        return this;
	    }
	
	    BleFilter.prototype.setBoundaries = function (boundary) {
	        this.rssiBoundary = boundary && boundary.rssiBoundary ? boundary.rssiBoundary : this.rssiBoundary ? this.rssiBoundary : 10;
	        this.distBoundary = boundary && boundary.distBoundary ? boundary.distBoundary : this.distBoundary ? this.distBoundary : 6;
	        return this;
	    };
	
	    BleFilter.prototype.rssiFilter = function (rssi, atten) {
	        if (rssi < 0) return rssi > atten - this.rssiBoundary;
	        return false;
	    };
	
	    BleFilter.prototype.distanceFilter = function (distance) {
	        return distance > 0 && distance < this.distBoundary;
	    };
	
	    BleFilter.prototype.locationFilter = function (bleBeaconCoordinate, bleLocationPoint) {
	        var triCenterPoint = Object.create(Point.prototype);
	        var triCenterAndLocation = Object.create(Points.prototype);
	        var filterPoint = Object.create(Point.prototype);
	        var distBoundary = 4;
	        triCenterPoint.x = (bleBeaconCoordinate[0].x + bleBeaconCoordinate[1].x + bleBeaconCoordinate[2].x) / 3;
	        triCenterPoint.y = (bleBeaconCoordinate[0].y + bleBeaconCoordinate[1].y + bleBeaconCoordinate[2].y) / 3;
	
	        triCenterAndLocation.setPoints(triCenterPoint, bleLocationPoint);
	        var dist = triCenterAndLocation.getDistance();
	        if (dist > distBoundary) {
	            filterPoint.x = triCenterPoint.x + (bleLocationPoint.x - triCenterPoint.x) * (distBoundary / dist);
	            filterPoint.y = triCenterPoint.y + (bleLocationPoint.y - triCenterPoint.y) * (distBoundary / dist);
	            return filterPoint;
	        } else {
	            return bleLocationPoint;
	        }
	    };
	
	    BleFilter.prototype.historyLocationFilter = function (bleLocationPoint) {
	        var locationPoints = Object.create(Points.prototype);
	        var optiLocationPoint = Object.create(Point.prototype);
	        locationPoints.setPoints(bleLocationPoint, oldBleLocationPoint);
	        var disBoundary = 2;
	        var distance = locationPoints.getDistance();
	        if (distance <= disBoundary || oldBleLocationPoint.x == 0 && oldBleLocationPoint.y == 0) {
	            oldBleLocationPoint = bleLocationPoint;
	            return bleLocationPoint;
	        } else {
	            optiLocationPoint.x = oldBleLocationPoint.x + (oldBleLocationPoint.x - bleLocationPoint.x) * (disBoundary / distance);
	            optiLocationPoint.y = oldBleLocationPoint.y + (oldBleLocationPoint.y - bleLocationPoint.y) * (disBoundary / distance);
	            oldBleLocationPoint = optiLocationPoint;
	            return optiLocationPoint;
	        }
	    };
	
	    function JsonOperation() {}
	
	    JsonOperation.prototype.parseInfo = function (info) {
	        try {
	            return JSON.parse(info);
	        } catch (e) {
	            return e;
	        }
	    };
	
	    JsonOperation.prototype.stringifyInfo = function (info) {
	        try {
	            return JSON.stringify(info);
	        } catch (e) {
	            return e;
	        }
	    };
	
	    var GLOBAL = {
	        "BEACON_USE_NUM": "3",
	        "DIS_A": "0",
	        "DIS_B": "1",
	        "DIS_C": "2"
	    };
	    var pointError = new Point(-1000, -1000);
	    var oldBleLocationPoint = new Point(0, 0);
	    var BleLocationEngine = function BleLocationEngine(BeaconsCfg, config) {
	        this.BeaconsCfg = BeaconsCfg;
	        this.bleConfig = config;
	        this.bleLocationInfo = function () {
	            var instance;
	
	            function getInstance() {
	                if (instance == undefined) {
	                    instance = new Construct();
	                }
	                return instance;
	            }
	
	            function Construct() {
	                Construct.instance = {
	                    "type": "FeatureCollection",
	                    "features": [{
	                        "type": "Feature",
	                        "properties": {
	                            "floor_id": 0
	                        },
	                        "geometry": {
	                            "type": "Point",
	                            "coordinates": [0, 0]
	                        }
	                    }]
	                };
	                return Construct.instance;
	            }
	
	            return {
	                getInstance: getInstance
	            };
	        }();
	        this.bleLocationInfoInstance = this.bleLocationInfo.getInstance();
	        this.bleLocationStrategy = function (beaconNum, beaconsMap, beaconsCfgMap, bleLocationInfoInstance) {
	            var strategyChoose;
	            switch (beaconNum) {
	                case 1:
	                    strategyChoose = "beaconNumEqualOne";
	                    break;
	                case 2:
	                    strategyChoose = "beaconNumEqualTwo";
	                    break;
	                case 3:
	                    strategyChoose = "beaconNumEqualThree";
	                    break;
	                default:
	                    strategyChoose = "beaconNumMoreThanThree";
	                    break;
	            }
	
	            var bleTriLocate = function bleTriLocate(bleBeaconCoordinate, bleDistance) {
	                var betBeaconDis = Object.create(Array.prototype);
	                var betCirCen = Object.create(Array.prototype);
	                var centerPointsArray = Object.create(Array.prototype);
	                for (var i = 0; i < GLOBAL.BEACON_USE_NUM; i++) {
	                    centerPointsArray[i] = Object.create(Points.prototype);
	                }
	                centerPointsArray[0].setPoints(bleBeaconCoordinate[0], bleBeaconCoordinate[1]);
	                centerPointsArray[1].setPoints(bleBeaconCoordinate[0], bleBeaconCoordinate[2]);
	                centerPointsArray[2].setPoints(bleBeaconCoordinate[1], bleBeaconCoordinate[2]);
	
	                betBeaconDis[0] = centerPointsArray[0].getDistance(); //the distance of the centers between circle0 and circle1
	                betBeaconDis[1] = centerPointsArray[1].getDistance(); //the distance of the centers between circle0 and circle2
	                betBeaconDis[2] = centerPointsArray[2].getDistance(); //the distance of the centers between circle1 and circle2
	
	                betCirCen[0] = bleDistance[GLOBAL.DIS_A] + bleDistance[GLOBAL.DIS_B]; //the sum of the radius between circle0 and circle1
	                betCirCen[1] = bleDistance[GLOBAL.DIS_A] + bleDistance[GLOBAL.DIS_C]; //the sum of the radius between circle0 and circle2
	                betCirCen[2] = bleDistance[GLOBAL.DIS_B] + bleDistance[GLOBAL.DIS_C]; //the sum of the radius between circle1 and circle2
	                betCirCen[3] = Math.abs(bleDistance[GLOBAL.DIS_A] - bleDistance[GLOBAL.DIS_B]); //the different of the radius between circle0 and circle1
	                betCirCen[4] = Math.abs([GLOBAL.DIS_A] - bleDistance[GLOBAL.DIS_C]); //the different of the radius between circle0 and circle2
	                betCirCen[5] = Math.abs(bleDistance[GLOBAL.DIS_B] - bleDistance[GLOBAL.DIS_C]); //the different of the radius between circle1 and circle2
	
	                var bet01 = betBeaconDis[0] > betCirCen[0] ? 300 : betBeaconDis[0] < betCirCen[3] ? 100 : 200;
	                var bet02 = betBeaconDis[1] > betCirCen[1] ? 30 : betBeaconDis[1] < betCirCen[4] ? 10 : 20;
	                var bet03 = betBeaconDis[2] > betCirCen[2] ? 3 : betBeaconDis[2] < betCirCen[5] ? 1 : 2;
	                //var locationMode = bet01 + bet02 + bet03;
	                var locationMode = 333;
	                var locationStrategy;
	                /*
	                 locationMode:
	                 百位表示圆0与圆1之间的关系
	                 十位表示圆0与圆2之间的关系
	                 个位表示圆1与圆2之间的关系
	                 3：相离-
	                 2：相交+
	                 1：包含&
	                 */
	                switch (locationMode) {
	                    case 333:
	                        locationStrategy = "allDeviation";
	                        console.info("C0-C1 C0-C2 C1-C2");
	                        break;
	                    case 222:
	                        locationStrategy = "disWeightAlg";
	                        console.info("C0+C1 C0+C2 C1+C2");
	                        break;
	                    case 233:
	                        locationStrategy = "CirTwoDeviation";
	                        console.info("C0+C1 C0-C2 C1-C2");
	                        break;
	                    case 323:
	                        locationStrategy = "CirOneDeviation";
	                        console.info("C0-C1 C0+C2 C1-C2");
	                        break;
	                    case 332:
	                        locationStrategy = "CirZeroDeviation";
	                        console.info("C0-C1 C0-C2 C1+C2");
	                        break;
	                    case 221:
	                    case 223:
	                        locationStrategy = "CirOneTwoDeviation";
	                        console.info("C0+C1 C0+C2 C1-&C2");
	                        break;
	                    case 212:
	                    case 232:
	                        locationStrategy = "CirZeroTwoDeviation";
	                        console.info("C0+C1 C0-&C2 C1+C2");
	                        break;
	                    case 122:
	                    case 322:
	                        locationStrategy = "CirZeroOneDeviation";
	                        console.info("C0-&C1 C0+C2 C1+C2");
	                        break;
	                    default:
	                        console.log("no Result!");
	                        break;
	                }
	
	                var bleTriLocateStrategy = {
	                    'allDeviation': function allDeviation(bleBeaconCoordinate, bleDistance) {
	                        var disWeight = Object.create(Array.prototype);
	                        var disWeightSum = 0;
	                        var x = 0;
	                        var y = 0;
	                        for (var i = 0; i < 3; ++i) {
	                            disWeightSum += 1 / bleDistance[i];
	                        }
	                        for (var j = 0; j < 3; ++j) {
	                            disWeight[j] = 1 / bleDistance[j] / disWeightSum;
	                        }
	                        var bleLocationPoint = Object.create(Point.prototype);
	                        for (var k = 0; k < 3; ++k) {
	                            x += disWeight[k] * bleBeaconCoordinate[k].x;
	                            y += disWeight[k] * bleBeaconCoordinate[k].y;
	                        }
	                        bleLocationPoint.setPoint(x, y);
	                        return bleLocationPoint;
	                    },
	
	                    'disWeightAlg': function disWeightAlg(bleBeaconCoordinate, bleDistance) {
	                        var bleLocationPoint = Object.create(Point.prototype);
	                        var circleArray = Object.create(Array.prototype);
	                        var circlesArray = Object.create(Array.prototype);
	                        var cirInsectNode = Object.create(Array.prototype);
	                        var cirInsectNodeArray = Object.create(Array.prototype);
	                        for (var i = 0; i < GLOBAL.BEACON_USE_NUM; i++) {
	                            circleArray[i] = Object.create(Circle.prototype);
	                            circlesArray[i] = Object.create(Circles.prototype);
	                        }
	                        circleArray[0].setCircle(bleBeaconCoordinate[0], bleDistance[GLOBAL.DIS_A]);
	                        circleArray[1].setCircle(bleBeaconCoordinate[1], bleDistance[GLOBAL.DIS_B]);
	                        circleArray[2].setCircle(bleBeaconCoordinate[2], bleDistance[GLOBAL.DIS_C]);
	
	                        circlesArray[0].setCircles(circleArray[0], circleArray[1]);
	                        circlesArray[1].setCircles(circleArray[0], circleArray[2]);
	                        circlesArray[2].setCircles(circleArray[1], circleArray[2]);
	
	                        cirInsectNodeArray[0] = circlesArray[0].insect();
	                        cirInsectNodeArray[1] = circlesArray[1].insect();
	                        cirInsectNodeArray[2] = circlesArray[2].insect();
	                        var pointsArray = Object.create(Array.prototype);
	                        for (i = 0; i < Number(GLOBAL.BEACON_USE_NUM) * 2; i++) {
	                            pointsArray[i] = Object.create(Points.prototype);
	                        }
	                        pointsArray[0].setPoints(cirInsectNodeArray[0][0], bleBeaconCoordinate[2]);
	                        pointsArray[1].setPoints(cirInsectNodeArray[0][1], bleBeaconCoordinate[2]);
	                        pointsArray[2].setPoints(cirInsectNodeArray[1][0], bleBeaconCoordinate[1]);
	                        pointsArray[3].setPoints(cirInsectNodeArray[1][1], bleBeaconCoordinate[1]);
	                        pointsArray[4].setPoints(cirInsectNodeArray[2][0], bleBeaconCoordinate[0]);
	                        pointsArray[5].setPoints(cirInsectNodeArray[2][1], bleBeaconCoordinate[0]);
	
	                        if (pointsArray[0].getDistance() < pointsArray[1].getDistance()) {
	                            cirInsectNode[0] = cirInsectNodeArray[0][0];
	                        } else {
	                            cirInsectNode[0] = cirInsectNodeArray[0][1];
	                        }
	
	                        if (pointsArray[2].getDistance() < pointsArray[3].getDistance()) {
	                            cirInsectNode[1] = cirInsectNodeArray[1][0];
	                        } else {
	                            cirInsectNode[1] = cirInsectNodeArray[1][1];
	                        }
	
	                        if (pointsArray[4].getDistance() < pointsArray[5].getDistance()) {
	                            cirInsectNode[2] = cirInsectNodeArray[2][0];
	                        } else {
	                            cirInsectNode[2] = cirInsectNodeArray[2][1];
	                        }
	
	                        bleLocationPoint.x = (cirInsectNode[0].x / (bleDistance[GLOBAL.DIS_A] * bleDistance[GLOBAL.DIS_A]) + cirInsectNode[1].x / (bleDistance[GLOBAL.DIS_B] * bleDistance[GLOBAL.DIS_B]) + cirInsectNode[2].x / (bleDistance[GLOBAL.DIS_C] * bleDistance[GLOBAL.DIS_C])) / (1 / (bleDistance[GLOBAL.DIS_A] * bleDistance[GLOBAL.DIS_A]) + 1 / (bleDistance[GLOBAL.DIS_B] * bleDistance[GLOBAL.DIS_B]) + 1 / (bleDistance[GLOBAL.DIS_C] * bleDistance[GLOBAL.DIS_C]));
	                        bleLocationPoint.y = (cirInsectNode[0].y / (bleDistance[GLOBAL.DIS_A] * bleDistance[GLOBAL.DIS_A]) + cirInsectNode[1].y / (bleDistance[GLOBAL.DIS_B] * bleDistance[GLOBAL.DIS_B]) + cirInsectNode[2].y / (bleDistance[GLOBAL.DIS_C] * bleDistance[GLOBAL.DIS_C])) / (1 / (bleDistance[GLOBAL.DIS_A] * bleDistance[GLOBAL.DIS_A]) + 1 / (bleDistance[GLOBAL.DIS_B] * bleDistance[GLOBAL.DIS_B]) + 1 / (bleDistance[GLOBAL.DIS_C] * bleDistance[GLOBAL.DIS_C]));
	                        return bleLocationPoint;
	                    },
	
	                    'CirZeroDeviation': function CirZeroDeviation(bleBeaconCoordinate, bleDistance) {
	                        var bleLocationPoint = Object.create(Point.prototype);
	                        var circleArray = Object.create(Array.prototype);
	                        var circles = Object.create(Circles.prototype);
	                        var pointsArray = Object.create(Array.prototype);
	                        for (var i = 0; i < 2; i++) {
	                            circleArray[i] = Object.create(Circle.prototype);
	                            pointsArray[i] = Object.create(Points.prototype);
	                        }
	                        circleArray[0].setCircle(bleBeaconCoordinate[1], bleDistance[1]);
	                        circleArray[1].setCircle(bleBeaconCoordinate[2], bleDistance[2]);
	                        circles.setCircles(circleArray[0], circleArray[1]);
	                        var cirInsectNode = circles.insect();
	                        pointsArray[0].setPoints(cirInsectNode[0], bleBeaconCoordinate[0]);
	                        pointsArray[1].setPoints(cirInsectNode[1], bleBeaconCoordinate[0]);
	                        if (pointsArray[0].getDistance() < pointsArray[1].getDistance()) {
	                            bleLocationPoint = cirInsectNode[0];
	                        } else {
	                            bleLocationPoint = cirInsectNode[1];
	                        }
	                        return bleLocationPoint;
	                    },
	
	                    'CirOneDeviation': function CirOneDeviation(bleBeaconCoordinate, bleDistance) {
	                        var bleLocationPoint = Object.create(Point.prototype);
	                        var circleArray = Object.create(Array.prototype);
	                        var circles = Object.create(Circles.prototype);
	                        var pointsArray = Object.create(Array.prototype);
	                        for (var i = 0; i < 2; i++) {
	                            circleArray[i] = Object.create(Circle.prototype);
	                            pointsArray[i] = Object.create(Points.prototype);
	                        }
	                        circleArray[0].setCircle(bleBeaconCoordinate[0], bleDistance[0]);
	                        circleArray[1].setCircle(bleBeaconCoordinate[2], bleDistance[2]);
	                        circles.setCircles(circleArray[0], circleArray[1]);
	                        var cirInsectNode = circles.insect();
	                        pointsArray[0].setPoints(cirInsectNode[0], bleBeaconCoordinate[1]);
	                        pointsArray[1].setPoints(cirInsectNode[1], bleBeaconCoordinate[1]);
	                        if (pointsArray[0].getDistance() < pointsArray[1].getDistance()) {
	                            bleLocationPoint = cirInsectNode[0];
	                        } else {
	                            bleLocationPoint = cirInsectNode[1];
	                        }
	                        return bleLocationPoint;
	                    },
	
	                    'CirTwoDeviation': function CirTwoDeviation(bleBeaconCoordinate, bleDistance) {
	                        var bleLocationPoint = Object.create(Point.prototype);
	                        var circleArray = Object.create(Array.prototype);
	                        var circles = Object.create(Circles.prototype);
	                        var pointsArray = Object.create(Array.prototype);
	                        for (var i = 0; i < 2; i++) {
	                            circleArray[i] = Object.create(Circle.prototype);
	                            pointsArray[i] = Object.create(Points.prototype);
	                        }
	                        circleArray[0].setCircle(bleBeaconCoordinate[0], bleDistance[0]);
	                        circleArray[1].setCircle(bleBeaconCoordinate[1], bleDistance[1]);
	                        circles.setCircles(circleArray[0], circleArray[1]);
	                        var cirInsectNodes = circles.insect();
	                        pointsArray[0].setPoints(cirInsectNodes[0], bleBeaconCoordinate[2]);
	                        pointsArray[1].setPoints(cirInsectNodes[1], bleBeaconCoordinate[2]);
	                        if (pointsArray[0].getDistance() < pointsArray[1].getDistance()) {
	                            bleLocationPoint = cirInsectNodes[0];
	                        } else {
	                            bleLocationPoint = cirInsectNodes[1];
	                        }
	                        return bleLocationPoint;
	                    },
	
	                    'CirOneTwoDeviation': function CirOneTwoDeviation(bleBeaconCoordinate, bleDistance) {
	                        var bleLocationPoint = Object.create(Point.prototype);
	                        var bleLocationPointArray = Object.create(Array.prototype);
	                        var circleArray = Object.create(Array.prototype);
	                        var circlesArray = Object.create(Array.prototype);
	                        var cirInsectNodesArray = Object.create(Array.prototype);
	                        var pointsArray = Object.create(Array.prototype);
	                        for (var i = 0; i < 2; i++) {
	                            bleLocationPointArray[i] = Object.create(Point.prototype);
	                            circlesArray[i] = Object.create(Circles.prototype);
	                            cirInsectNodesArray[i] = Object.create(Points.prototype);
	                        }
	                        for (i = 0; i < 3; i++) {
	                            circleArray[i] = Object.create(Circle.prototype);
	                        }
	                        for (i = 0; i < 4; i++) {
	                            pointsArray[i] = Object.create(Points.prototype);
	                        }
	                        circleArray[0].setCircle(bleBeaconCoordinate[0], bleDistance[0]);
	                        circleArray[1].setCircle(bleBeaconCoordinate[1], bleDistance[1]);
	                        circleArray[2].setCircle(bleBeaconCoordinate[2], bleDistance[2]);
	
	                        circlesArray[0].setCircles(circleArray[0], circleArray[1]);
	                        circlesArray[1].setCircles(circleArray[0], circleArray[2]);
	
	                        cirInsectNodesArray[0] = circlesArray[0].insect();
	                        cirInsectNodesArray[1] = circlesArray[1].insect();
	
	                        pointsArray[0].setPoints(cirInsectNodesArray[0][0], bleBeaconCoordinate[2]);
	                        pointsArray[1].setPoints(cirInsectNodesArray[0][1], bleBeaconCoordinate[2]);
	                        pointsArray[2].setPoints(cirInsectNodesArray[1][0], bleBeaconCoordinate[1]);
	                        pointsArray[3].setPoints(cirInsectNodesArray[1][1], bleBeaconCoordinate[1]);
	                        if (pointsArray[0].getDistance() < pointsArray[1].getDistance()) {
	                            bleLocationPointArray[0] = cirInsectNodesArray[0][0];
	                        } else {
	                            bleLocationPointArray[0] = cirInsectNodesArray[0][1];
	                        }
	                        if (pointsArray[2].getDistance() < pointsArray[3].getDistance()) {
	                            bleLocationPointArray[1] = cirInsectNodesArray[1][0];
	                        } else {
	                            bleLocationPointArray[1] = cirInsectNodesArray[1][1];
	                        }
	                        bleLocationPoint.setPoint((bleLocationPointArray[0].x + bleLocationPointArray[1].x) / 2, (bleLocationPointArray[0].y + bleLocationPointArray[1].y) / 2);
	                        return bleLocationPoint;
	                    },
	
	                    'CirZeroTwoDeviation': function CirZeroTwoDeviation(bleBeaconCoordinate, bleDistance) {
	                        var bleLocationPoint = Object.create(Point.prototype);
	                        var bleLocationPointArray = Object.create(Array.prototype);
	                        var circleArray = Object.create(Array.prototype);
	                        var circlesArray = Object.create(Array.prototype);
	                        var cirInsectNodesArray = Object.create(Array.prototype);
	                        var pointsArray = Object.create(Array.prototype);
	                        for (var i = 0; i < 2; i++) {
	                            bleLocationPointArray[i] = Object.create(Point.prototype);
	                            circlesArray[i] = Object.create(Circles.prototype);
	                            cirInsectNodesArray[i] = Object.create(Points.prototype);
	                        }
	                        for (i = 0; i < 3; i++) {
	                            circleArray[i] = Object.create(Circle.prototype);
	                        }
	                        for (i = 0; i < 4; i++) {
	                            pointsArray[i] = Object.create(Points.prototype);
	                        }
	                        circleArray[0].setCircle(bleBeaconCoordinate[0], bleDistance[0]);
	                        circleArray[1].setCircle(bleBeaconCoordinate[1], bleDistance[1]);
	                        circleArray[2].setCircle(bleBeaconCoordinate[2], bleDistance[2]);
	
	                        circlesArray[0].setCircles(circleArray[0], circleArray[1]);
	                        circlesArray[1].setCircles(circleArray[1], circleArray[2]);
	
	                        cirInsectNodesArray[0] = circlesArray[0].insect();
	                        cirInsectNodesArray[1] = circlesArray[1].insect();
	
	                        pointsArray[0].setPoints(cirInsectNodesArray[0][0], bleBeaconCoordinate[2]);
	                        pointsArray[1].setPoints(cirInsectNodesArray[0][1], bleBeaconCoordinate[2]);
	                        pointsArray[2].setPoints(cirInsectNodesArray[1][0], bleBeaconCoordinate[0]);
	                        pointsArray[3].setPoints(cirInsectNodesArray[1][1], bleBeaconCoordinate[0]);
	                        if (pointsArray[0].getDistance() < pointsArray[1].getDistance()) {
	                            bleLocationPointArray[0] = cirInsectNodesArray[0][0];
	                        } else {
	                            bleLocationPointArray[0] = cirInsectNodesArray[0][1];
	                        }
	                        if (pointsArray[2].getDistance() < pointsArray[3].getDistance()) {
	                            bleLocationPointArray[1] = cirInsectNodesArray[1][0];
	                        } else {
	                            bleLocationPointArray[1] = cirInsectNodesArray[1][1];
	                        }
	                        bleLocationPoint.setPoint((bleLocationPointArray[0].x + bleLocationPointArray[1].x) / 2, (bleLocationPointArray[0].y + bleLocationPointArray[1].y) / 2);
	                        return bleLocationPoint;
	                    },
	
	                    'CirZeroOneDeviation': function CirZeroOneDeviation(bleBeaconCoordinate, bleDistance) {
	                        var bleLocationPoint = Object.create(Point.prototype);
	                        var bleLocationPointArray = Object.create(Array.prototype);
	                        var circleArray = Object.create(Array.prototype);
	                        var circlesArray = Object.create(Array.prototype);
	                        var cirInsectNodesArray = Object.create(Array.prototype);
	                        var pointsArray = Object.create(Array.prototype);
	                        for (var i = 0; i < 2; i++) {
	                            bleLocationPointArray[i] = Object.create(Point.prototype);
	                            circlesArray[i] = Object.create(Circles.prototype);
	                            cirInsectNodesArray[i] = Object.create(Points.prototype);
	                        }
	                        for (i = 0; i < 3; i++) {
	                            circleArray[i] = Object.create(Circle.prototype);
	                        }
	                        for (i = 0; i < 4; i++) {
	                            pointsArray[i] = Object.create(Points.prototype);
	                        }
	                        circleArray[0].setCircle(bleBeaconCoordinate[0], bleDistance[0]);
	                        circleArray[1].setCircle(bleBeaconCoordinate[1], bleDistance[1]);
	                        circleArray[2].setCircle(bleBeaconCoordinate[2], bleDistance[2]);
	
	                        circlesArray[0].setCircles(circleArray[0], circleArray[2]);
	                        circlesArray[1].setCircles(circleArray[1], circleArray[2]);
	
	                        cirInsectNodesArray[0] = circlesArray[0].insect();
	                        cirInsectNodesArray[1] = circlesArray[1].insect();
	
	                        pointsArray[0].setPoints(cirInsectNodesArray[0][0], bleBeaconCoordinate[1]);
	                        pointsArray[1].setPoints(cirInsectNodesArray[0][1], bleBeaconCoordinate[1]);
	                        pointsArray[2].setPoints(cirInsectNodesArray[1][0], bleBeaconCoordinate[0]);
	                        pointsArray[3].setPoints(cirInsectNodesArray[1][1], bleBeaconCoordinate[0]);
	                        if (pointsArray[0].getDistance() < pointsArray[1].getDistance()) {
	                            bleLocationPointArray[0] = cirInsectNodesArray[0][0];
	                        } else {
	                            bleLocationPointArray[0] = cirInsectNodesArray[0][1];
	                        }
	                        if (pointsArray[2].getDistance() < pointsArray[3].getDistance()) {
	                            bleLocationPointArray[1] = cirInsectNodesArray[1][0];
	                        } else {
	                            bleLocationPointArray[1] = cirInsectNodesArray[1][1];
	                        }
	                        bleLocationPoint.setPoint((bleLocationPointArray[0].x + bleLocationPointArray[1].x) / 2, (bleLocationPointArray[0].y + bleLocationPointArray[1].y) / 2);
	                        return bleLocationPoint;
	                    }
	                };
	                var bleFilterObj = Object.create(BleFilter.prototype);
	                var triPoint = bleTriLocateStrategy[locationStrategy](bleBeaconCoordinate, bleDistance);
	                return bleFilterObj.locationFilter(bleBeaconCoordinate, triPoint);
	
	                //return bleTriLocateStrategy[locationStrategy](bleBeaconCoordinate, bleDistance);
	            };
	
	            var locStra = {
	                'beaconNumEqualOne': function beaconNumEqualOne(beaconsMap, beaconsCfgMap, bleLocationInfoInstance) {
	                    var bleLocationResult = Object.create(Point.prototype);
	                    var bleDistance;
	
	                    var key = beaconsMap.keyArray()[0];
	                    bleLocationResult.setPoint(beaconsCfgMap.get(key).x, beaconsCfgMap.get(key).y);
	                    bleDistance = beaconsMap.get(key).distance;
	                    // console.log(bleLocationResult, bleDistance);
	
	                    bleLocationInfoInstance.features[0].properties.floor_id = beaconsCfgMap.get(key).floorId;
	                    bleLocationInfoInstance.features[0].geometry.coordinates[0] = beaconsCfgMap.get(key).x;
	                    bleLocationInfoInstance.features[0].geometry.coordinates[1] = beaconsCfgMap.get(key).y;
	                    // console.log("BeaconNum = 1");
	                },
	
	                'beaconNumEqualTwo': function beaconNumEqualTwo(beaconsMap, beaconsCfgMap, bleLocationInfoInstance) {
	                    var recvBeaNum = 2;
	                    var iGreater;
	                    var bleLocationResult = Object.create(Array.prototype);
	                    var bleDistance = Object.create(Array.prototype);
	                    var key = Object.create(Array.prototype);
	                    var bleDistWeight = Object.create(Array.prototype);
	                    var bleDistWeightSum = 0;
	                    var x = 0,
	                        y = 0;
	                    for (var i = 0; i < recvBeaNum; i++) {
	                        bleLocationResult[i] = Object.create(Point.prototype);
	                    }
	
	                    var keys = beaconsMap.keyArray();
	                    for (i = 0; i < recvBeaNum; i++) {
	                        key[i] = keys[i];
	                        bleDistance[i] = Number(beaconsMap.get(key[i]).distance);
	                        bleLocationResult[i].setPoint(beaconsCfgMap.get(key[i]).x, beaconsCfgMap.get(key[i]).y);
	                    }
	                    // for (i = 0; i < recvBeaNum; i++) {
	                    //     console.log(bleLocationResult[i], bleDistance[i]);
	                    // }
	                    iGreater = bleDistance[GLOBAL.DIS_A] < bleDistance[GLOBAL.DIS_B] ? 0 : 1;
	
	                    for (i = 0; i < recvBeaNum; ++i) {
	                        bleDistWeightSum += 1 / bleDistance[i];
	                    }
	                    for (i = 0; i < recvBeaNum; ++i) {
	                        bleDistWeight[i] = 1 / bleDistance[i] / bleDistWeightSum;
	                    }
	                    // console.log(bleDistWeight);
	                    for (i = 0; i < recvBeaNum; ++i) {
	                        x += bleDistWeight[i] * bleLocationResult[i].x;
	                        y += bleDistWeight[i] * bleLocationResult[i].y;
	                    }
	
	                    bleLocationInfoInstance.features[0].properties.floor_id = beaconsCfgMap.get(key[iGreater]).floorId;
	                    bleLocationInfoInstance.features[0].geometry.coordinates[0] = x;
	                    bleLocationInfoInstance.features[0].geometry.coordinates[1] = y;
	                    // console.log("BeaconNum = 2");
	                },
	
	                'beaconNumEqualThree': function beaconNumEqualThree(beaconsMap, beaconsCfgMap, bleLocationInfoInstance) {
	                    var recvBeaNum = 3;
	                    var bleLocationResult = Object.create(Array.prototype);
	                    var bleDistance = Object.create(Array.prototype);
	                    var key = Object.create(Array.prototype);
	                    var bleDistanceToUse = Object.create(Array.prototype);
	                    var floorArray = new Array(3);
	                    var bleDistMin = 1000;
	                    var floorId;
	
	                    for (var i = 0; i < recvBeaNum; i++) {
	                        bleLocationResult[i] = Object.create(Point.prototype);
	                    }
	                    var kes = beaconsMap.keyArray();
	                    for (i = 0; i < recvBeaNum; i++) {
	                        key[i] = kes[i];
	                        bleDistance[i] = Number(beaconsMap.get(key[i]).distance);
	                        bleLocationResult[i].setPoint(beaconsCfgMap.get(key[i]).x, beaconsCfgMap.get(key[i]).y);
	                        bleDistanceToUse[i] = Number(beaconsMap.get(key[i]).distance);
	                        floorArray[i] = beaconsCfgMap.get(key[i]).floorId;
	                        if (bleDistMin > bleDistanceToUse[i]) {
	                            bleDistMin = bleDistanceToUse[i];
	                            floorId = beaconsCfgMap.get(key[i]).floorId;
	                        }
	                    }
	                    // for (i = 0; i < recvBeaNum; i++) {
	                    //     console.log(bleLocationResult[i], bleDistance[i]);
	                    // }
	                    var bleLocationPoint = bleTriLocate(bleLocationResult, bleDistance);
	                    floorArray.sort(BleTools.sortRule);
	                    //bleLocationInfoInstance.features[0].properties.floor_id = floorArray[(recvBeaNum + 1) / 2 - 1];
	                    bleDistance.sort(BleTools.sortRule);
	                    if (bleDistance[0] != bleDistance[1]) {
	                        bleLocationInfoInstance.features[0].properties.floor_id = floorId;
	                    } else {
	                        bleLocationInfoInstance.features[0].properties.floor_id = floorArrayToUse[(Number(GLOBAL.BEACON_USE_NUM) + 1) / 2 - 1];
	                    }
	                    bleLocationInfoInstance.features[0].geometry.coordinates[0] = bleLocationPoint.x;
	                    bleLocationInfoInstance.features[0].geometry.coordinates[1] = bleLocationPoint.y;
	                    // console.log("BeaconNum = 3");
	                },
	
	                'beaconNumMoreThanThree': function beaconNumMoreThanThree(beaconsMap, beaconsCfgMap, bleLocationInfoInstance) {
	                    var recvBeaNum = beaconsMap.size();
	                    var bleDistance = new Array(recvBeaNum);
	                    var bleLocationResultToUse = Object.create(Array.prototype);
	                    var keyToUse = Object.create(Array.prototype);
	                    var bleDistanceToUse = Object.create(Array.prototype);
	                    var floorArrayToUse = new Array(3);
	                    var bleDistMin = 1000;
	                    var floorId;
	
	                    for (var i = 0; i < GLOBAL.BEACON_USE_NUM; i++) {
	                        bleLocationResultToUse[i] = Object.create(Point.prototype);
	                    }
	
	                    var keys = beaconsMap.keyArray();
	                    for (i = 0; i < recvBeaNum; i++) {
	                        bleDistance[i] = Number(beaconsMap.get(keys[i]).distance);
	                    }
	                    bleDistance.sort(BleTools.sortRule);
	                    for (i = 0; i < GLOBAL.BEACON_USE_NUM; i++) {
	                        for (var j = 0; j < beaconsMap.size(); j++) {
	                            var be = beaconsMap.get(keys[j]);
	                            if (be && be.distance && be.distance == bleDistance[i]) {
	                                keyToUse[i] = keys[j];
	                                bleLocationResultToUse[i].setPoint(beaconsCfgMap.get(keyToUse[i]).x, beaconsCfgMap.get(keyToUse[i]).y);
	                                bleDistanceToUse[i] = Number(beaconsMap.get(keyToUse[i]).distance);
	                                floorArrayToUse[i] = beaconsCfgMap.get(keyToUse[i]).floorId;
	                                if (bleDistMin > bleDistanceToUse[i]) {
	                                    bleDistMin = bleDistanceToUse[i];
	                                    floorId = beaconsCfgMap.get(keyToUse[i]).floorId;
	                                }
	                                //beaconsMap.remove(keys[j]);
	                                break;
	                            }
	                        }
	                    }
	                    // for (i = 0; i < 3; i++) {
	                    //     console.log(bleLocationResultToUse[i], bleDistanceToUse[i]);
	                    // }
	                    var bleLocationPoint = bleTriLocate(bleLocationResultToUse, bleDistanceToUse);
	                    floorArrayToUse.sort(BleTools.sortRule);
	                    bleDistanceToUse.sort(BleTools.sortRule);
	                    if (bleDistanceToUse[0] != bleDistanceToUse[1]) {
	                        bleLocationInfoInstance.features[0].properties.floor_id = floorId;
	                    } else {
	                        bleLocationInfoInstance.features[0].properties.floor_id = floorArrayToUse[(Number(GLOBAL.BEACON_USE_NUM) + 1) / 2 - 1];
	                    }
	                    bleLocationInfoInstance.features[0].geometry.coordinates[0] = bleLocationPoint.x;
	                    bleLocationInfoInstance.features[0].geometry.coordinates[1] = bleLocationPoint.y;
	                    // console.log("BeaconNum > 3");
	                }
	            };
	            locStra[strategyChoose](beaconsMap, beaconsCfgMap, bleLocationInfoInstance);
	        };
	    };
	
	    BleLocationEngine.prototype.init = function (BeaconsCfg) {
	        this.BeaconsCfg = BeaconsCfg;
	    };
	
	    BleLocationEngine.prototype.locate = function (Beacons) {
	        var beacons;
	        var beaconsSize;
	        var beaconsCfg;
	        var beaconsCfgSize;
	        var bleLocationInfoObj;
	        var beaconNum;
	        // var jsonInfoOperObj = Object.create(JsonOperation.prototype);
	        var bleToolObj = Object.create(BleTools.prototype);
	        var bleFilterObj = Object.create(BleFilter.prototype);
	        var beaconsCfgMap = new HashMap();
	        var beaconsMap = new HashMap();
	
	        //set rssi and distance boundaries
	        bleFilterObj.setBoundaries(this.bleConfig);
	
	        //parse Beacons and BeaconsCfg
	        // beaconsCfg = jsonInfoOperObj.parseInfo(this.BeaconsCfg);
	        beaconsCfg = this.BeaconsCfg;
	        beacons = Beacons;
	        // beacons = jsonInfoOperObj.parseInfo(Beacons);
	
	        //get beacons's and beaconsCfg's size
	        beaconsCfgSize = beaconsCfg.length;
	        beaconsSize = beacons.length;
	
	        if (beaconsCfgSize != 0) {
	            //push beaconsCfg into beaconsCfgMap
	            for (var i = 0; i < beaconsCfgSize; i++) {
	                var atten, lossCoe;
	                if ("atten" in beaconsCfg[i] && "lossCoe" in beaconsCfg[i]) {
	                    atten = beaconsCfg[i].atten;
	                    lossCoe = beaconsCfg[i].lossCoe;
	                } else {
	                    atten = -59;
	                    lossCoe = 2.0;
	                }
	                var beaconCfgObject = new BeaconCfgClass(beaconsCfg[i]["beaconId"], beaconsCfg[i]["mapId"], beaconsCfg[i]["sceneId"], beaconsCfg[i]["floorId"], beaconsCfg[i]["uuid"], beaconsCfg[i]["major"], beaconsCfg[i]["minor"], Number(beaconsCfg[i]["geom"].x), Number(beaconsCfg[i]["geom"].y), atten, lossCoe);
	                var beaconsCfgKey = new String(beaconsCfg[i]["uuid"] + beaconsCfg[i]["major"] + beaconsCfg[i]["minor"]);
	                beaconsCfgMap.put(beaconsCfgKey, beaconCfgObject);
	            }
	            if (beaconsCfgMap.isEmpty()) {
	                console.log("BeaconCfgNum = 0");
	                return this.bleLocationInfoInstance;
	            }
	        } else {
	            console.warn("beaconsCfg is empty!");
	            return this.bleLocationInfoInstance;
	        }
	
	        if (beaconsSize != 0) {
	            //push beacons into beaconsMap
	            for (i = 0; i < beaconsSize; i++) {
	                var beaconsKey = new String(beacons[i]["uuid"] + beacons[i]["major"] + beacons[i]["minor"]);
	                if (beaconsCfgMap.containsKey(beaconsKey)) {
	                    var distance = 0;
	                    if ("distance" in beacons[i]) {
	                        if (bleFilterObj.distanceFilter(beacons[i]["distance"])) distance = beacons[i]["distance"];
	                    } else {
	                        if (bleFilterObj.rssiFilter(Number(beacons[i].rssi), beaconsCfgMap.get(beaconsKey).atten)) distance = bleToolObj.calcDistByRssi(Number(beacons[i].rssi), beaconsCfgMap.get(beaconsKey).atten, beaconsCfgMap.get(beaconsKey).lossCoe);
	                    }
	                    if (distance) {
	                        var beaconObject = new BeaconClass(beacons[i]["uuid"], beacons[i]["major"], beacons[i]["minor"], distance);
	                        beaconsMap.put(beaconsKey, beaconObject);
	                    }
	                }
	            }
	            if (!beaconsMap.isEmpty()) {
	                beaconNum = beaconsMap.size();
	            } else {
	                console.warn("BeaconNum = 0");
	                return this.bleLocationInfoInstance;
	            }
	        } else {
	            console.warn("beacons is empty!");
	            return this.bleLocationInfoInstance;
	        }
	
	        if (!beaconsCfgMap.isEmpty() && !beaconsMap.isEmpty()) {
	            this.bleLocationStrategy(beaconNum, beaconsMap, beaconsCfgMap, this.bleLocationInfoInstance);
	
	            beaconsMap.clear();
	            beaconsCfgMap.clear();
	            // console.info(this.bleLocationInfoInstance.features[0].properties);
	            // console.info(this.bleLocationInfoInstance.features[0].geometry.coordinates);
	            return this.bleLocationInfoInstance;
	        } else {
	            console.warn("beaconsCfgMap or beaconsMap is empty!");
	            return this.bleLocationInfoInstance;
	        }
	    };
	
	    BleLocationEngine.prototype.getBleLocationInfo = function () {
	        var jsonInfoOperObj = Object.create(JsonOperation.prototype);
	        return jsonInfoOperObj.stringifyInfo(this.bleLocationInfoInstance);
	    };
	
	    if (( false ? 'undefined' : _typeof(module)) === 'object' && _typeof(module.exports) === 'object') {
	        module.exports = BleLocationEngine;
	    } else if (true) {
	        !(__WEBPACK_AMD_DEFINE_FACTORY__ = (BleLocationEngine), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	    }
	})();
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(30)(module)))

/***/ }),
/* 118 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _three = __webpack_require__(2);
	
	var THREE = _interopRequireWildcard(_three);
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var fontHeightCache = {};
	
	var CanvasText = function () {
	  function CanvasText() {
	    _classCallCheck(this, CanvasText);
	
	    this.textWidth = null;
	    this.textHeight = null;
	
	    this.canvas = document.createElement('canvas');
	    this.ctx = this.canvas.getContext('2d');
	  }
	
	  _createClass(CanvasText, [{
	    key: 'drawText',
	    value: function drawText(text, ctxOptions) {
	      // return this.drawTextOpt(text, ctxOptions);
	      return ctxOptions.optTextRect ? this.drawTextOpt(text, ctxOptions) : this.drawTextRect(text, ctxOptions);
	    }
	  }, {
	    key: 'drawTextOpt',
	    value: function drawTextOpt(text, ctxOptions) {
	      var canvas = this.canvas;
	      var ctx = this.ctx;
	      ctx.font = ctxOptions.font;
	
	      var textW = Math.ceil(this.ctx.measureText(text).width);
	      var textH = getFontHeight(text, ctx.font);
	      var width = textW + (ctxOptions.lineWidth ? ctxOptions.lineWidth * 2 : 0) + 30;
	      var height = textH + 30;
	
	      var dx = 0;
	      if (ctxOptions.lineWidth) {
	        dx = ctxOptions.lineWidth * 2;
	      }
	
	      var left = 0;
	      var top = 0;
	      var right = dx + textW;
	      var bottom = dx / 2 + textH;
	
	      width = right - left;
	      height = bottom - top;
	
	      this.textWidth = width;
	      this.textHeight = height;
	      canvas.width = THREE.Math.nextPowerOfTwo(width);
	      canvas.height = THREE.Math.nextPowerOfTwo(height);
	
	      ctx.font = ctxOptions.font;
	      ctx.textAlign = 'left';
	      ctx.textBaseline = 'top';
	      if (ctxOptions.lineWidth && ctxOptions.strokeStyle) {
	        ctx.strokeStyle = ctxOptions.strokeStyle;
	        ctx.lineWidth = ctxOptions.lineWidth;
	        ctx.strokeText(text, dx, dx);
	      }
	
	      ctx.shadowColor = ctxOptions.shadowColor ? ctxOptions.shadowColor : ctx.shadowColor;
	      ctx.shadowBlur = ctxOptions.shadowBlur ? ctxOptions.shadowBlur : ctx.shadowColor;
	
	      ctx.fillStyle = ctxOptions.fillStyle;
	      ctx.fillText(text, dx, dx);
	
	      return this.canvas;
	    }
	  }, {
	    key: 'drawTextRect',
	    value: function drawTextRect(text, ctxOptions) {
	      var canvas = this.canvas;
	      var ctx = this.ctx;
	      ctx.font = ctxOptions.font;
	
	      var textW = Math.ceil(this.ctx.measureText(text).width);
	      var textH = getFontHeight(text, ctx.font);
	      var width = textW + (ctxOptions.lineWidth ? ctxOptions.lineWidth * 2 : 0) + 30;
	      var height = textH + 30;
	
	      canvas.width = width;
	      canvas.height = height;
	
	      ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
	
	      var dx = 0;
	      if (ctxOptions.lineWidth) {
	        dx = ctxOptions.lineWidth * 2;
	      }
	
	      ctx.font = ctxOptions.font;
	      ctx.textAlign = 'left';
	      ctx.textBaseline = 'top';
	      if (ctxOptions.lineWidth && ctxOptions.strokeStyle) {
	        ctx.strokeStyle = ctxOptions.strokeStyle;
	        ctx.lineWidth = ctxOptions.lineWidth;
	        ctx.strokeText(text, dx, dx);
	      }
	
	      ctx.shadowColor = ctxOptions.shadowColor ? ctxOptions.shadowColor : ctx.shadowColor;
	      ctx.shadowBlur = ctxOptions.shadowBlur ? ctxOptions.shadowBlur : ctx.shadowColor;
	
	      ctx.fillStyle = ctxOptions.fillStyle;
	      ctx.fillText(text, dx, dx);
	
	      var data = ctx.getImageData(0, 0, width, height);
	
	      var left = 0;
	      var top = 0;
	      var right = 0;
	      var bottom = 0;
	      var index = void 0,
	          i = void 0,
	          j = void 0;
	      var d = data.data;
	
	      for (i = dx; i > 0; --i) {
	        for (j = 0; j < data.height; ++j) {
	          index = 4 * (j * data.width + i) + 3;
	          if (d[index]) {
	            break;
	          }
	        }
	        if (!d[index]) {
	          left = i + 1;
	          break;
	        }
	      }
	
	      for (i = dx; i > 0; --i) {
	        for (j = left; j < data.width; ++j) {
	          index = 4 * (i * data.width + j) + 3;
	          if (d[index]) {
	            break;
	          }
	        }
	        if (!d[index]) {
	          top = i + 1;
	          break;
	        }
	      }
	
	      var ddx = dx - left;
	      var ddy = dx - top;
	
	      for (i = textH - ddy; i < data.height; ++i) {
	        for (j = left; j < data.width; ++j) {
	          index = 4 * (i * data.width + j) + 3;
	          if (d[index]) {
	            break;
	          }
	        }
	        if (!d[index]) {
	          bottom = i - 1;
	          break;
	        }
	      }
	
	      for (i = textW - ddx; i < data.width; ++i) {
	        for (j = top; j <= bottom; ++j) {
	          index = 4 * (j * data.width + i) + 3;
	          if (d[index]) {
	            break;
	          }
	        }
	        if (!d[index]) {
	          right = i - 1;
	          break;
	        }
	      }
	
	      width = right - left;
	      height = bottom - top;
	
	      data = ctx.getImageData(left, top, width, height);
	
	      this.textWidth = width;
	      this.textHeight = height;
	      canvas.width = THREE.Math.nextPowerOfTwo(width);
	      canvas.height = THREE.Math.nextPowerOfTwo(height);
	
	      ctx.putImageData(data, 0, 0, 0, 0, this.textWidth, this.textHeight);
	
	      return this.canvas;
	    }
	  }, {
	    key: 'width',
	    get: function get() {
	      return this.canvas.width;
	    }
	  }, {
	    key: 'height',
	    get: function get() {
	      return this.canvas.height;
	    }
	  }]);
	
	  return CanvasText;
	}();
	
	function getFontHeight(text, fontStyle) {
	  var result = fontHeightCache[fontStyle];
	
	  if (!result) {
	    var body = document.getElementsByTagName('body')[0];
	    var dummy = document.createElement('div');
	
	    var dummyText = document.createTextNode(text);
	    dummy.appendChild(dummyText);
	    dummy.setAttribute('style', 'font:' + fontStyle + ';position:absolute;top:0;left:0');
	    body.appendChild(dummy);
	    result = dummy.offsetHeight;
	
	    fontHeightCache[fontStyle] = result;
	    body.removeChild(dummy);
	  }
	
	  return result;
	}
	
	exports.default = CanvasText;

/***/ }),
/* 119 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _assign = __webpack_require__(1);
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _three = __webpack_require__(2);
	
	var THREE = _interopRequireWildcard(_three);
	
	var _textAlign = __webpack_require__(59);
	
	var _textAlign2 = _interopRequireDefault(_textAlign);
	
	var _CanvasText = __webpack_require__(118);
	
	var _CanvasText2 = _interopRequireDefault(_CanvasText);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	// import { AnimatorFactory } from '../../src/animation';
	
	var SpriteText2D = function (_THREE$Object3D) {
	  _inherits(SpriteText2D, _THREE$Object3D);
	
	  function SpriteText2D() {
	    var text = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
	    var options = arguments[1];
	
	    _classCallCheck(this, SpriteText2D);
	
	    var _this = _possibleConstructorReturn(this, (SpriteText2D.__proto__ || Object.getPrototypeOf(SpriteText2D)).call(this));
	
	    _this._options = _assign({
	      font: '30px Arial',
	      fillStyle: '#FFFFFF',
	      depthTest: false,
	      antialias: true,
	      align: _textAlign2.default.center,
	      optTextRect: false
	    }, options || {});
	    _this.canvas = new _CanvasText2.default();
	    _this.text = text;
	    return _this;
	  }
	
	  // delegate raycast method to mesh instance
	
	
	  _createClass(SpriteText2D, [{
	    key: 'raycast',
	    value: function raycast() {
	      var _sprite;
	
	      return (_sprite = this.sprite).raycast.apply(_sprite, arguments);
	    }
	  }, {
	    key: 'updateText',
	
	
	    // set metersPixel(metersPixel) {
	    // }
	
	    value: function updateText() {
	      if (!this.canvas) {
	        return;
	      }
	      this.canvas.drawText(this._text, this._options);
	
	      // cleanup previous texture
	      this.cleanUp();
	
	      this.texture = new THREE.Texture(this.canvas.canvas);
	      this.texture.needsUpdate = true;
	      this.applyAntiAlias();
	
	      if (!this.material) {
	        this.material = new THREE.SpriteMaterial({ map: this.texture, depthTest: this._options.depthTest, alphaTest: 0.01 });
	        // this.material.needsUpdate = false;
	      } else {
	        this.material.map = this.texture;
	      }
	
	      this.texture.offset.x = 0;
	      this.texture.offset.y = 1 - this.canvas.textHeight / this.canvas.height;
	      this.texture.repeat.x = this.canvas.textWidth / this.canvas.width;
	      this.texture.repeat.y = this.canvas.textHeight / this.canvas.height;
	
	      if (!this.sprite) {
	        this.sprite = new THREE.Sprite(this.material);
	        this.geometry = this.sprite.geometry;
	        this.add(this.sprite);
	      }
	
	      this.sprite.scale.set(this.canvas.textWidth / 2, this.canvas.textHeight / 2, 0);
	
	      this.sprite.position.x = this.canvas.textWidth / 2 * this._options.align.x;
	      this.sprite.position.y = this.canvas.textHeight / 2 * this._options.align.y;
	    }
	  }, {
	    key: 'cleanUp',
	    value: function cleanUp() {
	      if (this.texture) {
	        this.texture.dispose();
	      }
	    }
	  }, {
	    key: 'applyAntiAlias',
	    value: function applyAntiAlias() {
	      if (this._options.antialias === false) {
	        this.texture.magFilter = THREE.LinearFilter;
	        this.texture.minFilter = THREE.LinearFilter;
	      } else {
	        this.texture.magFilter = THREE.LinearFilter;
	        this.texture.minFilter = THREE.LinearFilter;
	      }
	    }
	  }, {
	    key: 'getAABB',
	    value: function getAABB(camera) {
	      var position = new THREE.Vector3(0, 0, 0);
	      var margin = this.margin || 0;
	      var scale = this.sprite.scale;
	      var centerX = scale.x / 2;
	      var centerY = scale.y / 2;
	      var aabb = [];
	      var matrix = this.sprite.matrixWorld;
	      position.setFromMatrixPosition(matrix);
	      position = camera.toScreenCoordinate(position.x, position.y, position.z);
	      var anchor = this.sprite.material.anchor;
	      var tempX = 0;
	      var tempY = 0;
	      if (anchor) {
	        tempX = centerX - scale.x * anchor[0];
	        tempY = centerY - scale.y * anchor[1];
	        position.setX(position.x + tempX);
	        position.setY(position.y + tempY);
	      }
	      aabb.push(position.x - centerX - margin);
	      aabb.push(position.y - centerY - margin);
	      aabb.push(0);
	      aabb.push(position.x + centerX + margin);
	      aabb.push(position.y + centerY + margin);
	      aabb.push(0);
	      return aabb;
	    }
	  }, {
	    key: 'makeCollision',
	    value: function makeCollision(collision) {
	      var visible = !collision;
	      var opacity = this.destOpacity ? this.destOpacity : 1;
	
	      this.visible = visible;
	      this.material.opacity = opacity;
	
	      for (var _iterator = this.children, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
	        var _ref;
	
	        if (_isArray) {
	          if (_i >= _iterator.length) break;
	          _ref = _iterator[_i++];
	        } else {
	          _i = _iterator.next();
	          if (_i.done) break;
	          _ref = _i.value;
	        }
	
	        var child = _ref;
	
	        child.visible = visible;
	      }
	
	      return this;
	    }
	  }, {
	    key: 'width',
	    get: function get() {
	      return this.canvas.textWidth;
	    }
	  }, {
	    key: 'height',
	    get: function get() {
	      return this.canvas.textHeight;
	    }
	  }, {
	    key: 'text',
	    get: function get() {
	      return this._text;
	    },
	    set: function set(value) {
	      if (this._text !== value) {
	        this._text = value;
	        this.updateText();
	      }
	    }
	  }, {
	    key: 'font',
	    get: function get() {
	      return this._options.font;
	    },
	    set: function set(value) {
	      if (this._options.font !== value) {
	        this._options.font = value;
	        this.updateText();
	      }
	    }
	  }, {
	    key: 'fillStyle',
	    get: function get() {
	      return this._options.fillStyle;
	    },
	    set: function set(value) {
	      if (this._options.fillStyle !== value) {
	        this._options.fillStyle = value;
	        this.updateText();
	      }
	    }
	  }]);
	
	  return SpriteText2D;
	}(THREE.Object3D);
	
	exports.default = SpriteText2D;

/***/ }),
/* 120 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var _three = __webpack_require__(2);
	
	var THREE = _interopRequireWildcard(_three);
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	THREE.CSS2DObject = function (element) {
	
		THREE.Object3D.call(this);
	
		this.element = element;
		this.element.style.position = 'absolute';
		this.element.style.pointerEvents = 'all';
	
		this.addEventListener('removed', function (event) {
	
			if (this.element.parentNode !== null) {
	
				this.element.parentNode.removeChild(this.element);
			}
		});
	}; /* eslint-disable */
	
	
	THREE.CSS2DObject.prototype = Object.create(THREE.Object3D.prototype);
	THREE.CSS2DObject.prototype.constructor = THREE.CSS2DObject;
	
	//
	
	THREE.CSS2DRenderer = function () {
	
		console.log('THREE.CSS2DRenderer', THREE.REVISION);
	
		var _width, _height;
		var _widthHalf, _heightHalf;
	
		var vector = new THREE.Vector3();
		var viewMatrix = new THREE.Matrix4();
		var viewProjectionMatrix = new THREE.Matrix4();
	
		var domElement = document.createElement('div');
		domElement.style.overflow = 'hidden';
	
		this.domElement = domElement;
	
		this.setSize = function (width, height) {
	
			_width = width;
			_height = height;
	
			_widthHalf = _width / 2;
			_heightHalf = _height / 2;
	
			domElement.style.width = width + 'px';
			domElement.style.height = height + 'px';
		};
	
		var renderObject = function renderObject(object, camera) {
	
			if (object instanceof THREE.CSS2DObject) {
	
				vector.setFromMatrixPosition(object.matrixWorld);
				vector.applyMatrix4(viewProjectionMatrix);
	
				var element = object.element;
				var style = 'translate(-50%,-50%) translate(' + (vector.x * _widthHalf + _widthHalf) + 'px,' + (-vector.y * _heightHalf + _heightHalf) + 'px)';
	
				element.style.WebkitTransform = style;
				element.style.MozTransform = style;
				element.style.oTransform = style;
				element.style.transform = style;
	
				if (element.parentNode !== domElement) {
	
					domElement.appendChild(element);
				}
			}
	
			for (var i = 0, l = object.children.length; i < l; i++) {
	
				renderObject(object.children[i], camera);
			}
		};
	
		this.render = function (scene, camera) {
	
			scene.updateMatrixWorld();
	
			if (camera.parent === null) camera.updateMatrixWorld();
	
			camera.matrixWorldInverse.getInverse(camera.matrixWorld);
	
			viewMatrix.copy(camera.matrixWorldInverse.getInverse(camera.matrixWorld));
			viewProjectionMatrix.multiplyMatrices(camera.projectionMatrix, viewMatrix);
	
			renderObject(scene, camera);
		};
	};
	/* eslint-enable */

/***/ }),
/* 121 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var _three = __webpack_require__(2);
	
	var THREE = _interopRequireWildcard(_three);
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	THREE.ColladaLoader = function () {
	
		var COLLADA = null;
		var scene = null;
		var visualScene;
		var kinematicsModel;
	
		var readyCallbackFunc = null;
	
		var sources = {};
		var images = {};
		var animations = {};
		var controllers = {};
		var geometries = {};
		var materials = {};
		var effects = {};
		var cameras = {};
		var lights = {};
	
		var animData;
		var kinematics;
		var visualScenes;
		var kinematicsModels;
		var baseUrl;
		var morphs;
		var skins;
	
		var flip_uv = true;
		var preferredShading = THREE.SmoothShading;
	
		var options = {
			// Force Geometry to always be centered at the local origin of the
			// containing Mesh.
			centerGeometry: false,
	
			// Axis conversion is done for geometries, animations, and controllers.
			// If we ever pull cameras or lights out of the COLLADA file, they'll
			// need extra work.
			convertUpAxis: false,
	
			subdivideFaces: true,
	
			upAxis: 'Y',
	
			// For reflective or refractive materials we'll use this cubemap
			defaultEnvMap: null
	
		};
	
		var colladaUnit = 1.0;
		var colladaUp = 'Y';
		var upConversion = null;
	
		function load(url, readyCallback, progressCallback, failCallback) {
	
			var length = 0;
	
			if (document.implementation && document.implementation.createDocument) {
	
				var request = new XMLHttpRequest();
	
				request.onreadystatechange = function () {
	
					if (request.readyState === 4) {
	
						if (request.status === 0 || request.status === 200) {
	
							if (request.response) {
	
								readyCallbackFunc = readyCallback;
								parse(request.response, undefined, url);
							} else {
	
								if (failCallback) {
	
									failCallback({ type: 'error', url: url });
								} else {
	
									console.error("ColladaLoader: Empty or non-existing file (" + url + ")");
								}
							}
						} else {
	
							if (failCallback) {
	
								failCallback({ type: 'error', url: url });
							} else {
	
								console.error('ColladaLoader: Couldn\'t load "' + url + '" (' + request.status + ')');
							}
						}
					} else if (request.readyState === 3) {
	
						if (progressCallback) {
	
							if (length === 0) {
	
								length = request.getResponseHeader("Content-Length");
							}
	
							progressCallback({ total: length, loaded: request.responseText.length });
						}
					}
				};
	
				request.open("GET", url, true);
				request.send(null);
			} else {
	
				alert("Don't know how to parse XML!");
			}
		}
	
		function parse(text, callBack, url) {
	
			COLLADA = new DOMParser().parseFromString(text, 'text/xml');
			callBack = callBack || readyCallbackFunc;
	
			if (url !== undefined) {
	
				var parts = url.split('/');
				parts.pop();
				baseUrl = (parts.length < 1 ? '.' : parts.join('/')) + '/';
			}
	
			parseAsset();
			setUpConversion();
			images = parseLib("library_images image", _Image, "image");
			materials = parseLib("library_materials material", Material, "material");
			effects = parseLib("library_effects effect", Effect, "effect");
			geometries = parseLib("library_geometries geometry", Geometry, "geometry");
			cameras = parseLib("library_cameras camera", Camera, "camera");
			lights = parseLib("library_lights light", Light, "light");
			controllers = parseLib("library_controllers controller", Controller, "controller");
			animations = parseLib("library_animations animation", Animation, "animation");
			visualScenes = parseLib("library_visual_scenes visual_scene", VisualScene, "visual_scene");
			kinematicsModels = parseLib("library_kinematics_models kinematics_model", KinematicsModel, "kinematics_model");
	
			morphs = [];
			skins = [];
	
			visualScene = parseScene();
			scene = new THREE.Group();
	
			for (var i = 0; i < visualScene.nodes.length; i++) {
	
				scene.add(createSceneGraph(visualScene.nodes[i]));
			}
	
			// unit conversion
			scene.scale.multiplyScalar(colladaUnit);
	
			createAnimations();
	
			kinematicsModel = parseKinematicsModel();
			createKinematics();
	
			var result = {
	
				scene: scene,
				morphs: morphs,
				skins: skins,
				animations: animData,
				kinematics: kinematics,
				dae: {
					images: images,
					materials: materials,
					cameras: cameras,
					lights: lights,
					effects: effects,
					geometries: geometries,
					controllers: controllers,
					animations: animations,
					visualScenes: visualScenes,
					visualScene: visualScene,
					scene: visualScene,
					kinematicsModels: kinematicsModels,
					kinematicsModel: kinematicsModel
				}
	
			};
	
			if (callBack) {
	
				callBack(result);
			}
	
			return result;
		}
	
		function setPreferredShading(shading) {
	
			preferredShading = shading;
		}
	
		function parseAsset() {
	
			var elements = COLLADA.querySelectorAll('asset');
	
			var element = elements[0];
	
			if (element && element.childNodes) {
	
				for (var i = 0; i < element.childNodes.length; i++) {
	
					var child = element.childNodes[i];
	
					switch (child.nodeName) {
	
						case 'unit':
	
							var meter = child.getAttribute('meter');
	
							if (meter) {
	
								colladaUnit = parseFloat(meter);
							}
	
							break;
	
						case 'up_axis':
	
							colladaUp = child.textContent.charAt(0);
							break;
	
					}
				}
			}
		}
	
		function parseLib(q, classSpec, prefix) {
	
			var elements = COLLADA.querySelectorAll(q);
	
			var lib = {};
	
			var i = 0;
	
			var elementsLength = elements.length;
	
			for (var j = 0; j < elementsLength; j++) {
	
				var element = elements[j];
				var daeElement = new classSpec().parse(element);
	
				if (!daeElement.id || daeElement.id.length === 0) daeElement.id = prefix + i++;
				lib[daeElement.id] = daeElement;
			}
	
			return lib;
		}
	
		function parseScene() {
	
			var sceneElement = COLLADA.querySelectorAll('scene instance_visual_scene')[0];
	
			if (sceneElement) {
	
				var url = sceneElement.getAttribute('url').replace(/^#/, '');
				return visualScenes[url.length > 0 ? url : 'visual_scene0'];
			} else {
	
				return null;
			}
		}
	
		function parseKinematicsModel() {
	
			var kinematicsModelElement = COLLADA.querySelectorAll('instance_kinematics_model')[0];
	
			if (kinematicsModelElement) {
	
				var url = kinematicsModelElement.getAttribute('url').replace(/^#/, '');
				return kinematicsModels[url.length > 0 ? url : 'kinematics_model0'];
			} else {
	
				return null;
			}
		}
	
		function createAnimations() {
	
			animData = [];
	
			// fill in the keys
			recurseHierarchy(scene);
		}
	
		function recurseHierarchy(node) {
	
			var n = visualScene.getChildById(node.colladaId, true),
			    newData = null;
	
			if (n && n.keys) {
	
				newData = {
					fps: 60,
					hierarchy: [{
						node: n,
						keys: n.keys,
						sids: n.sids
					}],
					node: node,
					name: 'animation_' + node.name,
					length: 0
				};
	
				animData.push(newData);
	
				for (var i = 0, il = n.keys.length; i < il; i++) {
	
					newData.length = Math.max(newData.length, n.keys[i].time);
				}
			} else {
	
				newData = {
					hierarchy: [{
						keys: [],
						sids: []
					}]
				};
			}
	
			for (var i = 0, il = node.children.length; i < il; i++) {
	
				var d = recurseHierarchy(node.children[i]);
	
				for (var j = 0, jl = d.hierarchy.length; j < jl; j++) {
	
					newData.hierarchy.push({
						keys: [],
						sids: []
					});
				}
			}
	
			return newData;
		}
	
		function calcAnimationBounds() {
	
			var start = 1000000;
			var end = -start;
			var frames = 0;
			var ID;
			for (var id in animations) {
	
				var animation = animations[id];
				ID = ID || animation.id;
				for (var i = 0; i < animation.sampler.length; i++) {
	
					var sampler = animation.sampler[i];
	
					sampler.create();
	
					start = Math.min(start, sampler.startTime);
					end = Math.max(end, sampler.endTime);
					frames = Math.max(frames, sampler.input.length);
				}
			}
	
			return { start: start, end: end, frames: frames, ID: ID };
		}
	
		function createMorph(geometry, ctrl) {
	
			var morphCtrl = ctrl instanceof InstanceController ? controllers[ctrl.url] : ctrl;
	
			if (!morphCtrl || !morphCtrl.morph) {
	
				console.log("could not find morph controller!");
				return;
			}
	
			var morph = morphCtrl.morph;
	
			for (var i = 0; i < morph.targets.length; i++) {
	
				var target_id = morph.targets[i];
				var daeGeometry = geometries[target_id];
	
				if (!daeGeometry.mesh || !daeGeometry.mesh.primitives || !daeGeometry.mesh.primitives.length) {
					continue;
				}
	
				var target = daeGeometry.mesh.primitives[0].geometry;
	
				if (target.vertices.length === geometry.vertices.length) {
	
					geometry.morphTargets.push({ name: "target_1", vertices: target.vertices });
				}
			}
	
			geometry.morphTargets.push({ name: "target_Z", vertices: geometry.vertices });
		}
	
		function createSkin(geometry, ctrl, applyBindShape) {
	
			var skinCtrl = controllers[ctrl.url];
	
			if (!skinCtrl || !skinCtrl.skin) {
	
				console.log("could not find skin controller!");
				return;
			}
	
			if (!ctrl.skeleton || !ctrl.skeleton.length) {
	
				console.log("could not find the skeleton for the skin!");
				return;
			}
	
			var skin = skinCtrl.skin;
			var skeleton = visualScene.getChildById(ctrl.skeleton[0]);
			var hierarchy = [];
	
			applyBindShape = applyBindShape !== undefined ? applyBindShape : true;
	
			var bones = [];
			geometry.skinWeights = [];
			geometry.skinIndices = [];
	
			//createBones( geometry.bones, skin, hierarchy, skeleton, null, -1 );
			//createWeights( skin, geometry.bones, geometry.skinIndices, geometry.skinWeights );
	
			/*
	  geometry.animation = {
	  	name: 'take_001',
	  	fps: 30,
	  	length: 2,
	  	JIT: true,
	  	hierarchy: hierarchy
	  };
	  */
	
			if (applyBindShape) {
	
				for (var i = 0; i < geometry.vertices.length; i++) {
	
					geometry.vertices[i].applyMatrix4(skin.bindShapeMatrix);
				}
			}
		}
	
		function setupSkeleton(node, bones, frame, parent) {
	
			node.world = node.world || new THREE.Matrix4();
			node.localworld = node.localworld || new THREE.Matrix4();
			node.world.copy(node.matrix);
			node.localworld.copy(node.matrix);
	
			if (node.channels && node.channels.length) {
	
				var channel = node.channels[0];
				var m = channel.sampler.output[frame];
	
				if (m instanceof THREE.Matrix4) {
	
					node.world.copy(m);
					node.localworld.copy(m);
					if (frame === 0) node.matrix.copy(m);
				}
			}
	
			if (parent) {
	
				node.world.multiplyMatrices(parent, node.world);
			}
	
			bones.push(node);
	
			for (var i = 0; i < node.nodes.length; i++) {
	
				setupSkeleton(node.nodes[i], bones, frame, node.world);
			}
		}
	
		function setupSkinningMatrices(bones, skin) {
	
			// FIXME: this is dumb...
	
			for (var i = 0; i < bones.length; i++) {
	
				var bone = bones[i];
				var found = -1;
	
				if (bone.type != 'JOINT') continue;
	
				for (var j = 0; j < skin.joints.length; j++) {
	
					if (bone.sid === skin.joints[j]) {
	
						found = j;
						break;
					}
				}
	
				if (found >= 0) {
	
					var inv = skin.invBindMatrices[found];
	
					bone.invBindMatrix = inv;
					bone.skinningMatrix = new THREE.Matrix4();
					bone.skinningMatrix.multiplyMatrices(bone.world, inv); // (IBMi * JMi)
					bone.animatrix = new THREE.Matrix4();
	
					bone.animatrix.copy(bone.localworld);
					bone.weights = [];
	
					for (var j = 0; j < skin.weights.length; j++) {
	
						for (var k = 0; k < skin.weights[j].length; k++) {
	
							var w = skin.weights[j][k];
	
							if (w.joint === found) {
	
								bone.weights.push(w);
							}
						}
					}
				} else {
	
					console.warn("ColladaLoader: Could not find joint '" + bone.sid + "'.");
	
					bone.skinningMatrix = new THREE.Matrix4();
					bone.weights = [];
				}
			}
		}
	
		//Walk the Collada tree and flatten the bones into a list, extract the position, quat and scale from the matrix
		function flattenSkeleton(skeleton) {
	
			var list = [];
			var walk = function walk(parentid, node, list) {
	
				var bone = {};
				bone.name = node.sid;
				bone.parent = parentid;
				bone.matrix = node.matrix;
				var data = [new THREE.Vector3(), new THREE.Quaternion(), new THREE.Vector3()];
				bone.matrix.decompose(data[0], data[1], data[2]);
	
				bone.pos = [data[0].x, data[0].y, data[0].z];
	
				bone.scl = [data[2].x, data[2].y, data[2].z];
				bone.rotq = [data[1].x, data[1].y, data[1].z, data[1].w];
				list.push(bone);
	
				for (var i in node.nodes) {
	
					walk(node.sid, node.nodes[i], list);
				}
			};
	
			walk(-1, skeleton, list);
			return list;
		}
	
		//Move the vertices into the pose that is proper for the start of the animation
		function skinToBindPose(geometry, skeleton, skinController) {
	
			var bones = [];
			setupSkeleton(skeleton, bones, -1);
			setupSkinningMatrices(bones, skinController.skin);
			var v = new THREE.Vector3();
			var skinned = [];
	
			for (var i = 0; i < geometry.vertices.length; i++) {
	
				skinned.push(new THREE.Vector3());
			}
	
			for (i = 0; i < bones.length; i++) {
	
				if (bones[i].type != 'JOINT') continue;
	
				for (var j = 0; j < bones[i].weights.length; j++) {
	
					var w = bones[i].weights[j];
					var vidx = w.index;
					var weight = w.weight;
	
					var o = geometry.vertices[vidx];
					var s = skinned[vidx];
	
					v.x = o.x;
					v.y = o.y;
					v.z = o.z;
	
					v.applyMatrix4(bones[i].skinningMatrix);
	
					s.x += v.x * weight;
					s.y += v.y * weight;
					s.z += v.z * weight;
				}
			}
	
			for (var i = 0; i < geometry.vertices.length; i++) {
	
				geometry.vertices[i] = skinned[i];
			}
		}
	
		function applySkin(geometry, instanceCtrl, frame) {
	
			var skinController = controllers[instanceCtrl.url];
	
			frame = frame !== undefined ? frame : 40;
	
			if (!skinController || !skinController.skin) {
	
				console.log('ColladaLoader: Could not find skin controller.');
				return;
			}
	
			if (!instanceCtrl.skeleton || !instanceCtrl.skeleton.length) {
	
				console.log('ColladaLoader: Could not find the skeleton for the skin. ');
				return;
			}
	
			var animationBounds = calcAnimationBounds();
			var skeleton = visualScene.getChildById(instanceCtrl.skeleton[0], true) || visualScene.getChildBySid(instanceCtrl.skeleton[0], true);
	
			//flatten the skeleton into a list of bones
			var bonelist = flattenSkeleton(skeleton);
			var joints = skinController.skin.joints;
	
			//sort that list so that the order reflects the order in the joint list
			var sortedbones = [];
			for (var i = 0; i < joints.length; i++) {
	
				for (var j = 0; j < bonelist.length; j++) {
	
					if (bonelist[j].name === joints[i]) {
	
						sortedbones[i] = bonelist[j];
					}
				}
			}
	
			//hook up the parents by index instead of name
			for (var i = 0; i < sortedbones.length; i++) {
	
				for (var j = 0; j < sortedbones.length; j++) {
	
					if (sortedbones[i].parent === sortedbones[j].name) {
	
						sortedbones[i].parent = j;
					}
				}
			}
	
			var i, j, w, vidx, weight;
			var v = new THREE.Vector3(),
			    o,
			    s;
	
			// move vertices to bind shape
			for (i = 0; i < geometry.vertices.length; i++) {
				geometry.vertices[i].applyMatrix4(skinController.skin.bindShapeMatrix);
			}
	
			var skinIndices = [];
			var skinWeights = [];
			var weights = skinController.skin.weights;
	
			// hook up the skin weights
			// TODO - this might be a good place to choose greatest 4 weights
			for (var i = 0; i < weights.length; i++) {
	
				var indicies = new THREE.Vector4(weights[i][0] ? weights[i][0].joint : 0, weights[i][1] ? weights[i][1].joint : 0, weights[i][2] ? weights[i][2].joint : 0, weights[i][3] ? weights[i][3].joint : 0);
				var weight = new THREE.Vector4(weights[i][0] ? weights[i][0].weight : 0, weights[i][1] ? weights[i][1].weight : 0, weights[i][2] ? weights[i][2].weight : 0, weights[i][3] ? weights[i][3].weight : 0);
	
				skinIndices.push(indicies);
				skinWeights.push(weight);
			}
	
			geometry.skinIndices = skinIndices;
			geometry.skinWeights = skinWeights;
			geometry.bones = sortedbones;
			// process animation, or simply pose the rig if no animation
	
			//create an animation for the animated bones
			//NOTE: this has no effect when using morphtargets
			var animationdata = { "name": animationBounds.ID, "fps": 30, "length": animationBounds.frames / 30, "hierarchy": [] };
	
			for (var j = 0; j < sortedbones.length; j++) {
	
				animationdata.hierarchy.push({ parent: sortedbones[j].parent, name: sortedbones[j].name, keys: [] });
			}
	
			console.log('ColladaLoader:', animationBounds.ID + ' has ' + sortedbones.length + ' bones.');
	
			skinToBindPose(geometry, skeleton, skinController);
	
			for (frame = 0; frame < animationBounds.frames; frame++) {
	
				var bones = [];
				var skinned = [];
				// process the frame and setup the rig with a fresh
				// transform, possibly from the bone's animation channel(s)
	
				setupSkeleton(skeleton, bones, frame);
				setupSkinningMatrices(bones, skinController.skin);
	
				for (var i = 0; i < bones.length; i++) {
	
					for (var j = 0; j < animationdata.hierarchy.length; j++) {
	
						if (animationdata.hierarchy[j].name === bones[i].sid) {
	
							var key = {};
							key.time = frame / 30;
							key.matrix = bones[i].animatrix;
	
							if (frame === 0) bones[i].matrix = key.matrix;
	
							var data = [new THREE.Vector3(), new THREE.Quaternion(), new THREE.Vector3()];
							key.matrix.decompose(data[0], data[1], data[2]);
	
							key.pos = [data[0].x, data[0].y, data[0].z];
	
							key.scl = [data[2].x, data[2].y, data[2].z];
							key.rot = data[1];
	
							animationdata.hierarchy[j].keys.push(key);
						}
					}
				}
	
				geometry.animation = animationdata;
			}
		}
	
		function createKinematics() {
	
			if (kinematicsModel && kinematicsModel.joints.length === 0) {
				kinematics = undefined;
				return;
			}
	
			var jointMap = {};
	
			var _addToMap = function _addToMap(jointIndex, parentVisualElement) {
	
				var parentVisualElementId = parentVisualElement.getAttribute('id');
				var colladaNode = visualScene.getChildById(parentVisualElementId, true);
				var joint = kinematicsModel.joints[jointIndex];
	
				scene.traverse(function (node) {
	
					if (node.colladaId == parentVisualElementId) {
	
						jointMap[jointIndex] = {
							node: node,
							transforms: colladaNode.transforms,
							joint: joint,
							position: joint.zeroPosition
						};
					}
				});
			};
	
			kinematics = {
	
				joints: kinematicsModel && kinematicsModel.joints,
	
				getJointValue: function getJointValue(jointIndex) {
	
					var jointData = jointMap[jointIndex];
	
					if (jointData) {
	
						return jointData.position;
					} else {
	
						console.log('getJointValue: joint ' + jointIndex + ' doesn\'t exist');
					}
				},
	
				setJointValue: function setJointValue(jointIndex, value) {
	
					var jointData = jointMap[jointIndex];
	
					if (jointData) {
	
						var joint = jointData.joint;
	
						if (value > joint.limits.max || value < joint.limits.min) {
	
							console.log('setJointValue: joint ' + jointIndex + ' value ' + value + ' outside of limits (min: ' + joint.limits.min + ', max: ' + joint.limits.max + ')');
						} else if (joint.static) {
	
							console.log('setJointValue: joint ' + jointIndex + ' is static');
						} else {
	
							var threejsNode = jointData.node;
							var axis = joint.axis;
							var transforms = jointData.transforms;
	
							var matrix = new THREE.Matrix4();
	
							for (i = 0; i < transforms.length; i++) {
	
								var transform = transforms[i];
	
								// kinda ghetto joint detection
								if (transform.sid && transform.sid.indexOf('joint' + jointIndex) !== -1) {
	
									// apply actual joint value here
									switch (joint.type) {
	
										case 'revolute':
	
											matrix.multiply(m1.makeRotationAxis(axis, THREE.Math.degToRad(value)));
											break;
	
										case 'prismatic':
	
											matrix.multiply(m1.makeTranslation(axis.x * value, axis.y * value, axis.z * value));
											break;
	
										default:
	
											console.warn('setJointValue: unknown joint type: ' + joint.type);
											break;
	
									}
								} else {
	
									var m1 = new THREE.Matrix4();
	
									switch (transform.type) {
	
										case 'matrix':
	
											matrix.multiply(transform.obj);
	
											break;
	
										case 'translate':
	
											matrix.multiply(m1.makeTranslation(transform.obj.x, transform.obj.y, transform.obj.z));
	
											break;
	
										case 'rotate':
	
											matrix.multiply(m1.makeRotationAxis(transform.obj, transform.angle));
	
											break;
	
									}
								}
							}
	
							// apply the matrix to the threejs node
							var elementsFloat32Arr = matrix.elements;
							var elements = Array.prototype.slice.call(elementsFloat32Arr);
	
							var elementsRowMajor = [elements[0], elements[4], elements[8], elements[12], elements[1], elements[5], elements[9], elements[13], elements[2], elements[6], elements[10], elements[14], elements[3], elements[7], elements[11], elements[15]];
	
							threejsNode.matrix.set.apply(threejsNode.matrix, elementsRowMajor);
							threejsNode.matrix.decompose(threejsNode.position, threejsNode.quaternion, threejsNode.scale);
						}
					} else {
	
						console.log('setJointValue: joint ' + jointIndex + ' doesn\'t exist');
					}
				}
	
			};
	
			var element = COLLADA.querySelector('scene instance_kinematics_scene');
	
			if (element) {
	
				for (var i = 0; i < element.childNodes.length; i++) {
	
					var child = element.childNodes[i];
	
					if (child.nodeType != 1) continue;
	
					switch (child.nodeName) {
	
						case 'bind_joint_axis':
	
							var visualTarget = child.getAttribute('target').split('/').pop();
							var axis = child.querySelector('axis param').textContent;
							var jointIndex = parseInt(axis.split('joint').pop().split('.')[0]);
							var visualTargetElement = COLLADA.querySelector('[sid="' + visualTarget + '"]');
	
							if (visualTargetElement) {
								var parentVisualElement = visualTargetElement.parentElement;
								_addToMap(jointIndex, parentVisualElement);
							}
	
							break;
	
						default:
	
							break;
	
					}
				}
			}
		}
	
		function createSceneGraph(node, parent) {
	
			var obj = new THREE.Object3D();
			var skinned = false;
			var skinController;
			var morphController;
			var i, j;
	
			// FIXME: controllers
	
			for (i = 0; i < node.controllers.length; i++) {
	
				var controller = controllers[node.controllers[i].url];
	
				switch (controller.type) {
	
					case 'skin':
	
						if (geometries[controller.skin.source]) {
	
							var inst_geom = new InstanceGeometry();
	
							inst_geom.url = controller.skin.source;
							inst_geom.instance_material = node.controllers[i].instance_material;
	
							node.geometries.push(inst_geom);
							skinned = true;
							skinController = node.controllers[i];
						} else if (controllers[controller.skin.source]) {
	
							// urgh: controller can be chained
							// handle the most basic case...
	
							var second = controllers[controller.skin.source];
							morphController = second;
							//	skinController = node.controllers[i];
	
							if (second.morph && geometries[second.morph.source]) {
	
								var inst_geom = new InstanceGeometry();
	
								inst_geom.url = second.morph.source;
								inst_geom.instance_material = node.controllers[i].instance_material;
	
								node.geometries.push(inst_geom);
							}
						}
	
						break;
	
					case 'morph':
	
						if (geometries[controller.morph.source]) {
	
							var inst_geom = new InstanceGeometry();
	
							inst_geom.url = controller.morph.source;
							inst_geom.instance_material = node.controllers[i].instance_material;
	
							node.geometries.push(inst_geom);
							morphController = node.controllers[i];
						}
	
						console.log('ColladaLoader: Morph-controller partially supported.');
	
					default:
						break;
	
				}
			}
	
			// geometries
	
			var double_sided_materials = {};
	
			for (i = 0; i < node.geometries.length; i++) {
	
				var instance_geometry = node.geometries[i];
				var instance_materials = instance_geometry.instance_material;
				var geometry = geometries[instance_geometry.url];
				var used_materials = {};
				var used_materials_array = [];
				var num_materials = 0;
				var first_material;
	
				if (geometry) {
	
					if (!geometry.mesh || !geometry.mesh.primitives) continue;
	
					if (obj.name.length === 0) {
	
						obj.name = geometry.id;
					}
	
					// collect used fx for this geometry-instance
	
					if (instance_materials) {
	
						for (j = 0; j < instance_materials.length; j++) {
	
							var instance_material = instance_materials[j];
							var mat = materials[instance_material.target];
							var effect_id = mat.instance_effect.url;
							var shader = effects[effect_id].shader;
							var material3js = shader.material;
	
							if (geometry.doubleSided) {
	
								if (!(instance_material.symbol in double_sided_materials)) {
	
									var _copied_material = material3js.clone();
									_copied_material.side = THREE.DoubleSide;
									double_sided_materials[instance_material.symbol] = _copied_material;
								}
	
								material3js = double_sided_materials[instance_material.symbol];
							}
	
							material3js.opacity = !material3js.opacity ? 1 : material3js.opacity;
							used_materials[instance_material.symbol] = num_materials;
							used_materials_array.push(material3js);
							first_material = material3js;
							first_material.name = mat.name === null || mat.name === '' ? mat.id : mat.name;
							num_materials++;
						}
					}
	
					var mesh;
					var material = first_material || new THREE.MeshLambertMaterial({ color: 0xdddddd, side: geometry.doubleSided ? THREE.DoubleSide : THREE.FrontSide });
					var geom = geometry.mesh.geometry3js;
	
					if (num_materials > 1) {
	
						material = new THREE.MultiMaterial(used_materials_array);
	
						for (j = 0; j < geom.faces.length; j++) {
	
							var face = geom.faces[j];
							face.materialIndex = used_materials[face.daeMaterial];
						}
					}
	
					if (skinController !== undefined) {
	
						applySkin(geom, skinController);
	
						if (geom.morphTargets.length > 0) {
	
							material.morphTargets = true;
							material.skinning = false;
						} else {
	
							material.morphTargets = false;
							material.skinning = true;
						}
	
						mesh = new THREE.SkinnedMesh(geom, material, false);
	
						//mesh.skeleton = skinController.skeleton;
						//mesh.skinController = controllers[ skinController.url ];
						//mesh.skinInstanceController = skinController;
						mesh.name = 'skin_' + skins.length;
	
						//mesh.animationHandle.setKey(0);
						skins.push(mesh);
					} else if (morphController !== undefined) {
	
						createMorph(geom, morphController);
	
						material.morphTargets = true;
	
						mesh = new THREE.Mesh(geom, material);
						mesh.name = 'morph_' + morphs.length;
	
						morphs.push(mesh);
					} else {
	
						if (geom.isLineStrip === true) {
	
							mesh = new THREE.Line(geom);
						} else {
	
							mesh = new THREE.Mesh(geom, material);
						}
					}
	
					obj.add(mesh);
				}
			}
	
			for (i = 0; i < node.cameras.length; i++) {
	
				var instance_camera = node.cameras[i];
				var cparams = cameras[instance_camera.url];
	
				var cam = new THREE.PerspectiveCamera(cparams.yfov, parseFloat(cparams.aspect_ratio), parseFloat(cparams.znear), parseFloat(cparams.zfar));
	
				obj.add(cam);
			}
	
			for (i = 0; i < node.lights.length; i++) {
	
				var light = null;
				var instance_light = node.lights[i];
				var lparams = lights[instance_light.url];
	
				if (lparams && lparams.technique) {
	
					var color = lparams.color.getHex();
					var intensity = lparams.intensity;
					var distance = lparams.distance;
					var angle = lparams.falloff_angle;
	
					switch (lparams.technique) {
	
						case 'directional':
	
							light = new THREE.DirectionalLight(color, intensity, distance);
							light.position.set(0, 0, 1);
							break;
	
						case 'point':
	
							light = new THREE.PointLight(color, intensity, distance);
							break;
	
						case 'spot':
	
							light = new THREE.SpotLight(color, intensity, distance, angle);
							light.position.set(0, 0, 1);
							break;
	
						case 'ambient':
	
							light = new THREE.AmbientLight(color);
							break;
	
					}
				}
	
				if (light) {
					obj.add(light);
				}
			}
	
			obj.name = node.name || node.id || "";
			obj.colladaId = node.id || "";
			obj.layer = node.layer || "";
			obj.matrix = node.matrix;
			obj.matrix.decompose(obj.position, obj.quaternion, obj.scale);
	
			if (options.centerGeometry && obj.geometry) {
	
				var delta = obj.geometry.center();
				delta.multiply(obj.scale);
				delta.applyQuaternion(obj.quaternion);
	
				obj.position.sub(delta);
			}
	
			for (i = 0; i < node.nodes.length; i++) {
	
				obj.add(createSceneGraph(node.nodes[i], node));
			}
	
			return obj;
		}
	
		function getJointId(skin, id) {
	
			for (var i = 0; i < skin.joints.length; i++) {
	
				if (skin.joints[i] === id) {
	
					return i;
				}
			}
		}
	
		function getLibraryNode(id) {
	
			var nodes = COLLADA.querySelectorAll('library_nodes node');
	
			for (var i = 0; i < nodes.length; i++) {
	
				var attObj = nodes[i].attributes.getNamedItem('id');
	
				if (attObj && attObj.value === id) {
	
					return nodes[i];
				}
			}
	
			return undefined;
		}
	
		function getChannelsForNode(node) {
	
			var channels = [];
			var startTime = 1000000;
			var endTime = -1000000;
	
			for (var id in animations) {
	
				var animation = animations[id];
	
				for (var i = 0; i < animation.channel.length; i++) {
	
					var channel = animation.channel[i];
					var sampler = animation.sampler[i];
					var id = channel.target.split('/')[0];
	
					if (id == node.id) {
	
						sampler.create();
						channel.sampler = sampler;
						startTime = Math.min(startTime, sampler.startTime);
						endTime = Math.max(endTime, sampler.endTime);
						channels.push(channel);
					}
				}
			}
	
			if (channels.length) {
	
				node.startTime = startTime;
				node.endTime = endTime;
			}
	
			return channels;
		}
	
		function calcFrameDuration(node) {
	
			var minT = 10000000;
	
			for (var i = 0; i < node.channels.length; i++) {
	
				var sampler = node.channels[i].sampler;
	
				for (var j = 0; j < sampler.input.length - 1; j++) {
	
					var t0 = sampler.input[j];
					var t1 = sampler.input[j + 1];
					minT = Math.min(minT, t1 - t0);
				}
			}
	
			return minT;
		}
	
		function calcMatrixAt(node, t) {
	
			var animated = {};
	
			var i, j;
	
			for (i = 0; i < node.channels.length; i++) {
	
				var channel = node.channels[i];
				animated[channel.sid] = channel;
			}
	
			var matrix = new THREE.Matrix4();
	
			for (i = 0; i < node.transforms.length; i++) {
	
				var transform = node.transforms[i];
				var channel = animated[transform.sid];
	
				if (channel !== undefined) {
	
					var sampler = channel.sampler;
					var value;
	
					for (j = 0; j < sampler.input.length - 1; j++) {
	
						if (sampler.input[j + 1] > t) {
	
							value = sampler.output[j];
							//console.log(value.flatten)
							break;
						}
					}
	
					if (value !== undefined) {
	
						if (value instanceof THREE.Matrix4) {
	
							matrix.multiplyMatrices(matrix, value);
						} else {
	
							// FIXME: handle other types
	
							matrix.multiplyMatrices(matrix, transform.matrix);
						}
					} else {
	
						matrix.multiplyMatrices(matrix, transform.matrix);
					}
				} else {
	
					matrix.multiplyMatrices(matrix, transform.matrix);
				}
			}
	
			return matrix;
		}
	
		function bakeAnimations(node) {
	
			if (node.channels && node.channels.length) {
	
				var keys = [],
				    sids = [];
	
				for (var i = 0, il = node.channels.length; i < il; i++) {
	
					var channel = node.channels[i],
					    fullSid = channel.fullSid,
					    sampler = channel.sampler,
					    input = sampler.input,
					    transform = node.getTransformBySid(channel.sid),
					    member;
	
					if (channel.arrIndices) {
	
						member = [];
	
						for (var j = 0, jl = channel.arrIndices.length; j < jl; j++) {
	
							member[j] = getConvertedIndex(channel.arrIndices[j]);
						}
					} else {
	
						member = getConvertedMember(channel.member);
					}
	
					if (transform) {
	
						if (sids.indexOf(fullSid) === -1) {
	
							sids.push(fullSid);
						}
	
						for (var j = 0, jl = input.length; j < jl; j++) {
	
							var time = input[j],
							    data = sampler.getData(transform.type, j, member),
							    key = findKey(keys, time);
	
							if (!key) {
	
								key = new Key(time);
								var timeNdx = findTimeNdx(keys, time);
								keys.splice(timeNdx === -1 ? keys.length : timeNdx, 0, key);
							}
	
							key.addTarget(fullSid, transform, member, data);
						}
					} else {
	
						console.log('Could not find transform "' + channel.sid + '" in node ' + node.id);
					}
				}
	
				// post process
				for (var i = 0; i < sids.length; i++) {
	
					var sid = sids[i];
	
					for (var j = 0; j < keys.length; j++) {
	
						var key = keys[j];
	
						if (!key.hasTarget(sid)) {
	
							interpolateKeys(keys, key, j, sid);
						}
					}
				}
	
				node.keys = keys;
				node.sids = sids;
			}
		}
	
		function findKey(keys, time) {
	
			var retVal = null;
	
			for (var i = 0, il = keys.length; i < il && retVal === null; i++) {
	
				var key = keys[i];
	
				if (key.time === time) {
	
					retVal = key;
				} else if (key.time > time) {
	
					break;
				}
			}
	
			return retVal;
		}
	
		function findTimeNdx(keys, time) {
	
			var ndx = -1;
	
			for (var i = 0, il = keys.length; i < il && ndx === -1; i++) {
	
				var key = keys[i];
	
				if (key.time >= time) {
	
					ndx = i;
				}
			}
	
			return ndx;
		}
	
		function interpolateKeys(keys, key, ndx, fullSid) {
	
			var prevKey = getPrevKeyWith(keys, fullSid, ndx ? ndx - 1 : 0),
			    nextKey = getNextKeyWith(keys, fullSid, ndx + 1);
	
			if (prevKey && nextKey) {
	
				var scale = (key.time - prevKey.time) / (nextKey.time - prevKey.time),
				    prevTarget = prevKey.getTarget(fullSid),
				    nextData = nextKey.getTarget(fullSid).data,
				    prevData = prevTarget.data,
				    data;
	
				if (prevTarget.type === 'matrix') {
	
					data = prevData;
				} else if (prevData.length) {
	
					data = [];
	
					for (var i = 0; i < prevData.length; ++i) {
	
						data[i] = prevData[i] + (nextData[i] - prevData[i]) * scale;
					}
				} else {
	
					data = prevData + (nextData - prevData) * scale;
				}
	
				key.addTarget(fullSid, prevTarget.transform, prevTarget.member, data);
			}
		}
	
		// Get next key with given sid
	
		function getNextKeyWith(keys, fullSid, ndx) {
	
			for (; ndx < keys.length; ndx++) {
	
				var key = keys[ndx];
	
				if (key.hasTarget(fullSid)) {
	
					return key;
				}
			}
	
			return null;
		}
	
		// Get previous key with given sid
	
		function getPrevKeyWith(keys, fullSid, ndx) {
	
			ndx = ndx >= 0 ? ndx : ndx + keys.length;
	
			for (; ndx >= 0; ndx--) {
	
				var key = keys[ndx];
	
				if (key.hasTarget(fullSid)) {
	
					return key;
				}
			}
	
			return null;
		}
	
		function _Image() {
	
			this.id = "";
			this.init_from = "";
		}
	
		_Image.prototype.parse = function (element) {
	
			this.id = element.getAttribute('id');
	
			for (var i = 0; i < element.childNodes.length; i++) {
	
				var child = element.childNodes[i];
	
				if (child.nodeName === 'init_from') {
	
					this.init_from = child.textContent;
				}
			}
	
			return this;
		};
	
		function Controller() {
	
			this.id = "";
			this.name = "";
			this.type = "";
			this.skin = null;
			this.morph = null;
		}
	
		Controller.prototype.parse = function (element) {
	
			this.id = element.getAttribute('id');
			this.name = element.getAttribute('name');
			this.type = "none";
	
			for (var i = 0; i < element.childNodes.length; i++) {
	
				var child = element.childNodes[i];
	
				switch (child.nodeName) {
	
					case 'skin':
	
						this.skin = new Skin().parse(child);
						this.type = child.nodeName;
						break;
	
					case 'morph':
	
						this.morph = new Morph().parse(child);
						this.type = child.nodeName;
						break;
	
					default:
						break;
	
				}
			}
	
			return this;
		};
	
		function Morph() {
	
			this.method = null;
			this.source = null;
			this.targets = null;
			this.weights = null;
		}
	
		Morph.prototype.parse = function (element) {
	
			var sources = {};
			var inputs = [];
			var i;
	
			this.method = element.getAttribute('method');
			this.source = element.getAttribute('source').replace(/^#/, '');
	
			for (i = 0; i < element.childNodes.length; i++) {
	
				var child = element.childNodes[i];
				if (child.nodeType != 1) continue;
	
				switch (child.nodeName) {
	
					case 'source':
	
						var source = new Source().parse(child);
						sources[source.id] = source;
						break;
	
					case 'targets':
	
						inputs = this.parseInputs(child);
						break;
	
					default:
	
						console.log(child.nodeName);
						break;
	
				}
			}
	
			for (i = 0; i < inputs.length; i++) {
	
				var input = inputs[i];
				var source = sources[input.source];
	
				switch (input.semantic) {
	
					case 'MORPH_TARGET':
	
						this.targets = source.read();
						break;
	
					case 'MORPH_WEIGHT':
	
						this.weights = source.read();
						break;
	
					default:
						break;
	
				}
			}
	
			return this;
		};
	
		Morph.prototype.parseInputs = function (element) {
	
			var inputs = [];
	
			for (var i = 0; i < element.childNodes.length; i++) {
	
				var child = element.childNodes[i];
				if (child.nodeType != 1) continue;
	
				switch (child.nodeName) {
	
					case 'input':
	
						inputs.push(new Input().parse(child));
						break;
	
					default:
						break;
				}
			}
	
			return inputs;
		};
	
		function Skin() {
	
			this.source = "";
			this.bindShapeMatrix = null;
			this.invBindMatrices = [];
			this.joints = [];
			this.weights = [];
		}
	
		Skin.prototype.parse = function (element) {
	
			var sources = {};
			var joints, weights;
	
			this.source = element.getAttribute('source').replace(/^#/, '');
			this.invBindMatrices = [];
			this.joints = [];
			this.weights = [];
	
			for (var i = 0; i < element.childNodes.length; i++) {
	
				var child = element.childNodes[i];
				if (child.nodeType != 1) continue;
	
				switch (child.nodeName) {
	
					case 'bind_shape_matrix':
	
						var f = _floats(child.textContent);
						this.bindShapeMatrix = getConvertedMat4(f);
						break;
	
					case 'source':
	
						var src = new Source().parse(child);
						sources[src.id] = src;
						break;
	
					case 'joints':
	
						joints = child;
						break;
	
					case 'vertex_weights':
	
						weights = child;
						break;
	
					default:
	
						console.log(child.nodeName);
						break;
	
				}
			}
	
			this.parseJoints(joints, sources);
			this.parseWeights(weights, sources);
	
			return this;
		};
	
		Skin.prototype.parseJoints = function (element, sources) {
	
			for (var i = 0; i < element.childNodes.length; i++) {
	
				var child = element.childNodes[i];
				if (child.nodeType != 1) continue;
	
				switch (child.nodeName) {
	
					case 'input':
	
						var input = new Input().parse(child);
						var source = sources[input.source];
	
						if (input.semantic === 'JOINT') {
	
							this.joints = source.read();
						} else if (input.semantic === 'INV_BIND_MATRIX') {
	
							this.invBindMatrices = source.read();
						}
	
						break;
	
					default:
						break;
				}
			}
		};
	
		Skin.prototype.parseWeights = function (element, sources) {
	
			var v,
			    vcount,
			    inputs = [];
	
			for (var i = 0; i < element.childNodes.length; i++) {
	
				var child = element.childNodes[i];
				if (child.nodeType != 1) continue;
	
				switch (child.nodeName) {
	
					case 'input':
	
						inputs.push(new Input().parse(child));
						break;
	
					case 'v':
	
						v = _ints(child.textContent);
						break;
	
					case 'vcount':
	
						vcount = _ints(child.textContent);
						break;
	
					default:
						break;
	
				}
			}
	
			var index = 0;
	
			for (var i = 0; i < vcount.length; i++) {
	
				var numBones = vcount[i];
				var vertex_weights = [];
	
				for (var j = 0; j < numBones; j++) {
	
					var influence = {};
	
					for (var k = 0; k < inputs.length; k++) {
	
						var input = inputs[k];
						var value = v[index + input.offset];
	
						switch (input.semantic) {
	
							case 'JOINT':
	
								influence.joint = value; //this.joints[value];
								break;
	
							case 'WEIGHT':
	
								influence.weight = sources[input.source].data[value];
								break;
	
							default:
								break;
	
						}
					}
	
					vertex_weights.push(influence);
					index += inputs.length;
				}
	
				for (var j = 0; j < vertex_weights.length; j++) {
	
					vertex_weights[j].index = i;
				}
	
				this.weights.push(vertex_weights);
			}
		};
	
		function VisualScene() {
	
			this.id = "";
			this.name = "";
			this.nodes = [];
			this.scene = new THREE.Group();
		}
	
		VisualScene.prototype.getChildById = function (id, recursive) {
	
			for (var i = 0; i < this.nodes.length; i++) {
	
				var node = this.nodes[i].getChildById(id, recursive);
	
				if (node) {
	
					return node;
				}
			}
	
			return null;
		};
	
		VisualScene.prototype.getChildBySid = function (sid, recursive) {
	
			for (var i = 0; i < this.nodes.length; i++) {
	
				var node = this.nodes[i].getChildBySid(sid, recursive);
	
				if (node) {
	
					return node;
				}
			}
	
			return null;
		};
	
		VisualScene.prototype.parse = function (element) {
	
			this.id = element.getAttribute('id');
			this.name = element.getAttribute('name');
			this.nodes = [];
	
			for (var i = 0; i < element.childNodes.length; i++) {
	
				var child = element.childNodes[i];
				if (child.nodeType != 1) continue;
	
				switch (child.nodeName) {
	
					case 'node':
	
						this.nodes.push(new Node().parse(child));
						break;
	
					default:
						break;
	
				}
			}
	
			return this;
		};
	
		function Node() {
	
			this.id = "";
			this.name = "";
			this.sid = "";
			this.nodes = [];
			this.controllers = [];
			this.transforms = [];
			this.geometries = [];
			this.channels = [];
			this.matrix = new THREE.Matrix4();
		}
	
		Node.prototype.getChannelForTransform = function (transformSid) {
	
			for (var i = 0; i < this.channels.length; i++) {
	
				var channel = this.channels[i];
				var parts = channel.target.split('/');
				var id = parts.shift();
				var sid = parts.shift();
				var dotSyntax = sid.indexOf(".") >= 0;
				var arrSyntax = sid.indexOf("(") >= 0;
				var arrIndices;
				var member;
	
				if (dotSyntax) {
	
					parts = sid.split(".");
					sid = parts.shift();
					member = parts.shift();
				} else if (arrSyntax) {
	
					arrIndices = sid.split("(");
					sid = arrIndices.shift();
	
					for (var j = 0; j < arrIndices.length; j++) {
	
						arrIndices[j] = parseInt(arrIndices[j].replace(/\)/, ''));
					}
				}
	
				if (sid === transformSid) {
	
					channel.info = { sid: sid, dotSyntax: dotSyntax, arrSyntax: arrSyntax, arrIndices: arrIndices };
					return channel;
				}
			}
	
			return null;
		};
	
		Node.prototype.getChildById = function (id, recursive) {
	
			if (this.id === id) {
	
				return this;
			}
	
			if (recursive) {
	
				for (var i = 0; i < this.nodes.length; i++) {
	
					var n = this.nodes[i].getChildById(id, recursive);
	
					if (n) {
	
						return n;
					}
				}
			}
	
			return null;
		};
	
		Node.prototype.getChildBySid = function (sid, recursive) {
	
			if (this.sid === sid) {
	
				return this;
			}
	
			if (recursive) {
	
				for (var i = 0; i < this.nodes.length; i++) {
	
					var n = this.nodes[i].getChildBySid(sid, recursive);
	
					if (n) {
	
						return n;
					}
				}
			}
	
			return null;
		};
	
		Node.prototype.getTransformBySid = function (sid) {
	
			for (var i = 0; i < this.transforms.length; i++) {
	
				if (this.transforms[i].sid === sid) return this.transforms[i];
			}
	
			return null;
		};
	
		Node.prototype.parse = function (element) {
	
			var url;
	
			this.id = element.getAttribute('id');
			this.sid = element.getAttribute('sid');
			this.name = element.getAttribute('name');
			this.type = element.getAttribute('type');
			this.layer = element.getAttribute('layer');
	
			this.type = this.type === 'JOINT' ? this.type : 'NODE';
	
			this.nodes = [];
			this.transforms = [];
			this.geometries = [];
			this.cameras = [];
			this.lights = [];
			this.controllers = [];
			this.matrix = new THREE.Matrix4();
	
			for (var i = 0; i < element.childNodes.length; i++) {
	
				var child = element.childNodes[i];
				if (child.nodeType != 1) continue;
	
				switch (child.nodeName) {
	
					case 'node':
	
						this.nodes.push(new Node().parse(child));
						break;
	
					case 'instance_camera':
	
						this.cameras.push(new InstanceCamera().parse(child));
						break;
	
					case 'instance_controller':
	
						this.controllers.push(new InstanceController().parse(child));
						break;
	
					case 'instance_geometry':
	
						this.geometries.push(new InstanceGeometry().parse(child));
						break;
	
					case 'instance_light':
	
						this.lights.push(new InstanceLight().parse(child));
						break;
	
					case 'instance_node':
	
						url = child.getAttribute('url').replace(/^#/, '');
						var iNode = getLibraryNode(url);
	
						if (iNode) {
	
							this.nodes.push(new Node().parse(iNode));
						}
	
						break;
	
					case 'rotate':
					case 'translate':
					case 'scale':
					case 'matrix':
					case 'lookat':
					case 'skew':
	
						this.transforms.push(new Transform().parse(child));
						break;
	
					case 'extra':
						break;
	
					default:
	
						console.log(child.nodeName);
						break;
	
				}
			}
	
			this.channels = getChannelsForNode(this);
			bakeAnimations(this);
	
			this.updateMatrix();
	
			return this;
		};
	
		Node.prototype.updateMatrix = function () {
	
			this.matrix.identity();
	
			for (var i = 0; i < this.transforms.length; i++) {
	
				this.transforms[i].apply(this.matrix);
			}
		};
	
		function Transform() {
	
			this.sid = "";
			this.type = "";
			this.data = [];
			this.obj = null;
		}
	
		Transform.prototype.parse = function (element) {
	
			this.sid = element.getAttribute('sid');
			this.type = element.nodeName;
			this.data = _floats(element.textContent);
			this.convert();
	
			return this;
		};
	
		Transform.prototype.convert = function () {
	
			switch (this.type) {
	
				case 'matrix':
	
					this.obj = getConvertedMat4(this.data);
					break;
	
				case 'rotate':
	
					this.angle = THREE.Math.degToRad(this.data[3]);
	
				case 'translate':
	
					fixCoords(this.data, -1);
					this.obj = new THREE.Vector3(this.data[0], this.data[1], this.data[2]);
					break;
	
				case 'scale':
	
					fixCoords(this.data, 1);
					this.obj = new THREE.Vector3(this.data[0], this.data[1], this.data[2]);
					break;
	
				default:
					console.log('Can not convert Transform of type ' + this.type);
					break;
	
			}
		};
	
		Transform.prototype.apply = function () {
	
			var m1 = new THREE.Matrix4();
	
			return function (matrix) {
	
				switch (this.type) {
	
					case 'matrix':
	
						matrix.multiply(this.obj);
	
						break;
	
					case 'translate':
	
						matrix.multiply(m1.makeTranslation(this.obj.x, this.obj.y, this.obj.z));
	
						break;
	
					case 'rotate':
	
						matrix.multiply(m1.makeRotationAxis(this.obj, this.angle));
	
						break;
	
					case 'scale':
	
						matrix.scale(this.obj);
	
						break;
	
				}
			};
		}();
	
		Transform.prototype.update = function (data, member) {
	
			var members = ['X', 'Y', 'Z', 'ANGLE'];
	
			switch (this.type) {
	
				case 'matrix':
	
					if (!member) {
	
						this.obj.copy(data);
					} else if (member.length === 1) {
	
						switch (member[0]) {
	
							case 0:
	
								this.obj.n11 = data[0];
								this.obj.n21 = data[1];
								this.obj.n31 = data[2];
								this.obj.n41 = data[3];
	
								break;
	
							case 1:
	
								this.obj.n12 = data[0];
								this.obj.n22 = data[1];
								this.obj.n32 = data[2];
								this.obj.n42 = data[3];
	
								break;
	
							case 2:
	
								this.obj.n13 = data[0];
								this.obj.n23 = data[1];
								this.obj.n33 = data[2];
								this.obj.n43 = data[3];
	
								break;
	
							case 3:
	
								this.obj.n14 = data[0];
								this.obj.n24 = data[1];
								this.obj.n34 = data[2];
								this.obj.n44 = data[3];
	
								break;
	
						}
					} else if (member.length === 2) {
	
						var propName = 'n' + (member[0] + 1) + (member[1] + 1);
						this.obj[propName] = data;
					} else {
	
						console.log('Incorrect addressing of matrix in transform.');
					}
	
					break;
	
				case 'translate':
				case 'scale':
	
					if (Object.prototype.toString.call(member) === '[object Array]') {
	
						member = members[member[0]];
					}
	
					switch (member) {
	
						case 'X':
	
							this.obj.x = data;
							break;
	
						case 'Y':
	
							this.obj.y = data;
							break;
	
						case 'Z':
	
							this.obj.z = data;
							break;
	
						default:
	
							this.obj.x = data[0];
							this.obj.y = data[1];
							this.obj.z = data[2];
							break;
	
					}
	
					break;
	
				case 'rotate':
	
					if (Object.prototype.toString.call(member) === '[object Array]') {
	
						member = members[member[0]];
					}
	
					switch (member) {
	
						case 'X':
	
							this.obj.x = data;
							break;
	
						case 'Y':
	
							this.obj.y = data;
							break;
	
						case 'Z':
	
							this.obj.z = data;
							break;
	
						case 'ANGLE':
	
							this.angle = THREE.Math.degToRad(data);
							break;
	
						default:
	
							this.obj.x = data[0];
							this.obj.y = data[1];
							this.obj.z = data[2];
							this.angle = THREE.Math.degToRad(data[3]);
							break;
	
					}
					break;
	
			}
		};
	
		function InstanceController() {
	
			this.url = "";
			this.skeleton = [];
			this.instance_material = [];
		}
	
		InstanceController.prototype.parse = function (element) {
	
			this.url = element.getAttribute('url').replace(/^#/, '');
			this.skeleton = [];
			this.instance_material = [];
	
			for (var i = 0; i < element.childNodes.length; i++) {
	
				var child = element.childNodes[i];
				if (child.nodeType !== 1) continue;
	
				switch (child.nodeName) {
	
					case 'skeleton':
	
						this.skeleton.push(child.textContent.replace(/^#/, ''));
						break;
	
					case 'bind_material':
	
						var instances = child.querySelectorAll('instance_material');
	
						for (var j = 0; j < instances.length; j++) {
	
							var instance = instances[j];
							this.instance_material.push(new InstanceMaterial().parse(instance));
						}
	
						break;
	
					case 'extra':
						break;
	
					default:
						break;
	
				}
			}
	
			return this;
		};
	
		function InstanceMaterial() {
	
			this.symbol = "";
			this.target = "";
		}
	
		InstanceMaterial.prototype.parse = function (element) {
	
			this.symbol = element.getAttribute('symbol');
			this.target = element.getAttribute('target').replace(/^#/, '');
			return this;
		};
	
		function InstanceGeometry() {
	
			this.url = "";
			this.instance_material = [];
		}
	
		InstanceGeometry.prototype.parse = function (element) {
	
			this.url = element.getAttribute('url').replace(/^#/, '');
			this.instance_material = [];
	
			for (var i = 0; i < element.childNodes.length; i++) {
	
				var child = element.childNodes[i];
				if (child.nodeType != 1) continue;
	
				if (child.nodeName === 'bind_material') {
	
					var instances = child.querySelectorAll('instance_material');
	
					for (var j = 0; j < instances.length; j++) {
	
						var instance = instances[j];
						this.instance_material.push(new InstanceMaterial().parse(instance));
					}
	
					break;
				}
			}
	
			return this;
		};
	
		function Geometry() {
	
			this.id = "";
			this.mesh = null;
		}
	
		Geometry.prototype.parse = function (element) {
	
			this.id = element.getAttribute('id');
	
			extractDoubleSided(this, element);
	
			for (var i = 0; i < element.childNodes.length; i++) {
	
				var child = element.childNodes[i];
	
				switch (child.nodeName) {
	
					case 'mesh':
	
						this.mesh = new Mesh(this).parse(child);
						break;
	
					case 'extra':
	
						// console.log( child );
						break;
	
					default:
						break;
				}
			}
	
			return this;
		};
	
		function Mesh(geometry) {
	
			this.geometry = geometry.id;
			this.primitives = [];
			this.vertices = null;
			this.geometry3js = null;
		}
	
		Mesh.prototype.parse = function (element) {
	
			this.primitives = [];
	
			for (var i = 0; i < element.childNodes.length; i++) {
	
				var child = element.childNodes[i];
	
				switch (child.nodeName) {
	
					case 'source':
	
						_source(child);
						break;
	
					case 'vertices':
	
						this.vertices = new Vertices().parse(child);
						break;
	
					case 'linestrips':
	
						this.primitives.push(new LineStrips().parse(child));
						break;
	
					case 'triangles':
	
						this.primitives.push(new Triangles().parse(child));
						break;
	
					case 'polygons':
	
						this.primitives.push(new Polygons().parse(child));
						break;
	
					case 'polylist':
	
						this.primitives.push(new Polylist().parse(child));
						break;
	
					default:
						break;
	
				}
			}
	
			this.geometry3js = new THREE.Geometry();
	
			if (this.vertices === null) {
	
				// TODO (mrdoob): Study case when this is null (carrier.dae)
	
				return this;
			}
	
			var vertexData = sources[this.vertices.input['POSITION'].source].data;
	
			for (var i = 0; i < vertexData.length; i += 3) {
	
				this.geometry3js.vertices.push(getConvertedVec3(vertexData, i).clone());
			}
	
			for (var i = 0; i < this.primitives.length; i++) {
	
				var primitive = this.primitives[i];
				primitive.setVertices(this.vertices);
				this.handlePrimitive(primitive, this.geometry3js);
			}
	
			if (this.geometry3js.calcNormals) {
	
				this.geometry3js.computeVertexNormals();
				delete this.geometry3js.calcNormals;
			}
	
			return this;
		};
	
		Mesh.prototype.handlePrimitive = function (primitive, geom) {
	
			if (primitive instanceof LineStrips) {
	
				// TODO: Handle indices. Maybe easier with BufferGeometry?
	
				geom.isLineStrip = true;
				return;
			}
	
			var j,
			    k,
			    pList = primitive.p,
			    inputs = primitive.inputs;
			var input, index, idx32;
			var source, numParams;
			var vcIndex = 0,
			    vcount = 3,
			    maxOffset = 0;
			var texture_sets = [];
	
			for (j = 0; j < inputs.length; j++) {
	
				input = inputs[j];
	
				var offset = input.offset + 1;
				maxOffset = maxOffset < offset ? offset : maxOffset;
	
				switch (input.semantic) {
	
					case 'TEXCOORD':
						texture_sets.push(input.set);
						break;
	
				}
			}
	
			for (var pCount = 0; pCount < pList.length; ++pCount) {
	
				var p = pList[pCount],
				    i = 0;
	
				while (i < p.length) {
	
					var vs = [];
					var ns = [];
					var ts = null;
					var cs = [];
	
					if (primitive.vcount) {
	
						vcount = primitive.vcount.length ? primitive.vcount[vcIndex++] : primitive.vcount;
					} else {
	
						vcount = p.length / maxOffset;
					}
	
					for (j = 0; j < vcount; j++) {
	
						for (k = 0; k < inputs.length; k++) {
	
							input = inputs[k];
							source = sources[input.source];
	
							index = p[i + j * maxOffset + input.offset];
							numParams = source.accessor.params.length;
							idx32 = index * numParams;
	
							switch (input.semantic) {
	
								case 'VERTEX':
	
									vs.push(index);
	
									break;
	
								case 'NORMAL':
	
									ns.push(getConvertedVec3(source.data, idx32));
	
									break;
	
								case 'TEXCOORD':
	
									ts = ts || {};
									if (ts[input.set] === undefined) ts[input.set] = [];
									// invert the V
									ts[input.set].push(new THREE.Vector2(source.data[idx32], source.data[idx32 + 1]));
	
									break;
	
								case 'COLOR':
	
									cs.push(new THREE.Color().setRGB(source.data[idx32], source.data[idx32 + 1], source.data[idx32 + 2]));
	
									break;
	
								default:
	
									break;
	
							}
						}
					}
	
					if (ns.length === 0) {
	
						// check the vertices inputs
						input = this.vertices.input.NORMAL;
	
						if (input) {
	
							source = sources[input.source];
							numParams = source.accessor.params.length;
	
							for (var ndx = 0, len = vs.length; ndx < len; ndx++) {
	
								ns.push(getConvertedVec3(source.data, vs[ndx] * numParams));
							}
						} else {
	
							geom.calcNormals = true;
						}
					}
	
					if (!ts) {
	
						ts = {};
						// check the vertices inputs
						input = this.vertices.input.TEXCOORD;
	
						if (input) {
	
							texture_sets.push(input.set);
							source = sources[input.source];
							numParams = source.accessor.params.length;
	
							for (var ndx = 0, len = vs.length; ndx < len; ndx++) {
	
								idx32 = vs[ndx] * numParams;
								if (ts[input.set] === undefined) ts[input.set] = [];
								// invert the V
								ts[input.set].push(new THREE.Vector2(source.data[idx32], 1.0 - source.data[idx32 + 1]));
							}
						}
					}
	
					if (cs.length === 0) {
	
						// check the vertices inputs
						input = this.vertices.input.COLOR;
	
						if (input) {
	
							source = sources[input.source];
							numParams = source.accessor.params.length;
	
							for (var ndx = 0, len = vs.length; ndx < len; ndx++) {
	
								idx32 = vs[ndx] * numParams;
								cs.push(new THREE.Color().setRGB(source.data[idx32], source.data[idx32 + 1], source.data[idx32 + 2]));
							}
						}
					}
	
					var face = null,
					    faces = [],
					    uv,
					    uvArr;
	
					if (vcount === 3) {
	
						faces.push(new THREE.Face3(vs[0], vs[1], vs[2], ns, cs.length ? cs : new THREE.Color()));
					} else if (vcount === 4) {
	
						faces.push(new THREE.Face3(vs[0], vs[1], vs[3], ns.length ? [ns[0].clone(), ns[1].clone(), ns[3].clone()] : [], cs.length ? [cs[0], cs[1], cs[3]] : new THREE.Color()));
	
						faces.push(new THREE.Face3(vs[1], vs[2], vs[3], ns.length ? [ns[1].clone(), ns[2].clone(), ns[3].clone()] : [], cs.length ? [cs[1], cs[2], cs[3]] : new THREE.Color()));
					} else if (vcount > 4 && options.subdivideFaces) {
	
						var clr = cs.length ? cs : new THREE.Color(),
						    vec1,
						    vec2,
						    vec3,
						    v1,
						    v2,
						    norm;
	
						// subdivide into multiple Face3s
	
						for (k = 1; k < vcount - 1;) {
	
							faces.push(new THREE.Face3(vs[0], vs[k], vs[k + 1], ns.length ? [ns[0].clone(), ns[k++].clone(), ns[k].clone()] : [], clr));
						}
					}
	
					if (faces.length) {
	
						for (var ndx = 0, len = faces.length; ndx < len; ndx++) {
	
							face = faces[ndx];
							face.daeMaterial = primitive.material;
							geom.faces.push(face);
	
							for (k = 0; k < texture_sets.length; k++) {
	
								uv = ts[texture_sets[k]];
	
								if (vcount > 4) {
	
									// Grab the right UVs for the vertices in this face
									uvArr = [uv[0], uv[ndx + 1], uv[ndx + 2]];
								} else if (vcount === 4) {
	
									if (ndx === 0) {
	
										uvArr = [uv[0], uv[1], uv[3]];
									} else {
	
										uvArr = [uv[1].clone(), uv[2], uv[3].clone()];
									}
								} else {
	
									uvArr = [uv[0], uv[1], uv[2]];
								}
	
								if (geom.faceVertexUvs[k] === undefined) {
	
									geom.faceVertexUvs[k] = [];
								}
	
								geom.faceVertexUvs[k].push(uvArr);
							}
						}
					} else {
	
						console.log('dropped face with vcount ' + vcount + ' for geometry with id: ' + geom.id);
					}
	
					i += maxOffset * vcount;
				}
			}
		};
	
		function Polygons() {
	
			this.material = "";
			this.count = 0;
			this.inputs = [];
			this.vcount = null;
			this.p = [];
			this.geometry = new THREE.Geometry();
		}
	
		Polygons.prototype.setVertices = function (vertices) {
	
			for (var i = 0; i < this.inputs.length; i++) {
	
				if (this.inputs[i].source === vertices.id) {
	
					this.inputs[i].source = vertices.input['POSITION'].source;
				}
			}
		};
	
		Polygons.prototype.parse = function (element) {
	
			this.material = element.getAttribute('material');
			this.count = _attr_as_int(element, 'count', 0);
	
			for (var i = 0; i < element.childNodes.length; i++) {
	
				var child = element.childNodes[i];
	
				switch (child.nodeName) {
	
					case 'input':
	
						this.inputs.push(new Input().parse(element.childNodes[i]));
						break;
	
					case 'vcount':
	
						this.vcount = _ints(child.textContent);
						break;
	
					case 'p':
	
						this.p.push(_ints(child.textContent));
						break;
	
					case 'ph':
	
						console.warn('polygon holes not yet supported!');
						break;
	
					default:
						break;
	
				}
			}
	
			return this;
		};
	
		function Polylist() {
	
			Polygons.call(this);
	
			this.vcount = [];
		}
	
		Polylist.prototype = Object.create(Polygons.prototype);
		Polylist.prototype.constructor = Polylist;
	
		function LineStrips() {
	
			Polygons.call(this);
	
			this.vcount = 1;
		}
	
		LineStrips.prototype = Object.create(Polygons.prototype);
		LineStrips.prototype.constructor = LineStrips;
	
		function Triangles() {
	
			Polygons.call(this);
	
			this.vcount = 3;
		}
	
		Triangles.prototype = Object.create(Polygons.prototype);
		Triangles.prototype.constructor = Triangles;
	
		function Accessor() {
	
			this.source = "";
			this.count = 0;
			this.stride = 0;
			this.params = [];
		}
	
		Accessor.prototype.parse = function (element) {
	
			this.params = [];
			this.source = element.getAttribute('source');
			this.count = _attr_as_int(element, 'count', 0);
			this.stride = _attr_as_int(element, 'stride', 0);
	
			for (var i = 0; i < element.childNodes.length; i++) {
	
				var child = element.childNodes[i];
	
				if (child.nodeName === 'param') {
	
					var param = {};
					param['name'] = child.getAttribute('name');
					param['type'] = child.getAttribute('type');
					this.params.push(param);
				}
			}
	
			return this;
		};
	
		function Vertices() {
	
			this.input = {};
		}
	
		Vertices.prototype.parse = function (element) {
	
			this.id = element.getAttribute('id');
	
			for (var i = 0; i < element.childNodes.length; i++) {
	
				if (element.childNodes[i].nodeName === 'input') {
	
					var input = new Input().parse(element.childNodes[i]);
					this.input[input.semantic] = input;
				}
			}
	
			return this;
		};
	
		function Input() {
	
			this.semantic = "";
			this.offset = 0;
			this.source = "";
			this.set = 0;
		}
	
		Input.prototype.parse = function (element) {
	
			this.semantic = element.getAttribute('semantic');
			this.source = element.getAttribute('source').replace(/^#/, '');
			this.set = _attr_as_int(element, 'set', -1);
			this.offset = _attr_as_int(element, 'offset', 0);
	
			if (this.semantic === 'TEXCOORD' && this.set < 0) {
	
				this.set = 0;
			}
	
			return this;
		};
	
		function Source(id) {
	
			this.id = id;
			this.type = null;
		}
	
		Source.prototype.parse = function (element) {
	
			this.id = element.getAttribute('id');
	
			for (var i = 0; i < element.childNodes.length; i++) {
	
				var child = element.childNodes[i];
	
				switch (child.nodeName) {
	
					case 'bool_array':
	
						this.data = _bools(child.textContent);
						this.type = child.nodeName;
						break;
	
					case 'float_array':
	
						this.data = _floats(child.textContent);
						this.type = child.nodeName;
						break;
	
					case 'int_array':
	
						this.data = _ints(child.textContent);
						this.type = child.nodeName;
						break;
	
					case 'IDREF_array':
					case 'Name_array':
	
						this.data = _strings(child.textContent);
						this.type = child.nodeName;
						break;
	
					case 'technique_common':
	
						for (var j = 0; j < child.childNodes.length; j++) {
	
							if (child.childNodes[j].nodeName === 'accessor') {
	
								this.accessor = new Accessor().parse(child.childNodes[j]);
								break;
							}
						}
						break;
	
					default:
						// console.log(child.nodeName);
						break;
	
				}
			}
	
			return this;
		};
	
		Source.prototype.read = function () {
	
			var result = [];
	
			//for (var i = 0; i < this.accessor.params.length; i++) {
	
			var param = this.accessor.params[0];
	
			//console.log(param.name + " " + param.type);
	
			switch (param.type) {
	
				case 'IDREF':
				case 'Name':case 'name':
				case 'float':
	
					return this.data;
	
				case 'float4x4':
	
					for (var j = 0; j < this.data.length; j += 16) {
	
						var s = this.data.slice(j, j + 16);
						var m = getConvertedMat4(s);
						result.push(m);
					}
	
					break;
	
				default:
	
					console.log('ColladaLoader: Source: Read dont know how to read ' + param.type + '.');
					break;
	
			}
	
			//}
	
			return result;
		};
	
		function Material() {
	
			this.id = "";
			this.name = "";
			this.instance_effect = null;
		}
	
		Material.prototype.parse = function (element) {
	
			this.id = element.getAttribute('id');
			this.name = element.getAttribute('name');
	
			for (var i = 0; i < element.childNodes.length; i++) {
	
				if (element.childNodes[i].nodeName === 'instance_effect') {
	
					this.instance_effect = new InstanceEffect().parse(element.childNodes[i]);
					break;
				}
			}
	
			return this;
		};
	
		function ColorOrTexture() {
	
			this.color = new THREE.Color();
			this.color.setRGB(Math.random(), Math.random(), Math.random());
			this.color.a = 1.0;
	
			this.texture = null;
			this.texcoord = null;
			this.texOpts = null;
		}
	
		ColorOrTexture.prototype.isColor = function () {
	
			return this.texture === null;
		};
	
		ColorOrTexture.prototype.isTexture = function () {
	
			return this.texture != null;
		};
	
		ColorOrTexture.prototype.parse = function (element) {
	
			if (element.nodeName === 'transparent') {
	
				this.opaque = element.getAttribute('opaque');
			}
	
			for (var i = 0; i < element.childNodes.length; i++) {
	
				var child = element.childNodes[i];
				if (child.nodeType != 1) continue;
	
				switch (child.nodeName) {
	
					case 'color':
	
						var rgba = _floats(child.textContent);
						this.color = new THREE.Color();
						this.color.setRGB(rgba[0], rgba[1], rgba[2]);
						this.color.a = rgba[3];
						break;
	
					case 'texture':
	
						this.texture = child.getAttribute('texture');
						this.texcoord = child.getAttribute('texcoord');
						// Defaults from:
						// https://collada.org/mediawiki/index.php/Maya_texture_placement_MAYA_extension
						this.texOpts = {
							offsetU: 0,
							offsetV: 0,
							repeatU: 1,
							repeatV: 1,
							wrapU: 1,
							wrapV: 1
						};
						this.parseTexture(child);
						break;
	
					default:
						break;
	
				}
			}
	
			return this;
		};
	
		ColorOrTexture.prototype.parseTexture = function (element) {
	
			if (!element.childNodes) return this;
	
			// This should be supported by Maya, 3dsMax, and MotionBuilder
	
			if (element.childNodes[1] && element.childNodes[1].nodeName === 'extra') {
	
				element = element.childNodes[1];
	
				if (element.childNodes[1] && element.childNodes[1].nodeName === 'technique') {
	
					element = element.childNodes[1];
				}
			}
	
			for (var i = 0; i < element.childNodes.length; i++) {
	
				var child = element.childNodes[i];
	
				switch (child.nodeName) {
	
					case 'offsetU':
					case 'offsetV':
					case 'repeatU':
					case 'repeatV':
	
						this.texOpts[child.nodeName] = parseFloat(child.textContent);
	
						break;
	
					case 'wrapU':
					case 'wrapV':
	
						// some dae have a value of true which becomes NaN via parseInt
	
						if (child.textContent.toUpperCase() === 'TRUE') {
	
							this.texOpts[child.nodeName] = 1;
						} else {
	
							this.texOpts[child.nodeName] = parseInt(child.textContent);
						}
						break;
	
					default:
	
						this.texOpts[child.nodeName] = child.textContent;
	
						break;
	
				}
			}
	
			return this;
		};
	
		function Shader(type, effect) {
	
			this.type = type;
			this.effect = effect;
			this.material = null;
		}
	
		Shader.prototype.parse = function (element) {
	
			for (var i = 0; i < element.childNodes.length; i++) {
	
				var child = element.childNodes[i];
				if (child.nodeType != 1) continue;
	
				switch (child.nodeName) {
	
					case 'emission':
					case 'diffuse':
					case 'specular':
					case 'transparent':
	
						this[child.nodeName] = new ColorOrTexture().parse(child);
						break;
	
					case 'bump':
	
						// If 'bumptype' is 'heightfield', create a 'bump' property
						// Else if 'bumptype' is 'normalmap', create a 'normal' property
						// (Default to 'bump')
						var bumpType = child.getAttribute('bumptype');
						if (bumpType) {
							if (bumpType.toLowerCase() === "heightfield") {
								this['bump'] = new ColorOrTexture().parse(child);
							} else if (bumpType.toLowerCase() === "normalmap") {
								this['normal'] = new ColorOrTexture().parse(child);
							} else {
								console.error("Shader.prototype.parse: Invalid value for attribute 'bumptype' (" + bumpType + ") - valid bumptypes are 'HEIGHTFIELD' and 'NORMALMAP' - defaulting to 'HEIGHTFIELD'");
								this['bump'] = new ColorOrTexture().parse(child);
							}
						} else {
							console.warn("Shader.prototype.parse: Attribute 'bumptype' missing from bump node - defaulting to 'HEIGHTFIELD'");
							this['bump'] = new ColorOrTexture().parse(child);
						}
	
						break;
	
					case 'shininess':
					case 'reflectivity':
					case 'index_of_refraction':
					case 'transparency':
	
						var f = child.querySelectorAll('float');
	
						if (f.length > 0) this[child.nodeName] = parseFloat(f[0].textContent);
	
						break;
	
					default:
						break;
	
				}
			}
	
			this.create();
			return this;
		};
	
		Shader.prototype.create = function () {
	
			var props = {};
	
			var transparent = false;
	
			if (this['transparency'] !== undefined && this['transparent'] !== undefined) {
				// convert transparent color RBG to average value
				var transparentColor = this['transparent'];
				var transparencyLevel = (this.transparent.color.r + this.transparent.color.g + this.transparent.color.b) / 3 * this.transparency;
	
				if (transparencyLevel > 0) {
					transparent = true;
					props['transparent'] = true;
					props['opacity'] = 1 - transparencyLevel;
				}
			}
	
			var keys = {
				'diffuse': 'map',
				'ambient': 'lightMap',
				'specular': 'specularMap',
				'emission': 'emissionMap',
				'bump': 'bumpMap',
				'normal': 'normalMap'
			};
	
			for (var prop in this) {
	
				switch (prop) {
	
					case 'ambient':
					case 'emission':
					case 'diffuse':
					case 'specular':
					case 'bump':
					case 'normal':
	
						var cot = this[prop];
	
						if (cot instanceof ColorOrTexture) {
	
							if (cot.isTexture()) {
	
								var samplerId = cot.texture;
								var surfaceId = this.effect.sampler[samplerId];
	
								if (surfaceId !== undefined && surfaceId.source !== undefined) {
	
									var surface = this.effect.surface[surfaceId.source];
	
									if (surface !== undefined) {
	
										var image = images[surface.init_from];
	
										if (image) {
	
											var url = baseUrl + image.init_from;
	
											var texture;
											var loader = THREE.Loader.Handlers.get(url);
	
											if (loader !== null) {
	
												texture = loader.load(url);
											} else {
	
												texture = new THREE.Texture();
	
												loadTextureImage(texture, url);
											}
	
											texture.wrapS = cot.texOpts.wrapU ? THREE.RepeatWrapping : THREE.ClampToEdgeWrapping;
											texture.wrapT = cot.texOpts.wrapV ? THREE.RepeatWrapping : THREE.ClampToEdgeWrapping;
											texture.offset.x = cot.texOpts.offsetU;
											texture.offset.y = cot.texOpts.offsetV;
											texture.repeat.x = cot.texOpts.repeatU;
											texture.repeat.y = cot.texOpts.repeatV;
											props[keys[prop]] = texture;
	
											// Texture with baked lighting?
											if (prop === 'emission') props['emissive'] = 0xffffff;
										}
									}
								}
							} else if (prop === 'diffuse' || !transparent) {
	
								if (prop === 'emission') {
	
									props['emissive'] = cot.color.getHex();
								} else {
	
									props[prop] = cot.color.getHex();
								}
							}
						}
	
						break;
	
					case 'shininess':
	
						props[prop] = this[prop];
						break;
	
					case 'reflectivity':
	
						props[prop] = this[prop];
						if (props[prop] > 0.0) props['envMap'] = options.defaultEnvMap;
						props['combine'] = THREE.MixOperation; //mix regular shading with reflective component
						break;
	
					case 'index_of_refraction':
	
						props['refractionRatio'] = this[prop]; //TODO: "index_of_refraction" becomes "refractionRatio" in shader, but I'm not sure if the two are actually comparable
						if (this[prop] !== 1.0) props['envMap'] = options.defaultEnvMap;
						break;
	
					case 'transparency':
						// gets figured out up top
						break;
	
					default:
						break;
	
				}
			}
	
			props['shading'] = preferredShading;
			props['side'] = this.effect.doubleSided ? THREE.DoubleSide : THREE.FrontSide;
	
			if (props.diffuse !== undefined) {
	
				props.color = props.diffuse;
				delete props.diffuse;
			}
	
			switch (this.type) {
	
				case 'constant':
	
					if (props.emissive != undefined) props.color = props.emissive;
					this.material = new THREE.MeshBasicMaterial(props);
					break;
	
				case 'phong':
				case 'blinn':
	
					this.material = new THREE.MeshBasicMaterial(props);
					// this.material = new THREE.MeshPhongMaterial( props );
					break;
	
				case 'lambert':
				default:
	
					this.material = new THREE.MeshLambertMaterial(props);
					break;
	
			}
	
			return this.material;
		};
	
		function Surface(effect) {
	
			this.effect = effect;
			this.init_from = null;
			this.format = null;
		}
	
		Surface.prototype.parse = function (element) {
	
			for (var i = 0; i < element.childNodes.length; i++) {
	
				var child = element.childNodes[i];
				if (child.nodeType != 1) continue;
	
				switch (child.nodeName) {
	
					case 'init_from':
	
						this.init_from = child.textContent;
						break;
	
					case 'format':
	
						this.format = child.textContent;
						break;
	
					default:
	
						console.log("unhandled Surface prop: " + child.nodeName);
						break;
	
				}
			}
	
			return this;
		};
	
		function Sampler2D(effect) {
	
			this.effect = effect;
			this.source = null;
			this.wrap_s = null;
			this.wrap_t = null;
			this.minfilter = null;
			this.magfilter = null;
			this.mipfilter = null;
		}
	
		Sampler2D.prototype.parse = function (element) {
	
			for (var i = 0; i < element.childNodes.length; i++) {
	
				var child = element.childNodes[i];
				if (child.nodeType != 1) continue;
	
				switch (child.nodeName) {
	
					case 'source':
	
						this.source = child.textContent;
						break;
	
					case 'minfilter':
	
						this.minfilter = child.textContent;
						break;
	
					case 'magfilter':
	
						this.magfilter = child.textContent;
						break;
	
					case 'mipfilter':
	
						this.mipfilter = child.textContent;
						break;
	
					case 'wrap_s':
	
						this.wrap_s = child.textContent;
						break;
	
					case 'wrap_t':
	
						this.wrap_t = child.textContent;
						break;
	
					default:
	
						console.log("unhandled Sampler2D prop: " + child.nodeName);
						break;
	
				}
			}
	
			return this;
		};
	
		function Effect() {
	
			this.id = "";
			this.name = "";
			this.shader = null;
			this.surface = {};
			this.sampler = {};
		}
	
		Effect.prototype.create = function () {
	
			if (this.shader === null) {
	
				return null;
			}
		};
	
		Effect.prototype.parse = function (element) {
	
			this.id = element.getAttribute('id');
			this.name = element.getAttribute('name');
	
			extractDoubleSided(this, element);
	
			this.shader = null;
	
			for (var i = 0; i < element.childNodes.length; i++) {
	
				var child = element.childNodes[i];
				if (child.nodeType != 1) continue;
	
				switch (child.nodeName) {
	
					case 'profile_COMMON':
	
						this.parseTechnique(this.parseProfileCOMMON(child));
						break;
	
					default:
						break;
	
				}
			}
	
			return this;
		};
	
		Effect.prototype.parseNewparam = function (element) {
	
			var sid = element.getAttribute('sid');
	
			for (var i = 0; i < element.childNodes.length; i++) {
	
				var child = element.childNodes[i];
				if (child.nodeType != 1) continue;
	
				switch (child.nodeName) {
	
					case 'surface':
	
						this.surface[sid] = new Surface(this).parse(child);
						break;
	
					case 'sampler2D':
	
						this.sampler[sid] = new Sampler2D(this).parse(child);
						break;
	
					case 'extra':
	
						break;
	
					default:
	
						console.log(child.nodeName);
						break;
	
				}
			}
		};
	
		Effect.prototype.parseProfileCOMMON = function (element) {
	
			var technique;
	
			for (var i = 0; i < element.childNodes.length; i++) {
	
				var child = element.childNodes[i];
	
				if (child.nodeType != 1) continue;
	
				switch (child.nodeName) {
	
					case 'profile_COMMON':
	
						this.parseProfileCOMMON(child);
						break;
	
					case 'technique':
	
						technique = child;
						break;
	
					case 'newparam':
	
						this.parseNewparam(child);
						break;
	
					case 'image':
	
						var _image = new _Image().parse(child);
						images[_image.id] = _image;
						break;
	
					case 'extra':
						break;
	
					default:
	
						console.log(child.nodeName);
						break;
	
				}
			}
	
			return technique;
		};
	
		Effect.prototype.parseTechnique = function (element) {
	
			for (var i = 0; i < element.childNodes.length; i++) {
	
				var child = element.childNodes[i];
				if (child.nodeType != 1) continue;
	
				switch (child.nodeName) {
	
					case 'constant':
					case 'lambert':
					case 'blinn':
					case 'phong':
	
						this.shader = new Shader(child.nodeName, this).parse(child);
						break;
					case 'extra':
						this.parseExtra(child);
						break;
					default:
						break;
	
				}
			}
		};
	
		Effect.prototype.parseExtra = function (element) {
	
			for (var i = 0; i < element.childNodes.length; i++) {
	
				var child = element.childNodes[i];
				if (child.nodeType != 1) continue;
	
				switch (child.nodeName) {
	
					case 'technique':
						this.parseExtraTechnique(child);
						break;
					default:
						break;
	
				}
			}
		};
	
		Effect.prototype.parseExtraTechnique = function (element) {
	
			for (var i = 0; i < element.childNodes.length; i++) {
	
				var child = element.childNodes[i];
				if (child.nodeType != 1) continue;
	
				switch (child.nodeName) {
	
					case 'bump':
						this.shader.parse(element);
						break;
					default:
						break;
	
				}
			}
		};
	
		function InstanceEffect() {
	
			this.url = "";
		}
	
		InstanceEffect.prototype.parse = function (element) {
	
			this.url = element.getAttribute('url').replace(/^#/, '');
			return this;
		};
	
		function Animation() {
	
			this.id = "";
			this.name = "";
			this.source = {};
			this.sampler = [];
			this.channel = [];
		}
	
		Animation.prototype.parse = function (element) {
	
			this.id = element.getAttribute('id');
			this.name = element.getAttribute('name');
			this.source = {};
	
			for (var i = 0; i < element.childNodes.length; i++) {
	
				var child = element.childNodes[i];
	
				if (child.nodeType != 1) continue;
	
				switch (child.nodeName) {
	
					case 'animation':
	
						var anim = new Animation().parse(child);
	
						for (var src in anim.source) {
	
							this.source[src] = anim.source[src];
						}
	
						for (var j = 0; j < anim.channel.length; j++) {
	
							this.channel.push(anim.channel[j]);
							this.sampler.push(anim.sampler[j]);
						}
	
						break;
	
					case 'source':
	
						var src = new Source().parse(child);
						this.source[src.id] = src;
						break;
	
					case 'sampler':
	
						this.sampler.push(new Sampler(this).parse(child));
						break;
	
					case 'channel':
	
						this.channel.push(new Channel(this).parse(child));
						break;
	
					default:
						break;
	
				}
			}
	
			return this;
		};
	
		function Channel(animation) {
	
			this.animation = animation;
			this.source = "";
			this.target = "";
			this.fullSid = null;
			this.sid = null;
			this.dotSyntax = null;
			this.arrSyntax = null;
			this.arrIndices = null;
			this.member = null;
		}
	
		Channel.prototype.parse = function (element) {
	
			this.source = element.getAttribute('source').replace(/^#/, '');
			this.target = element.getAttribute('target');
	
			var parts = this.target.split('/');
	
			var id = parts.shift();
			var sid = parts.shift();
	
			var dotSyntax = sid.indexOf(".") >= 0;
			var arrSyntax = sid.indexOf("(") >= 0;
	
			if (dotSyntax) {
	
				parts = sid.split(".");
				this.sid = parts.shift();
				this.member = parts.shift();
			} else if (arrSyntax) {
	
				var arrIndices = sid.split("(");
				this.sid = arrIndices.shift();
	
				for (var j = 0; j < arrIndices.length; j++) {
	
					arrIndices[j] = parseInt(arrIndices[j].replace(/\)/, ''));
				}
	
				this.arrIndices = arrIndices;
			} else {
	
				this.sid = sid;
			}
	
			this.fullSid = sid;
			this.dotSyntax = dotSyntax;
			this.arrSyntax = arrSyntax;
	
			return this;
		};
	
		function Sampler(animation) {
	
			this.id = "";
			this.animation = animation;
			this.inputs = [];
			this.input = null;
			this.output = null;
			this.strideOut = null;
			this.interpolation = null;
			this.startTime = null;
			this.endTime = null;
			this.duration = 0;
		}
	
		Sampler.prototype.parse = function (element) {
	
			this.id = element.getAttribute('id');
			this.inputs = [];
	
			for (var i = 0; i < element.childNodes.length; i++) {
	
				var child = element.childNodes[i];
				if (child.nodeType != 1) continue;
	
				switch (child.nodeName) {
	
					case 'input':
	
						this.inputs.push(new Input().parse(child));
						break;
	
					default:
						break;
	
				}
			}
	
			return this;
		};
	
		Sampler.prototype.create = function () {
	
			for (var i = 0; i < this.inputs.length; i++) {
	
				var input = this.inputs[i];
				var source = this.animation.source[input.source];
	
				switch (input.semantic) {
	
					case 'INPUT':
	
						this.input = source.read();
						break;
	
					case 'OUTPUT':
	
						this.output = source.read();
						this.strideOut = source.accessor.stride;
						break;
	
					case 'INTERPOLATION':
	
						this.interpolation = source.read();
						break;
	
					case 'IN_TANGENT':
	
						break;
	
					case 'OUT_TANGENT':
	
						break;
	
					default:
	
						console.log(input.semantic);
						break;
	
				}
			}
	
			this.startTime = 0;
			this.endTime = 0;
			this.duration = 0;
	
			if (this.input.length) {
	
				this.startTime = 100000000;
				this.endTime = -100000000;
	
				for (var i = 0; i < this.input.length; i++) {
	
					this.startTime = Math.min(this.startTime, this.input[i]);
					this.endTime = Math.max(this.endTime, this.input[i]);
				}
	
				this.duration = this.endTime - this.startTime;
			}
		};
	
		Sampler.prototype.getData = function (type, ndx, member) {
	
			var data;
	
			if (type === 'matrix' && this.strideOut === 16) {
	
				data = this.output[ndx];
			} else if (this.strideOut > 1) {
	
				data = [];
				ndx *= this.strideOut;
	
				for (var i = 0; i < this.strideOut; ++i) {
	
					data[i] = this.output[ndx + i];
				}
	
				if (this.strideOut === 3) {
	
					switch (type) {
	
						case 'rotate':
						case 'translate':
	
							fixCoords(data, -1);
							break;
	
						case 'scale':
	
							fixCoords(data, 1);
							break;
	
					}
				} else if (this.strideOut === 4 && type === 'matrix') {
	
					fixCoords(data, -1);
				}
			} else {
	
				data = this.output[ndx];
	
				if (member && type === 'translate') {
					data = getConvertedTranslation(member, data);
				}
			}
	
			return data;
		};
	
		function Key(time) {
	
			this.targets = [];
			this.time = time;
		}
	
		Key.prototype.addTarget = function (fullSid, transform, member, data) {
	
			this.targets.push({
				sid: fullSid,
				member: member,
				transform: transform,
				data: data
			});
		};
	
		Key.prototype.apply = function (opt_sid) {
	
			for (var i = 0; i < this.targets.length; ++i) {
	
				var target = this.targets[i];
	
				if (!opt_sid || target.sid === opt_sid) {
	
					target.transform.update(target.data, target.member);
				}
			}
		};
	
		Key.prototype.getTarget = function (fullSid) {
	
			for (var i = 0; i < this.targets.length; ++i) {
	
				if (this.targets[i].sid === fullSid) {
	
					return this.targets[i];
				}
			}
	
			return null;
		};
	
		Key.prototype.hasTarget = function (fullSid) {
	
			for (var i = 0; i < this.targets.length; ++i) {
	
				if (this.targets[i].sid === fullSid) {
	
					return true;
				}
			}
	
			return false;
		};
	
		// TODO: Currently only doing linear interpolation. Should support full COLLADA spec.
		Key.prototype.interpolate = function (nextKey, time) {
	
			for (var i = 0, l = this.targets.length; i < l; i++) {
	
				var target = this.targets[i],
				    nextTarget = nextKey.getTarget(target.sid),
				    data;
	
				if (target.transform.type !== 'matrix' && nextTarget) {
	
					var scale = (time - this.time) / (nextKey.time - this.time),
					    nextData = nextTarget.data,
					    prevData = target.data;
	
					if (scale < 0) scale = 0;
					if (scale > 1) scale = 1;
	
					if (prevData.length) {
	
						data = [];
	
						for (var j = 0; j < prevData.length; ++j) {
	
							data[j] = prevData[j] + (nextData[j] - prevData[j]) * scale;
						}
					} else {
	
						data = prevData + (nextData - prevData) * scale;
					}
				} else {
	
					data = target.data;
				}
	
				target.transform.update(data, target.member);
			}
		};
	
		// Camera
		function Camera() {
	
			this.id = "";
			this.name = "";
			this.technique = "";
		}
	
		Camera.prototype.parse = function (element) {
	
			this.id = element.getAttribute('id');
			this.name = element.getAttribute('name');
	
			for (var i = 0; i < element.childNodes.length; i++) {
	
				var child = element.childNodes[i];
				if (child.nodeType != 1) continue;
	
				switch (child.nodeName) {
	
					case 'optics':
	
						this.parseOptics(child);
						break;
	
					default:
						break;
	
				}
			}
	
			return this;
		};
	
		Camera.prototype.parseOptics = function (element) {
	
			for (var i = 0; i < element.childNodes.length; i++) {
	
				if (element.childNodes[i].nodeName === 'technique_common') {
	
					var technique = element.childNodes[i];
	
					for (var j = 0; j < technique.childNodes.length; j++) {
	
						this.technique = technique.childNodes[j].nodeName;
	
						if (this.technique === 'perspective') {
	
							var perspective = technique.childNodes[j];
	
							for (var k = 0; k < perspective.childNodes.length; k++) {
	
								var param = perspective.childNodes[k];
	
								switch (param.nodeName) {
	
									case 'yfov':
										this.yfov = param.textContent;
										break;
									case 'xfov':
										this.xfov = param.textContent;
										break;
									case 'znear':
										this.znear = param.textContent;
										break;
									case 'zfar':
										this.zfar = param.textContent;
										break;
									case 'aspect_ratio':
										this.aspect_ratio = param.textContent;
										break;
	
								}
							}
						} else if (this.technique === 'orthographic') {
	
							var orthographic = technique.childNodes[j];
	
							for (var k = 0; k < orthographic.childNodes.length; k++) {
	
								var param = orthographic.childNodes[k];
	
								switch (param.nodeName) {
	
									case 'xmag':
										this.xmag = param.textContent;
										break;
									case 'ymag':
										this.ymag = param.textContent;
										break;
									case 'znear':
										this.znear = param.textContent;
										break;
									case 'zfar':
										this.zfar = param.textContent;
										break;
									case 'aspect_ratio':
										this.aspect_ratio = param.textContent;
										break;
	
								}
							}
						}
					}
				}
			}
	
			return this;
		};
	
		function InstanceCamera() {
	
			this.url = "";
		}
	
		InstanceCamera.prototype.parse = function (element) {
	
			this.url = element.getAttribute('url').replace(/^#/, '');
	
			return this;
		};
	
		// Light
	
		function Light() {
	
			this.id = "";
			this.name = "";
			this.technique = "";
		}
	
		Light.prototype.parse = function (element) {
	
			this.id = element.getAttribute('id');
			this.name = element.getAttribute('name');
	
			for (var i = 0; i < element.childNodes.length; i++) {
	
				var child = element.childNodes[i];
				if (child.nodeType != 1) continue;
	
				switch (child.nodeName) {
	
					case 'technique_common':
	
						this.parseCommon(child);
						break;
	
					case 'technique':
	
						this.parseTechnique(child);
						break;
	
					default:
						break;
	
				}
			}
	
			return this;
		};
	
		Light.prototype.parseCommon = function (element) {
	
			for (var i = 0; i < element.childNodes.length; i++) {
	
				switch (element.childNodes[i].nodeName) {
	
					case 'directional':
					case 'point':
					case 'spot':
					case 'ambient':
	
						this.technique = element.childNodes[i].nodeName;
	
						var light = element.childNodes[i];
	
						for (var j = 0; j < light.childNodes.length; j++) {
	
							var child = light.childNodes[j];
	
							switch (child.nodeName) {
	
								case 'color':
	
									var rgba = _floats(child.textContent);
									this.color = new THREE.Color(0);
									this.color.setRGB(rgba[0], rgba[1], rgba[2]);
									this.color.a = rgba[3];
									break;
	
								case 'falloff_angle':
	
									this.falloff_angle = parseFloat(child.textContent);
									break;
	
								case 'quadratic_attenuation':
									var f = parseFloat(child.textContent);
									this.distance = f ? Math.sqrt(1 / f) : 0;
							}
						}
	
				}
			}
	
			return this;
		};
	
		Light.prototype.parseTechnique = function (element) {
	
			this.profile = element.getAttribute('profile');
	
			for (var i = 0; i < element.childNodes.length; i++) {
	
				var child = element.childNodes[i];
	
				switch (child.nodeName) {
	
					case 'intensity':
	
						this.intensity = parseFloat(child.textContent);
						break;
	
				}
			}
	
			return this;
		};
	
		function InstanceLight() {
	
			this.url = "";
		}
	
		InstanceLight.prototype.parse = function (element) {
	
			this.url = element.getAttribute('url').replace(/^#/, '');
	
			return this;
		};
	
		function KinematicsModel() {
	
			this.id = '';
			this.name = '';
			this.joints = [];
			this.links = [];
		}
	
		KinematicsModel.prototype.parse = function (element) {
	
			this.id = element.getAttribute('id');
			this.name = element.getAttribute('name');
			this.joints = [];
			this.links = [];
	
			for (var i = 0; i < element.childNodes.length; i++) {
	
				var child = element.childNodes[i];
				if (child.nodeType != 1) continue;
	
				switch (child.nodeName) {
	
					case 'technique_common':
	
						this.parseCommon(child);
						break;
	
					default:
						break;
	
				}
			}
	
			return this;
		};
	
		KinematicsModel.prototype.parseCommon = function (element) {
	
			for (var i = 0; i < element.childNodes.length; i++) {
	
				var child = element.childNodes[i];
				if (child.nodeType != 1) continue;
	
				switch (element.childNodes[i].nodeName) {
	
					case 'joint':
						this.joints.push(new Joint().parse(child));
						break;
	
					case 'link':
						this.links.push(new Link().parse(child));
						break;
	
					default:
						break;
	
				}
			}
	
			return this;
		};
	
		function Joint() {
	
			this.sid = '';
			this.name = '';
			this.axis = new THREE.Vector3();
			this.limits = {
				min: 0,
				max: 0
			};
			this.type = '';
			this.static = false;
			this.zeroPosition = 0.0;
			this.middlePosition = 0.0;
		}
	
		Joint.prototype.parse = function (element) {
	
			this.sid = element.getAttribute('sid');
			this.name = element.getAttribute('name');
			this.axis = new THREE.Vector3();
			this.limits = {
				min: 0,
				max: 0
			};
			this.type = '';
			this.static = false;
			this.zeroPosition = 0.0;
			this.middlePosition = 0.0;
	
			var axisElement = element.querySelector('axis');
			var _axis = _floats(axisElement.textContent);
			this.axis = getConvertedVec3(_axis, 0);
	
			var min = element.querySelector('limits min') ? parseFloat(element.querySelector('limits min').textContent) : -360;
			var max = element.querySelector('limits max') ? parseFloat(element.querySelector('limits max').textContent) : 360;
	
			this.limits = {
				min: min,
				max: max
			};
	
			var jointTypes = ['prismatic', 'revolute'];
			for (var i = 0; i < jointTypes.length; i++) {
	
				var type = jointTypes[i];
	
				var jointElement = element.querySelector(type);
	
				if (jointElement) {
	
					this.type = type;
				}
			}
	
			// if the min is equal to or somehow greater than the max, consider the joint static
			if (this.limits.min >= this.limits.max) {
	
				this.static = true;
			}
	
			this.middlePosition = (this.limits.min + this.limits.max) / 2.0;
			return this;
		};
	
		function Link() {
	
			this.sid = '';
			this.name = '';
			this.transforms = [];
			this.attachments = [];
		}
	
		Link.prototype.parse = function (element) {
	
			this.sid = element.getAttribute('sid');
			this.name = element.getAttribute('name');
			this.transforms = [];
			this.attachments = [];
	
			for (var i = 0; i < element.childNodes.length; i++) {
	
				var child = element.childNodes[i];
				if (child.nodeType != 1) continue;
	
				switch (child.nodeName) {
	
					case 'attachment_full':
						this.attachments.push(new Attachment().parse(child));
						break;
	
					case 'rotate':
					case 'translate':
					case 'matrix':
	
						this.transforms.push(new Transform().parse(child));
						break;
	
					default:
	
						break;
	
				}
			}
	
			return this;
		};
	
		function Attachment() {
	
			this.joint = '';
			this.transforms = [];
			this.links = [];
		}
	
		Attachment.prototype.parse = function (element) {
	
			this.joint = element.getAttribute('joint').split('/').pop();
			this.links = [];
	
			for (var i = 0; i < element.childNodes.length; i++) {
	
				var child = element.childNodes[i];
				if (child.nodeType != 1) continue;
	
				switch (child.nodeName) {
	
					case 'link':
						this.links.push(new Link().parse(child));
						break;
	
					case 'rotate':
					case 'translate':
					case 'matrix':
	
						this.transforms.push(new Transform().parse(child));
						break;
	
					default:
	
						break;
	
				}
			}
	
			return this;
		};
	
		function _source(element) {
	
			var id = element.getAttribute('id');
	
			if (sources[id] != undefined) {
	
				return sources[id];
			}
	
			sources[id] = new Source(id).parse(element);
			return sources[id];
		}
	
		function _nsResolver(nsPrefix) {
	
			if (nsPrefix === "dae") {
	
				return "http://www.collada.org/2005/11/COLLADASchema";
			}
	
			return null;
		}
	
		function _bools(str) {
	
			var raw = _strings(str);
			var data = [];
	
			for (var i = 0, l = raw.length; i < l; i++) {
	
				data.push(raw[i] === 'true' || raw[i] === '1' ? true : false);
			}
	
			return data;
		}
	
		function _floats(str) {
	
			var raw = _strings(str);
			var data = [];
	
			for (var i = 0, l = raw.length; i < l; i++) {
	
				data.push(parseFloat(raw[i]));
			}
	
			return data;
		}
	
		function _ints(str) {
	
			var raw = _strings(str);
			var data = [];
	
			for (var i = 0, l = raw.length; i < l; i++) {
	
				data.push(parseInt(raw[i], 10));
			}
	
			return data;
		}
	
		function _strings(str) {
	
			return str.length > 0 ? _trimString(str).split(/\s+/) : [];
		}
	
		function _trimString(str) {
	
			return str.replace(/^\s+/, "").replace(/\s+$/, "");
		}
	
		function _attr_as_float(element, name, defaultValue) {
	
			if (element.hasAttribute(name)) {
	
				return parseFloat(element.getAttribute(name));
			} else {
	
				return defaultValue;
			}
		}
	
		function _attr_as_int(element, name, defaultValue) {
	
			if (element.hasAttribute(name)) {
	
				return parseInt(element.getAttribute(name), 10);
			} else {
	
				return defaultValue;
			}
		}
	
		function _attr_as_string(element, name, defaultValue) {
	
			if (element.hasAttribute(name)) {
	
				return element.getAttribute(name);
			} else {
	
				return defaultValue;
			}
		}
	
		function _format_float(f, num) {
	
			if (f === undefined) {
	
				var s = '0.';
	
				while (s.length < num + 2) {
	
					s += '0';
				}
	
				return s;
			}
	
			num = num || 2;
	
			var parts = f.toString().split('.');
			parts[1] = parts.length > 1 ? parts[1].substr(0, num) : "0";
	
			while (parts[1].length < num) {
	
				parts[1] += '0';
			}
	
			return parts.join('.');
		}
	
		function loadTextureImage(texture, url) {
	
			var loader = new THREE.ImageLoader();
	
			loader.load(url, function (image) {
	
				texture.image = image;
				texture.needsUpdate = true;
			});
		}
	
		function extractDoubleSided(obj, element) {
	
			obj.doubleSided = false;
	
			var node = element.querySelectorAll('extra double_sided')[0];
	
			if (node) {
	
				if (node && parseInt(node.textContent, 10) === 1) {
	
					obj.doubleSided = true;
				}
			}
		}
	
		// Up axis conversion
	
		function setUpConversion() {
	
			if (options.convertUpAxis !== true || colladaUp === options.upAxis) {
	
				upConversion = null;
			} else {
	
				switch (colladaUp) {
	
					case 'X':
	
						upConversion = options.upAxis === 'Y' ? 'XtoY' : 'XtoZ';
						break;
	
					case 'Y':
	
						upConversion = options.upAxis === 'X' ? 'YtoX' : 'YtoZ';
						break;
	
					case 'Z':
	
						upConversion = options.upAxis === 'X' ? 'ZtoX' : 'ZtoY';
						break;
	
				}
			}
		}
	
		function fixCoords(data, sign) {
	
			if (options.convertUpAxis !== true || colladaUp === options.upAxis) {
	
				return;
			}
	
			switch (upConversion) {
	
				case 'XtoY':
	
					var tmp = data[0];
					data[0] = sign * data[1];
					data[1] = tmp;
					break;
	
				case 'XtoZ':
	
					var tmp = data[2];
					data[2] = data[1];
					data[1] = data[0];
					data[0] = tmp;
					break;
	
				case 'YtoX':
	
					var tmp = data[0];
					data[0] = data[1];
					data[1] = sign * tmp;
					break;
	
				case 'YtoZ':
	
					var tmp = data[1];
					data[1] = sign * data[2];
					data[2] = tmp;
					break;
	
				case 'ZtoX':
	
					var tmp = data[0];
					data[0] = data[1];
					data[1] = data[2];
					data[2] = tmp;
					break;
	
				case 'ZtoY':
	
					var tmp = data[1];
					data[1] = data[2];
					data[2] = sign * tmp;
					break;
	
			}
		}
	
		function getConvertedTranslation(axis, data) {
	
			if (options.convertUpAxis !== true || colladaUp === options.upAxis) {
	
				return data;
			}
	
			switch (axis) {
				case 'X':
					data = upConversion === 'XtoY' ? data * -1 : data;
					break;
				case 'Y':
					data = upConversion === 'YtoZ' || upConversion === 'YtoX' ? data * -1 : data;
					break;
				case 'Z':
					data = upConversion === 'ZtoY' ? data * -1 : data;
					break;
				default:
					break;
			}
	
			return data;
		}
	
		function getConvertedVec3(data, offset) {
	
			var arr = [data[offset], data[offset + 1], data[offset + 2]];
			fixCoords(arr, -1);
			return new THREE.Vector3(arr[0], arr[1], arr[2]);
		}
	
		function getConvertedMat4(data) {
	
			if (options.convertUpAxis) {
	
				// First fix rotation and scale
	
				// Columns first
				var arr = [data[0], data[4], data[8]];
				fixCoords(arr, -1);
				data[0] = arr[0];
				data[4] = arr[1];
				data[8] = arr[2];
				arr = [data[1], data[5], data[9]];
				fixCoords(arr, -1);
				data[1] = arr[0];
				data[5] = arr[1];
				data[9] = arr[2];
				arr = [data[2], data[6], data[10]];
				fixCoords(arr, -1);
				data[2] = arr[0];
				data[6] = arr[1];
				data[10] = arr[2];
				// Rows second
				arr = [data[0], data[1], data[2]];
				fixCoords(arr, -1);
				data[0] = arr[0];
				data[1] = arr[1];
				data[2] = arr[2];
				arr = [data[4], data[5], data[6]];
				fixCoords(arr, -1);
				data[4] = arr[0];
				data[5] = arr[1];
				data[6] = arr[2];
				arr = [data[8], data[9], data[10]];
				fixCoords(arr, -1);
				data[8] = arr[0];
				data[9] = arr[1];
				data[10] = arr[2];
	
				// Now fix translation
				arr = [data[3], data[7], data[11]];
				fixCoords(arr, -1);
				data[3] = arr[0];
				data[7] = arr[1];
				data[11] = arr[2];
			}
	
			return new THREE.Matrix4().set(data[0], data[1], data[2], data[3], data[4], data[5], data[6], data[7], data[8], data[9], data[10], data[11], data[12], data[13], data[14], data[15]);
		}
	
		function getConvertedIndex(index) {
	
			if (index > -1 && index < 3) {
	
				var members = ['X', 'Y', 'Z'],
				    indices = { X: 0, Y: 1, Z: 2 };
	
				index = getConvertedMember(members[index]);
				index = indices[index];
			}
	
			return index;
		}
	
		function getConvertedMember(member) {
	
			if (options.convertUpAxis) {
	
				switch (member) {
	
					case 'X':
	
						switch (upConversion) {
	
							case 'XtoY':
							case 'XtoZ':
							case 'YtoX':
	
								member = 'Y';
								break;
	
							case 'ZtoX':
	
								member = 'Z';
								break;
	
						}
	
						break;
	
					case 'Y':
	
						switch (upConversion) {
	
							case 'XtoY':
							case 'YtoX':
							case 'ZtoX':
	
								member = 'X';
								break;
	
							case 'XtoZ':
							case 'YtoZ':
							case 'ZtoY':
	
								member = 'Z';
								break;
	
						}
	
						break;
	
					case 'Z':
	
						switch (upConversion) {
	
							case 'XtoZ':
	
								member = 'X';
								break;
	
							case 'YtoZ':
							case 'ZtoX':
							case 'ZtoY':
	
								member = 'Y';
								break;
	
						}
	
						break;
	
				}
			}
	
			return member;
		}
	
		return {
	
			load: load,
			parse: parse,
			setPreferredShading: setPreferredShading,
			applySkin: applySkin,
			geometries: geometries,
			options: options
	
		};
	};
	/* eslint-enable */
	/* eslint-disable */

/***/ }),
/* 122 */
/***/ (function(module, exports) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var Cylinder = function () {
	  function Cylinder(center, radius, height) {
	    _classCallCheck(this, Cylinder);
	
	    this._center = center;
	    this._radius = radius;
	    this._height = height;
	  }
	
	  _createClass(Cylinder, [{
	    key: "containsPoint",
	    value: function containsPoint(pt) {
	      var point = pt.clone();
	      if (point.sub(this._center).setZ(0).length() < this._radius && Math.abs(pt.z - this._center.z) < this._height) {
	        return true;
	      }
	      return false;
	    }
	  }, {
	    key: "clone",
	    value: function clone() {
	      return new this.constructor(this._center, this._radius, this._height);
	    }
	  }, {
	    key: "scaleRadius",
	    value: function scaleRadius(scalar) {
	      this._radius *= scalar;
	    }
	  }]);
	
	  return Cylinder;
	}();
	
	var EllipticCylinder = function () {
	  function EllipticCylinder(center, a, b) {
	    _classCallCheck(this, EllipticCylinder);
	
	    this._center = center;
	    this._a = a;
	    this._b = b;
	  }
	
	  _createClass(EllipticCylinder, [{
	    key: "containsPoint",
	    value: function containsPoint(pt) {
	      var point = pt.clone();
	      if ((point.x - this._center.x) * (point.x - this._center.x) / this._a / this._a + (point.y - this._center.y) * (point.y - this._center.y) / this._b / this._b < 1) {
	        return true;
	      }
	      return false;
	    }
	  }, {
	    key: "clone",
	    value: function clone() {
	      return new this.constructor(this._center, this._a, this._b);
	    }
	  }, {
	    key: "scaleRadius",
	    value: function scaleRadius(scalar) {
	      this._a *= scalar;
	      this._b *= scalar;
	    }
	  }]);
	
	  return EllipticCylinder;
	}();
	
	exports.EllipticCylinder = EllipticCylinder;
	exports.Cylinder = Cylinder;

/***/ }),
/* 123 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var _assign = __webpack_require__(1); /* eslint-disable */
	/**
	 * @author yamahigashi https://github.com/yamahigashi
	 *
	 * This loader loads FBX file in *ASCII and version 7 format*.
	 *
	 * Support
	 *  - mesh
	 *  - skinning
	 *  - normal / uv
	 *
	 *  Not Support
	 *  - material
	 *  - texture
	 *  - morph
	 */
	
	
	var _three = __webpack_require__(2);
	
	var THREE = _interopRequireWildcard(_three);
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	/**
	 * @author Kyle-Larson https://github.com/Kyle-Larson
	 *
	 * Loader loads FBX file and generates Group representing FBX scene.
	 * Requires FBX file to be >= 7.0 and in ASCII format.
	 *
	 * Supports:
	 * 	Mesh Generation (Positional Data)
	 * 	Normal Data (Per Vertex Drawing Instance)
	 *  UV Data (Per Vertex Drawing Instance)
	 *  Skinning
	 *  Animation
	 * 	- Separated Animations based on stacks.
	 * 	- Skeletal & Non-Skeletal Animations
	 *
	 * Needs Support:
	 * 	Indexed Buffers
	 * 	PreRotation support.
	 */
	/**
	 * @author yamahigashi https://github.com/yamahigashi
	 */
	
	/**
	 * @author Kyle-Larson https://github.com/Kyle-Larson
	 *
	 * Loader loads FBX file and generates Group representing FBX scene.
	 * Requires FBX file to be >= 7.0 and in ASCII format.
	 *
	 * Supports:
	 * 	Mesh Generation (Positional Data)
	 * 	Normal Data (Per Vertex Drawing Instance)
	 *  UV Data (Per Vertex Drawing Instance)
	 *  Skinning
	 *  Animation
	 * 	- Separated Animations based on stacks.
	 * 	- Skeletal & Non-Skeletal Animations
	 *
	 * Needs Support:
	 * 	Indexed Buffers
	 * 	PreRotation support.
	 */
	
	(function () {
	
		/**
	  * Generates a loader for loading FBX files from URL and parsing into
	  * a THREE.Group.
	  * @param {THREE.LoadingManager} manager - Loading Manager for loader to use.
	  */
		THREE.FBXLoader = function (manager) {
	
			THREE.Loader.call(this);
			this.manager = manager !== undefined ? manager : THREE.DefaultLoadingManager;
			this.fileLoader = new THREE.FileLoader(this.manager);
			this.textureLoader = new THREE.TextureLoader(this.manager);
		};
	
		_assign(THREE.FBXLoader.prototype, THREE.Loader.prototype);
	
		THREE.FBXLoader.prototype.constructor = THREE.FBXLoader;
	
		_assign(THREE.FBXLoader.prototype, {
	
			/**
	   * Loads an ASCII FBX file from URL and parses into a THREE.Group.
	   * THREE.Group will have an animations property of AnimationClips
	   * of the different animations exported with the FBX.
	   * @param {string} url - URL of the FBX file.
	   * @param {function(THREE.Group):void} onLoad - Callback for when FBX file is loaded and parsed.
	   * @param {function(ProgressEvent):void} onProgress - Callback fired periodically when file is being retrieved from server.
	   * @param {function(Event):void} onError - Callback fired when error occurs (Currently only with retrieving file, not with parsing errors).
	   */
			load: function load(url, onLoad, onProgress, onError) {
	
				var self = this;
	
				var resourceDirectory = url.split(/[\\\/]/);
				resourceDirectory.pop();
				resourceDirectory = resourceDirectory.join('/');
	
				this.fileLoader.load(url, function (text) {
	
					if (!isFbxFormatASCII(text)) {
	
						console.error('FBXLoader: FBX Binary format not supported.');
						self.manager.itemError(url);
						return;
					}
					if (getFbxVersion(text) < 7000) {
	
						console.error('FBXLoader: FBX version not supported for file at ' + url + ', FileVersion: ' + getFbxVersion(text));
						self.manager.itemError(url);
						return;
					}
	
					var scene = self.parse(text, resourceDirectory);
					onLoad(scene);
				}, onProgress, onError);
			},
	
			/**
	   * Parses an ASCII FBX file and returns a THREE.Group.
	   * THREE.Group will have an animations property of AnimationClips
	   * of the different animations within the FBX file.
	   * @param {string} FBXText - Contents of FBX file to parse.
	   * @param {string} resourceDirectory - Directory to load external assets (e.g. textures ) from.
	   * @returns {THREE.Group}
	   */
			parse: function parse(FBXText, resourceDirectory) {
	
				var loader = this;
	
				var FBXTree = new TextParser().parse(FBXText);
	
				var connections = parseConnections(FBXTree);
	
				var textures = parseTextures(FBXTree);
	
				var materials = parseMaterials(FBXTree, textures, connections);
	
				var deformerMap = parseDeformers(FBXTree, connections);
	
				var geometryMap = parseGeometries(FBXTree, connections, deformerMap);
	
				var sceneGraph = parseScene(FBXTree, connections, deformerMap, geometryMap, materials);
	
				return sceneGraph;
	
				/**
	    * @typedef {{value: number}} FBXValue
	    */
				/**
	    * @typedef {{value: {x: string, y: string, z: string}}} FBXVector3
	    */
				/**
	    * @typedef {{properties: {a: string}}} FBXArrayNode
	    */
				/**
	    * @typedef {{properties: {MappingInformationType: string, ReferenceInformationType: string }, subNodes: Object<string, FBXArrayNode>}} FBXMappedArrayNode
	    */
				/**
	    * @typedef {{id: number, name: string, properties: {FileName: string}}} FBXTextureNode
	    */
				/**
	    * @typedef {{id: number, attrName: string, properties: {ShadingModel: string, Diffuse: FBXVector3, Specular: FBXVector3, Shininess: FBXValue, Emissive: FBXVector3, EmissiveFactor: FBXValue, Opacity: FBXValue}}} FBXMaterialNode
	    */
				/**
	    * @typedef {{subNodes: {Indexes: FBXArrayNode, Weights: FBXArrayNode, Transform: FBXArrayNode, TransformLink: FBXArrayNode}, properties: { Mode: string }}} FBXSubDeformerNode
	    */
				/**
	    * @typedef {{id: number, attrName: string, attrType: string, subNodes: {Vertices: FBXArrayNode, PolygonVertexIndex: FBXArrayNode, LayerElementNormal: FBXMappedArrayNode[], LayerElementMaterial: FBXMappedArrayNode[], LayerElementUV: FBXMappedArrayNode[]}}} FBXGeometryNode
	    */
				/**
	    * @typedef {{id: number, attrName: string, attrType: string, properties: {Lcl_Translation: FBXValue, Lcl_Rotation: FBXValue, Lcl_Scaling: FBXValue}}} FBXModelNode
	    */
	
				/**
	    * Parses map of relationships between objects.
	    * @param {{Connections: { properties: { connections: [number, number, string][]}}}} FBXTree
	    * @returns {Map<number, {parents: {ID: number, relationship: string}[], children: {ID: number, relationship: string}[]}>}
	    */
				function parseConnections(FBXTree) {
	
					/**
	     * @type {Map<number, { parents: {ID: number, relationship: string}[], children: {ID: number, relationship: string}[]}>}
	     */
					var connectionMap = new Map();
	
					if ('Connections' in FBXTree) {
	
						/**
	      * @type {[number, number, string][]}
	      */
						var connectionArray = FBXTree.Connections.properties.connections;
						connectionArray.forEach(function (connection) {
	
							if (!connectionMap.has(connection[0])) {
	
								connectionMap.set(connection[0], {
									parents: [],
									children: []
								});
							}
	
							var parentRelationship = { ID: connection[1], relationship: connection[2] };
							connectionMap.get(connection[0]).parents.push(parentRelationship);
	
							if (!connectionMap.has(connection[1])) {
	
								connectionMap.set(connection[1], {
									parents: [],
									children: []
								});
							}
	
							var childRelationship = { ID: connection[0], relationship: connection[2] };
							connectionMap.get(connection[1]).children.push(childRelationship);
						});
					}
	
					return connectionMap;
				}
	
				/**
	    * Parses map of textures referenced in FBXTree.
	    * @param {{Objects: {subNodes: {Texture: Object.<string, FBXTextureNode>}}}} FBXTree
	    * @returns {Map<number, THREE.Texture>}
	    */
				function parseTextures(FBXTree) {
	
					/**
	     * @type {Map<number, THREE.Texture>}
	     */
					var textureMap = new Map();
	
					if ('Texture' in FBXTree.Objects.subNodes) {
	
						var textureNodes = FBXTree.Objects.subNodes.Texture;
						for (var nodeID in textureNodes) {
	
							var texture = parseTexture(textureNodes[nodeID]);
							textureMap.set(parseInt(nodeID), texture);
						}
					}
	
					return textureMap;
	
					/**
	     * @param {textureNode} textureNode - Node to get texture information from.
	     * @returns {THREE.Texture}
	     */
					function parseTexture(textureNode) {
	
						var FBX_ID = textureNode.id;
						var name = textureNode.name;
						var filePath = textureNode.properties.FileName;
						var split = filePath.split(/[\\\/]/);
						if (split.length > 0) {
	
							var fileName = split[split.length - 1];
						} else {
	
							var fileName = filePath;
						}
						/**
	      * @type {THREE.Texture}
	      */
						var texture = loader.textureLoader.load(resourceDirectory + '/' + fileName);
						texture.name = name;
						texture.FBX_ID = FBX_ID;
	
						return texture;
					}
				}
	
				/**
	    * Parses map of Material information.
	    * @param {{Objects: {subNodes: {Material: Object.<number, FBXMaterialNode>}}}} FBXTree
	    * @param {Map<number, THREE.Texture>} textureMap
	    * @param {Map<number, {parents: {ID: number, relationship: string}[], children: {ID: number, relationship: string}[]}>} connections
	    * @returns {Map<number, THREE.Material>}
	    */
				function parseMaterials(FBXTree, textureMap, connections) {
	
					var materialMap = new Map();
	
					if ('Material' in FBXTree.Objects.subNodes) {
	
						var materialNodes = FBXTree.Objects.subNodes.Material;
						for (var nodeID in materialNodes) {
	
							var material = parseMaterial(materialNodes[nodeID], textureMap, connections);
							materialMap.set(parseInt(nodeID), material);
						}
					}
	
					return materialMap;
	
					/**
	     * Takes information from Material node and returns a generated THREE.Material
	     * @param {FBXMaterialNode} materialNode
	     * @param {Map<number, THREE.Texture>} textureMap
	     * @param {Map<number, {parents: {ID: number, relationship: string}[], children: {ID: number, relationship: string}[]}>} connections
	     * @returns {THREE.Material}
	     */
					function parseMaterial(materialNode, textureMap, connections) {
	
						var FBX_ID = materialNode.id;
						var name = materialNode.attrName;
						var type = materialNode.properties.ShadingModel;
	
						var children = connections.get(FBX_ID).children;
	
						var parameters = parseParameters(materialNode.properties, textureMap, children);
	
						var material;
						switch (type) {
	
							case 'phong':
								material = new THREE.MeshPhongMaterial();
								break;
							case 'lambert':
								material = new THREE.MeshLambertMaterial();
								break;
							default:
								console.warn('No implementation given for material type ' + type + ' in FBXLoader.js.  Defaulting to basic material');
								material = new THREE.MeshBasicMaterial({ color: 0x3300ff });
								break;
	
						}
	
						material.setValues(parameters);
						material.name = name;
	
						return material;
	
						/**
	      * @typedef {{Diffuse: FBXVector3, Specular: FBXVector3, Shininess: FBXValue, Emissive: FBXVector3, EmissiveFactor: FBXValue, Opacity: FBXValue}} FBXMaterialProperties
	      */
						/**
	      * @typedef {{color: THREE.Color=, specular: THREE.Color=, shininess: number=, emissive: THREE.Color=, emissiveIntensity: number=, opacity: number=, transparent: boolean=, map: THREE.Texture=}} THREEMaterialParameterPack
	      */
						/**
	      * @param {FBXMaterialProperties} properties
	      * @param {Map<number, THREE.Texture>} textureMap
	      * @param {{ID: number, relationship: string}[]} childrenRelationships
	      * @returns {THREEMaterialParameterPack}
	      */
						function parseParameters(properties, textureMap, childrenRelationships) {
	
							var parameters = {};
	
							if (properties.Diffuse) {
	
								parameters.color = parseColor(properties.Diffuse);
							}
							if (properties.Specular) {
	
								parameters.specular = parseColor(properties.Specular);
							}
							if (properties.Shininess) {
	
								parameters.shininess = properties.Shininess.value;
							}
							if (properties.Emissive) {
	
								parameters.emissive = parseColor(properties.Emissive);
							}
							if (properties.EmissiveFactor) {
	
								parameters.emissiveIntensity = properties.EmissiveFactor.value;
							}
							if (properties.Opacity) {
	
								parameters.opacity = properties.Opacity.value;
							}
							if (parameters.opacity < 1.0) {
	
								parameters.transparent = true;
							}
	
							childrenRelationships.forEach(function (relationship) {
	
								var type = relationship.relationship;
								switch (type) {
	
									case " \"AmbientColor":
										//TODO: Support AmbientColor textures
										break;
	
									case " \"DiffuseColor":
										parameters.map = textureMap.get(relationship.ID);
										break;
	
									default:
										console.warn('Unknown texture application of type ' + type + ', skipping texture');
										break;
	
								}
							});
	
							return parameters;
						}
					}
				}
	
				/**
	    * Generates map of Skeleton-like objects for use later when generating and binding skeletons.
	    * @param {{Objects: {subNodes: {Deformer: Object.<number, FBXSubDeformerNode>}}}} FBXTree
	    * @param {Map<number, {parents: {ID: number, relationship: string}[], children: {ID: number, relationship: string}[]}>} connections
	    * @returns {Map<number, {map: Map<number, {FBX_ID: number, indices: number[], weights: number[], transform: number[], transformLink: number[], linkMode: string}>, array: {FBX_ID: number, indices: number[], weights: number[], transform: number[], transformLink: number[], linkMode: string}[], skeleton: THREE.Skeleton|null}>}
	    */
				function parseDeformers(FBXTree, connections) {
	
					var skeletonMap = new Map();
	
					if ('Deformer' in FBXTree.Objects.subNodes) {
	
						var DeformerNodes = FBXTree.Objects.subNodes.Deformer;
						for (var nodeID in DeformerNodes) {
	
							var deformerNode = DeformerNodes[nodeID];
							if (deformerNode.attrType === 'Skin') {
	
								var conns = connections.get(parseInt(nodeID));
								var skeleton = parseSkeleton(conns, DeformerNodes);
								skeleton.FBX_ID = parseInt(nodeID);
								skeletonMap.set(parseInt(nodeID), skeleton);
							}
						}
					}
	
					return skeletonMap;
	
					/**
	     * Generates a "Skeleton Representation" of FBX nodes based on an FBX Skin Deformer's connections and an object containing SubDeformer nodes.
	     * @param {{parents: {ID: number, relationship: string}[], children: {ID: number, relationship: string}[]}} connections
	     * @param {Object.<number, FBXSubDeformerNode>} DeformerNodes
	     * @returns {{map: Map<number, {FBX_ID: number, indices: number[], weights: number[], transform: number[], transformLink: number[], linkMode: string}>, array: {FBX_ID: number, indices: number[], weights: number[], transform: number[], transformLink: number[], linkMode: string}[], skeleton: THREE.Skeleton|null}}
	     */
					function parseSkeleton(connections, DeformerNodes) {
	
						var subDeformers = new Map();
						var subDeformerArray = [];
						connections.children.forEach(function (child) {
	
							var subDeformerNode = DeformerNodes[child.ID];
							var subDeformer = {
								FBX_ID: child.ID,
								indices: parseIntArray(subDeformerNode.subNodes.Indexes.properties.a),
								weights: parseFloatArray(subDeformerNode.subNodes.Weights.properties.a),
								transform: parseMatrixArray(subDeformerNode.subNodes.Transform.properties.a),
								transformLink: parseMatrixArray(subDeformerNode.subNodes.TransformLink.properties.a),
								linkMode: subDeformerNode.properties.Mode
							};
							subDeformers.set(child.ID, subDeformer);
							subDeformerArray.push(subDeformer);
						});
	
						return {
							map: subDeformers,
							array: subDeformerArray,
							bones: []
						};
					}
				}
	
				/**
	    * Generates Buffer geometries from geometry information in FBXTree, and generates map of THREE.BufferGeometries
	    * @param {{Objects: {subNodes: {Geometry: Object.<number, FBXGeometryNode}}}} FBXTree
	    * @param {Map<number, {parents: {ID: number, relationship: string}[], children: {ID: number, relationship: string}[]}>} connections
	    * @param {Map<number, {map: Map<number, {FBX_ID: number, indices: number[], weights: number[], transform: number[], transformLink: number[], linkMode: string}>, array: {FBX_ID: number, indices: number[], weights: number[], transform: number[], transformLink: number[], linkMode: string}[], skeleton: THREE.Skeleton|null}>} deformerMap
	    * @returns {Map<number, THREE.BufferGeometry>}
	    */
				function parseGeometries(FBXTree, connections, deformerMap) {
	
					var geometryMap = new Map();
	
					if ('Geometry' in FBXTree.Objects.subNodes) {
	
						var geometryNodes = FBXTree.Objects.subNodes.Geometry;
						for (var nodeID in geometryNodes) {
	
							var relationships = connections.get(parseInt(nodeID));
							var geo = parseGeometry(geometryNodes[nodeID], relationships, deformerMap);
							geometryMap.set(parseInt(nodeID), geo);
						}
					}
	
					return geometryMap;
	
					/**
	     * Generates BufferGeometry from FBXGeometryNode.
	     * @param {FBXGeometryNode} geometryNode
	     * @param {{parents: {ID: number, relationship: string}[], children: {ID: number, relationship: string}[]}} relationships
	     * @param {Map<number, {map: Map<number, {FBX_ID: number, indices: number[], weights: number[], transform: number[], transformLink: number[], linkMode: string}>, array: {FBX_ID: number, indices: number[], weights: number[], transform: number[], transformLink: number[], linkMode: string}[]}>} deformerMap
	     * @returns {THREE.BufferGeometry}
	     */
					function parseGeometry(geometryNode, relationships, deformerMap) {
	
						switch (geometryNode.attrType) {
	
							case 'Mesh':
								return parseMeshGeometry(geometryNode, relationships, deformerMap);
								break;
	
							case 'NurbsCurve':
								return parseNurbsGeometry(geometryNode, relationships, deformerMap);
								break;
	
						}
	
						/**
	      * Specialty function for parsing Mesh based Geometry Nodes.
	      * @param {FBXGeometryNode} geometryNode
	      * @param {{parents: {ID: number, relationship: string}[], children: {ID: number, relationship: string}[]}} relationships - Object representing relationships between specific geometry node and other nodes.
	      * @param {Map<number, {map: Map<number, {FBX_ID: number, indices: number[], weights: number[], transform: number[], transformLink: number[], linkMode: string}>, array: {FBX_ID: number, indices: number[], weights: number[], transform: number[], transformLink: number[], linkMode: string}[]}>} deformerMap - Map object of deformers and subDeformers by ID.
	      * @returns {THREE.BufferGeometry}
	      */
						function parseMeshGeometry(geometryNode, relationships, deformerMap) {
	
							var FBX_ID = geometryNode.id;
							var name = geometryNode.attrName;
							for (var i = 0; i < relationships.children.length; ++i) {
	
								if (deformerMap.has(relationships.children[i].ID)) {
	
									var deformer = deformerMap.get(relationships.children[i].ID);
									break;
								}
							}
	
							var geometry = genGeometry(geometryNode, deformer);
	
							return geometry;
	
							/**
	       * @param {{map: Map<number, {FBX_ID: number, indices: number[], weights: number[], transform: number[], transformLink: number[], linkMode: string}>, array: {FBX_ID: number, indices: number[], weights: number[], transform: number[], transformLink: number[], linkMode: string}[]}} deformer - Skeleton representation for geometry instance.
	       * @returns {THREE.BufferGeometry}
	       */
							function genGeometry(geometryNode, deformer) {
	
								var geometry = new Geometry();
	
								//First, each index is going to be its own vertex.
								var vertexBuffer = parseFloatArray(geometryNode.subNodes.Vertices.properties.a);
								var indexBuffer = parseIntArray(geometryNode.subNodes.PolygonVertexIndex.properties.a);
	
								if ('LayerElementNormal' in geometryNode.subNodes) {
	
									var normalInfo = getNormals(geometryNode);
								}
	
								if ('LayerElementUV' in geometryNode.subNodes) {
	
									var uvInfo = getUVs(geometryNode);
								}
	
								if ('LayerElementMaterial' in geometryNode.subNodes) {
	
									var materialInfo = getMaterials(geometryNode);
								}
	
								var faceVertexBuffer = [];
								var polygonIndex = 0;
								for (var polygonVertexIndex = 0; polygonVertexIndex < indexBuffer.length; ++polygonVertexIndex) {
	
									var endOfFace;
									var vertexIndex = indexBuffer[polygonVertexIndex];
									if (indexBuffer[polygonVertexIndex] < 0) {
	
										vertexIndex = vertexIndex ^ -1;
										indexBuffer[polygonVertexIndex] = vertexIndex;
										endOfFace = true;
									}
									var vertex = new Vertex();
									var weightIndices = [];
									var weights = [];
									vertex.position.fromArray(vertexBuffer, vertexIndex * 3);
	
									// If we have a deformer for this geometry, get the skinIndex and skinWeights for this object.
									// They are stored as vertex indices on each deformer, and we need them as deformer indices
									// for each vertex.
									if (deformer) {
	
										for (var j = 0; j < deformer.array.length; ++j) {
	
											var index = deformer.array[j].indices.findIndex(function (index) {
	
												return index === indexBuffer[polygonVertexIndex];
											});
	
											if (index !== -1) {
	
												weights.push(deformer.array[j].weights[index]);
												weightIndices.push(j);
											}
										}
	
										if (weights.length > 4) {
	
											console.warn('FBXLoader: Vertex has more than 4 skinning weights assigned to vertex.  Deleting additional weights.');
	
											var WIndex = [0, 0, 0, 0];
											var Weight = [0, 0, 0, 0];
	
											for (var polygonVertexIndex = 0; polygonVertexIndex < weights.length; ++polygonVertexIndex) {
	
												var currentWeight = weights[polygonVertexIndex];
												var currentIndex = weightIndices[polygonVertexIndex];
												for (var j = 0; j < Weight.length; ++j) {
	
													if (currentWeight > Weight[j]) {
	
														var tmp = Weight[j];
														Weight[j] = currentWeight;
														currentWeight = tmp;
	
														tmp = WIndex[j];
														WIndex[j] = currentIndex;
														currentIndex = tmp;
													}
												}
											}
	
											weightIndices = WIndex;
											weights = Weight;
										}
	
										for (var i = weights.length; i < 4; i++) {
	
											weights[i] = 0;
											weightIndices[i] = 0;
										}
	
										vertex.skinWeights.fromArray(weights);
										vertex.skinIndices.fromArray(weightIndices);
	
										//vertex.skinWeights.normalize();
									}
	
									if (normalInfo) {
	
										vertex.normal.fromArray(getData(polygonVertexIndex, polygonIndex, vertexIndex, normalInfo));
									}
	
									if (uvInfo) {
	
										vertex.uv.fromArray(getData(polygonVertexIndex, polygonIndex, vertexIndex, uvInfo));
									}
	
									//Add vertex to face buffer.
									faceVertexBuffer.push(vertex);
	
									// If index was negative to start with, we have finished this individual face
									// and can generate the face data to the geometry.
									if (endOfFace) {
	
										var face = new Face();
										var materials = getData(polygonVertexIndex, polygonIndex, vertexIndex, materialInfo);
										face.genTrianglesFromVertices(faceVertexBuffer);
										face.materialIndex = materials[0];
										geometry.faces.push(face);
										faceVertexBuffer = [];
										polygonIndex++;
										endOfFace = false;
									}
								}
	
								/**
	        * @type {{vertexBuffer: number[], normalBuffer: number[], uvBuffer: number[], skinIndexBuffer: number[], skinWeightBuffer: number[], materialIndexBuffer: number[]}}
	        */
								var bufferInfo = geometry.flattenToBuffers();
	
								var geo = new THREE.BufferGeometry();
								geo.name = geometryNode.name;
								geo.addAttribute('position', new THREE.BufferAttribute(new Float32Array(bufferInfo.vertexBuffer), 3));
	
								if (bufferInfo.normalBuffer.length > 0) {
	
									geo.addAttribute('normal', new THREE.BufferAttribute(new Float32Array(bufferInfo.normalBuffer), 3));
								}
								if (bufferInfo.uvBuffer.length > 0) {
	
									geo.addAttribute('uv', new THREE.BufferAttribute(new Float32Array(bufferInfo.uvBuffer), 2));
								}
	
								if (deformer) {
	
									geo.addAttribute('skinIndex', new THREE.BufferAttribute(new Float32Array(bufferInfo.skinIndexBuffer), 4));
	
									geo.addAttribute('skinWeight', new THREE.BufferAttribute(new Float32Array(bufferInfo.skinWeightBuffer), 4));
	
									geo.FBX_Deformer = deformer;
								}
	
								// Convert the material indices of each vertex into rendering groups on the geometry.
								var prevMaterialIndex = bufferInfo.materialIndexBuffer[0];
								var startIndex = 0;
								for (var materialBufferIndex = 0; materialBufferIndex < bufferInfo.materialIndexBuffer.length; ++materialBufferIndex) {
	
									if (bufferInfo.materialIndexBuffer[materialBufferIndex] !== prevMaterialIndex) {
	
										geo.addGroup(startIndex, materialBufferIndex - startIndex, prevMaterialIndex);
										startIndex = materialBufferIndex;
										prevMaterialIndex = bufferInfo.materialIndexBuffer[materialBufferIndex];
									}
								}
	
								return geo;
	
								/**
	        * Parses normal information for geometry.
	        * @param {FBXGeometryNode} geometryNode
	        * @returns {{dataSize: number, buffer: number[], indices: number[], mappingType: string, referenceType: string}}
	        */
								function getNormals(geometryNode) {
	
									var NormalNode = geometryNode.subNodes.LayerElementNormal[0];
	
									var mappingType = NormalNode.properties.MappingInformationType;
									var referenceType = NormalNode.properties.ReferenceInformationType;
									var buffer = parseFloatArray(NormalNode.subNodes.Normals.properties.a);
									var indexBuffer = [];
									if (referenceType === 'IndexToDirect') {
	
										indexBuffer = parseIntArray(NormalNode.subNodes.NormalIndex.properties.a);
									}
	
									return {
										dataSize: 3,
										buffer: buffer,
										indices: indexBuffer,
										mappingType: mappingType,
										referenceType: referenceType
									};
								}
	
								/**
	        * Parses UV information for geometry.
	        * @param {FBXGeometryNode} geometryNode
	        * @returns {{dataSize: number, buffer: number[], indices: number[], mappingType: string, referenceType: string}}
	        */
								function getUVs(geometryNode) {
	
									var UVNode = geometryNode.subNodes.LayerElementUV[0];
	
									var mappingType = UVNode.properties.MappingInformationType;
									var referenceType = UVNode.properties.ReferenceInformationType;
									var buffer = parseFloatArray(UVNode.subNodes.UV.properties.a);
									var indexBuffer = [];
									if (referenceType === 'IndexToDirect') {
	
										indexBuffer = parseIntArray(UVNode.subNodes.UVIndex.properties.a);
									}
	
									return {
										dataSize: 2,
										buffer: buffer,
										indices: indexBuffer,
										mappingType: mappingType,
										referenceType: referenceType
									};
								}
	
								/**
	        * Parses material application information for geometry.
	        * @param {FBXGeometryNode}
	        * @returns {{dataSize: number, buffer: number[], indices: number[], mappingType: string, referenceType: string}}
	        */
								function getMaterials(geometryNode) {
	
									var MaterialNode = geometryNode.subNodes.LayerElementMaterial[0];
									var mappingType = MaterialNode.properties.MappingInformationType;
									var referenceType = MaterialNode.properties.ReferenceInformationType;
									var materialIndexBuffer = parseIntArray(MaterialNode.subNodes.Materials.properties.a);
	
									// Since materials are stored as indices, there's a bit of a mismatch between FBX and what
									// we expect.  So we create an intermediate buffer that points to the index in the buffer,
									// for conforming with the other functions we've written for other data.
									var materialIndices = [];
									materialIndexBuffer.forEach(function (materialIndex, index) {
	
										materialIndices.push(index);
									});
	
									return {
										dataSize: 1,
										buffer: materialIndexBuffer,
										indices: materialIndices,
										mappingType: mappingType,
										referenceType: referenceType
									};
								}
	
								/**
	        * Function uses the infoObject and given indices to return value array of object.
	        * @param {number} polygonVertexIndex - Index of vertex in draw order (which index of the index buffer refers to this vertex).
	        * @param {number} polygonIndex - Index of polygon in geometry.
	        * @param {number} vertexIndex - Index of vertex inside vertex buffer (used because some data refers to old index buffer that we don't use anymore).
	        * @param {{datasize: number, buffer: number[], indices: number[], mappingType: string, referenceType: string}} infoObject - Object containing data and how to access data.
	        * @returns {number[]}
	        */
								function getData(polygonVertexIndex, polygonIndex, vertexIndex, infoObject) {
	
									var GetData = {
	
										ByPolygonVertex: {
	
											/**
	           * Function uses the infoObject and given indices to return value array of object.
	           * @param {number} polygonVertexIndex - Index of vertex in draw order (which index of the index buffer refers to this vertex).
	           * @param {number} polygonIndex - Index of polygon in geometry.
	           * @param {number} vertexIndex - Index of vertex inside vertex buffer (used because some data refers to old index buffer that we don't use anymore).
	           * @param {{datasize: number, buffer: number[], indices: number[], mappingType: string, referenceType: string}} infoObject - Object containing data and how to access data.
	           * @returns {number[]}
	           */
											Direct: function Direct(polygonVertexIndex, polygonIndex, vertexIndex, infoObject) {
	
												return infoObject.buffer.slice(polygonVertexIndex * infoObject.dataSize, polygonVertexIndex * infoObject.dataSize + infoObject.dataSize);
											},
	
											/**
	           * Function uses the infoObject and given indices to return value array of object.
	           * @param {number} polygonVertexIndex - Index of vertex in draw order (which index of the index buffer refers to this vertex).
	           * @param {number} polygonIndex - Index of polygon in geometry.
	           * @param {number} vertexIndex - Index of vertex inside vertex buffer (used because some data refers to old index buffer that we don't use anymore).
	           * @param {{datasize: number, buffer: number[], indices: number[], mappingType: string, referenceType: string}} infoObject - Object containing data and how to access data.
	           * @returns {number[]}
	           */
											IndexToDirect: function IndexToDirect(polygonVertexIndex, polygonIndex, vertexIndex, infoObject) {
	
												var index = infoObject.indices[polygonVertexIndex];
												return infoObject.buffer.slice(index * infoObject.dataSize, index * infoObject.dataSize + infoObject.dataSize);
											}
	
										},
	
										ByPolygon: {
	
											/**
	           * Function uses the infoObject and given indices to return value array of object.
	           * @param {number} polygonVertexIndex - Index of vertex in draw order (which index of the index buffer refers to this vertex).
	           * @param {number} polygonIndex - Index of polygon in geometry.
	           * @param {number} vertexIndex - Index of vertex inside vertex buffer (used because some data refers to old index buffer that we don't use anymore).
	           * @param {{datasize: number, buffer: number[], indices: number[], mappingType: string, referenceType: string}} infoObject - Object containing data and how to access data.
	           * @returns {number[]}
	           */
											Direct: function Direct(polygonVertexIndex, polygonIndex, vertexIndex, infoObject) {
	
												return infoObject.buffer.slice(polygonIndex * infoObject.dataSize, polygonIndex * infoObject.dataSize + infoObject.dataSize);
											},
	
											/**
	           * Function uses the infoObject and given indices to return value array of object.
	           * @param {number} polygonVertexIndex - Index of vertex in draw order (which index of the index buffer refers to this vertex).
	           * @param {number} polygonIndex - Index of polygon in geometry.
	           * @param {number} vertexIndex - Index of vertex inside vertex buffer (used because some data refers to old index buffer that we don't use anymore).
	           * @param {{datasize: number, buffer: number[], indices: number[], mappingType: string, referenceType: string}} infoObject - Object containing data and how to access data.
	           * @returns {number[]}
	           */
											IndexToDirect: function IndexToDirect(polygonVertexIndex, polygonIndex, vertexIndex, infoObject) {
	
												var index = infoObject.indices[polygonIndex];
												return infoObject.buffer.slice(index * infoObject.dataSize, index * infoObject.dataSize + infoObject.dataSize);
											}
	
										},
	
										AllSame: {
	
											/**
	           * Function uses the infoObject and given indices to return value array of object.
	           * @param {number} polygonVertexIndex - Index of vertex in draw order (which index of the index buffer refers to this vertex).
	           * @param {number} polygonIndex - Index of polygon in geometry.
	           * @param {number} vertexIndex - Index of vertex inside vertex buffer (used because some data refers to old index buffer that we don't use anymore).
	           * @param {{datasize: number, buffer: number[], indices: number[], mappingType: string, referenceType: string}} infoObject - Object containing data and how to access data.
	           * @returns {number[]}
	           */
											IndexToDirect: function IndexToDirect(polygonVertexIndex, polygonIndex, vertexIndex, infoObject) {
	
												return infoObject.buffer.slice(infoObject.indices[0] * infoObject.dataSize, infoObject.indices[0] * infoObject.dataSize + infoObject.dataSize);
											}
	
										}
	
									};
	
									return GetData[infoObject.mappingType][infoObject.referenceType](polygonVertexIndex, polygonIndex, vertexIndex, infoObject);
								}
							}
						}
	
						/**
	      * Specialty function for parsing NurbsCurve based Geometry Nodes.
	      * @param {FBXGeometryNode} geometryNode
	      * @param {{parents: {ID: number, relationship: string}[], children: {ID: number, relationship: string}[]}} relationships
	      * @returns {THREE.BufferGeometry}
	      */
						function parseNurbsGeometry(geometryNode, relationships) {
	
							if (THREE.NURBSCurve === undefined) {
	
								console.error("THREE.FBXLoader relies on THREE.NURBSCurve for any nurbs present in the model.  Nurbs will show up as empty geometry.");
								return new THREE.BufferGeometry();
							}
	
							var order = parseInt(geometryNode.properties.Order);
	
							if (isNaN(order)) {
	
								console.error("FBXLoader: Invalid Order " + geometryNode.properties.Order + " given for geometry ID: " + geometryNode.id);
								return new THREE.BufferGeometry();
							}
	
							var knots = parseFloatArray(geometryNode.subNodes.KnotVector.properties.a);
							var controlPoints = [];
							var pointsValues = parseFloatArray(geometryNode.subNodes.Points.properties.a);
	
							for (var i = 0; i < pointsValues.length; i += 4) {
	
								controlPoints.push(new THREE.Vector4(pointsValues[i], pointsValues[i + 1], pointsValues[i + 2], pointsValues[i + 3]));
							}
	
							if (geometryNode.properties.Form === 'Closed') {
	
								controlPoints.push(controlPoints[0]);
							}
	
							var curve = new THREE.NURBSCurve(order - 1, knots, controlPoints);
							var vertices = curve.getPoints(controlPoints.length * 1.5);
	
							var vertexBuffer = [];
							vertices.forEach(function (position) {
	
								var array = position.toArray();
								vertexBuffer = vertexBuffer.concat(array);
							});
	
							var geometry = new THREE.BufferGeometry();
							geometry.addAttribute('position', new THREE.BufferAttribute(new Float32Array(vertexBuffer), 3));
	
							return geometry;
						}
					}
				}
	
				/**
	    * Finally generates Scene graph and Scene graph Objects.
	    * @param {{Objects: {subNodes: {Model: Object.<number, FBXModelNode>}}}} FBXTree
	    * @param {Map<number, {parents: {ID: number, relationship: string}[], children: {ID: number, relationship: string}[]}>} connections
	    * @param {Map<number, {map: Map<number, {FBX_ID: number, indices: number[], weights: number[], transform: number[], transformLink: number[], linkMode: string}>, array: {FBX_ID: number, indices: number[], weights: number[], transform: number[], transformLink: number[], linkMode: string}[], skeleton: THREE.Skeleton|null}>} deformerMap
	    * @param {Map<number, THREE.BufferGeometry>} geometryMap
	    * @param {Map<number, THREE.Material>} materialMap
	    * @returns {THREE.Group}
	    */
				function parseScene(FBXTree, connections, deformerMap, geometryMap, materialMap) {
	
					var sceneGraph = new THREE.Group();
	
					var ModelNode = FBXTree.Objects.subNodes.Model;
	
					/**
	     * @type {Array.<THREE.Object3D>}
	     */
					var modelArray = [];
	
					/**
	     * @type {Map.<number, THREE.Object3D>}
	     */
					var modelMap = new Map();
	
					for (var nodeID in ModelNode) {
	
						var id = parseInt(nodeID);
						var node = ModelNode[nodeID];
						var conns = connections.get(id);
						var model = null;
						for (var i = 0; i < conns.parents.length; ++i) {
	
							deformerMap.forEach(function (deformer) {
	
								if (deformer.map.has(conns.parents[i].ID)) {
	
									model = new THREE.Bone();
									var index = deformer.array.findIndex(function (subDeformer) {
	
										return subDeformer.FBX_ID === conns.parents[i].ID;
									});
									deformer.bones[index] = model;
								}
							});
						}
						if (!model) {
	
							switch (node.attrType) {
	
								case "Mesh":
									/**
	         * @type {?THREE.BufferGeometry}
	         */
									var geometry = null;
	
									/**
	         * @type {THREE.MultiMaterial|THREE.Material}
	         */
									var material = null;
	
									/**
	         * @type {Array.<THREE.Material>}
	         */
									var materials = [];
	
									conns.children.forEach(function (child) {
	
										if (geometryMap.has(child.ID)) {
	
											geometry = geometryMap.get(child.ID);
										}
	
										if (materialMap.has(child.ID)) {
	
											materials.push(materialMap.get(child.ID));
										}
									});
									if (materials.length > 1) {
	
										material = new THREE.MultiMaterial(materials);
									} else if (materials.length > 0) {
	
										material = materials[0];
									} else {
	
										material = new THREE.MeshBasicMaterial({ color: 0x3300ff });
									}
									if (geometry.FBX_Deformer) {
	
										materials.forEach(function (material) {
	
											material.skinning = true;
										});
										material.skinning = true;
										model = new THREE.SkinnedMesh(geometry, material);
									} else {
	
										model = new THREE.Mesh(geometry, material);
									}
									break;
	
								case "NurbsCurve":
									var geometry = null;
	
									conns.children.forEach(function (child) {
	
										if (geometryMap.has(child.ID)) {
	
											geometry = geometryMap.get(child.ID);
										}
									});
	
									// FBX does not list materials for Nurbs lines, so we'll just put our own in here.
									material = new THREE.LineBasicMaterial({ color: 0x3300ff, linewidth: 5 });
									model = new THREE.Line(geometry, material);
									break;
	
								default:
									model = new THREE.Object3D();
									break;
	
							}
						}
	
						model.name = node.attrName.replace(/:/, '').replace(/_/, '').replace(/-/, '');
						model.FBX_ID = id;
	
						modelArray.push(model);
						modelMap.set(id, model);
					}
	
					modelArray.forEach(function (model) {
	
						var node = ModelNode[model.FBX_ID];
	
						if ('Lcl_Translation' in node.properties) {
	
							model.position.fromArray(parseFloatArray(node.properties.Lcl_Translation.value));
						}
	
						if ('Lcl_Rotation' in node.properties) {
	
							var rotation = parseFloatArray(node.properties.Lcl_Rotation.value).map(function (value) {
	
								return value * Math.PI / 180;
							});
							rotation.push('ZYX');
							model.rotation.fromArray(rotation);
						}
	
						if ('Lcl_Scaling' in node.properties) {
	
							model.scale.fromArray(parseFloatArray(node.properties.Lcl_Scaling.value));
						}
	
						var conns = connections.get(model.FBX_ID);
						for (var parentIndex = 0; parentIndex < conns.parents.length; parentIndex++) {
	
							var pIndex = modelArray.findIndex(function (mod) {
	
								return mod.FBX_ID === conns.parents[parentIndex].ID;
							});
							if (pIndex > -1) {
	
								modelArray[pIndex].add(model);
								break;
							}
						}
						if (model.parent === null) {
	
							sceneGraph.add(model);
						}
					});
	
					// Now with the bones created, we can update the skeletons and bind them to the skinned meshes.
					sceneGraph.updateMatrixWorld(true);
	
					// Put skeleton into bind pose.
					var BindPoseNode = FBXTree.Objects.subNodes.Pose;
					for (var nodeID in BindPoseNode) {
	
						if (BindPoseNode[nodeID].attrType === 'BindPose') {
	
							BindPoseNode = BindPoseNode[nodeID];
							break;
						}
					}
					if (BindPoseNode) {
	
						var PoseNode = BindPoseNode.subNodes.PoseNode;
						var worldMatrices = new Map();
	
						PoseNode.forEach(function (node) {
	
							var rawMatWrd = parseMatrixArray(node.subNodes.Matrix.properties.a);
	
							worldMatrices.set(parseInt(node.id), rawMatWrd);
						});
					}
	
					deformerMap.forEach(function (deformer, FBX_ID) {
	
						deformer.array.forEach(function (subDeformer, subDeformerIndex) {
	
							/**
	       * @type {THREE.Bone}
	       */
							var bone = deformer.bones[subDeformerIndex];
							if (!worldMatrices.has(bone.FBX_ID)) {
	
								return;
							}
							var mat = worldMatrices.get(bone.FBX_ID);
							bone.matrixWorld.copy(mat);
						});
	
						// Now that skeleton is in bind pose, bind to model.
						deformer.skeleton = new THREE.Skeleton(deformer.bones);
						var conns = connections.get(FBX_ID);
						conns.parents.forEach(function (parent) {
	
							if (geometryMap.has(parent.ID)) {
	
								var geoID = parent.ID;
								var geoConns = connections.get(geoID);
								for (var i = 0; i < geoConns.parents.length; ++i) {
	
									if (modelMap.has(geoConns.parents[i].ID)) {
	
										var model = modelMap.get(geoConns.parents[i].ID);
										//ASSERT model typeof SkinnedMesh
										model.bind(deformer.skeleton, model.matrixWorld);
										break;
									}
								}
							}
						});
					});
	
					// Skeleton is now bound, we are now free to set up the
					// scene graph.
					modelArray.forEach(function (model) {
	
						var node = ModelNode[model.FBX_ID];
	
						if ('Lcl_Translation' in node.properties) {
	
							model.position.fromArray(parseFloatArray(node.properties.Lcl_Translation.value));
						}
	
						if ('Lcl_Rotation' in node.properties) {
	
							var rotation = parseFloatArray(node.properties.Lcl_Rotation.value).map(function (value) {
	
								return value * Math.PI / 180;
							});
							rotation.push('ZYX');
							model.rotation.fromArray(rotation);
						}
	
						if ('Lcl_Scaling' in node.properties) {
	
							model.scale.fromArray(parseFloatArray(node.properties.Lcl_Scaling.value));
						}
					});
	
					// Silly hack with the animation parsing.  We're gonna pretend the scene graph has a skeleton
					// to attach animations to, since FBXs treat animations as animations for the entire scene,
					// not just for individual objects.
					sceneGraph.skeleton = {
						bones: modelArray
					};
	
					var animations = parseAnimations(FBXTree, connections, sceneGraph);
	
					addAnimations(sceneGraph, animations);
	
					return sceneGraph;
				}
	
				/**
	    * Parses animation information from FBXTree and generates an AnimationInfoObject.
	    * @param {{Objects: {subNodes: {AnimationCurveNode: any, AnimationCurve: any, AnimationLayer: any, AnimationStack: any}}}} FBXTree
	    * @param {Map<number, {parents: {ID: number, relationship: string}[], children: {ID: number, relationship: string}[]}>} connections
	    */
				function parseAnimations(FBXTree, connections, sceneGraph) {
	
					var rawNodes = FBXTree.Objects.subNodes.AnimationCurveNode;
					var rawCurves = FBXTree.Objects.subNodes.AnimationCurve;
					var rawLayers = FBXTree.Objects.subNodes.AnimationLayer;
					var rawStacks = FBXTree.Objects.subNodes.AnimationStack;
	
					/**
	     * @type {{
	         curves: Map<number, {
	    		 T: {
	    			id: number;
	    			attr: string;
	    			internalID: number;
	    			attrX: boolean;
	    			attrY: boolean;
	    			attrZ: boolean;
	    			containerBoneID: number;
	    			containerID: number;
	    			curves: {
	    				x: {
	    					version: any;
	    					id: number;
	    					internalID: number;
	    					times: number[];
	    					values: number[];
	    					attrFlag: number[];
	    					attrData: number[];
	    				};
	    				y: {
	    					version: any;
	    					id: number;
	    					internalID: number;
	    					times: number[];
	    					values: number[];
	    					attrFlag: number[];
	    					attrData: number[];
	    				};
	    				z: {
	    					version: any;
	    					id: number;
	    					internalID: number;
	    					times: number[];
	    					values: number[];
	    					attrFlag: number[];
	    					attrData: number[];
	    				};
	    			};
	    		},
	    		 R: {
	    			id: number;
	    			attr: string;
	    			internalID: number;
	    			attrX: boolean;
	    			attrY: boolean;
	    			attrZ: boolean;
	    			containerBoneID: number;
	    			containerID: number;
	    			curves: {
	    				x: {
	    					version: any;
	    					id: number;
	    					internalID: number;
	    					times: number[];
	    					values: number[];
	    					attrFlag: number[];
	    					attrData: number[];
	    				};
	    				y: {
	    					version: any;
	    					id: number;
	    					internalID: number;
	    					times: number[];
	    					values: number[];
	    					attrFlag: number[];
	    					attrData: number[];
	    				};
	    				z: {
	    					version: any;
	    					id: number;
	    					internalID: number;
	    					times: number[];
	    					values: number[];
	    					attrFlag: number[];
	    					attrData: number[];
	    				};
	    			};
	    		},
	    		 S: {
	    			id: number;
	    			attr: string;
	    			internalID: number;
	    			attrX: boolean;
	    			attrY: boolean;
	    			attrZ: boolean;
	    			containerBoneID: number;
	    			containerID: number;
	    			curves: {
	    				x: {
	    					version: any;
	    					id: number;
	    					internalID: number;
	    					times: number[];
	    					values: number[];
	    					attrFlag: number[];
	    					attrData: number[];
	    				};
	    				y: {
	    					version: any;
	    					id: number;
	    					internalID: number;
	    					times: number[];
	    					values: number[];
	    					attrFlag: number[];
	    					attrData: number[];
	    				};
	    				z: {
	    					version: any;
	    					id: number;
	    					internalID: number;
	    					times: number[];
	    					values: number[];
	    					attrFlag: number[];
	    					attrData: number[];
	    				};
	    			};
	    		}
	    	 }>,
	    	 layers: Map<number, {
	    	 	T: {
	    			id: number;
	    			attr: string;
	    			internalID: number;
	    			attrX: boolean;
	    			attrY: boolean;
	    			attrZ: boolean;
	    			containerBoneID: number;
	    			containerID: number;
	    			curves: {
	    				x: {
	    					version: any;
	    					id: number;
	    					internalID: number;
	    					times: number[];
	    					values: number[];
	    					attrFlag: number[];
	    					attrData: number[];
	    				};
	    				y: {
	    					version: any;
	    					id: number;
	    					internalID: number;
	    					times: number[];
	    					values: number[];
	    					attrFlag: number[];
	    					attrData: number[];
	    				};
	    				z: {
	    					version: any;
	    					id: number;
	    					internalID: number;
	    					times: number[];
	    					values: number[];
	    					attrFlag: number[];
	    					attrData: number[];
	    				};
	    			},
	    		},
	    		R: {
	    			id: number;
	    			attr: string;
	    			internalID: number;
	    			attrX: boolean;
	    			attrY: boolean;
	    			attrZ: boolean;
	    			containerBoneID: number;
	    			containerID: number;
	    			curves: {
	    				x: {
	    					version: any;
	    					id: number;
	    					internalID: number;
	    					times: number[];
	    					values: number[];
	    					attrFlag: number[];
	    					attrData: number[];
	    				};
	    				y: {
	    					version: any;
	    					id: number;
	    					internalID: number;
	    					times: number[];
	    					values: number[];
	    					attrFlag: number[];
	    					attrData: number[];
	    				};
	    				z: {
	    					version: any;
	    					id: number;
	    					internalID: number;
	    					times: number[];
	    					values: number[];
	    					attrFlag: number[];
	    					attrData: number[];
	    				};
	    			},
	    		},
	    		S: {
	    			id: number;
	    			attr: string;
	    			internalID: number;
	    			attrX: boolean;
	    			attrY: boolean;
	    			attrZ: boolean;
	    			containerBoneID: number;
	    			containerID: number;
	    			curves: {
	    				x: {
	    					version: any;
	    					id: number;
	    					internalID: number;
	    					times: number[];
	    					values: number[];
	    					attrFlag: number[];
	    					attrData: number[];
	    				};
	    				y: {
	    					version: any;
	    					id: number;
	    					internalID: number;
	    					times: number[];
	    					values: number[];
	    					attrFlag: number[];
	    					attrData: number[];
	    				};
	    				z: {
	    					version: any;
	    					id: number;
	    					internalID: number;
	    					times: number[];
	    					values: number[];
	    					attrFlag: number[];
	    					attrData: number[];
	    				};
	    			},
	    		}
	    		}[]>,
	    	 stacks: Map<number, {
	    		 name: string,
	    		 layers: {
	    			T: {
	    				id: number;
	    				attr: string;
	    				internalID: number;
	    				attrX: boolean;
	    				attrY: boolean;
	    				attrZ: boolean;
	    				containerBoneID: number;
	    				containerID: number;
	    				curves: {
	    					x: {
	    						version: any;
	    						id: number;
	    						internalID: number;
	    						times: number[];
	    						values: number[];
	    						attrFlag: number[];
	    						attrData: number[];
	    					};
	    					y: {
	    						version: any;
	    						id: number;
	    						internalID: number;
	    						times: number[];
	    						values: number[];
	    						attrFlag: number[];
	    						attrData: number[];
	    					};
	    					z: {
	    						version: any;
	    						id: number;
	    						internalID: number;
	    						times: number[];
	    						values: number[];
	    						attrFlag: number[];
	    						attrData: number[];
	    					};
	    				};
	    			};
	    			R: {
	    				id: number;
	    				attr: string;
	    				internalID: number;
	    				attrX: boolean;
	    				attrY: boolean;
	    				attrZ: boolean;
	    				containerBoneID: number;
	    				containerID: number;
	    				curves: {
	    					x: {
	    						version: any;
	    						id: number;
	    						internalID: number;
	    						times: number[];
	    						values: number[];
	    						attrFlag: number[];
	    						attrData: number[];
	    					};
	    					y: {
	    						version: any;
	    						id: number;
	    						internalID: number;
	    						times: number[];
	    						values: number[];
	    						attrFlag: number[];
	    						attrData: number[];
	    					};
	    					z: {
	    						version: any;
	    						id: number;
	    						internalID: number;
	    						times: number[];
	    						values: number[];
	    						attrFlag: number[];
	    						attrData: number[];
	    					};
	    				};
	    			};
	    			S: {
	    				id: number;
	    				attr: string;
	    				internalID: number;
	    				attrX: boolean;
	    				attrY: boolean;
	    				attrZ: boolean;
	    				containerBoneID: number;
	    				containerID: number;
	    				curves: {
	    					x: {
	    						version: any;
	    						id: number;
	    						internalID: number;
	    						times: number[];
	    						values: number[];
	    						attrFlag: number[];
	    						attrData: number[];
	    					};
	    					y: {
	    						version: any;
	    						id: number;
	    						internalID: number;
	    						times: number[];
	    						values: number[];
	    						attrFlag: number[];
	    						attrData: number[];
	    					};
	    					z: {
	    						version: any;
	    						id: number;
	    						internalID: number;
	    						times: number[];
	    						values: number[];
	    						attrFlag: number[];
	    						attrData: number[];
	    					};
	    				};
	    			};
	    		}[][],
	    	 length: number,
	    	 frames: number }>,
	    	 length: number,
	    	 fps: number,
	    	 frames: number
	     }}
	     */
					var returnObject = {
						curves: new Map(),
						layers: new Map(),
						stacks: new Map(),
						length: 0,
						fps: 30,
						frames: 0
					};
	
					/**
	     * @type {Array.<{
	    		id: number;
	    		attr: string;
	    		internalID: number;
	    		attrX: boolean;
	    		attrY: boolean;
	    		attrZ: boolean;
	    		containerBoneID: number;
	    		containerID: number;
	    	}>}
	     */
					var animationCurveNodes = [];
					for (var nodeID in rawNodes) {
	
						if (nodeID.match(/\d+/)) {
	
							var animationNode = parseAnimationNode(FBXTree, rawNodes[nodeID], connections, sceneGraph);
							animationCurveNodes.push(animationNode);
						}
					}
	
					/**
	     * @type {Map.<number, {
	    		id: number,
	    		attr: string,
	    		internalID: number,
	    		attrX: boolean,
	    		attrY: boolean,
	    		attrZ: boolean,
	    		containerBoneID: number,
	    		containerID: number,
	    		curves: {
	    			x: {
	    				version: any,
	    				id: number,
	    				internalID: number,
	    				times: number[],
	    				values: number[],
	    				attrFlag: number[],
	    				attrData: number[],
	    			},
	    			y: {
	    				version: any,
	    				id: number,
	    				internalID: number,
	    				times: number[],
	    				values: number[],
	    				attrFlag: number[],
	    				attrData: number[],
	    			},
	    			z: {
	    				version: any,
	    				id: number,
	    				internalID: number,
	    				times: number[],
	    				values: number[],
	    				attrFlag: number[],
	    				attrData: number[],
	    			}
	    		}
	    	}>}
	     */
					var tmpMap = new Map();
					for (var animationCurveNodeIndex = 0; animationCurveNodeIndex < animationCurveNodes.length; ++animationCurveNodeIndex) {
	
						if (animationCurveNodes[animationCurveNodeIndex] === null) {
	
							continue;
						}
						tmpMap.set(animationCurveNodes[animationCurveNodeIndex].id, animationCurveNodes[animationCurveNodeIndex]);
					}
	
					/**
	     * @type {{
	    		version: any,
	    		id: number,
	    		internalID: number,
	    		times: number[],
	    		values: number[],
	    		attrFlag: number[],
	    		attrData: number[],
	    	}[]}
	     */
					var animationCurves = [];
					for (nodeID in rawCurves) {
	
						if (nodeID.match(/\d+/)) {
	
							var animationCurve = parseAnimationCurve(rawCurves[nodeID]);
							animationCurves.push(animationCurve);
	
							var firstParentConn = connections.get(animationCurve.id).parents[0];
							var firstParentID = firstParentConn.ID;
							var firstParentRelationship = firstParentConn.relationship;
							var axis = '';
	
							if (firstParentRelationship.match(/X/)) {
	
								axis = 'x';
							} else if (firstParentRelationship.match(/Y/)) {
	
								axis = 'y';
							} else if (firstParentRelationship.match(/Z/)) {
	
								axis = 'z';
							} else {
	
								continue;
							}
	
							tmpMap.get(firstParentID).curves[axis] = animationCurve;
						}
					}
	
					tmpMap.forEach(function (curveNode) {
	
						var id = curveNode.containerBoneID;
						if (!returnObject.curves.has(id)) {
	
							returnObject.curves.set(id, { T: null, R: null, S: null });
						}
						returnObject.curves.get(id)[curveNode.attr] = curveNode;
					});
	
					for (var nodeID in rawLayers) {
	
						/**
	      * @type {{
	      	T: {
	     		id: number;
	     		attr: string;
	     		internalID: number;
	     		attrX: boolean;
	     		attrY: boolean;
	     		attrZ: boolean;
	     		containerBoneID: number;
	     		containerID: number;
	     		curves: {
	     			x: {
	     				version: any;
	     				id: number;
	     				internalID: number;
	     				times: number[];
	     				values: number[];
	     				attrFlag: number[];
	     				attrData: number[];
	     			};
	     			y: {
	     				version: any;
	     				id: number;
	     				internalID: number;
	     				times: number[];
	     				values: number[];
	     				attrFlag: number[];
	     				attrData: number[];
	     			};
	     			z: {
	     				version: any;
	     				id: number;
	     				internalID: number;
	     				times: number[];
	     				values: number[];
	     				attrFlag: number[];
	     				attrData: number[];
	     			};
	     		},
	     	},
	     	R: {
	     		id: number;
	     		attr: string;
	     		internalID: number;
	     		attrX: boolean;
	     		attrY: boolean;
	     		attrZ: boolean;
	     		containerBoneID: number;
	     		containerID: number;
	     		curves: {
	     			x: {
	     				version: any;
	     				id: number;
	     				internalID: number;
	     				times: number[];
	     				values: number[];
	     				attrFlag: number[];
	     				attrData: number[];
	     			};
	     			y: {
	     				version: any;
	     				id: number;
	     				internalID: number;
	     				times: number[];
	     				values: number[];
	     				attrFlag: number[];
	     				attrData: number[];
	     			};
	     			z: {
	     				version: any;
	     				id: number;
	     				internalID: number;
	     				times: number[];
	     				values: number[];
	     				attrFlag: number[];
	     				attrData: number[];
	     			};
	     		},
	     	},
	     	S: {
	     		id: number;
	     		attr: string;
	     		internalID: number;
	     		attrX: boolean;
	     		attrY: boolean;
	     		attrZ: boolean;
	     		containerBoneID: number;
	     		containerID: number;
	     		curves: {
	     			x: {
	     				version: any;
	     				id: number;
	     				internalID: number;
	     				times: number[];
	     				values: number[];
	     				attrFlag: number[];
	     				attrData: number[];
	     			};
	     			y: {
	     				version: any;
	     				id: number;
	     				internalID: number;
	     				times: number[];
	     				values: number[];
	     				attrFlag: number[];
	     				attrData: number[];
	     			};
	     			z: {
	     				version: any;
	     				id: number;
	     				internalID: number;
	     				times: number[];
	     				values: number[];
	     				attrFlag: number[];
	     				attrData: number[];
	     			};
	     		},
	     	}
	     	}[]}
	      */
						var layer = [];
						var children = connections.get(parseInt(nodeID)).children;
						for (var childIndex = 0; childIndex < children.length; childIndex++) {
	
							// Skip lockInfluenceWeights
							if (tmpMap.has(children[childIndex].ID)) {
	
								var curveNode = tmpMap.get(children[childIndex].ID);
								var boneID = curveNode.containerBoneID;
								if (layer[boneID] === undefined) {
	
									layer[boneID] = {
										T: null,
										R: null,
										S: null
									};
								}
	
								layer[boneID][curveNode.attr] = curveNode;
							}
						}
	
						returnObject.layers.set(parseInt(nodeID), layer);
					}
	
					for (var nodeID in rawStacks) {
	
						var layers = [];
						var children = connections.get(parseInt(nodeID)).children;
						var maxTimeStamp = 0;
						var minTimeStamp = Number.MAX_VALUE;
						for (var childIndex = 0; childIndex < children.length; ++childIndex) {
	
							if (returnObject.layers.has(children[childIndex].ID)) {
	
								var currentLayer = returnObject.layers.get(children[childIndex].ID);
								layers.push(currentLayer);
	
								currentLayer.forEach(function (layer) {
	
									if (layer) {
	
										getCurveNodeMaxMinTimeStamps(layer);
									}
	
									/**
	         * Sets the maxTimeStamp and minTimeStamp variables if it has timeStamps that are either larger or smaller
	         * than the max or min respectively.
	         * @param {{
	        			T: {
	        					id: number,
	        					attr: string,
	        					internalID: number,
	        					attrX: boolean,
	        					attrY: boolean,
	        					attrZ: boolean,
	        					containerBoneID: number,
	        					containerID: number,
	        					curves: {
	        							x: {
	        									version: any,
	        									id: number,
	        									internalID: number,
	        									times: number[],
	        									values: number[],
	        									attrFlag: number[],
	        									attrData: number[],
	        							},
	        							y: {
	        									version: any,
	        									id: number,
	        									internalID: number,
	        									times: number[],
	        									values: number[],
	        									attrFlag: number[],
	        									attrData: number[],
	        							},
	        							z: {
	        									version: any,
	        									id: number,
	        									internalID: number,
	        									times: number[],
	        									values: number[],
	        									attrFlag: number[],
	        									attrData: number[],
	        							},
	        					},
	        			},
	        			R: {
	        					id: number,
	        					attr: string,
	        					internalID: number,
	        					attrX: boolean,
	        					attrY: boolean,
	        					attrZ: boolean,
	        					containerBoneID: number,
	        					containerID: number,
	        					curves: {
	        							x: {
	        									version: any,
	        									id: number,
	        									internalID: number,
	        									times: number[],
	        									values: number[],
	        									attrFlag: number[],
	        									attrData: number[],
	        							},
	        							y: {
	        									version: any,
	        									id: number,
	        									internalID: number,
	        									times: number[],
	        									values: number[],
	        									attrFlag: number[],
	        									attrData: number[],
	        							},
	        							z: {
	        									version: any,
	        									id: number,
	        									internalID: number,
	        									times: number[],
	        									values: number[],
	        									attrFlag: number[],
	        									attrData: number[],
	        							},
	        					},
	        			},
	        			S: {
	        					id: number,
	        					attr: string,
	        					internalID: number,
	        					attrX: boolean,
	        					attrY: boolean,
	        					attrZ: boolean,
	        					containerBoneID: number,
	        					containerID: number,
	        					curves: {
	        							x: {
	        									version: any,
	        									id: number,
	        									internalID: number,
	        									times: number[],
	        									values: number[],
	        									attrFlag: number[],
	        									attrData: number[],
	        							},
	        							y: {
	        									version: any,
	        									id: number,
	        									internalID: number,
	        									times: number[],
	        									values: number[],
	        									attrFlag: number[],
	        									attrData: number[],
	        							},
	        							z: {
	        									version: any,
	        									id: number,
	        									internalID: number,
	        									times: number[],
	        									values: number[],
	        									attrFlag: number[],
	        									attrData: number[],
	        							},
	        					},
	        			},
	        	}} layer
	         */
									function getCurveNodeMaxMinTimeStamps(layer) {
	
										/**
	          * Sets the maxTimeStamp and minTimeStamp if one of the curve's time stamps
	          * exceeds the maximum or minimum.
	          * @param {{
	         			x: {
	         					version: any,
	         					id: number,
	         					internalID: number,
	         					times: number[],
	         					values: number[],
	         					attrFlag: number[],
	         					attrData: number[],
	         			},
	         			y: {
	         					version: any,
	         					id: number,
	         					internalID: number,
	         					times: number[],
	         					values: number[],
	         					attrFlag: number[],
	         					attrData: number[],
	         			},
	         			z: {
	         					version: any,
	         					id: number,
	         					internalID: number,
	         					times: number[],
	         					values: number[],
	         					attrFlag: number[],
	         					attrData: number[],
	         			}
	         	}} curve
	          */
										function getCurveMaxMinTimeStamp(curve) {
	
											/**
	           * Sets the maxTimeStamp and minTimeStamp if one of its timestamps exceeds the maximum or minimum.
	           * @param {{times: number[]}} axis
	           */
											function getCurveAxisMaxMinTimeStamps(axis) {
	
												maxTimeStamp = axis.times[axis.times.length - 1] > maxTimeStamp ? axis.times[axis.times.length - 1] : maxTimeStamp;
												minTimeStamp = axis.times[0] < minTimeStamp ? axis.times[0] : minTimeStamp;
											}
	
											if (curve.x) {
	
												getCurveAxisMaxMinTimeStamps(curve.x);
											}
											if (curve.y) {
	
												getCurveAxisMaxMinTimeStamps(curve.y);
											}
											if (curve.z) {
	
												getCurveAxisMaxMinTimeStamps(curve.z);
											}
										}
	
										if (layer.R) {
	
											getCurveMaxMinTimeStamp(layer.R.curves);
										}
										if (layer.S) {
	
											getCurveMaxMinTimeStamp(layer.S.curves);
										}
										if (layer.T) {
	
											getCurveMaxMinTimeStamp(layer.T.curves);
										}
									}
								});
							}
						}
	
						// Do we have an animation clip with actual length?
						if (maxTimeStamp > minTimeStamp) {
	
							returnObject.stacks.set(parseInt(nodeID), {
								name: rawStacks[nodeID].attrName,
								layers: layers,
								length: maxTimeStamp - minTimeStamp,
								frames: (maxTimeStamp - minTimeStamp) * 30
							});
						}
					}
	
					return returnObject;
	
					/**
	     * @param {Object} FBXTree
	     * @param {{id: number, attrName: string, properties: Object<string, any>}} animationCurveNode
	     * @param {Map<number, {parents: {ID: number, relationship: string}[], children: {ID: number, relationship: string}[]}>} connections
	     * @param {{skeleton: {bones: {FBX_ID: number}[]}}} sceneGraph
	     */
					function parseAnimationNode(FBXTree, animationCurveNode, connections, sceneGraph) {
	
						var returnObject = {
							/**
	       * @type {number}
	       */
							id: animationCurveNode.id,
	
							/**
	       * @type {string}
	       */
							attr: animationCurveNode.attrName,
	
							/**
	       * @type {number}
	       */
							internalID: animationCurveNode.id,
	
							/**
	       * @type {boolean}
	       */
							attrX: false,
	
							/**
	       * @type {boolean}
	       */
							attrY: false,
	
							/**
	       * @type {boolean}
	       */
							attrZ: false,
	
							/**
	       * @type {number}
	       */
							containerBoneID: -1,
	
							/**
	       * @type {number}
	       */
							containerID: -1,
	
							curves: {
								x: null,
								y: null,
								z: null
							}
						};
	
						if (returnObject.attr.match(/S|R|T/)) {
	
							for (var attributeKey in animationCurveNode.properties) {
	
								if (attributeKey.match(/X/)) {
	
									returnObject.attrX = true;
								}
								if (attributeKey.match(/Y/)) {
	
									returnObject.attrY = true;
								}
								if (attributeKey.match(/Z/)) {
	
									returnObject.attrZ = true;
								}
							}
						} else {
	
							return null;
						}
	
						var conns = connections.get(returnObject.id);
						var containerIndices = conns.parents;
	
						for (var containerIndicesIndex = containerIndices.length - 1; containerIndicesIndex >= 0; --containerIndicesIndex) {
	
							var boneID = sceneGraph.skeleton.bones.findIndex(function (bone) {
	
								return bone.FBX_ID === containerIndices[containerIndicesIndex].ID;
							});
							if (boneID > -1) {
	
								returnObject.containerBoneID = boneID;
								returnObject.containerID = containerIndices[containerIndicesIndex].ID;
								break;
							}
						}
	
						return returnObject;
					}
	
					/**
	     * @param {{id: number, subNodes: {KeyTime: {properties: {a: string}}, KeyValueFloat: {properties: {a: string}}, KeyAttrFlags: {properties: {a: string}}, KeyAttrDataFloat: {properties: {a: string}}}}} animationCurve
	     */
					function parseAnimationCurve(animationCurve) {
	
						return {
							version: null,
							id: animationCurve.id,
							internalID: animationCurve.id,
							times: parseFloatArray(animationCurve.subNodes.KeyTime.properties.a).map(function (time) {
	
								return ConvertFBXTimeToSeconds(time);
							}),
							values: parseFloatArray(animationCurve.subNodes.KeyValueFloat.properties.a),
	
							attrFlag: parseIntArray(animationCurve.subNodes.KeyAttrFlags.properties.a),
							attrData: parseFloatArray(animationCurve.subNodes.KeyAttrDataFloat.properties.a)
						};
					}
				}
	
				/**
	    * @param {{
	   	curves: Map<number, {
	   		T: {
	   			id: number;
	   			attr: string;
	   			internalID: number;
	   			attrX: boolean;
	   			attrY: boolean;
	   			attrZ: boolean;
	   			containerBoneID: number;
	   			containerID: number;
	   			curves: {
	   				x: {
	   					version: any;
	   					id: number;
	   					internalID: number;
	   					times: number[];
	   					values: number[];
	   					attrFlag: number[];
	   					attrData: number[];
	   				};
	   				y: {
	   					version: any;
	   					id: number;
	   					internalID: number;
	   					times: number[];
	   					values: number[];
	   					attrFlag: number[];
	   					attrData: number[];
	   				};
	   				z: {
	   					version: any;
	   					id: number;
	   					internalID: number;
	   					times: number[];
	   					values: number[];
	   					attrFlag: number[];
	   					attrData: number[];
	   				};
	   			};
	   		};
	   		R: {
	   			id: number;
	   			attr: string;
	   			internalID: number;
	   			attrX: boolean;
	   			attrY: boolean;
	   			attrZ: boolean;
	   			containerBoneID: number;
	   			containerID: number;
	   			curves: {
	   				x: {
	   					version: any;
	   					id: number;
	   					internalID: number;
	   					times: number[];
	   					values: number[];
	   					attrFlag: number[];
	   					attrData: number[];
	   				};
	   				y: {
	   					version: any;
	   					id: number;
	   					internalID: number;
	   					times: number[];
	   					values: number[];
	   					attrFlag: number[];
	   					attrData: number[];
	   				};
	   				z: {
	   					version: any;
	   					id: number;
	   					internalID: number;
	   					times: number[];
	   					values: number[];
	   					attrFlag: number[];
	   					attrData: number[];
	   				};
	   			};
	   		};
	   		S: {
	   			id: number;
	   			attr: string;
	   			internalID: number;
	   			attrX: boolean;
	   			attrY: boolean;
	   			attrZ: boolean;
	   			containerBoneID: number;
	   			containerID: number;
	   			curves: {
	   				x: {
	   					version: any;
	   					id: number;
	   					internalID: number;
	   					times: number[];
	   					values: number[];
	   					attrFlag: number[];
	   					attrData: number[];
	   				};
	   				y: {
	   					version: any;
	   					id: number;
	   					internalID: number;
	   					times: number[];
	   					values: number[];
	   					attrFlag: number[];
	   					attrData: number[];
	   				};
	   				z: {
	   					version: any;
	   					id: number;
	   					internalID: number;
	   					times: number[];
	   					values: number[];
	   					attrFlag: number[];
	   					attrData: number[];
	   				};
	   			};
	   		};
	   	}>;
	   	layers: Map<number, {
	   		T: {
	   			id: number;
	   			attr: string;
	   			internalID: number;
	   			attrX: boolean;
	   			attrY: boolean;
	   			attrZ: boolean;
	   			containerBoneID: number;
	   			containerID: number;
	   			curves: {
	   				x: {
	   					version: any;
	   					id: number;
	   					internalID: number;
	   					times: number[];
	   					values: number[];
	   					attrFlag: number[];
	   					attrData: number[];
	   				};
	   				y: {
	   					version: any;
	   					id: number;
	   					internalID: number;
	   					times: number[];
	   					values: number[];
	   					attrFlag: number[];
	   					attrData: number[];
	   				};
	   				z: {
	   					version: any;
	   					id: number;
	   					internalID: number;
	   					times: number[];
	   					values: number[];
	   					attrFlag: number[];
	   					attrData: number[];
	   				};
	   			};
	   		};
	   		R: {
	   			id: number;
	   			attr: string;
	   			internalID: number;
	   			attrX: boolean;
	   			attrY: boolean;
	   			attrZ: boolean;
	   			containerBoneID: number;
	   			containerID: number;
	   			curves: {
	   				x: {
	   					version: any;
	   					id: number;
	   					internalID: number;
	   					times: number[];
	   					values: number[];
	   					attrFlag: number[];
	   					attrData: number[];
	   				};
	   				y: {
	   					version: any;
	   					id: number;
	   					internalID: number;
	   					times: number[];
	   					values: number[];
	   					attrFlag: number[];
	   					attrData: number[];
	   				};
	   				z: {
	   					version: any;
	   					id: number;
	   					internalID: number;
	   					times: number[];
	   					values: number[];
	   					attrFlag: number[];
	   					attrData: number[];
	   				};
	   			};
	   		};
	   		S: {
	   			id: number;
	   			attr: string;
	   			internalID: number;
	   			attrX: boolean;
	   			attrY: boolean;
	   			attrZ: boolean;
	   			containerBoneID: number;
	   			containerID: number;
	   			curves: {
	   				x: {
	   					version: any;
	   					id: number;
	   					internalID: number;
	   					times: number[];
	   					values: number[];
	   					attrFlag: number[];
	   					attrData: number[];
	   				};
	   				y: {
	   					version: any;
	   					id: number;
	   					internalID: number;
	   					times: number[];
	   					values: number[];
	   					attrFlag: number[];
	   					attrData: number[];
	   				};
	   				z: {
	   					version: any;
	   					id: number;
	   					internalID: number;
	   					times: number[];
	   					values: number[];
	   					attrFlag: number[];
	   					attrData: number[];
	   				};
	   			};
	   		};
	   	}[]>;
	   	stacks: Map<number, {
	   		name: string;
	   		layers: {
	   			T: {
	   				id: number;
	   				attr: string;
	   				internalID: number;
	   				attrX: boolean;
	   				attrY: boolean;
	   				attrZ: boolean;
	   				containerBoneID: number;
	   				containerID: number;
	   				curves: {
	   					x: {
	   						version: any;
	   						id: number;
	   						internalID: number;
	   						times: number[];
	   						values: number[];
	   						attrFlag: number[];
	   						attrData: number[];
	   					};
	   					y: {
	   						version: any;
	   						id: number;
	   						internalID: number;
	   						times: number[];
	   						values: number[];
	   						attrFlag: number[];
	   						attrData: number[];
	   					};
	   					z: {
	   						version: any;
	   						id: number;
	   						internalID: number;
	   						times: number[];
	   						values: number[];
	   						attrFlag: number[];
	   						attrData: number[];
	   					};
	   				};
	   			};
	   			R: {
	   				id: number;
	   				attr: string;
	   				internalID: number;
	   				attrX: boolean;
	   				attrY: boolean;
	   				attrZ: boolean;
	   				containerBoneID: number;
	   				containerID: number;
	   				curves: {
	   					x: {
	   						version: any;
	   						id: number;
	   						internalID: number;
	   						times: number[];
	   						values: number[];
	   						attrFlag: number[];
	   						attrData: number[];
	   					};
	   					y: {
	   						version: any;
	   						id: number;
	   						internalID: number;
	   						times: number[];
	   						values: number[];
	   						attrFlag: number[];
	   						attrData: number[];
	   					};
	   					z: {
	   						version: any;
	   						id: number;
	   						internalID: number;
	   						times: number[];
	   						values: number[];
	   						attrFlag: number[];
	   						attrData: number[];
	   					};
	   				};
	   			};
	   			S: {
	   				id: number;
	   				attr: string;
	   				internalID: number;
	   				attrX: boolean;
	   				attrY: boolean;
	   				attrZ: boolean;
	   				containerBoneID: number;
	   				containerID: number;
	   				curves: {
	   					x: {
	   						version: any;
	   						id: number;
	   						internalID: number;
	   						times: number[];
	   						values: number[];
	   						attrFlag: number[];
	   						attrData: number[];
	   					};
	   					y: {
	   						version: any;
	   						id: number;
	   						internalID: number;
	   						times: number[];
	   						values: number[];
	   						attrFlag: number[];
	   						attrData: number[];
	   					};
	   					z: {
	   						version: any;
	   						id: number;
	   						internalID: number;
	   						times: number[];
	   						values: number[];
	   						attrFlag: number[];
	   						attrData: number[];
	   					};
	   				};
	   			};
	   		}[][];
	   		length: number;
	   		frames: number;
	   	}>;
	   	length: number;
	   	fps: number;
	   	frames: number;
	   }} animations,
	    * @param {{skeleton: { bones: THREE.Bone[]}}} group
	    */
				function addAnimations(group, animations) {
	
					if (group.animations === undefined) {
	
						group.animations = [];
					}
	
					animations.stacks.forEach(function (stack) {
	
						var animationData = {
							name: stack.name,
							fps: 30,
							length: stack.length,
							hierarchy: []
						};
	
						var bones = group.skeleton.bones;
	
						bones.forEach(function (bone) {
	
							var name = bone.name.replace(/.*:/, '');
							var parentIndex = bones.findIndex(function (parentBone) {
	
								return bone.parent === parentBone;
							});
							animationData.hierarchy.push({ parent: parentIndex, name: name, keys: [] });
						});
	
						for (var frame = 0; frame < stack.frames; frame++) {
	
							bones.forEach(function (bone, boneIndex) {
	
								var animationNode = stack.layers[0][boneIndex];
	
								animationData.hierarchy.forEach(function (node) {
	
									if (node.name === bone.name) {
	
										node.keys.push(generateKey(animationNode, bone, frame));
									}
								});
							});
						}
	
						group.animations.push(THREE.AnimationClip.parseAnimation(animationData, bones));
	
						/**
	      * @param {THREE.Bone} bone
	      */
						function generateKey(animationNode, bone, frame) {
	
							var key = {
								time: frame / animations.fps,
								pos: bone.position.toArray(),
								rot: bone.quaternion.toArray(),
								scl: bone.scale.toArray()
							};
	
							if (animationNode === undefined) {
	
								return key;
							}
	
							try {
	
								if (hasCurve(animationNode, 'T') && hasKeyOnFrame(animationNode.T, frame)) {
	
									key.pos = [animationNode.T.curves.x.values[frame], animationNode.T.curves.y.values[frame], animationNode.T.curves.z.values[frame]];
								}
	
								if (hasCurve(animationNode, 'R') && hasKeyOnFrame(animationNode.R, frame)) {
	
									var rotationX = degreeToRadian(animationNode.R.curves.x.values[frame]);
									var rotationY = degreeToRadian(animationNode.R.curves.y.values[frame]);
									var rotationZ = degreeToRadian(animationNode.R.curves.z.values[frame]);
									var euler = new THREE.Euler(rotationX, rotationY, rotationZ, 'ZYX');
									key.rot = new THREE.Quaternion().setFromEuler(euler).toArray();
								}
	
								if (hasCurve(animationNode, 'S') && hasKeyOnFrame(animationNode.S, frame)) {
	
									key.scl = [animationNode.S.curves.x.values[frame], animationNode.S.curves.y.values[frame], animationNode.S.curves.z.values[frame]];
								}
							} catch (error) {
	
								// Curve is not fully plotted.
								console.log(bone);
								console.log(error);
							}
	
							return key;
	
							function hasCurve(animationNode, attribute) {
	
								if (animationNode === undefined) {
	
									return false;
								}
	
								var attributeNode = animationNode[attribute];
								if (!attributeNode) {
	
									return false;
								}
	
								return ['x', 'y', 'z'].every(function (key) {
	
									return attributeNode.curves[key] !== undefined;
								});
							}
	
							function hasKeyOnFrame(attributeNode, frame) {
	
								return ['x', 'y', 'z'].every(function (key) {
	
									return isKeyExistOnFrame(attributeNode.curves[key], frame);
	
									function isKeyExistOnFrame(curve, frame) {
	
										return curve.values[frame] !== undefined;
									}
								});
							}
						}
					});
				}
	
				// UTILS
				/**
	    * Parses Vector3 property from FBXTree.  Property is given as .value.x, .value.y, etc.
	    * @param {FBXVector3} property - Property to parse as Vector3.
	    * @returns {THREE.Vector3}
	    */
				function parseVector3(property) {
	
					return new THREE.Vector3(parseFloat(property.value.x), parseFloat(property.value.y), parseFloat(property.value.z));
				}
	
				/**
	    * Parses Color property from FBXTree.  Property is given as .value.x, .value.y, etc.
	    * @param {FBXVector3} property - Property to parse as Color.
	    * @returns {THREE.Color}
	    */
				function parseColor(property) {
	
					return new THREE.Color().fromArray(parseVector3(property).toArray());
				}
			}
	
		});
	
		/**
	  * An instance of a Vertex with data for drawing vertices to the screen.
	  * @constructor
	  */
		function Vertex() {
	
			/**
	   * Position of the vertex.
	   * @type {THREE.Vector3}
	   */
			this.position = new THREE.Vector3();
	
			/**
	   * Normal of the vertex
	   * @type {THREE.Vector3}
	   */
			this.normal = new THREE.Vector3();
	
			/**
	   * UV coordinates of the vertex.
	   * @type {THREE.Vector2}
	   */
			this.uv = new THREE.Vector2();
	
			/**
	   * Indices of the bones vertex is influenced by.
	   * @type {THREE.Vector4}
	   */
			this.skinIndices = new THREE.Vector4(0, 0, 0, 0);
	
			/**
	   * Weights that each bone influences the vertex.
	   * @type {THREE.Vector4}
	   */
			this.skinWeights = new THREE.Vector4(0, 0, 0, 0);
		}
	
		_assign(Vertex.prototype, {
	
			copy: function copy(target) {
	
				var returnVar = target || new Vertex();
	
				returnVar.position.copy(this.position);
				returnVar.normal.copy(this.normal);
				returnVar.uv.copy(this.uv);
				returnVar.skinIndices.copy(this.skinIndices);
				returnVar.skinWeights.copy(this.skinWeights);
	
				return returnVar;
			},
	
			flattenToBuffers: function flattenToBuffers() {
	
				var vertexBuffer = this.position.toArray();
				var normalBuffer = this.normal.toArray();
				var uvBuffer = this.uv.toArray();
				var skinIndexBuffer = this.skinIndices.toArray();
				var skinWeightBuffer = this.skinWeights.toArray();
	
				return {
					vertexBuffer: vertexBuffer,
					normalBuffer: normalBuffer,
					uvBuffer: uvBuffer,
					skinIndexBuffer: skinIndexBuffer,
					skinWeightBuffer: skinWeightBuffer
				};
			}
	
		});
	
		/**
	  * @constructor
	  */
		function Triangle() {
	
			/**
	   * @type {{position: THREE.Vector3, normal: THREE.Vector3, uv: THREE.Vector2, skinIndices: THREE.Vector4, skinWeights: THREE.Vector4}[]}
	   */
			this.vertices = [];
		}
	
		_assign(Triangle.prototype, {
	
			copy: function copy(target) {
	
				var returnVar = target || new Triangle();
	
				for (var i = 0; i < this.vertices.length; ++i) {
	
					this.vertices[i].copy(returnVar.vertices[i]);
				}
	
				return returnVar;
			},
	
			flattenToBuffers: function flattenToBuffers() {
	
				var vertexBuffer = [];
				var normalBuffer = [];
				var uvBuffer = [];
				var skinIndexBuffer = [];
				var skinWeightBuffer = [];
	
				this.vertices.forEach(function (vertex) {
	
					var flatVertex = vertex.flattenToBuffers();
					vertexBuffer = vertexBuffer.concat(flatVertex.vertexBuffer);
					normalBuffer = normalBuffer.concat(flatVertex.normalBuffer);
					uvBuffer = uvBuffer.concat(flatVertex.uvBuffer);
					skinIndexBuffer = skinIndexBuffer.concat(flatVertex.skinIndexBuffer);
					skinWeightBuffer = skinWeightBuffer.concat(flatVertex.skinWeightBuffer);
				});
	
				return {
					vertexBuffer: vertexBuffer,
					normalBuffer: normalBuffer,
					uvBuffer: uvBuffer,
					skinIndexBuffer: skinIndexBuffer,
					skinWeightBuffer: skinWeightBuffer
				};
			}
	
		});
	
		/**
	  * @constructor
	  */
		function Face() {
	
			/**
	   * @type {{vertices: {position: THREE.Vector3, normal: THREE.Vector3, uv: THREE.Vector2, skinIndices: THREE.Vector4, skinWeights: THREE.Vector4}[]}[]}
	   */
			this.triangles = [];
			this.materialIndex = 0;
		}
	
		_assign(Face.prototype, {
	
			copy: function copy(target) {
	
				var returnVar = target || new Face();
	
				for (var i = 0; i < this.triangles.length; ++i) {
	
					this.triangles[i].copy(returnVar.triangles[i]);
				}
	
				returnVar.materialIndex = this.materialIndex;
	
				return returnVar;
			},
	
			genTrianglesFromVertices: function genTrianglesFromVertices(vertexArray) {
	
				for (var i = 2; i < vertexArray.length; ++i) {
	
					var triangle = new Triangle();
					triangle.vertices[0] = vertexArray[0];
					triangle.vertices[1] = vertexArray[i - 1];
					triangle.vertices[2] = vertexArray[i];
					this.triangles.push(triangle);
				}
			},
	
			flattenToBuffers: function flattenToBuffers() {
	
				var vertexBuffer = [];
				var normalBuffer = [];
				var uvBuffer = [];
				var skinIndexBuffer = [];
				var skinWeightBuffer = [];
	
				var materialIndexBuffer = [];
	
				var materialIndex = this.materialIndex;
	
				this.triangles.forEach(function (triangle) {
	
					var flatTriangle = triangle.flattenToBuffers();
					vertexBuffer = vertexBuffer.concat(flatTriangle.vertexBuffer);
					normalBuffer = normalBuffer.concat(flatTriangle.normalBuffer);
					uvBuffer = uvBuffer.concat(flatTriangle.uvBuffer);
					skinIndexBuffer = skinIndexBuffer.concat(flatTriangle.skinIndexBuffer);
					skinWeightBuffer = skinWeightBuffer.concat(flatTriangle.skinWeightBuffer);
					materialIndexBuffer = materialIndexBuffer.concat([materialIndex, materialIndex, materialIndex]);
				});
	
				return {
					vertexBuffer: vertexBuffer,
					normalBuffer: normalBuffer,
					uvBuffer: uvBuffer,
					skinIndexBuffer: skinIndexBuffer,
					skinWeightBuffer: skinWeightBuffer,
					materialIndexBuffer: materialIndexBuffer
				};
			}
	
		});
	
		/**
	  * @constructor
	  */
		function Geometry() {
	
			/**
	   * @type {{triangles: {vertices: {position: THREE.Vector3, normal: THREE.Vector3, uv: THREE.Vector2, skinIndices: THREE.Vector4, skinWeights: THREE.Vector4}[]}[], materialIndex: number}[]}
	   */
			this.faces = [];
	
			/**
	   * @type {{}|THREE.Skeleton}
	   */
			this.skeleton = null;
		}
	
		_assign(Geometry.prototype, {
	
			/**
	   * @returns	{{vertexBuffer: number[], normalBuffer: number[], uvBuffer: number[], skinIndexBuffer: number[], skinWeightBuffer: number[], materialIndexBuffer: number[]}}
	   */
			flattenToBuffers: function flattenToBuffers() {
	
				var vertexBuffer = [];
				var normalBuffer = [];
				var uvBuffer = [];
				var skinIndexBuffer = [];
				var skinWeightBuffer = [];
	
				var materialIndexBuffer = [];
	
				this.faces.forEach(function (face) {
	
					var flatFace = face.flattenToBuffers();
					vertexBuffer = vertexBuffer.concat(flatFace.vertexBuffer);
					normalBuffer = normalBuffer.concat(flatFace.normalBuffer);
					uvBuffer = uvBuffer.concat(flatFace.uvBuffer);
					skinIndexBuffer = skinIndexBuffer.concat(flatFace.skinIndexBuffer);
					skinWeightBuffer = skinWeightBuffer.concat(flatFace.skinWeightBuffer);
					materialIndexBuffer = materialIndexBuffer.concat(flatFace.materialIndexBuffer);
				});
	
				return {
					vertexBuffer: vertexBuffer,
					normalBuffer: normalBuffer,
					uvBuffer: uvBuffer,
					skinIndexBuffer: skinIndexBuffer,
					skinWeightBuffer: skinWeightBuffer,
					materialIndexBuffer: materialIndexBuffer
				};
			}
	
		});
	
		function TextParser() {}
	
		_assign(TextParser.prototype, {
	
			getPrevNode: function getPrevNode() {
	
				return this.nodeStack[this.currentIndent - 2];
			},
	
			getCurrentNode: function getCurrentNode() {
	
				return this.nodeStack[this.currentIndent - 1];
			},
	
			getCurrentProp: function getCurrentProp() {
	
				return this.currentProp;
			},
	
			pushStack: function pushStack(node) {
	
				this.nodeStack.push(node);
				this.currentIndent += 1;
			},
	
			popStack: function popStack() {
	
				this.nodeStack.pop();
				this.currentIndent -= 1;
			},
	
			setCurrentProp: function setCurrentProp(val, name) {
	
				this.currentProp = val;
				this.currentPropName = name;
			},
	
			// ----------parse ---------------------------------------------------
			parse: function parse(text) {
	
				this.currentIndent = 0;
				this.allNodes = new FBXTree();
				this.nodeStack = [];
				this.currentProp = [];
				this.currentPropName = '';
	
				var split = text.split("\n");
				for (var line in split) {
	
					var l = split[line];
	
					// short cut
					if (l.match(/^[\s\t]*;/)) {
	
						continue;
					} // skip comment line
					if (l.match(/^[\s\t]*$/)) {
	
						continue;
					} // skip empty line
	
					// beginning of node
					var beginningOfNodeExp = new RegExp("^\\t{" + this.currentIndent + "}(\\w+):(.*){", '');
					var match = l.match(beginningOfNodeExp);
					if (match) {
	
						var nodeName = match[1].trim().replace(/^"/, '').replace(/"$/, "");
						var nodeAttrs = match[2].split(',').map(function (element) {
	
							return element.trim().replace(/^"/, '').replace(/"$/, '');
						});
	
						this.parseNodeBegin(l, nodeName, nodeAttrs || null);
						continue;
					}
	
					// node's property
					var propExp = new RegExp("^\\t{" + this.currentIndent + "}(\\w+):[\\s\\t\\r\\n](.*)");
					var match = l.match(propExp);
					if (match) {
	
						var propName = match[1].replace(/^"/, '').replace(/"$/, "").trim();
						var propValue = match[2].replace(/^"/, '').replace(/"$/, "").trim();
	
						this.parseNodeProperty(l, propName, propValue);
						continue;
					}
	
					// end of node
					var endOfNodeExp = new RegExp("^\\t{" + (this.currentIndent - 1) + "}}");
					if (l.match(endOfNodeExp)) {
	
						this.nodeEnd();
						continue;
					}
	
					// for special case,
					//
					//	  Vertices: *8670 {
					//		  a: 0.0356229953467846,13.9599733352661,-0.399196773.....(snip)
					// -0.0612030513584614,13.960485458374,-0.409748703241348,-0.10.....
					// 0.12490539252758,13.7450733184814,-0.454119384288788,0.09272.....
					// 0.0836158767342567,13.5432004928589,-0.435397416353226,0.028.....
					//
					// these case the lines must contiue with previous line
					if (l.match(/^[^\s\t}]/)) {
	
						this.parseNodePropertyContinued(l);
					}
				}
	
				return this.allNodes;
			},
	
			parseNodeBegin: function parseNodeBegin(line, nodeName, nodeAttrs) {
	
				// var nodeName = match[1];
				var node = { 'name': nodeName, properties: {}, 'subNodes': {} };
				var attrs = this.parseNodeAttr(nodeAttrs);
				var currentNode = this.getCurrentNode();
	
				// a top node
				if (this.currentIndent === 0) {
	
					this.allNodes.add(nodeName, node);
				} else {
	
					// a subnode
	
					// already exists subnode, then append it
					if (nodeName in currentNode.subNodes) {
	
						var tmp = currentNode.subNodes[nodeName];
	
						// console.log( "duped entry found\nkey: " + nodeName + "\nvalue: " + propValue );
						if (this.isFlattenNode(currentNode.subNodes[nodeName])) {
	
							if (attrs.id === '') {
	
								currentNode.subNodes[nodeName] = [];
								currentNode.subNodes[nodeName].push(tmp);
							} else {
	
								currentNode.subNodes[nodeName] = {};
								currentNode.subNodes[nodeName][tmp.id] = tmp;
							}
						}
	
						if (attrs.id === '') {
	
							currentNode.subNodes[nodeName].push(node);
						} else {
	
							currentNode.subNodes[nodeName][attrs.id] = node;
						}
					} else if (typeof attrs.id === 'number' || attrs.id.match(/^\d+$/)) {
	
						currentNode.subNodes[nodeName] = {};
						currentNode.subNodes[nodeName][attrs.id] = node;
					} else {
	
						currentNode.subNodes[nodeName] = node;
					}
				}
	
				// for this		  ↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓
				// NodeAttribute: 1001463072, "NodeAttribute::", "LimbNode" {
				if (nodeAttrs) {
	
					node.id = attrs.id;
					node.attrName = attrs.name;
					node.attrType = attrs.type;
				}
	
				this.pushStack(node);
			},
	
			parseNodeAttr: function parseNodeAttr(attrs) {
	
				var id = attrs[0];
	
				if (attrs[0] !== "") {
	
					id = parseInt(attrs[0]);
	
					if (isNaN(id)) {
	
						// PolygonVertexIndex: *16380 {
						id = attrs[0];
					}
				}
	
				var name;
				var type;
				if (attrs.length > 1) {
	
					name = attrs[1].replace(/^(\w+)::/, '');
					type = attrs[2];
				}
	
				return { id: id, name: name || '', type: type || '' };
			},
	
			parseNodeProperty: function parseNodeProperty(line, propName, propValue) {
	
				var currentNode = this.getCurrentNode();
				var parentName = currentNode.name;
	
				// special case parent node's is like "Properties70"
				// these chilren nodes must treat with careful
				if (parentName !== undefined) {
	
					var propMatch = parentName.match(/Properties(\d)+/);
					if (propMatch) {
	
						this.parseNodeSpecialProperty(line, propName, propValue);
						return;
					}
				}
	
				// special case Connections
				if (propName == 'C') {
	
					var connProps = propValue.split(',').slice(1);
					var from = parseInt(connProps[0]);
					var to = parseInt(connProps[1]);
	
					var rest = propValue.split(',').slice(3);
	
					propName = 'connections';
					propValue = [from, to];
					propValue = propValue.concat(rest);
	
					if (currentNode.properties[propName] === undefined) {
	
						currentNode.properties[propName] = [];
					}
				}
	
				// special case Connections
				if (propName == 'Node') {
	
					var id = parseInt(propValue);
					currentNode.properties.id = id;
					currentNode.id = id;
				}
	
				// already exists in properties, then append this
				if (propName in currentNode.properties) {
	
					// console.log( "duped entry found\nkey: " + propName + "\nvalue: " + propValue );
					if (Array.isArray(currentNode.properties[propName])) {
	
						currentNode.properties[propName].push(propValue);
					} else {
	
						currentNode.properties[propName] += propValue;
					}
				} else {
	
					// console.log( propName + ":  " + propValue );
					if (Array.isArray(currentNode.properties[propName])) {
	
						currentNode.properties[propName].push(propValue);
					} else {
	
						currentNode.properties[propName] = propValue;
					}
				}
	
				this.setCurrentProp(currentNode.properties, propName);
			},
	
			// TODO:
			parseNodePropertyContinued: function parseNodePropertyContinued(line) {
	
				this.currentProp[this.currentPropName] += line;
			},
	
			parseNodeSpecialProperty: function parseNodeSpecialProperty(line, propName, propValue) {
	
				// split this
				// P: "Lcl Scaling", "Lcl Scaling", "", "A",1,1,1
				// into array like below
				// ["Lcl Scaling", "Lcl Scaling", "", "A", "1,1,1" ]
				var props = propValue.split('",').map(function (element) {
	
					return element.trim().replace(/^\"/, '').replace(/\s/, '_');
				});
	
				var innerPropName = props[0];
				var innerPropType1 = props[1];
				var innerPropType2 = props[2];
				var innerPropFlag = props[3];
				var innerPropValue = props[4];
	
				/*
	   if ( innerPropValue === undefined ) {
	   	innerPropValue = props[3];
	   }
	   */
	
				// cast value in its type
				switch (innerPropType1) {
	
					case "int":
						innerPropValue = parseInt(innerPropValue);
						break;
	
					case "double":
						innerPropValue = parseFloat(innerPropValue);
						break;
	
					case "ColorRGB":
					case "Vector3D":
						var tmp = innerPropValue.split(',');
						innerPropValue = new THREE.Vector3(tmp[0], tmp[1], tmp[2]);
						break;
	
				}
	
				// CAUTION: these props must append to parent's parent
				this.getPrevNode().properties[innerPropName] = {
	
					'type': innerPropType1,
					'type2': innerPropType2,
					'flag': innerPropFlag,
					'value': innerPropValue
	
				};
	
				this.setCurrentProp(this.getPrevNode().properties, innerPropName);
			},
	
			nodeEnd: function nodeEnd() {
	
				this.popStack();
			},
	
			/* ---------------------------------------------------------------- */
			/*		util													  */
			isFlattenNode: function isFlattenNode(node) {
	
				return 'subNodes' in node && 'properties' in node ? true : false;
			}
	
		});
	
		function FBXTree() {}
	
		_assign(FBXTree.prototype, {
	
			add: function add(key, val) {
	
				this[key] = val;
			},
	
			searchConnectionParent: function searchConnectionParent(id) {
	
				if (this.__cache_search_connection_parent === undefined) {
	
					this.__cache_search_connection_parent = [];
				}
	
				if (this.__cache_search_connection_parent[id] !== undefined) {
	
					return this.__cache_search_connection_parent[id];
				} else {
	
					this.__cache_search_connection_parent[id] = [];
				}
	
				var conns = this.Connections.properties.connections;
	
				var results = [];
				for (var i = 0; i < conns.length; ++i) {
	
					if (conns[i][0] == id) {
	
						// 0 means scene root
						var res = conns[i][1] === 0 ? -1 : conns[i][1];
						results.push(res);
					}
				}
	
				if (results.length > 0) {
	
					this.__cache_search_connection_parent[id] = this.__cache_search_connection_parent[id].concat(results);
					return results;
				} else {
	
					this.__cache_search_connection_parent[id] = [-1];
					return [-1];
				}
			},
	
			searchConnectionChildren: function searchConnectionChildren(id) {
	
				if (this.__cache_search_connection_children === undefined) {
	
					this.__cache_search_connection_children = [];
				}
	
				if (this.__cache_search_connection_children[id] !== undefined) {
	
					return this.__cache_search_connection_children[id];
				} else {
	
					this.__cache_search_connection_children[id] = [];
				}
	
				var conns = this.Connections.properties.connections;
	
				var res = [];
				for (var i = 0; i < conns.length; ++i) {
	
					if (conns[i][1] == id) {
	
						// 0 means scene root
						res.push(conns[i][0] === 0 ? -1 : conns[i][0]);
						// there may more than one kid, then search to the end
					}
				}
	
				if (res.length > 0) {
	
					this.__cache_search_connection_children[id] = this.__cache_search_connection_children[id].concat(res);
					return res;
				} else {
	
					this.__cache_search_connection_children[id] = [];
					return [];
				}
			},
	
			searchConnectionType: function searchConnectionType(id, to) {
	
				var key = id + ',' + to; // TODO: to hash
				if (this.__cache_search_connection_type === undefined) {
	
					this.__cache_search_connection_type = {};
				}
	
				if (this.__cache_search_connection_type[key] !== undefined) {
	
					return this.__cache_search_connection_type[key];
				} else {
	
					this.__cache_search_connection_type[key] = '';
				}
	
				var conns = this.Connections.properties.connections;
	
				for (var i = 0; i < conns.length; ++i) {
	
					if (conns[i][0] == id && conns[i][1] == to) {
	
						// 0 means scene root
						this.__cache_search_connection_type[key] = conns[i][2];
						return conns[i][2];
					}
				}
	
				this.__cache_search_connection_type[id] = null;
				return null;
			}
	
		});
	
		/**
	  * @returns {boolean}
	  */
		function isFbxFormatASCII(text) {
	
			var CORRECT = ['K', 'a', 'y', 'd', 'a', 'r', 'a', '\\', 'F', 'B', 'X', '\\', 'B', 'i', 'n', 'a', 'r', 'y', '\\', '\\'];
	
			var cursor = 0;
			var read = function read(offset) {
	
				var result = text[offset - 1];
				text = text.slice(cursor + offset);
				cursor++;
				return result;
			};
	
			for (var i = 0; i < CORRECT.length; ++i) {
	
				var num = read(1);
				if (num == CORRECT[i]) {
	
					return false;
				}
			}
	
			return true;
		}
	
		/**
	  * @returns {number}
	  */
		function getFbxVersion(text) {
	
			var versionRegExp = /FBXVersion: (\d+)/;
			var match = text.match(versionRegExp);
			if (match) {
	
				var version = parseInt(match[1]);
				return version;
			}
			throw new Error('FBXLoader: Cannot find the version number for the file given.');
		}
	
		/**
	  * Converts FBX ticks into real time seconds.
	  * @param {number} time - FBX tick timestamp to convert.
	  * @returns {number} - FBX tick in real world time.
	  */
		function ConvertFBXTimeToSeconds(time) {
	
			// Constant is FBX ticks per second.
			return time / 46186158000;
		}
	
		/**
	  * Parses comma separated list of float numbers and returns them in an array.
	  * @example
	  * // Returns [ 5.6, 9.4, 2.5, 1.4 ]
	  * parseFloatArray( "5.6,9.4,2.5,1.4" )
	  * @returns {number[]}
	  */
		function parseFloatArray(floatString) {
	
			return floatString.split(',').map(function (stringValue) {
	
				return parseFloat(stringValue);
			});
		}
	
		/**
	  * Parses comma separated list of int numbers and returns them in an array.
	  * @example
	  * // Returns [ 5, 8, 2, 3 ]
	  * parseFloatArray( "5,8,2,3" )
	  * @returns {number[]}
	  */
		function parseIntArray(intString) {
	
			return intString.split(',').map(function (stringValue) {
	
				return parseInt(stringValue);
			});
		}
	
		function parseMatrixArray(floatString) {
	
			return new THREE.Matrix4().fromArray(parseFloatArray(floatString));
		}
	
		/**
	  * Converts number from degrees into radians.
	  * @param {number} value
	  * @returns {number}
	  */
		function degreeToRadian(value) {
	
			return value * Math.PI / 180;
		}
	})();
	/* eslint-enable */

/***/ }),
/* 124 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var _three = __webpack_require__(2);
	
	var THREE = _interopRequireWildcard(_three);
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	/**
	 * Loads a Wavefront .mtl file specifying materials
	 *
	 * @author angelxuanchang
	 */
	
	THREE.MTLLoader = function (manager) {
	
		this.manager = manager !== undefined ? manager : THREE.DefaultLoadingManager;
	}; /* eslint-disable */
	/**
	 * Loads a Wavefront .mtl file specifying materials
	 *
	 * @author angelxuanchang
	 */
	
	
	THREE.MTLLoader.prototype = {
	
		constructor: THREE.MTLLoader,
	
		/**
	  * Loads and parses a MTL asset from a URL.
	  *
	  * @param {String} url - URL to the MTL file.
	  * @param {Function} [onLoad] - Callback invoked with the loaded object.
	  * @param {Function} [onProgress] - Callback for download progress.
	  * @param {Function} [onError] - Callback for download errors.
	  *
	  * @see setPath setTexturePath
	  *
	  * @note In order for relative texture references to resolve correctly
	  * you must call setPath and/or setTexturePath explicitly prior to load.
	  */
		load: function load(url, onLoad, onProgress, onError) {
	
			var scope = this;
	
			var loader = new THREE.FileLoader(this.manager);
			loader.setPath(this.path);
			loader.load(url, function (text) {
	
				onLoad(scope.parse(text));
			}, onProgress, onError);
		},
	
		/**
	  * Set base path for resolving references.
	  * If set this path will be prepended to each loaded and found reference.
	  *
	  * @see setTexturePath
	  * @param {String} path
	  *
	  * @example
	  *     mtlLoader.setPath( 'assets/obj/' );
	  *     mtlLoader.load( 'my.mtl', ... );
	  */
		setPath: function setPath(path) {
	
			this.path = path;
		},
	
		/**
	  * Set base path for resolving texture references.
	  * If set this path will be prepended found texture reference.
	  * If not set and setPath is, it will be used as texture base path.
	  *
	  * @see setPath
	  * @param {String} path
	  *
	  * @example
	  *     mtlLoader.setPath( 'assets/obj/' );
	  *     mtlLoader.setTexturePath( 'assets/textures/' );
	  *     mtlLoader.load( 'my.mtl', ... );
	  */
		setTexturePath: function setTexturePath(path) {
	
			this.texturePath = path;
		},
	
		setBaseUrl: function setBaseUrl(path) {
	
			console.warn('THREE.MTLLoader: .setBaseUrl() is deprecated. Use .setTexturePath( path ) for texture path or .setPath( path ) for general base path instead.');
	
			this.setTexturePath(path);
		},
	
		setCrossOrigin: function setCrossOrigin(value) {
	
			this.crossOrigin = value;
		},
	
		setMaterialOptions: function setMaterialOptions(value) {
	
			this.materialOptions = value;
		},
	
		/**
	  * Parses a MTL file.
	  *
	  * @param {String} text - Content of MTL file
	  * @return {THREE.MTLLoader.MaterialCreator}
	  *
	  * @see setPath setTexturePath
	  *
	  * @note In order for relative texture references to resolve correctly
	  * you must call setPath and/or setTexturePath explicitly prior to parse.
	  */
		parse: function parse(text) {
	
			var lines = text.split('\n');
			var info = {};
			var delimiter_pattern = /\s+/;
			var materialsInfo = {};
	
			for (var i = 0; i < lines.length; i++) {
	
				var line = lines[i];
				line = line.trim();
	
				if (line.length === 0 || line.charAt(0) === '#') {
	
					// Blank line or comment ignore
					continue;
				}
	
				var pos = line.indexOf(' ');
	
				var key = pos >= 0 ? line.substring(0, pos) : line;
				key = key.toLowerCase();
	
				var value = pos >= 0 ? line.substring(pos + 1) : '';
				value = value.trim();
	
				if (key === 'newmtl') {
	
					// New material
	
					info = { name: value };
					materialsInfo[value] = info;
				} else if (info) {
	
					if (key === 'ka' || key === 'kd' || key === 'ks') {
	
						var ss = value.split(delimiter_pattern, 3);
						info[key] = [parseFloat(ss[0]), parseFloat(ss[1]), parseFloat(ss[2])];
					} else {
	
						info[key] = value;
					}
				}
			}
	
			var materialCreator = new THREE.MTLLoader.MaterialCreator(this.texturePath || this.path, this.materialOptions);
			materialCreator.setCrossOrigin(this.crossOrigin);
			materialCreator.setManager(this.manager);
			materialCreator.setMaterials(materialsInfo);
			return materialCreator;
		}
	
	};
	
	/**
	 * Create a new THREE-MTLLoader.MaterialCreator
	 * @param baseUrl - Url relative to which textures are loaded
	 * @param options - Set of options on how to construct the materials
	 *                  side: Which side to apply the material
	 *                        THREE.FrontSide (default), THREE.BackSide, THREE.DoubleSide
	 *                  wrap: What type of wrapping to apply for textures
	 *                        THREE.RepeatWrapping (default), THREE.ClampToEdgeWrapping, THREE.MirroredRepeatWrapping
	 *                  normalizeRGB: RGBs need to be normalized to 0-1 from 0-255
	 *                                Default: false, assumed to be already normalized
	 *                  ignoreZeroRGBs: Ignore values of RGBs (Ka,Kd,Ks) that are all 0's
	 *                                  Default: false
	 * @constructor
	 */
	
	THREE.MTLLoader.MaterialCreator = function (baseUrl, options) {
	
		this.baseUrl = baseUrl || '';
		this.options = options;
		this.materialsInfo = {};
		this.materials = {};
		this.materialsArray = [];
		this.nameLookup = {};
	
		this.side = this.options && this.options.side ? this.options.side : THREE.FrontSide;
		this.wrap = this.options && this.options.wrap ? this.options.wrap : THREE.RepeatWrapping;
	};
	
	THREE.MTLLoader.MaterialCreator.prototype = {
	
		constructor: THREE.MTLLoader.MaterialCreator,
	
		setCrossOrigin: function setCrossOrigin(value) {
	
			this.crossOrigin = value;
		},
	
		setManager: function setManager(value) {
	
			this.manager = value;
		},
	
		setMaterials: function setMaterials(materialsInfo) {
	
			this.materialsInfo = this.convert(materialsInfo);
			this.materials = {};
			this.materialsArray = [];
			this.nameLookup = {};
		},
	
		convert: function convert(materialsInfo) {
	
			if (!this.options) return materialsInfo;
	
			var converted = {};
	
			for (var mn in materialsInfo) {
	
				// Convert materials info into normalized form based on options
	
				var mat = materialsInfo[mn];
	
				var covmat = {};
	
				converted[mn] = covmat;
	
				for (var prop in mat) {
	
					var save = true;
					var value = mat[prop];
					var lprop = prop.toLowerCase();
	
					switch (lprop) {
	
						case 'kd':
						case 'ka':
						case 'ks':
	
							// Diffuse color (color under white light) using RGB values
	
							if (this.options && this.options.normalizeRGB) {
	
								value = [value[0] / 255, value[1] / 255, value[2] / 255];
							}
	
							if (this.options && this.options.ignoreZeroRGBs) {
	
								if (value[0] === 0 && value[1] === 0 && value[2] === 0) {
	
									// ignore
	
									save = false;
								}
							}
	
							break;
	
						default:
	
							break;
	
					}
	
					if (save) {
	
						covmat[lprop] = value;
					}
				}
			}
	
			return converted;
		},
	
		preload: function preload() {
	
			for (var mn in this.materialsInfo) {
	
				this.create(mn);
			}
		},
	
		getIndex: function getIndex(materialName) {
	
			return this.nameLookup[materialName];
		},
	
		getAsArray: function getAsArray() {
	
			var index = 0;
	
			for (var mn in this.materialsInfo) {
	
				this.materialsArray[index] = this.create(mn);
				this.nameLookup[mn] = index;
				index++;
			}
	
			return this.materialsArray;
		},
	
		create: function create(materialName) {
	
			if (this.materials[materialName] === undefined) {
	
				this.createMaterial_(materialName);
			}
	
			return this.materials[materialName];
		},
	
		createMaterial_: function createMaterial_(materialName) {
	
			// Create material
	
			var scope = this;
			var mat = this.materialsInfo[materialName];
			var params = {
	
				name: materialName,
				side: this.side
	
			};
	
			function resolveURL(baseUrl, url) {
	
				if (typeof url !== 'string' || url === '') return '';
	
				// Absolute URL
				if (/^https?:\/\//i.test(url)) return url;
	
				return baseUrl + url;
			}
	
			function setMapForType(mapType, value) {
	
				if (params[mapType]) return; // Keep the first encountered texture
	
				var texParams = scope.getTextureParams(value, params);
				var map = scope.loadTexture(resolveURL(scope.baseUrl, texParams.url));
	
				map.repeat.copy(texParams.scale);
				map.offset.copy(texParams.offset);
	
				map.wrapS = scope.wrap;
				map.wrapT = scope.wrap;
	
				params[mapType] = map;
			}
	
			for (var prop in mat) {
	
				var value = mat[prop];
	
				if (value === '') continue;
	
				switch (prop.toLowerCase()) {
	
					// Ns is material specular exponent
	
					case 'kd':
	
						// Diffuse color (color under white light) using RGB values
	
						params.color = new THREE.Color().fromArray(value);
	
						break;
	
					case 'ks':
	
						// Specular color (color when light is reflected from shiny surface) using RGB values
						params.specular = new THREE.Color().fromArray(value);
	
						break;
	
					case 'map_kd':
	
						// Diffuse texture map
	
						setMapForType("map", value);
	
						break;
	
					case 'map_ks':
	
						// Specular map
	
						setMapForType("specularMap", value);
	
						break;
	
					case 'map_bump':
					case 'bump':
	
						// Bump texture map
	
						setMapForType("bumpMap", value);
	
						break;
	
					case 'ns':
	
						// The specular exponent (defines the focus of the specular highlight)
						// A high exponent results in a tight, concentrated highlight. Ns values normally range from 0 to 1000.
	
						params.shininess = parseFloat(value);
	
						break;
	
					case 'd':
	
						if (value < 1) {
	
							params.opacity = value;
							params.transparent = true;
						}
	
						break;
	
					case 'Tr':
	
						if (value > 0) {
	
							params.opacity = 1 - value;
							params.transparent = true;
						}
	
						break;
	
					default:
						break;
	
				}
			}
	
			this.materials[materialName] = new THREE.MeshPhongMaterial(params);
			return this.materials[materialName];
		},
	
		getTextureParams: function getTextureParams(value, matParams) {
	
			var texParams = {
	
				scale: new THREE.Vector2(1, 1),
				offset: new THREE.Vector2(0, 0)
	
			};
	
			var items = value.split(/\s+/);
			var pos;
	
			pos = items.indexOf('-bm');
	
			if (pos >= 0) {
	
				matParams.bumpScale = parseFloat(items[pos + 1]);
				items.splice(pos, 2);
			}
	
			pos = items.indexOf('-s');
	
			if (pos >= 0) {
	
				texParams.scale.set(parseFloat(items[pos + 1]), parseFloat(items[pos + 2]));
				items.splice(pos, 4); // we expect 3 parameters here!
			}
	
			pos = items.indexOf('-o');
	
			if (pos >= 0) {
	
				texParams.offset.set(parseFloat(items[pos + 1]), parseFloat(items[pos + 2]));
				items.splice(pos, 4); // we expect 3 parameters here!
			}
	
			texParams.url = items.join(' ').trim();
			return texParams;
		},
	
		loadTexture: function loadTexture(url, mapping, onLoad, onProgress, onError) {
	
			var texture;
			var loader = THREE.Loader.Handlers.get(url);
			var manager = this.manager !== undefined ? this.manager : THREE.DefaultLoadingManager;
	
			if (loader === null) {
	
				loader = new THREE.TextureLoader(manager);
			}
	
			if (loader.setCrossOrigin) loader.setCrossOrigin(this.crossOrigin);
			texture = loader.load(url, onLoad, onProgress, onError);
	
			if (mapping !== undefined) texture.mapping = mapping;
	
			return texture;
		}
	
	};
	/* eslint-enable */

/***/ }),
/* 125 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _set = function set(object, property, value, receiver) { var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent !== null) { set(parent, property, value, receiver); } } else if ("value" in desc && desc.writable) { desc.value = value; } else { var setter = desc.set; if (setter !== undefined) { setter.call(receiver, value); } } return value; };
	
	var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };
	
	var _three = __webpack_require__(2);
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var MeshProxy = function (_Group) {
	  _inherits(MeshProxy, _Group);
	
	  function MeshProxy() {
	    _classCallCheck(this, MeshProxy);
	
	    var _this = _possibleConstructorReturn(this, (MeshProxy.__proto__ || Object.getPrototypeOf(MeshProxy)).call(this));
	
	    _this.type = 'MeshProxy';
	    _this._proxy = null;
	
	    var self = _this;
	    _this._removedListener = function () {
	      self.removeEventListener('removed', self._removedListener);
	      self._proxy = null;
	    };
	
	    _this.addEventListener('removed', _this._removedListener);
	    return _this;
	  }
	
	  _createClass(MeshProxy, [{
	    key: 'addProxy',
	    value: function addProxy(proxy) {
	      this._proxy = proxy;
	      // Object.defineProperties(this, {
	      //   position: {
	      //     enumerable: true,
	      //     value: this._proxy.position,
	      //   },
	      //   rotation: {
	      //     enumerable: true,
	      //     value: this._proxy.rotation,
	      //   },
	      //   quaternion: {
	      //     enumerable: true,
	      //     value: this._proxy.quaternion,
	      //   },
	      //   scale: {
	      //     enumerable: true,
	      //     value: this._proxy.scale,
	      //   },
	      // });
	      _get(MeshProxy.prototype.__proto__ || Object.getPrototypeOf(MeshProxy.prototype), 'add', this).call(this, proxy);
	    }
	  }, {
	    key: 'proxyPosition',
	    get: function get() {
	      if (this._proxy) {
	        return this._proxy.position;
	      }
	      return _get(MeshProxy.prototype.__proto__ || Object.getPrototypeOf(MeshProxy.prototype), 'position', this);
	    },
	    set: function set(p) {
	      if (this._proxy) {
	        this._proxy.position = p;
	      } else {
	        _set(MeshProxy.prototype.__proto__ || Object.getPrototypeOf(MeshProxy.prototype), 'positon', p, this);
	      }
	    }
	  }, {
	    key: 'proxyRotation',
	    get: function get() {
	      if (this._proxy) {
	        return this._proxy.rotation;
	      }
	      return _get(MeshProxy.prototype.__proto__ || Object.getPrototypeOf(MeshProxy.prototype), 'rotation', this);
	    },
	    set: function set(r) {
	      if (this._proxy) {
	        this._proxy.rotation = r;
	      } else {
	        _set(MeshProxy.prototype.__proto__ || Object.getPrototypeOf(MeshProxy.prototype), 'rotation', r, this);
	      }
	    }
	  }, {
	    key: 'proxyScale',
	    get: function get() {
	      if (this._proxy) {
	        return this._proxy.scale;
	      }
	      return _get(MeshProxy.prototype.__proto__ || Object.getPrototypeOf(MeshProxy.prototype), 'scale', this);
	    },
	    set: function set(s) {
	      if (this._proxy) {
	        this._proxy.scale = s;
	      } else {
	        _set(MeshProxy.prototype.__proto__ || Object.getPrototypeOf(MeshProxy.prototype), 'scale', s, this);
	      }
	    }
	  }]);
	
	  return MeshProxy;
	}(_three.Group);
	
	exports.default = MeshProxy;

/***/ }),
/* 126 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _three = __webpack_require__(2);
	
	var THREE = _interopRequireWildcard(_three);
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var NGRSpritePlugin = function () {
	  function NGRSpritePlugin(renderer, sprites) {
	    var _this = this;
	
	    _classCallCheck(this, NGRSpritePlugin);
	
	    var gl = renderer.context;
	    var state = renderer.state;
	
	    var vertexBuffer = null;
	    var elementBuffer = null;
	    var program = null;
	    var attributes = null;
	    var uniforms = null;
	
	    var texture = void 0;
	
	    // decompose matrixWorld
	
	    var spritePosition = new THREE.Vector3();
	    // const spriteRotation = new THREE.Quaternion();
	    var spriteScale = new THREE.Vector3();
	
	    this.init = function () {
	      var vertices = new Float32Array([-0.5, -0.5, 0, 0, 0.5, -0.5, 1, 0, 0.5, 0.5, 1, 1, -0.5, 0.5, 0, 1]);
	
	      var faces = new Uint16Array([0, 1, 2, 0, 2, 3]);
	
	      vertexBuffer = gl.createBuffer();
	      elementBuffer = gl.createBuffer();
	
	      gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
	      gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);
	
	      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, elementBuffer);
	      gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, faces, gl.STATIC_DRAW);
	
	      program = _this.createProgram();
	
	      attributes = {
	        position: gl.getAttribLocation(program, 'position'),
	        uv: gl.getAttribLocation(program, 'uv')
	      };
	
	      uniforms = {
	        uvOffset: gl.getUniformLocation(program, 'uvOffset'),
	        uvScale: gl.getUniformLocation(program, 'uvScale'),
	
	        rotation: gl.getUniformLocation(program, 'rotation'),
	        scale: gl.getUniformLocation(program, 'scale'),
	        offset: gl.getUniformLocation(program, 'offset'),
	        anchor: gl.getUniformLocation(program, 'anchor'),
	
	        color: gl.getUniformLocation(program, 'color'),
	        map: gl.getUniformLocation(program, 'map'),
	        opacity: gl.getUniformLocation(program, 'opacity'),
	
	        modelViewMatrix: gl.getUniformLocation(program, 'modelViewMatrix'),
	        projectionMatrix: gl.getUniformLocation(program, 'projectionMatrix'),
	
	        fogType: gl.getUniformLocation(program, 'fogType'),
	        fogDensity: gl.getUniformLocation(program, 'fogDensity'),
	        fogNear: gl.getUniformLocation(program, 'fogNear'),
	        fogFar: gl.getUniformLocation(program, 'fogFar'),
	        fogColor: gl.getUniformLocation(program, 'fogColor'),
	
	        alphaTest: gl.getUniformLocation(program, 'alphaTest')
	      };
	
	      var canvas = document.createElementNS('http://www.w3.org/1999/xhtml', 'canvas');
	      canvas.width = 8;
	      canvas.height = 8;
	
	      var context = canvas.getContext('2d');
	      context.fillStyle = 'white';
	      context.fillRect(0, 0, 8, 8);
	
	      texture = new THREE.Texture(canvas);
	      texture.needsUpdate = true;
	    };
	
	    this.render = function (scene, camera) {
	
	      if (sprites.length === 0) {
	        return;
	      }
	
	      if (!program) {
	        _this.init();
	      }
	
	      gl.useProgram(program);
	
	      state.initAttributes();
	      state.enableAttribute(attributes.position);
	      state.enableAttribute(attributes.uv);
	      state.disableUnusedAttributes();
	
	      state.disable(gl.CULL_FACE);
	      state.enable(gl.BLEND);
	
	      gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
	      gl.vertexAttribPointer(attributes.position, 2, gl.FLOAT, false, 2 * 8, 0);
	      gl.vertexAttribPointer(attributes.uv, 2, gl.FLOAT, false, 2 * 8, 8);
	
	      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, elementBuffer);
	
	      gl.uniformMatrix4fv(uniforms.projectionMatrix, false, camera.projectionMatrix.elements);
	
	      state.activeTexture(gl.TEXTURE0);
	      gl.uniform1i(uniforms.map, 0);
	
	      var oldFogType = 0;
	      var sceneFogType = 0;
	      var fog = scene.fog;
	      if (fog) {
	        gl.uniform3f(uniforms.fogColor, fog.color.r, fog.color.g, fog.color.b);
	        if (fog instanceof THREE.Fog) {
	          gl.uniform1f(uniforms.fogNear, fog.near);
	          gl.uniform1f(uniforms.fogFar, fog.far);
	          gl.uniform1i(uniforms.fogType, 1);
	          oldFogType = 1;
	          sceneFogType = 1;
	        } else if (fog instanceof THREE.FogExp2) {
	          gl.uniform1f(uniforms.fogDensity, fog.density);
	          gl.uniform1i(uniforms.fogType, 2);
	          oldFogType = 2;
	          sceneFogType = 2;
	        }
	      } else {
	        gl.uniform1i(uniforms.fogType, 0);
	        oldFogType = 0;
	        sceneFogType = 0;
	      }
	
	      var width = renderer.domElement.width;
	      var height = renderer.domElement.height;
	
	      // TODO(by jian.feng)
	      // const texturePixelRatio = renderer.getPixelRatio() === window.devicePixelRatio ? renderer.getPixelRatio() : window.devicePixelRatio;
	      var texturePixelRatio = renderer.getPixelRatio();
	
	      // update positions and sort
	      // for (let i = 0, l = sprites.length; i < l; i++) {
	      //   const sprite = sprites[i];
	      //   sprite.modelViewMatrix.multiplyMatrices(camera.matrixWorldInverse, sprite.matrixWorld);
	      //   sprite.z = -sprite.modelViewMatrix.elements[14];
	      // }
	      // sprites.sort(this.painterSortStable);
	      // render all sprites
	      var scale = [];
	      for (var i = 0, l = sprites.length; i < l; i++) {
	        var sprite = sprites[i];
	        var material = sprite.material;
	        if (!material.visible) {
	          continue;
	        }
	
	        sprite.modelViewMatrix.multiplyMatrices(camera.matrixWorldInverse, sprite.matrixWorld);
	        gl.uniform1f(uniforms.alphaTest, material.alphaTest);
	        gl.uniformMatrix4fv(uniforms.modelViewMatrix, false, sprite.modelViewMatrix.elements);
	
	        spritePosition.setFromMatrixPosition(sprite.modelViewMatrix);
	        gl.uniform3f(uniforms.offset, spritePosition.x, spritePosition.y, spritePosition.z);
	
	        if (material.materialScale) {
	          scale[0] = sprite.scale.x / width * (texturePixelRatio + 1);
	          scale[1] = sprite.scale.y / height * (texturePixelRatio + 1);
	          // scale[0] = sprite.scale.x / width * 2;
	          // scale[1] = sprite.scale.y / height * 2;
	        } else {
	          scale[0] = spriteScale.x;
	          scale[1] = spriteScale.y;
	        }
	        var fogType = 0;
	        if (scene.fog && material.fog) {
	          fogType = sceneFogType;
	        }
	        if (oldFogType !== fogType) {
	          gl.uniform1i(uniforms.fogType, fogType);
	          oldFogType = fogType;
	        }
	
	        if (material.map !== null) {
	          gl.uniform2f(uniforms.uvOffset, material.map.offset.x, material.map.offset.y);
	          gl.uniform2f(uniforms.uvScale, material.map.repeat.x, material.map.repeat.y);
	        } else {
	          gl.uniform2f(uniforms.uvOffset, 0, 0);
	          gl.uniform2f(uniforms.uvScale, 1, 1);
	        }
	
	        gl.uniform1f(uniforms.opacity, material.opacity);
	        gl.uniform3f(uniforms.color, material.color.r, material.color.g, material.color.b);
	        gl.uniform1f(uniforms.rotation, material.rotation);
	        if (material.anchor) {
	          gl.uniform2f(uniforms.anchor, material.anchor[0], material.anchor[1]);
	        }
	        // gl.uniform3f(uniforms.offset, -2, -2, 0);
	        gl.uniform2fv(uniforms.scale, scale);
	
	        state.setBlending(material.blending, material.blendEquation, material.blendSrc, material.blendDst);
	        state.buffers.depth.setTest(material.depthTest);
	        state.buffers.depth.setMask(material.depthWrite);
	        // state.setDepthTest(material.depthTest);
	        // state.setDepthWrite(material.depthWrite);
	
	        if (material.map) {
	          renderer.setTexture2D(material.map, 0);
	        } else {
	          renderer.setTexture2D(texture, 0);
	        }
	        gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0);
	      }
	
	      // restore gl
	      renderer.resetGLState();
	    };
	
	    this.createProgram = function () {
	
	      var program = gl.createProgram();
	      var vertexShader = gl.createShader(gl.VERTEX_SHADER);
	      var fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
	      var aa = renderer.getPrecision();
	      var precision = 'precision ' + aa + ' float;';
	      gl.shaderSource(vertexShader, [precision, 'uniform mat4 modelViewMatrix;', 'uniform mat4 projectionMatrix;', 'uniform float rotation;', 'uniform vec2 scale;', 'uniform vec2 uvOffset;', 'uniform vec2 uvScale;', 'uniform vec3 offset;', 'uniform vec2 anchor;', 'attribute vec2 position;', 'attribute vec2 uv;', 'varying vec2 vUV;', 'void main() {', 'vUV = uvOffset + uv * uvScale;',
	
	      // 'float offsetX = anchor.x - 0.5;',
	      // 'vec2 alignedPosition = vec2(position.x, position.y) * scale;',
	      'vec2 alignedPosition = vec2(position.x + (0.5 - anchor.x), position.y - (0.5 - anchor.y)) * scale;',
	      // 'vec2 alignedPosition = vec2(position.x - 0.5, position.y);',
	      // 'alignedPosition *= scale;',
	      // 'alignedPosition.xy += vec2(-0.1, 0);',
	
	      'vec4 basePosition = projectionMatrix * vec4(offset, 1.0);', 'vec4 finalPosition = vec4(basePosition.x / basePosition.w, basePosition.y / basePosition.w, basePosition.z / basePosition.w, 1.0);', 'finalPosition.xy += alignedPosition;', 'gl_Position = finalPosition;', '}'].join('\n'));
	
	      gl.shaderSource(fragmentShader, [precision, 'uniform vec3 color;', 'uniform sampler2D map;', 'uniform float opacity;', 'uniform int fogType;', 'uniform vec3 fogColor;', 'uniform float fogDensity;', 'uniform float fogNear;', 'uniform float fogFar;', 'uniform float alphaTest;', 'varying vec2 vUV;', 'void main() {', 'vec4 texture = texture2D( map, vUV );', 'if ( texture.a < alphaTest ) discard;', 'gl_FragColor = vec4( color * texture.xyz, texture.a * opacity );', 'if ( fogType > 0 ) {', 'float depth = gl_FragCoord.z / gl_FragCoord.w;', 'float fogFactor = 0.0;', 'if ( fogType == 1 ) {', 'fogFactor = smoothstep( fogNear, fogFar, depth );', '} else {', 'const float LOG2 = 1.442695;', 'fogFactor = exp2( - fogDensity * fogDensity * depth * depth * LOG2 );', 'fogFactor = 1.0 - clamp( fogFactor, 0.0, 1.0 );', '}', 'gl_FragColor = mix( gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor );', '}', '}'].join('\n'));
	
	      gl.compileShader(vertexShader);
	      // console.log(gl.getShaderInfoLog(vertexShader));
	      gl.compileShader(fragmentShader);
	
	      gl.attachShader(program, vertexShader);
	      gl.attachShader(program, fragmentShader);
	
	      gl.linkProgram(program);
	      return program;
	    };
	
	    this.painterSortStable = function (a, b) {
	      if (a.renderOrder !== b.renderOrder) {
	        return a.renderOrder - b.renderOrder;
	      } else if (a.z !== b.z) {
	        return b.z - a.z;
	      }
	      return b.id - a.id;
	    };
	
	    // super(renderer, sprites);
	    // this.gl = renderer.context;
	    // this.state = renderer.state;
	    // this.vertexBuffer = null;
	    // this.elementBuffer = null;
	    // this.program = null;
	    // this.attributes = null;
	    // this.uniforms = null;
	    // this.texture = null;
	    // this.spritePosition = new THREE.Vector3();
	    // this.spriteRotation = new THREE.Quaternion();
	    // this.spriteScale = new THREE.Vector3();
	    // this.renderer = renderer;
	    // this.sprites = sprites;
	
	    // this.render = (scene, camera) => {
	    //   if (this.sprites.length === 0) {
	    //     return;
	    //   }
	    //   if (!this.program) {
	    //     this.init();
	    //   }
	
	    //   this.gl.useProgram(this.program);
	
	    //   this.state.initAttributes();
	    //   this.state.enableAttribute(this.attributes.position);
	    //   this.state.enableAttribute(this.attributes.uv);
	    //   this.state.disableUnusedAttributes();
	
	    //   this.state.disable(this.gl.CULL_FACE);
	    //   this.state.enable(this.gl.BLEND);
	
	    //   this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.vertexBuffer);
	    //   this.gl.vertexAttribPointer(this.attributes.position, 2, this.gl.FLOAT, false, 2 * 8, 0);
	    //   this.gl.vertexAttribPointer(this.attributes.uv, 2, this.gl.FLOAT, false, 2 * 8, 8);
	
	    //   this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, this.elementBuffer);
	
	    //   this.gl.uniformMatrix4fv(this.uniforms.projectionMatrix, false, camera.projectionMatrix.elements);
	
	    //   this.state.activeTexture(this.gl.TEXTURE0);
	    //   this.gl.uniform1i(this.uniforms.map, 0);
	
	    //   let oldFogType = 0;
	    //   let sceneFogType = 0;
	    //   const fog = scene.fog;
	
	    //   if (fog) {
	
	    //     this.gl.uniform3f(this.uniforms.fogColor, fog.color.r, fog.color.g, fog.color.b);
	
	    //     if (fog instanceof THREE.Fog) {
	
	    //       this.gl.uniform1f(this.uniforms.fogNear, fog.near);
	    //       this.gl.uniform1f(this.uniforms.fogFar, fog.far);
	
	    //       this.gl.uniform1i(this.uniforms.fogType, 1);
	    //       oldFogType = 1;
	    //       sceneFogType = 1;
	
	    //     } else if (fog instanceof THREE.FogExp2) {
	
	    //       this.gl.uniform1f(this.uniforms.fogDensity, fog.density);
	
	    //       this.gl.uniform1i(this.uniforms.fogType, 2);
	    //       oldFogType = 2;
	    //       sceneFogType = 2;
	    //     }
	
	    //   } else {
	    //     this.gl.uniform1i(this, this.uniforms.fogType, 0);
	    //     oldFogType = 0;
	    //     sceneFogType = 0;
	    //   }
	
	    //   for (let i = 0, l = this.sprites.length; i < l; i++) {
	    //     const sprite = this.sprites[i];
	    //     sprite.modelViewMatrix.multiplyMatrices(camera.matrixWorldInverse, sprite.matrixWorld);
	    //     sprite.z = -sprite.modelViewMatrix.elements[14];
	    //   }
	
	    //   this.sprites.sort(this.painterSortStable);
	
	    //   const scale = [];
	
	    //   for (let i = 0, l = this.sprites.length; i < l; i++) {
	
	    //     const sprite = this.sprites[i];
	    //     const material = sprite.material;
	    //     this.gl.uniform1f(this.uniforms.alphaTest, material.alphaTest);
	    //     this.gl.uniformMatrix4fv(this.uniforms.modelViewMatrix, false, sprite.modelViewMatrix.elements);
	    //     sprite.matrixWorld.decompose(this.spritePosition, this.spriteRotation, this.spriteScale);
	    //     scale[0] = this.spriteScale.x;
	    //     scale[1] = this.spriteScale.y;
	    //     let fogType = 0;
	
	    //     if (scene.fog && material.fog) {
	    //       fogType = sceneFogType;
	    //     }
	
	    //     if (oldFogType !== fogType) {
	    //       this.gl.uniform1i(this.uniforms.fogType, fogType);
	    //       oldFogType = fogType;
	    //     }
	
	    //     if (material.map !== null) {
	    //       this.gl.uniform2f(this.uniforms.uvOffset, material.map.offset.x, material.map.offset.y);
	    //       this.gl.uniform2f(this.uniforms.uvScale, material.map.repeat.x, material.map.repeat.y);
	    //     } else {
	    //       this.gl.uniform2f(this.uniforms.uvOffset, 0, 0);
	    //       this.gl.uniform2f(this.uniforms.uvScale, 1, 1);
	    //     }
	
	    //     this.gl.uniform1f(this.uniforms.opacity, material.opacity);
	    //     this.gl.uniform3f(this.uniforms.color, material.color.r, material.color.g, material.color.b);
	
	    //     this.gl.uniform1f(this.uniforms.rotation, material.rotation);
	    //     this.gl.uniform2fv(this.uniforms.scale, scale);
	
	    //     this.state.setBlending(material.blending, material.blendEquation, material.blendSrc, material.blendDst);
	    //     this.state.setDepthTest(material.depthTest);
	    //     this.state.setDepthWrite(material.depthWrite);
	
	    //     if (material.map) {
	    //       this.renderer.setTexture2D(material.map, 0);
	    //     } else {
	    //       this.renderer.setTexture2D(this.texture, 0);
	    //     }
	
	    //     this.gl.drawElements(this.gl.TRIANGLES, 6, this.gl.UNSIGNED_SHORT, 0);
	    //   }
	    //   this.state.enable(this.gl.CULL_FACE);
	    //   this.renderer.resetGLState();
	    // };
	  }
	
	  _createClass(NGRSpritePlugin, [{
	    key: 'getAABB',
	    value: function getAABB() {
	      return 'getAABB';
	    }
	  }]);
	
	  return NGRSpritePlugin;
	}();
	
	exports.default = NGRSpritePlugin;

/***/ }),
/* 127 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var _three = __webpack_require__(2);
	
	var THREE = _interopRequireWildcard(_three);
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	THREE.OBJLoader = function (manager) {
	
		this.manager = manager !== undefined ? manager : THREE.DefaultLoadingManager;
	
		this.materials = null;
	
		this.regexp = {
			// v float float float
			vertex_pattern: /^v\s+([\d|\.|\+|\-|e|E]+)\s+([\d|\.|\+|\-|e|E]+)\s+([\d|\.|\+|\-|e|E]+)/,
			// vn float float float
			normal_pattern: /^vn\s+([\d|\.|\+|\-|e|E]+)\s+([\d|\.|\+|\-|e|E]+)\s+([\d|\.|\+|\-|e|E]+)/,
			// vt float float
			uv_pattern: /^vt\s+([\d|\.|\+|\-|e|E]+)\s+([\d|\.|\+|\-|e|E]+)/,
			// f vertex vertex vertex
			face_vertex: /^f\s+(-?\d+)\s+(-?\d+)\s+(-?\d+)(?:\s+(-?\d+))?/,
			// f vertex/uv vertex/uv vertex/uv
			face_vertex_uv: /^f\s+(-?\d+)\/(-?\d+)\s+(-?\d+)\/(-?\d+)\s+(-?\d+)\/(-?\d+)(?:\s+(-?\d+)\/(-?\d+))?/,
			// f vertex/uv/normal vertex/uv/normal vertex/uv/normal
			face_vertex_uv_normal: /^f\s+(-?\d+)\/(-?\d+)\/(-?\d+)\s+(-?\d+)\/(-?\d+)\/(-?\d+)\s+(-?\d+)\/(-?\d+)\/(-?\d+)(?:\s+(-?\d+)\/(-?\d+)\/(-?\d+))?/,
			// f vertex//normal vertex//normal vertex//normal
			face_vertex_normal: /^f\s+(-?\d+)\/\/(-?\d+)\s+(-?\d+)\/\/(-?\d+)\s+(-?\d+)\/\/(-?\d+)(?:\s+(-?\d+)\/\/(-?\d+))?/,
			// o object_name | g group_name
			object_pattern: /^[og]\s*(.+)?/,
			// s boolean
			smoothing_pattern: /^s\s+(\d+|on|off)/,
			// mtllib file_reference
			material_library_pattern: /^mtllib /,
			// usemtl material_name
			material_use_pattern: /^usemtl /
		};
	}; /* eslint-disable */
	
	
	THREE.OBJLoader.prototype = {
	
		constructor: THREE.OBJLoader,
	
		load: function load(url, onLoad, onProgress, onError) {
	
			var scope = this;
	
			var loader = new THREE.FileLoader(scope.manager);
			loader.setPath(this.path);
			loader.load(url, function (text) {
	
				onLoad(scope.parse(text));
			}, onProgress, onError);
		},
	
		setPath: function setPath(value) {
	
			this.path = value;
		},
	
		setMaterials: function setMaterials(materials) {
	
			this.materials = materials;
		},
	
		_createParserState: function _createParserState() {
	
			var state = {
				objects: [],
				object: {},
	
				vertices: [],
				normals: [],
				uvs: [],
	
				materialLibraries: [],
	
				startObject: function startObject(name, fromDeclaration) {
	
					// If the current object (initial from reset) is not from a g/o declaration in the parsed
					// file. We need to use it for the first parsed g/o to keep things in sync.
					if (this.object && this.object.fromDeclaration === false) {
	
						this.object.name = name;
						this.object.fromDeclaration = fromDeclaration !== false;
						return;
					}
	
					var previousMaterial = this.object && typeof this.object.currentMaterial === 'function' ? this.object.currentMaterial() : undefined;
	
					if (this.object && typeof this.object._finalize === 'function') {
	
						this.object._finalize(true);
					}
	
					this.object = {
						name: name || '',
						fromDeclaration: fromDeclaration !== false,
	
						geometry: {
							vertices: [],
							normals: [],
							uvs: []
						},
						materials: [],
						smooth: true,
	
						startMaterial: function startMaterial(name, libraries) {
	
							var previous = this._finalize(false);
	
							// New usemtl declaration overwrites an inherited material, except if faces were declared
							// after the material, then it must be preserved for proper MultiMaterial continuation.
							if (previous && (previous.inherited || previous.groupCount <= 0)) {
	
								this.materials.splice(previous.index, 1);
							}
	
							var material = {
								index: this.materials.length,
								name: name || '',
								mtllib: Array.isArray(libraries) && libraries.length > 0 ? libraries[libraries.length - 1] : '',
								smooth: previous !== undefined ? previous.smooth : this.smooth,
								groupStart: previous !== undefined ? previous.groupEnd : 0,
								groupEnd: -1,
								groupCount: -1,
								inherited: false,
	
								clone: function clone(index) {
									var cloned = {
										index: typeof index === 'number' ? index : this.index,
										name: this.name,
										mtllib: this.mtllib,
										smooth: this.smooth,
										groupStart: 0,
										groupEnd: -1,
										groupCount: -1,
										inherited: false
									};
									cloned.clone = this.clone.bind(cloned);
									return cloned;
								}
							};
	
							this.materials.push(material);
	
							return material;
						},
	
						currentMaterial: function currentMaterial() {
	
							if (this.materials.length > 0) {
								return this.materials[this.materials.length - 1];
							}
	
							return undefined;
						},
	
						_finalize: function _finalize(end) {
	
							var lastMultiMaterial = this.currentMaterial();
							if (lastMultiMaterial && lastMultiMaterial.groupEnd === -1) {
	
								lastMultiMaterial.groupEnd = this.geometry.vertices.length / 3;
								lastMultiMaterial.groupCount = lastMultiMaterial.groupEnd - lastMultiMaterial.groupStart;
								lastMultiMaterial.inherited = false;
							}
	
							// Ignore objects tail materials if no face declarations followed them before a new o/g started.
							if (end && this.materials.length > 1) {
	
								for (var mi = this.materials.length - 1; mi >= 0; mi--) {
									if (this.materials[mi].groupCount <= 0) {
										this.materials.splice(mi, 1);
									}
								}
							}
	
							// Guarantee at least one empty material, this makes the creation later more straight forward.
							if (end && this.materials.length === 0) {
	
								this.materials.push({
									name: '',
									smooth: this.smooth
								});
							}
	
							return lastMultiMaterial;
						}
					};
	
					// Inherit previous objects material.
					// Spec tells us that a declared material must be set to all objects until a new material is declared.
					// If a usemtl declaration is encountered while this new object is being parsed, it will
					// overwrite the inherited material. Exception being that there was already face declarations
					// to the inherited material, then it will be preserved for proper MultiMaterial continuation.
	
					if (previousMaterial && previousMaterial.name && typeof previousMaterial.clone === "function") {
	
						var declared = previousMaterial.clone(0);
						declared.inherited = true;
						this.object.materials.push(declared);
					}
	
					this.objects.push(this.object);
				},
	
				finalize: function finalize() {
	
					if (this.object && typeof this.object._finalize === 'function') {
	
						this.object._finalize(true);
					}
				},
	
				parseVertexIndex: function parseVertexIndex(value, len) {
	
					var index = parseInt(value, 10);
					return (index >= 0 ? index - 1 : index + len / 3) * 3;
				},
	
				parseNormalIndex: function parseNormalIndex(value, len) {
	
					var index = parseInt(value, 10);
					return (index >= 0 ? index - 1 : index + len / 3) * 3;
				},
	
				parseUVIndex: function parseUVIndex(value, len) {
	
					var index = parseInt(value, 10);
					return (index >= 0 ? index - 1 : index + len / 2) * 2;
				},
	
				addVertex: function addVertex(a, b, c) {
	
					var src = this.vertices;
					var dst = this.object.geometry.vertices;
	
					dst.push(src[a + 0]);
					dst.push(src[a + 1]);
					dst.push(src[a + 2]);
					dst.push(src[b + 0]);
					dst.push(src[b + 1]);
					dst.push(src[b + 2]);
					dst.push(src[c + 0]);
					dst.push(src[c + 1]);
					dst.push(src[c + 2]);
				},
	
				addVertexLine: function addVertexLine(a) {
	
					var src = this.vertices;
					var dst = this.object.geometry.vertices;
	
					dst.push(src[a + 0]);
					dst.push(src[a + 1]);
					dst.push(src[a + 2]);
				},
	
				addNormal: function addNormal(a, b, c) {
	
					var src = this.normals;
					var dst = this.object.geometry.normals;
	
					dst.push(src[a + 0]);
					dst.push(src[a + 1]);
					dst.push(src[a + 2]);
					dst.push(src[b + 0]);
					dst.push(src[b + 1]);
					dst.push(src[b + 2]);
					dst.push(src[c + 0]);
					dst.push(src[c + 1]);
					dst.push(src[c + 2]);
				},
	
				addUV: function addUV(a, b, c) {
	
					var src = this.uvs;
					var dst = this.object.geometry.uvs;
	
					dst.push(src[a + 0]);
					dst.push(src[a + 1]);
					dst.push(src[b + 0]);
					dst.push(src[b + 1]);
					dst.push(src[c + 0]);
					dst.push(src[c + 1]);
				},
	
				addUVLine: function addUVLine(a) {
	
					var src = this.uvs;
					var dst = this.object.geometry.uvs;
	
					dst.push(src[a + 0]);
					dst.push(src[a + 1]);
				},
	
				addFace: function addFace(a, b, c, d, ua, ub, uc, ud, na, nb, nc, nd) {
	
					var vLen = this.vertices.length;
	
					var ia = this.parseVertexIndex(a, vLen);
					var ib = this.parseVertexIndex(b, vLen);
					var ic = this.parseVertexIndex(c, vLen);
					var id;
	
					if (d === undefined) {
	
						this.addVertex(ia, ib, ic);
					} else {
	
						id = this.parseVertexIndex(d, vLen);
	
						this.addVertex(ia, ib, id);
						this.addVertex(ib, ic, id);
					}
	
					if (ua !== undefined) {
	
						var uvLen = this.uvs.length;
	
						ia = this.parseUVIndex(ua, uvLen);
						ib = this.parseUVIndex(ub, uvLen);
						ic = this.parseUVIndex(uc, uvLen);
	
						if (d === undefined) {
	
							this.addUV(ia, ib, ic);
						} else {
	
							id = this.parseUVIndex(ud, uvLen);
	
							this.addUV(ia, ib, id);
							this.addUV(ib, ic, id);
						}
					}
	
					if (na !== undefined) {
	
						// Normals are many times the same. If so, skip function call and parseInt.
						var nLen = this.normals.length;
						ia = this.parseNormalIndex(na, nLen);
	
						ib = na === nb ? ia : this.parseNormalIndex(nb, nLen);
						ic = na === nc ? ia : this.parseNormalIndex(nc, nLen);
	
						if (d === undefined) {
	
							this.addNormal(ia, ib, ic);
						} else {
	
							id = this.parseNormalIndex(nd, nLen);
	
							this.addNormal(ia, ib, id);
							this.addNormal(ib, ic, id);
						}
					}
				},
	
				addLineGeometry: function addLineGeometry(vertices, uvs) {
	
					this.object.geometry.type = 'Line';
	
					var vLen = this.vertices.length;
					var uvLen = this.uvs.length;
	
					for (var vi = 0, l = vertices.length; vi < l; vi++) {
	
						this.addVertexLine(this.parseVertexIndex(vertices[vi], vLen));
					}
	
					for (var uvi = 0, l = uvs.length; uvi < l; uvi++) {
	
						this.addUVLine(this.parseUVIndex(uvs[uvi], uvLen));
					}
				}
	
			};
	
			state.startObject('', false);
	
			return state;
		},
	
		parse: function parse(text) {
	
			console.time('OBJLoader');
	
			var state = this._createParserState();
	
			if (text.indexOf('\r\n') !== -1) {
	
				// This is faster than String.split with regex that splits on both
				text = text.replace(/\r\n/g, '\n');
			}
	
			if (text.indexOf('\\\n') !== -1) {
	
				// join lines separated by a line continuation character (\)
				text = text.replace(/\\\n/g, '');
			}
	
			var lines = text.split('\n');
			var line = '',
			    lineFirstChar = '',
			    lineSecondChar = '';
			var lineLength = 0;
			var result = [];
	
			// Faster to just trim left side of the line. Use if available.
			var trimLeft = typeof ''.trimLeft === 'function';
	
			for (var i = 0, l = lines.length; i < l; i++) {
	
				line = lines[i];
	
				line = trimLeft ? line.trimLeft() : line.trim();
	
				lineLength = line.length;
	
				if (lineLength === 0) continue;
	
				lineFirstChar = line.charAt(0);
	
				// @todo invoke passed in handler if any
				if (lineFirstChar === '#') continue;
	
				if (lineFirstChar === 'v') {
	
					lineSecondChar = line.charAt(1);
	
					if (lineSecondChar === ' ' && (result = this.regexp.vertex_pattern.exec(line)) !== null) {
	
						// 0                  1      2      3
						// ["v 1.0 2.0 3.0", "1.0", "2.0", "3.0"]
	
						state.vertices.push(parseFloat(result[1]), parseFloat(result[2]), parseFloat(result[3]));
					} else if (lineSecondChar === 'n' && (result = this.regexp.normal_pattern.exec(line)) !== null) {
	
						// 0                   1      2      3
						// ["vn 1.0 2.0 3.0", "1.0", "2.0", "3.0"]
	
						state.normals.push(parseFloat(result[1]), parseFloat(result[2]), parseFloat(result[3]));
					} else if (lineSecondChar === 't' && (result = this.regexp.uv_pattern.exec(line)) !== null) {
	
						// 0               1      2
						// ["vt 0.1 0.2", "0.1", "0.2"]
	
						state.uvs.push(parseFloat(result[1]), parseFloat(result[2]));
					} else {
	
						throw new Error("Unexpected vertex/normal/uv line: '" + line + "'");
					}
				} else if (lineFirstChar === "f") {
	
					if ((result = this.regexp.face_vertex_uv_normal.exec(line)) !== null) {
	
						// f vertex/uv/normal vertex/uv/normal vertex/uv/normal
						// 0                        1    2    3    4    5    6    7    8    9   10         11         12
						// ["f 1/1/1 2/2/2 3/3/3", "1", "1", "1", "2", "2", "2", "3", "3", "3", undefined, undefined, undefined]
	
						state.addFace(result[1], result[4], result[7], result[10], result[2], result[5], result[8], result[11], result[3], result[6], result[9], result[12]);
					} else if ((result = this.regexp.face_vertex_uv.exec(line)) !== null) {
	
						// f vertex/uv vertex/uv vertex/uv
						// 0                  1    2    3    4    5    6   7          8
						// ["f 1/1 2/2 3/3", "1", "1", "2", "2", "3", "3", undefined, undefined]
	
						state.addFace(result[1], result[3], result[5], result[7], result[2], result[4], result[6], result[8]);
					} else if ((result = this.regexp.face_vertex_normal.exec(line)) !== null) {
	
						// f vertex//normal vertex//normal vertex//normal
						// 0                     1    2    3    4    5    6   7          8
						// ["f 1//1 2//2 3//3", "1", "1", "2", "2", "3", "3", undefined, undefined]
	
						state.addFace(result[1], result[3], result[5], result[7], undefined, undefined, undefined, undefined, result[2], result[4], result[6], result[8]);
					} else if ((result = this.regexp.face_vertex.exec(line)) !== null) {
	
						// f vertex vertex vertex
						// 0            1    2    3   4
						// ["f 1 2 3", "1", "2", "3", undefined]
	
						state.addFace(result[1], result[2], result[3], result[4]);
					} else {
	
						throw new Error("Unexpected face line: '" + line + "'");
					}
				} else if (lineFirstChar === "l") {
	
					var lineParts = line.substring(1).trim().split(" ");
					var lineVertices = [],
					    lineUVs = [];
	
					if (line.indexOf("/") === -1) {
	
						lineVertices = lineParts;
					} else {
	
						for (var li = 0, llen = lineParts.length; li < llen; li++) {
	
							var parts = lineParts[li].split("/");
	
							if (parts[0] !== "") lineVertices.push(parts[0]);
							if (parts[1] !== "") lineUVs.push(parts[1]);
						}
					}
					state.addLineGeometry(lineVertices, lineUVs);
				} else if ((result = this.regexp.object_pattern.exec(line)) !== null) {
	
					// o object_name
					// or
					// g group_name
	
					// WORKAROUND: https://bugs.chromium.org/p/v8/issues/detail?id=2869
					// var name = result[ 0 ].substr( 1 ).trim();
					var name = (" " + result[0].substr(1).trim()).substr(1);
	
					state.startObject(name);
				} else if (this.regexp.material_use_pattern.test(line)) {
	
					// material
	
					state.object.startMaterial(line.substring(7).trim(), state.materialLibraries);
				} else if (this.regexp.material_library_pattern.test(line)) {
	
					// mtl file
	
					state.materialLibraries.push(line.substring(7).trim());
				} else if ((result = this.regexp.smoothing_pattern.exec(line)) !== null) {
	
					// smooth shading
	
					// @todo Handle files that have varying smooth values for a set of faces inside one geometry,
					// but does not define a usemtl for each face set.
					// This should be detected and a dummy material created (later MultiMaterial and geometry groups).
					// This requires some care to not create extra material on each smooth value for "normal" obj files.
					// where explicit usemtl defines geometry groups.
					// Example asset: examples/models/obj/cerberus/Cerberus.obj
	
					var value = result[1].trim().toLowerCase();
					state.object.smooth = value === '1' || value === 'on';
	
					var material = state.object.currentMaterial();
					if (material) {
	
						material.smooth = state.object.smooth;
					}
				} else {
	
					// Handle null terminated files without exception
					if (line === '\0') continue;
	
					throw new Error("Unexpected line: '" + line + "'");
				}
			}
	
			state.finalize();
	
			var container = new THREE.Group();
			container.materialLibraries = [].concat(state.materialLibraries);
	
			for (var i = 0, l = state.objects.length; i < l; i++) {
	
				var object = state.objects[i];
				var geometry = object.geometry;
				var materials = object.materials;
				var isLine = geometry.type === 'Line';
	
				// Skip o/g line declarations that did not follow with any faces
				if (geometry.vertices.length === 0) continue;
	
				var buffergeometry = new THREE.BufferGeometry();
	
				buffergeometry.addAttribute('position', new THREE.BufferAttribute(new Float32Array(geometry.vertices), 3));
	
				if (geometry.normals.length > 0) {
	
					buffergeometry.addAttribute('normal', new THREE.BufferAttribute(new Float32Array(geometry.normals), 3));
				} else {
	
					buffergeometry.computeVertexNormals();
				}
	
				if (geometry.uvs.length > 0) {
	
					buffergeometry.addAttribute('uv', new THREE.BufferAttribute(new Float32Array(geometry.uvs), 2));
				}
	
				// Create materials
	
				var createdMaterials = [];
	
				for (var mi = 0, miLen = materials.length; mi < miLen; mi++) {
	
					var sourceMaterial = materials[mi];
					var material = undefined;
	
					if (this.materials !== null) {
	
						material = this.materials.create(sourceMaterial.name);
	
						// mtl etc. loaders probably can't create line materials correctly, copy properties to a line material.
						if (isLine && material && !(material instanceof THREE.LineBasicMaterial)) {
	
							var materialLine = new THREE.LineBasicMaterial();
							materialLine.copy(material);
							material = materialLine;
						}
					}
	
					if (!material) {
	
						material = !isLine ? new THREE.MeshPhongMaterial() : new THREE.LineBasicMaterial();
						material.name = sourceMaterial.name;
					}
	
					material.shading = sourceMaterial.smooth ? THREE.SmoothShading : THREE.FlatShading;
	
					createdMaterials.push(material);
				}
	
				// Create mesh
	
				var mesh;
	
				if (createdMaterials.length > 1) {
	
					for (var mi = 0, miLen = materials.length; mi < miLen; mi++) {
	
						var sourceMaterial = materials[mi];
						buffergeometry.addGroup(sourceMaterial.groupStart, sourceMaterial.groupCount, mi);
					}
	
					mesh = !isLine ? new THREE.Mesh(buffergeometry, createdMaterials) : new THREE.LineSegments(buffergeometry, createdMaterials);
				} else {
	
					mesh = !isLine ? new THREE.Mesh(buffergeometry, createdMaterials[0]) : new THREE.LineSegments(buffergeometry, createdMaterials[0]);
				}
	
				mesh.name = object.name;
	
				container.add(mesh);
			}
	
			console.timeEnd('OBJLoader');
	
			return container;
		}
	
	};
	/* eslint-enable */

/***/ }),
/* 128 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.RaycasterUtils = exports.Octree = undefined;
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _three = __webpack_require__(2);
	
	var THREE = _interopRequireWildcard(_three);
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	/* eslint-disable no-bitwise */
	
	function isNumber(n) {
	  return !isNaN(n) && isFinite(n);
	}
	
	function isArray(target) {
	  return Object.prototype.toString.call(target) === '[object Array]';
	}
	
	function toArray(target) {
	  if (target) {
	    return isArray(target) !== true ? [target] : target;
	  }
	  return [];
	}
	
	function indexOfValue(array, value) {
	  for (var i in array) {
	    if (array[i] === value) {
	      return i;
	    }
	  }
	  return -1;
	}
	
	function indexOfPropertyWithValue(array, property, value) {
	  for (var i in array) {
	    if (array[i][property] === value) {
	      return i;
	    }
	  }
	  return -1;
	}
	
	/**
	 * Alias for circular reference. Be Assigned after Octree declaration.
	 * @alias Octree
	 * @private
	 * @type {Class}
	 */
	var OctreeAlias = null;
	
	/**
	 * Object for octree.
	 * @private
	 */
	
	var OctreeObjectData = function () {
	  /**
	   * Constructor.
	   * @param  {Object}                    object Object.
	   * @param  {THREE.Face3|THREE.Vector3} [part] Face or vertice.
	   */
	  function OctreeObjectData(object, part) {
	    _classCallCheck(this, OctreeObjectData);
	
	    // properties
	    this.object = object;
	
	    // handle part by type
	    if (part instanceof THREE.Face3) {
	      this.faces = part;
	      this.face3 = true;
	      this.utilVec31FaceBounds = new THREE.Vector3();
	    } else if (part instanceof THREE.Vector3) {
	      this.vertices = part;
	    }
	
	    this.radius = 0;
	    this.position = new THREE.Vector3();
	
	    // initial update
	    if (this.object instanceof THREE.Object3D) {
	      this.update();
	    }
	
	    this.positionLast = this.position.clone();
	  }
	
	  /**
	   * Update radius and position.
	   * @return {undefined}
	   */
	
	
	  _createClass(OctreeObjectData, [{
	    key: 'update',
	    value: function update() {
	      if (this.face3) {
	        this.radius = this.getFace3BoundingRadius(this.object, this.faces);
	        this.position.copy(this.faces.centroid).applyMatrix4(this.object.matrixWorld);
	      } else if (this.vetices) {
	        this.radius = this.object.material.size || 1;
	        this.position.copy(this.vertices).applyMatrix4(this.object.matrixWorld);
	      } else if (this.object.geometry) {
	        if (this.object.geometry.boundingSphere === null) {
	          this.object.geometry.computeBoundingSphere();
	        }
	        this.radius = this.object.geometry.boundingSphere.radius;
	        this.position.copy(this.object.geometry.boundingSphere.center).applyMatrix4(this.object.matrixWorld);
	      } else {
	        this.radius = this.object.boundRadius;
	        this.position.setFromMatrixPosition(this.object.matrixWorld);
	      }
	
	      this.radius = this.radius * Math.max(this.object.scale.x, this.object.scale.y, this.object.scale.z);
	    }
	
	    /**
	     * Compute the radius of Face3 bounding.
	     * @param  {Object}      object Object.
	     * @param  {THREE.Face3} face   Face.
	     * @return {Number}             Radius.
	     */
	
	  }, {
	    key: 'getFace3BoundingRadius',
	    value: function getFace3BoundingRadius(object, face) {
	      if (typeof face.centroid === 'undefined') {
	        face.centroid = new THREE.Vector3();
	      }
	
	      var geometry = object.geometry || object;
	      var vertices = geometry.vertices;
	      var centroid = face.centroid;
	      var va = vertices[face.a];
	      var vb = vertices[face.b];
	      var vc = vertices[face.c];
	      var centroidToVert = this.utilVec31FaceBounds;
	
	      centroid.addVectors(va, vb).add(vc).divideScalar(3);
	
	      return Math.max(centroidToVert.subVectors(centroid, va).length(), centroidToVert.subVectors(centroid, vb).length(), centroidToVert.subVectors(centroid, vc).length());
	    }
	  }]);
	
	  return OctreeObjectData;
	}();
	
	/**
	 * Octree node.
	 * @private
	 */
	
	
	var OctreeNode = function () {
	  /**
	   * Constructor.
	   * @param  {Object}        [params]             Octree node parameters.
	   * @param  {Octree}        [params.tree]        Tree.
	   * @param  {Object}        [params.parent]      parent.
	   * @param  {THREE.Vector3} [params.position]    Position.
	   * @param  {Number}        [params.radius=1]    Raduis.
	   * @param  {Number}        [params.indexOctant] IndexOctant.
	   */
	  function OctreeNode(params) {
	    _classCallCheck(this, OctreeNode);
	
	    // utility
	    this.utilVec31Branch = new THREE.Vector3();
	    this.utilVec31Expand = new THREE.Vector3();
	    this.utilVec31Ray = new THREE.Vector3();
	
	    // handle parameters
	    var parameters = params || {};
	
	    // store or create tree
	    // use alias of Octree
	    if (parameters.tree instanceof OctreeAlias) {
	      this.tree = parameters.tree;
	    } else if (parameters.parent instanceof OctreeNode !== true) {
	      parameters.root = this;
	      this.tree = new OctreeAlias(parameters);
	    }
	
	    // basic properties
	    this.id = this.tree.nodeCount++;
	    this.position = parameters.position instanceof THREE.Vector3 ? parameters.position : new THREE.Vector3();
	    this.radius = parameters.radius > 0 ? parameters.radius : 1;
	    this.indexOctant = parameters.indexOctant;
	    this.depth = 0;
	
	    // reset and assign parent
	    this.reset();
	    this.setParent(parameters.parent);
	
	    // additional properties
	    this.overlap = this.radius * this.tree.overlapPct;
	    this.radiusOverlap = this.radius + this.overlap;
	    this.left = this.position.x - this.radiusOverlap;
	    this.right = this.position.x + this.radiusOverlap;
	    this.bottom = this.position.y - this.radiusOverlap;
	    this.top = this.position.y + this.radiusOverlap;
	    this.back = this.position.z - this.radiusOverlap;
	    this.front = this.position.z + this.radiusOverlap;
	
	    // visual
	    if (this.tree.scene) {
	      this.visual = new THREE.Mesh(this.tree.visualGeometry, this.tree.visualMaterial);
	      this.visual.scale.set(this.radiusOverlap * 2, this.radiusOverlap * 2, this.radiusOverlap * 2);
	      this.visual.position.copy(this.position);
	      this.tree.scene.add(this.visual);
	    }
	  }
	
	  /**
	   * Set parent of this node.
	   * @param {OctreeNode} parent Parent.
	   * @return {undefined}
	   */
	
	
	  _createClass(OctreeNode, [{
	    key: 'setParent',
	    value: function setParent(parent) {
	      // store new parent
	      if (parent !== this && this.parent !== parent) {
	        this.parent = parent;
	
	        // update properties
	        this.updateProperties();
	      }
	    }
	
	    /**
	     * Update properties (depth) of this node and the cascade of it.
	     * @return {undefined}
	     */
	
	  }, {
	    key: 'updateProperties',
	    value: function updateProperties() {
	      // properties
	      if (this.parent instanceof OctreeNode) {
	        this.tree = this.parent.tree;
	        this.depth = this.parent.depth + 1;
	      } else {
	        this.depth = 0;
	      }
	
	      // cascade
	      for (var _iterator = this.nodesIndices, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
	        var _ref;
	
	        if (_isArray) {
	          if (_i >= _iterator.length) break;
	          _ref = _iterator[_i++];
	        } else {
	          _i = _iterator.next();
	          if (_i.done) break;
	          _ref = _i.value;
	        }
	
	        var index = _ref;
	
	        this.nodesByIndex[index].updateProperties();
	      }
	    }
	
	    /**
	     * Reset parent.
	     * @param  {Boolean} cascade      Whether to reset cascade.
	     * @param  {Boolean} removeVisual Whether to remove visual.
	     * @return {undefined}
	     */
	
	  }, {
	    key: 'reset',
	    value: function reset(cascade, removeVisual) {
	      var nodesIndices = this.nodesIndices || [];
	      var nodesByIndex = this.nodesByIndex;
	
	      this.objects = [];
	      this.nodesIndices = [];
	      this.nodesByIndex = {};
	
	      // unset parent in nodes
	      for (var _iterator2 = nodesIndices, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator]();;) {
	        var _ref2;
	
	        if (_isArray2) {
	          if (_i2 >= _iterator2.length) break;
	          _ref2 = _iterator2[_i2++];
	        } else {
	          _i2 = _iterator2.next();
	          if (_i2.done) break;
	          _ref2 = _i2.value;
	        }
	
	        var index = _ref2;
	
	        var node = nodesByIndex[index];
	
	        // set undefined as parent
	        node.setParent();
	        if (cascade === true) {
	          node.reset(cascade, removeVisual);
	        }
	      }
	
	      // visual
	      if (removeVisual === true && this.visual && this.visual.parent) {
	        this.visual.parent.remove(this.visual);
	      }
	    }
	
	    /**
	     * Add another node to this node as a child.
	     * @param {Octree} node        Node.
	     * @param {Number} indexOctant Index octant.
	     * @return {undefined}
	     */
	
	  }, {
	    key: 'addNode',
	    value: function addNode(node, indexOctant) {
	      node.indexOctant = indexOctant;
	      if (indexOfValue(this.nodesIndices, indexOctant) === -1) {
	        this.nodesIndices.push(indexOctant);
	      }
	      this.nodesByIndex[indexOctant] = node;
	      if (node.parent !== this) {
	        node.setParent(this);
	      }
	    }
	
	    /**
	     * Remove a node from this node via indexOctant.
	     * @param  {Number} indexOctant Index octant.
	     * @return {undefined}
	     */
	
	  }, {
	    key: 'removeNode',
	    value: function removeNode(indexOctant) {
	      var index = indexOfValue(this.nodesIndices, indexOctant);
	      var node = this.nodesByIndex[indexOctant];
	
	      this.nodesIndices.splice(index, 1);
	      delete this.nodesByIndex[indexOctant];
	      if (node && node.parent === this) {
	        // set undefined as parent
	        node.setParent();
	      }
	    }
	
	    /**
	     * Add an object to this node (or its child).
	     * @param {OctreeObjectData} object Object.
	     * @return {undefined}
	     */
	
	  }, {
	    key: 'addObject',
	    value: function addObject(object) {
	      var indexOctant = this.getOctantIndex(object);
	
	      // if object fully contained by an octant, add to subtree
	      if (indexOctant > -1 && this.nodesIndices.length > 0) {
	        var node = this.branch(indexOctant);
	
	        node.addObject(object);
	      } else if (indexOctant < -1 && this.parent instanceof OctreeNode) {
	        // if object lies outside bounds, add to parent node
	        this.parent.addObject(object);
	      } else {
	        // add to this object list
	        var index = indexOfValue(this.objects, object);
	
	        if (index === -1) {
	          this.objects.push(object);
	        }
	
	        // node reference
	        object.node = this;
	
	        // check if need to expand, split, or both
	        this.checkGrow();
	      }
	    }
	
	    /**
	     * Add objects to this node (but not to its children) without check if need to expand, split, or both.
	     * @param {OctreeObjectData[]} objects Objects.
	     * @return {undefined}
	     */
	
	  }, {
	    key: 'addObjectWithoutCheck',
	    value: function addObjectWithoutCheck(objects) {
	      for (var _iterator3 = objects, _isArray3 = Array.isArray(_iterator3), _i3 = 0, _iterator3 = _isArray3 ? _iterator3 : _iterator3[Symbol.iterator]();;) {
	        var _ref3;
	
	        if (_isArray3) {
	          if (_i3 >= _iterator3.length) break;
	          _ref3 = _iterator3[_i3++];
	        } else {
	          _i3 = _iterator3.next();
	          if (_i3.done) break;
	          _ref3 = _i3.value;
	        }
	
	        var object = _ref3;
	
	        this.objects.push(object);
	        object.node = this;
	      }
	    }
	
	    /**
	     * Remove an object from this node.
	     * @param  {Object} object       Object
	     * @return {OctreeObjectData[]}  Object datas which be removed.
	     */
	
	  }, {
	    key: 'removeObject',
	    value: function removeObject(object) {
	      // cascade through tree to find and remove object
	      var removeData = this.removeObjectRecursive(object, {
	        searchComplete: false,
	        nodesRemovedFrom: [],
	        objectsDataRemoved: []
	      });
	
	      // if object removed, try to shrink the nodes it was removed from
	      var nodesRemovedFrom = removeData.nodesRemovedFrom;
	
	      if (nodesRemovedFrom.length > 0) {
	        for (var _iterator4 = nodesRemovedFrom, _isArray4 = Array.isArray(_iterator4), _i4 = 0, _iterator4 = _isArray4 ? _iterator4 : _iterator4[Symbol.iterator]();;) {
	          var _ref4;
	
	          if (_isArray4) {
	            if (_i4 >= _iterator4.length) break;
	            _ref4 = _iterator4[_i4++];
	          } else {
	            _i4 = _iterator4.next();
	            if (_i4.done) break;
	            _ref4 = _i4.value;
	          }
	
	          var node = _ref4;
	
	          node.shrink();
	        }
	      }
	
	      return removeData.objectsDataRemoved;
	    }
	
	    /**
	     * Remove an object from this node recursively.
	     * @param  {Object}             object                        Object.
	     * @param  {Object}             removeData                    Data needed to remove.
	     * @param  {Boolean}            removeData.searchComplete     Whether search complete.
	     * @param  {OctreeNode[]}       removeData.nodesRemovedFrom   Nodes.
	     * @param  {OctreeObjectData[]} removeData.objectsDataRemoved Object datas.
	     * @return {Object}                                           Updated removeData.
	     */
	
	  }, {
	    key: 'removeObjectRecursive',
	    value: function removeObjectRecursive(object, removeData) {
	      var objectRemoved = void 0;
	
	      // find index of object in objects list
	      // search and remove object data (fast)
	      if (object instanceof OctreeObjectData) {
	        // remove from this objects list
	        var index = indexOfValue(this.objects, object);
	
	        if (index !== -1) {
	          this.objects.splice(index, 1);
	          delete object.node;
	          removeData.objectsDataRemoved.push(object);
	          removeData.searchComplete = objectRemoved = true;
	        }
	      } else {
	        // search each object data for object and remove (slow)
	        for (var i = this.objects.length - 1; i >= 0; i--) {
	          var objectData = this.objects[i];
	          if (objectData.object === object) {
	            this.objects.splice(i, 1);
	            delete objectData.node;
	            removeData.objectsDataRemoved.push(objectData);
	            objectRemoved = true;
	            if (!objectData.faces && !objectData.vertices) {
	              removeData.searchComplete = true;
	              break;
	            }
	          }
	        }
	      }
	
	      // if object data removed and this is not on nodes removed from
	      if (objectRemoved === true) {
	        removeData.nodesRemovedFrom.push(this);
	      }
	
	      // if search not complete, search nodes
	      if (removeData.searchComplete !== true) {
	        for (var _iterator5 = this.nodesIndices, _isArray5 = Array.isArray(_iterator5), _i5 = 0, _iterator5 = _isArray5 ? _iterator5 : _iterator5[Symbol.iterator]();;) {
	          var _ref5;
	
	          if (_isArray5) {
	            if (_i5 >= _iterator5.length) break;
	            _ref5 = _iterator5[_i5++];
	          } else {
	            _i5 = _iterator5.next();
	            if (_i5.done) break;
	            _ref5 = _i5.value;
	          }
	
	          var _index = _ref5;
	
	          var node = this.nodesByIndex[_index];
	
	          // try removing object from node
	          removeData = node.removeObjectRecursive(object, removeData); // eslint-disable-line no-param-reassign
	          if (removeData.searchComplete === true) {
	            break;
	          }
	        }
	      }
	
	      return removeData;
	    }
	
	    /**
	     * Grow if need.
	     * @return {undefined}
	     */
	
	  }, {
	    key: 'checkGrow',
	    value: function checkGrow() {
	      // if object count above max
	      if (this.objects.length > this.tree.objectsThreshold && this.tree.objectsThreshold > 0) {
	        this.grow();
	      }
	    }
	
	    /**
	     * Grow (split, expand, and merge).
	     * @return {undefined}
	     */
	
	  }, {
	    key: 'grow',
	    value: function grow() {
	      var objectsExpand = [];
	      var objectsExpandOctants = [];
	      var objectsSplit = [];
	      var objectsSplitOctant = [];
	      var objectsRemaining = [];
	
	      // for each object
	      for (var _iterator6 = this.objects, _isArray6 = Array.isArray(_iterator6), _i6 = 0, _iterator6 = _isArray6 ? _iterator6 : _iterator6[Symbol.iterator]();;) {
	        var _ref6;
	
	        if (_isArray6) {
	          if (_i6 >= _iterator6.length) break;
	          _ref6 = _iterator6[_i6++];
	        } else {
	          _i6 = _iterator6.next();
	          if (_i6.done) break;
	          _ref6 = _i6.value;
	        }
	
	        var object = _ref6;
	
	        // get object octant index
	        var indexOctant = this.getOctantIndex(object);
	
	        // if lies within octant
	        if (indexOctant > -1) {
	          objectsSplit.push(object);
	          objectsSplitOctant.push(indexOctant);
	        } else if (indexOctant < -1) {
	          // lies outside radius
	          objectsExpand.push(object);
	          objectsExpandOctants.push(indexOctant);
	        } else {
	          // lies across bounds between octants
	          objectsRemaining.push(object);
	        }
	      }
	
	      // if has objects to split
	      if (objectsSplit.length > 0) {
	        objectsRemaining = objectsRemaining.concat(this.split(objectsSplit, objectsSplitOctant));
	      }
	
	      // if has objects to expand
	      if (objectsExpand.length > 0) {
	        objectsRemaining = objectsRemaining.concat(this.expand(objectsExpand, objectsExpandOctants));
	      }
	
	      // store remaining
	      this.objects = objectsRemaining;
	
	      // merge check
	      this.checkMerge();
	    }
	
	    /**
	     * Split objects by octants.
	     * @param  {Object[]} objects Objects.
	     * @param  {Number[]} octants Octants.
	     * @return {Object[]}         Remaining objects.
	     */
	
	  }, {
	    key: 'split',
	    value: function split(objects, octants) {
	      var objectsRemaining = void 0;
	
	      // if not at max depth
	      if (this.depth < this.tree.depthMax) {
	        var tempObjects = objects || this.objects;
	        var tempOctants = octants || [];
	
	        objectsRemaining = [];
	
	        // for each object
	        for (var i = 0; i < tempObjects.length; i++) {
	          var object = tempObjects[i];
	          var indexOctant = tempOctants[i];
	
	          // if object contained by octant, branch this tree
	          if (indexOctant > -1) {
	            var node = this.branch(indexOctant);
	
	            node.addObject(object);
	          } else {
	            objectsRemaining.push(object);
	          }
	        }
	
	        // if all objects, set remaining as new objects
	        if (tempObjects === this.objects) {
	          this.objects = objectsRemaining;
	        }
	      } else {
	        objectsRemaining = this.objects;
	      }
	
	      return objectsRemaining;
	    }
	
	    /**
	     * Branch a node by indexOctant.
	     * @param  {Number} indexOctant Index octant.
	     * @return {OctreeNode}         Branch node.
	     */
	
	  }, {
	    key: 'branch',
	    value: function branch(indexOctant) {
	      var node = void 0;
	
	      // node exists
	      if (this.nodesByIndex[indexOctant] instanceof OctreeNode) {
	        node = this.nodesByIndex[indexOctant];
	      } else {
	        // properties
	        var radius = this.radiusOverlap * 0.5;
	        var overlap = radius * this.tree.overlapPct;
	        var radiusOffset = radius - overlap;
	        var offset = this.utilVec31Branch.set(indexOctant & 1 ? radiusOffset : -radiusOffset, indexOctant & 2 ? radiusOffset : -radiusOffset, indexOctant & 4 ? radiusOffset : -radiusOffset);
	        var position = new THREE.Vector3().addVectors(this.position, offset);
	
	        // node
	        node = new OctreeNode({
	          tree: this.tree,
	          parent: this,
	          position: position,
	          radius: radius,
	          indexOctant: indexOctant
	        });
	
	        // store
	        this.addNode(node, indexOctant);
	      }
	
	      return node;
	    }
	
	    /**
	     * Expand this nod by objects and octants.
	     * @param  {Object[]} objects Objects.
	     * @param  {Number[]} octants Octants.
	     * @return {Object[]}         Remaining objects.
	     */
	
	  }, {
	    key: 'expand',
	    value: function expand(objects, octants) {
	      var objectsRemaining = void 0;
	
	      // handle max depth down tree
	      if (this.tree.root.getDepthEnd() < this.tree.depthMax) {
	        var iom = this.tree.INDEX_OUTSIDE_MAP;
	        var offset = this.utilVec31Expand;
	        var objectsExpand = [];
	
	        /* eslint-disable no-param-reassign */
	        objects = objects || this.objects;
	        octants = octants || [];
	        /* eslint-enable no-param-reassign */
	
	        objectsRemaining = [];
	
	        // reset counts
	        for (var _iterator7 = iom, _isArray7 = Array.isArray(_iterator7), _i7 = 0, _iterator7 = _isArray7 ? _iterator7 : _iterator7[Symbol.iterator]();;) {
	          var _ref7;
	
	          if (_isArray7) {
	            if (_i7 >= _iterator7.length) break;
	            _ref7 = _iterator7[_i7++];
	          } else {
	            _i7 = _iterator7.next();
	            if (_i7.done) break;
	            _ref7 = _i7.value;
	          }
	
	          var el = _ref7;
	
	          el.count = 0;
	        }
	
	        // for all outside objects, find outside octants containing most objects
	        for (var i = 0; i < objects.length; i++) {
	          var object = objects[i];
	          var indexOctant = octants[i];
	
	          // if object outside this, include in calculations
	          if (indexOctant < -1) {
	            // convert octant index to outside flags
	            var flagsOutside = -indexOctant - this.tree.INDEX_OUTSIDE_OFFSET;
	
	            // check against bitwise flags
	            // x
	            if (flagsOutside & this.tree.FLAG_POS_X) {
	              iom[this.tree.INDEX_OUTSIDE_POS_X].count++;
	            } else if (flagsOutside & this.tree.FLAG_NEG_X) {
	              iom[this.tree.INDEX_OUTSIDE_NEG_X].count++;
	            }
	
	            // y
	            if (flagsOutside & this.tree.FLAG_POS_Y) {
	              iom[this.tree.INDEX_OUTSIDE_POS_Y].count++;
	            } else if (flagsOutside & this.tree.FLAG_NEG_Y) {
	              iom[this.tree.INDEX_OUTSIDE_NEG_Y].count++;
	            }
	
	            // z
	            if (flagsOutside & this.tree.FLAG_POS_Z) {
	              iom[this.tree.INDEX_OUTSIDE_POS_Z].count++;
	            } else if (flagsOutside & this.tree.FLAG_NEG_Z) {
	              iom[this.tree.INDEX_OUTSIDE_NEG_Z].count++;
	            }
	
	            // store in expand list
	            objectsExpand.push(object);
	          } else {
	            objectsRemaining.push(object);
	          }
	        }
	
	        // if objects to expand
	        if (objectsExpand.length > 0) {
	          // shallow copy index outside map
	          var indexOutsideCounts = iom.slice(0);
	
	          // sort outside index count so highest is first
	          indexOutsideCounts.sort(function (a, b) {
	            return b.count - a.count;
	          });
	
	          // get highest outside indices
	          var infoIndexOutside3 = void 0,
	              infoPotential1 = void 0,
	              infoPotential2 = void 0;
	
	          // first is first
	          var infoIndexOutside1 = indexOutsideCounts[0];
	          var indexOutsideBitwise1 = infoIndexOutside1.index | 1;
	
	          // second is ( one of next two bitwise OR 1 ) that is not opposite of ( first bitwise OR 1 )
	          infoPotential1 = indexOutsideCounts[1];
	          infoPotential2 = indexOutsideCounts[2];
	
	          var infoIndexOutside2 = (infoPotential1.index | 1) !== indexOutsideBitwise1 ? infoPotential1 : infoPotential2;
	          var indexOutsideBitwise2 = infoIndexOutside2.index | 1;
	
	          // third is ( one of next three bitwise OR 1 ) that is not opposite of ( first or second bitwise OR 1 )
	
	          infoPotential1 = indexOutsideCounts[2];
	          infoPotential2 = indexOutsideCounts[3];
	          var infoPotential3 = indexOutsideCounts[4];
	
	          var indexPotentialBitwise1 = infoPotential1.index | 1;
	          var indexPotentialBitwise2 = infoPotential2.index | 1;
	
	          if (indexPotentialBitwise1 !== indexOutsideBitwise1 && indexPotentialBitwise1 !== indexOutsideBitwise2) {
	            infoIndexOutside3 = infoPotential1;
	          } else if (indexPotentialBitwise2 !== indexOutsideBitwise1 && indexPotentialBitwise2 !== indexOutsideBitwise2) {
	            infoIndexOutside3 = infoPotential2;
	          } else {
	            infoIndexOutside3 = infoPotential3;
	          }
	
	          // get this octant normal based on outside octant indices
	          var octantX = infoIndexOutside1.x + infoIndexOutside2.x + infoIndexOutside3.x;
	          var octantY = infoIndexOutside1.y + infoIndexOutside2.y + infoIndexOutside3.y;
	          var octantZ = infoIndexOutside1.z + infoIndexOutside2.z + infoIndexOutside3.z;
	
	          // get this octant indices based on octant normal
	          var _indexOctant = this.getOctantIndexFromPosition(octantX, octantY, octantZ);
	          var indexOctantInverse = this.getOctantIndexFromPosition(-octantX, -octantY, -octantZ);
	
	          // properties
	          var overlap = this.overlap;
	          var radius = this.radius;
	
	          // radius of parent comes from reversing overlap of this, unless overlap percent is 0
	          var radiusParent = this.tree.overlapPct > 0 ? overlap / (0.5 * this.tree.overlapPct * (1 + this.tree.overlapPct)) : radius * 2;
	          var overlapParent = radiusParent * this.tree.overlapPct;
	
	          // parent offset is difference between radius + overlap of parent and child
	          var radiusOffset = radiusParent + overlapParent - (radius + overlap);
	          offset.set(_indexOctant & 1 ? radiusOffset : -radiusOffset, _indexOctant & 2 ? radiusOffset : -radiusOffset, _indexOctant & 4 ? radiusOffset : -radiusOffset);
	          var position = new THREE.Vector3().addVectors(this.position, offset);
	
	          // parent
	          var parent = new OctreeNode({
	            tree: this.tree,
	            position: position,
	            radius: radiusParent
	          });
	
	          // set self as node of parent
	          parent.addNode(this, indexOctantInverse);
	
	          // set parent as root
	          this.tree.setRoot(parent);
	
	          // add all expand objects to parent
	          for (var _iterator8 = objectsExpand, _isArray8 = Array.isArray(_iterator8), _i8 = 0, _iterator8 = _isArray8 ? _iterator8 : _iterator8[Symbol.iterator]();;) {
	            var _ref8;
	
	            if (_isArray8) {
	              if (_i8 >= _iterator8.length) break;
	              _ref8 = _iterator8[_i8++];
	            } else {
	              _i8 = _iterator8.next();
	              if (_i8.done) break;
	              _ref8 = _i8.value;
	            }
	
	            var _object = _ref8;
	
	            this.tree.root.addObject(_object);
	          }
	        }
	
	        // if all objects, set remaining as new objects
	        if (objects === this.objects) {
	          this.objects = objectsRemaining;
	        }
	      } else {
	        objectsRemaining = objects;
	      }
	
	      return objectsRemaining;
	    }
	
	    /**
	     * Shrink this node.
	     * @return {undefined}
	     */
	
	  }, {
	    key: 'shrink',
	    value: function shrink() {
	      // merge check
	      this.checkMerge();
	
	      // contract check
	      this.tree.root.checkContract();
	    }
	
	    /**
	     * Merge this node or ancestor if need.
	     * @return {undefined}
	     */
	
	  }, {
	    key: 'checkMerge',
	    value: function checkMerge() {
	      var nodeParent = this; // eslint-disable-line consistent-this
	      var nodeMerge = void 0;
	
	      // traverse up tree as long as node + entire subtree's object count is under minimum
	      while (nodeParent.parent instanceof OctreeNode && nodeParent.getObjectCountEnd() < this.tree.objectsThreshold) {
	        nodeMerge = nodeParent;
	        nodeParent = nodeParent.parent;
	      }
	
	      // if parent node is not this, merge entire subtree into merge node
	      if (nodeParent !== this) {
	        nodeParent.merge(nodeMerge);
	      }
	    }
	
	    /**
	     * Merge nodes.
	     * @param  {OctreeNode|OctreeNode[]} nodes Nodes.
	     * @return {undefined}
	     */
	
	  }, {
	    key: 'merge',
	    value: function merge(nodes) {
	      // handle nodes
	      nodes = toArray(nodes); // eslint-disable-line no-param-reassign
	      for (var _iterator9 = nodes, _isArray9 = Array.isArray(_iterator9), _i9 = 0, _iterator9 = _isArray9 ? _iterator9 : _iterator9[Symbol.iterator]();;) {
	        var _ref9;
	
	        if (_isArray9) {
	          if (_i9 >= _iterator9.length) break;
	          _ref9 = _iterator9[_i9++];
	        } else {
	          _i9 = _iterator9.next();
	          if (_i9.done) break;
	          _ref9 = _i9.value;
	        }
	
	        var node = _ref9;
	
	        // gather node + all subtree objects
	        this.addObjectWithoutCheck(node.getObjectsEnd());
	
	        // reset node + entire subtree
	        node.reset(true, true);
	
	        // remove node
	        this.removeNode(node.indexOctant, node);
	      }
	
	      // merge check
	      this.checkMerge();
	    }
	
	    /**
	     * Contract nodes of this node if need to.
	     * @return {undefined}
	     */
	
	  }, {
	    key: 'checkContract',
	    value: function checkContract() {
	      // find node with highest object count
	      if (this.nodesIndices.length > 0) {
	        var nodeHeaviestObjectsCount = 0;
	        var outsideHeaviestObjectsCount = this.objects.length;
	        var nodeHeaviest = void 0;
	
	        for (var _iterator10 = this.nodesIndices, _isArray10 = Array.isArray(_iterator10), _i10 = 0, _iterator10 = _isArray10 ? _iterator10 : _iterator10[Symbol.iterator]();;) {
	          var _ref10;
	
	          if (_isArray10) {
	            if (_i10 >= _iterator10.length) break;
	            _ref10 = _iterator10[_i10++];
	          } else {
	            _i10 = _iterator10.next();
	            if (_i10.done) break;
	            _ref10 = _i10.value;
	          }
	
	          var index = _ref10;
	
	          var node = this.nodesByIndex[index];
	          var nodeObjectsCount = node.getObjectCountEnd();
	
	          outsideHeaviestObjectsCount += nodeObjectsCount;
	          if (nodeHeaviest instanceof OctreeNode === false || nodeObjectsCount > nodeHeaviestObjectsCount) {
	            nodeHeaviest = node;
	            nodeHeaviestObjectsCount = nodeObjectsCount;
	          }
	        }
	
	        // subtract heaviest count from outside count
	        outsideHeaviestObjectsCount -= nodeHeaviestObjectsCount;
	
	        // if should contract
	        if (outsideHeaviestObjectsCount < this.tree.objectsThreshold && nodeHeaviest instanceof OctreeNode) {
	          this.contract(nodeHeaviest);
	        }
	      }
	    }
	
	    /**
	     * Contract this node to nodeRoot.
	     * @param  {OctreeNode} nodeRoot Node root.
	     * @return {undefined}
	     */
	
	  }, {
	    key: 'contract',
	    value: function contract(nodeRoot) {
	      // handle all nodes
	      for (var _iterator11 = this.nodesIndices, _isArray11 = Array.isArray(_iterator11), _i11 = 0, _iterator11 = _isArray11 ? _iterator11 : _iterator11[Symbol.iterator]();;) {
	        var _ref11;
	
	        if (_isArray11) {
	          if (_i11 >= _iterator11.length) break;
	          _ref11 = _iterator11[_i11++];
	        } else {
	          _i11 = _iterator11.next();
	          if (_i11.done) break;
	          _ref11 = _i11.value;
	        }
	
	        var index = _ref11;
	
	        var node = this.nodesByIndex[index];
	
	        // if node is not new root
	        if (node !== nodeRoot) {
	
	          // add node + all subtree objects to root
	          nodeRoot.addObjectWithoutCheck(node.getObjectsEnd());
	
	          // reset node + entire subtree
	          node.reset(true, true);
	        }
	      }
	
	      // add own objects to root
	      nodeRoot.addObjectWithoutCheck(this.objects);
	
	      // reset self
	      this.reset(false, true);
	
	      // set new root
	      this.tree.setRoot(nodeRoot);
	
	      // contract check on new root
	      nodeRoot.checkContract();
	    }
	
	    /**
	     * Get the octant index (indicate the position of the object relative to this node) of an objectData.
	     * @param  {OctreeObjectData} objectData Object data.
	     * @return {Number}                      Octant index.
	     */
	
	  }, {
	    key: 'getOctantIndex',
	    value: function getOctantIndex(objectData) {
	      var positionObj = void 0,
	          radiusObj = void 0;
	
	      // handle type
	      if (objectData instanceof OctreeObjectData) {
	        radiusObj = objectData.radius;
	        positionObj = objectData.position;
	
	        // update object data position last
	        objectData.positionLast.copy(positionObj);
	      } else if (objectData instanceof OctreeNode) {
	        positionObj = objectData.position;
	        radiusObj = 0;
	      }
	
	      // find delta and distance
	      var position = this.position;
	
	      var deltaX = positionObj.x - position.x;
	      var deltaY = positionObj.y - position.y;
	      var deltaZ = positionObj.z - position.z;
	
	      var distX = Math.abs(deltaX);
	      var distY = Math.abs(deltaY);
	      var distZ = Math.abs(deltaZ);
	      var distance = Math.max(distX, distY, distZ);
	
	      // if outside, use bitwise flags to indicate on which sides object is outside of
	      var radiusOverlap = this.radiusOverlap;
	      var indexOctant = 0;
	
	      if (distance + radiusObj > radiusOverlap) {
	        // x
	        if (distX + radiusObj > radiusOverlap) {
	          indexOctant ^= deltaX > 0 ? this.tree.FLAG_POS_X : this.tree.FLAG_NEG_X;
	        }
	
	        // y
	        if (distY + radiusObj > radiusOverlap) {
	          indexOctant ^= deltaY > 0 ? this.tree.FLAG_POS_Y : this.tree.FLAG_NEG_Y;
	        }
	
	        // z
	        if (distZ + radiusObj > radiusOverlap) {
	          indexOctant ^= deltaZ > 0 ? this.tree.FLAG_POS_Z : this.tree.FLAG_NEG_Z;
	        }
	        objectData.indexOctant = -indexOctant - this.tree.INDEX_OUTSIDE_OFFSET;
	        return objectData.indexOctant;
	      }
	
	      // return octant index from delta xyz
	      var overlap = this.overlap;
	
	      if (deltaX - radiusObj > -overlap) {
	        // x right
	        indexOctant |= 1;
	      } else if (!(deltaX + radiusObj < overlap)) {
	        // x left
	        objectData.indexOctant = this.tree.INDEX_INSIDE_CROSS;
	        return objectData.indexOctant;
	      }
	
	      if (deltaY - radiusObj > -overlap) {
	        // y right
	        indexOctant |= 2;
	      } else if (!(deltaY + radiusObj < overlap)) {
	        // y left
	        objectData.indexOctant = this.tree.INDEX_INSIDE_CROSS;
	        return objectData.indexOctant;
	      }
	
	      if (deltaZ - radiusObj > -overlap) {
	        // z right
	        indexOctant |= 4;
	      } else if (!(deltaZ + radiusObj < overlap)) {
	        // z left
	        objectData.indexOctant = this.tree.INDEX_INSIDE_CROSS;
	        return objectData.indexOctant;
	      }
	
	      objectData.indexOctant = indexOctant;
	
	      return objectData.indexOctant;
	    }
	
	    /**
	     * Get octant index from position.
	     * @param  {Number} x X.
	     * @param  {Number} y Y.
	     * @param  {Number} z Z.
	     * @return {Number}   Octant index.
	     */
	
	  }, {
	    key: 'getOctantIndexFromPosition',
	    value: function getOctantIndexFromPosition(x, y, z) {
	      var indexOctant = 0;
	
	      if (x > 0) {
	        indexOctant |= 1;
	      }
	
	      if (y > 0) {
	        indexOctant |= 2;
	      }
	
	      if (z > 0) {
	        indexOctant |= 4;
	      }
	
	      return indexOctant;
	    }
	
	    /**
	     * Search objects.
	     * @param  {THREE.Vector3} position     Position.
	     * @param  {Number}        radius       Radius.
	     * @param  {Object[]}      objects      Array to push searched objects.
	     * @param  {THREE.Vector3} direction    Direction.
	     * @param  {Number}        directionPct Direction percent.
	     * @return {Object[]}                   Search results.
	     */
	
	  }, {
	    key: 'search',
	    value: function search(position, radius, objects, direction, directionPct) {
	      var intersects = void 0;
	
	      // test intersects by parameters
	      if (direction) {
	        intersects = this.intersectRay(position, direction, radius, directionPct);
	      } else {
	        intersects = this.intersectSphere(position, radius);
	      }
	
	      // if intersects
	      if (intersects === true) {
	        // gather objects
	        objects = objects.concat(this.objects); // eslint-disable-line no-param-reassign
	
	        // search subtree
	        for (var _iterator12 = this.nodesIndices, _isArray12 = Array.isArray(_iterator12), _i12 = 0, _iterator12 = _isArray12 ? _iterator12 : _iterator12[Symbol.iterator]();;) {
	          var _ref12;
	
	          if (_isArray12) {
	            if (_i12 >= _iterator12.length) break;
	            _ref12 = _iterator12[_i12++];
	          } else {
	            _i12 = _iterator12.next();
	            if (_i12.done) break;
	            _ref12 = _i12.value;
	          }
	
	          var index = _ref12;
	
	          var node = this.nodesByIndex[index];
	          objects = node.search(position, radius, objects, direction); // eslint-disable-line no-param-reassign
	        }
	      }
	
	      return objects;
	    }
	
	    /**
	     * Check if this node intersects the sphere defined by passed position and radius.
	     * @param  {THREE.Vector3} position Position.
	     * @param  {Number}        radius   Radius.
	     * @return {Boolean}                Check result.
	     */
	
	  }, {
	    key: 'intersectSphere',
	    value: function intersectSphere(position, radius) {
	      var px = position.x;
	      var py = position.y;
	      var pz = position.z;
	      var distance = radius * radius;
	
	      if (px < this.left) {
	        distance -= Math.pow(px - this.left, 2);
	      } else if (px > this.right) {
	        distance -= Math.pow(px - this.right, 2);
	      }
	      if (py < this.bottom) {
	        distance -= Math.pow(py - this.bottom, 2);
	      } else if (py > this.top) {
	        distance -= Math.pow(py - this.top, 2);
	      }
	
	      if (pz < this.back) {
	        distance -= Math.pow(pz - this.back, 2);
	      } else if (pz > this.front) {
	        distance -= Math.pow(pz - this.front, 2);
	      }
	
	      return distance >= 0;
	    }
	
	    /**
	     * Check this node if intersect by the ray defined by passed parameters.
	     * @param  {THREE.Vector3} origin       Origin.
	     * @param  {THREE.Vector3} direction    Direction.
	     * @param  {Number}        distance     Distance.
	     * @param  {Number}        directionPct Direction percent.
	     * @return {Boolean}                    Check result.
	     */
	
	  }, {
	    key: 'intersectRay',
	    value: function intersectRay(origin, direction, distance, directionPct) {
	      if (typeof directionPct === 'undefined') {
	        directionPct = this.utilVec31Ray.set(1, 1, 1).divide(direction); // eslint-disable-line no-param-reassign
	      }
	
	      var t1 = (this.left - origin.x) * directionPct.x;
	      var t2 = (this.right - origin.x) * directionPct.x;
	      var t3 = (this.bottom - origin.y) * directionPct.y;
	      var t4 = (this.top - origin.y) * directionPct.y;
	      var t5 = (this.back - origin.z) * directionPct.z;
	      var t6 = (this.front - origin.z) * directionPct.z;
	      var tmax = Math.min(Math.min(Math.max(t1, t2), Math.max(t3, t4)), Math.max(t5, t6));
	
	      // ray would intersect in reverse direction, i.e. this is behind ray
	      if (tmax < 0) {
	        return false;
	      }
	
	      var tmin = Math.max(Math.max(Math.min(t1, t2), Math.min(t3, t4)), Math.min(t5, t6));
	
	      // if tmin > tmax or tmin > ray distance, ray doesn't intersect AABB
	      if (tmin > tmax || tmin > distance) {
	        return false;
	      }
	
	      return true;
	    }
	
	    /**
	     * Get the depth end of this node.
	     * @param  {Number} depth Current depth.
	     * @return {Number}       Depth.
	     */
	
	  }, {
	    key: 'getDepthEnd',
	    value: function getDepthEnd(depth) {
	      if (this.nodesIndices.length > 0) {
	        for (var _iterator13 = this.nodesIndices, _isArray13 = Array.isArray(_iterator13), _i13 = 0, _iterator13 = _isArray13 ? _iterator13 : _iterator13[Symbol.iterator]();;) {
	          var _ref13;
	
	          if (_isArray13) {
	            if (_i13 >= _iterator13.length) break;
	            _ref13 = _iterator13[_i13++];
	          } else {
	            _i13 = _iterator13.next();
	            if (_i13.done) break;
	            _ref13 = _i13.value;
	          }
	
	          var index = _ref13;
	
	          var node = this.nodesByIndex[index];
	
	          depth = node.getDepthEnd(depth); // eslint-disable-line no-param-reassign
	        }
	      } else {
	        depth = !depth || this.depth > depth ? this.depth : depth; // eslint-disable-line no-param-reassign
	      }
	
	      return depth;
	    }
	
	    /**
	     * Get the node count end of this node.
	     * @return {Number} node count end.
	     */
	
	  }, {
	    key: 'getNodeCountEnd',
	    value: function getNodeCountEnd() {
	      return this.tree.root.getNodeCountRecursive() + 1;
	    }
	
	    /**
	     * Get thd node count of this node recursively.
	     * @return {Number} Count.
	     */
	
	  }, {
	    key: 'getNodeCountRecursive',
	    value: function getNodeCountRecursive() {
	      var count = this.nodesIndices.length;
	
	      for (var _iterator14 = this.nodesIndices, _isArray14 = Array.isArray(_iterator14), _i14 = 0, _iterator14 = _isArray14 ? _iterator14 : _iterator14[Symbol.iterator]();;) {
	        var _ref14;
	
	        if (_isArray14) {
	          if (_i14 >= _iterator14.length) break;
	          _ref14 = _iterator14[_i14++];
	        } else {
	          _i14 = _iterator14.next();
	          if (_i14.done) break;
	          _ref14 = _i14.value;
	        }
	
	        var index = _ref14;
	
	        count += this.nodesByIndex[index].getNodeCountRecursive();
	      }
	
	      return count;
	    }
	
	    /**
	     * Get Objects end.
	     * @param  {Object[]} objects Array to push objects.
	     * @return {Object[]}         Objects end.
	     */
	
	  }, {
	    key: 'getObjectsEnd',
	    value: function getObjectsEnd(objects) {
	      objects = (objects || []).concat(this.objects); // eslint-disable-line no-param-reassign
	      for (var _iterator15 = this.nodesIndices, _isArray15 = Array.isArray(_iterator15), _i15 = 0, _iterator15 = _isArray15 ? _iterator15 : _iterator15[Symbol.iterator]();;) {
	        var _ref15;
	
	        if (_isArray15) {
	          if (_i15 >= _iterator15.length) break;
	          _ref15 = _iterator15[_i15++];
	        } else {
	          _i15 = _iterator15.next();
	          if (_i15.done) break;
	          _ref15 = _i15.value;
	        }
	
	        var index = _ref15;
	
	        var node = this.nodesByIndex[index];
	
	        objects = node.getObjectsEnd(objects); // eslint-disable-line no-param-reassign
	      }
	
	      return objects;
	    }
	
	    /**
	     * Get object count end.
	     * @return {Number} Count.
	     */
	
	  }, {
	    key: 'getObjectCountEnd',
	    value: function getObjectCountEnd() {
	      var count = this.objects.length;
	
	      for (var _iterator16 = this.nodesIndices, _isArray16 = Array.isArray(_iterator16), _i16 = 0, _iterator16 = _isArray16 ? _iterator16 : _iterator16[Symbol.iterator]();;) {
	        var _ref16;
	
	        if (_isArray16) {
	          if (_i16 >= _iterator16.length) break;
	          _ref16 = _iterator16[_i16++];
	        } else {
	          _i16 = _iterator16.next();
	          if (_i16.done) break;
	          _ref16 = _i16.value;
	        }
	
	        var index = _ref16;
	
	        count += this.nodesByIndex[index].getObjectCountEnd();
	      }
	
	      return count;
	    }
	
	    /**
	     * Get object count start.
	     * @return {Number} Count.
	     */
	
	  }, {
	    key: 'getObjectCountStart',
	    value: function getObjectCountStart() {
	      var count = this.objects.length;
	      var parent = this.parent;
	
	      while (parent instanceof OctreeNode) {
	        count += parent.objects.length;
	        parent = parent.parent;
	      }
	
	      return count;
	    }
	
	    /**
	     * Publish this node to console.
	     * @param  {String} [space='...'] Space to split node.
	     * @return {undefined}
	     */
	
	  }, {
	    key: 'toConsole',
	    value: function toConsole(space) {
	      var spaceAddition = '   ';
	
	      space = typeof space === 'string' ? space : spaceAddition; // eslint-disable-line no-param-reassign
	      console.log(this.parent ? space + ' octree NODE > ' : ' octree ROOT > ', this, ' // id: ', this.id, ' // indexOctant: ', this.indexOctant, ' // position: ', this.position.x, this.position.y, this.position.z, ' // radius: ', this.radius, ' // depth: ', this.depth);
	      console.log(this.parent ? space + ' ' : ' ', '+ objects ( ', this.objects.length, ' ) ', this.objects);
	      console.log(this.parent ? space + ' ' : ' ', '+ children ( ', this.nodesIndices.length, ' )', this.nodesIndices, this.nodesByIndex);
	
	      for (var _iterator17 = this.nodesIndices, _isArray17 = Array.isArray(_iterator17), _i17 = 0, _iterator17 = _isArray17 ? _iterator17 : _iterator17[Symbol.iterator]();;) {
	        var _ref17;
	
	        if (_isArray17) {
	          if (_i17 >= _iterator17.length) break;
	          _ref17 = _iterator17[_i17++];
	        } else {
	          _i17 = _iterator17.next();
	          if (_i17.done) break;
	          _ref17 = _i17.value;
	        }
	
	        var index = _ref17;
	
	        var node = this.nodesByIndex[index];
	        node.toConsole(space + spaceAddition);
	      }
	    }
	  }]);
	
	  return OctreeNode;
	}();
	
	/**
	 * Octree for three.
	 * @private
	 * @see {@link https://github.com/collinhover/threeoctree|threeoctree}
	 */
	
	
	var Octree = function () {
	  /**
	   * Constructor.
	   * @param  {Object}  [params]                     Octree parameters.
	   * @param  {Boolean} [params.undeferred=false]    When undeferred = true, objects are inserted immediately instead
	   *                                                of being deferred until next octree.update() call. This may
	   *                                                decrease performance as it forces a matrix update.
	   * @param  {Number}  [params.depthMax=Infinity]   The max depth of tree.
	   * @param  {Number}  [params.objectsThreshold=8]  Max number of objects before nodes split or merge
	   * @param  {Number}  [params.overlapPct=0.15]     Percent between 0 and 1 that nodes will overlap each other.
	   *                                                Helps insert objects that lie over more than one node.
	   */
	  function Octree(params) {
	    _classCallCheck(this, Octree);
	
	    var parameters = params || {};
	
	    parameters.tree = this;
	
	    // static properties( modification is not recomended).
	    this.nodeCount = 0;
	
	    this.INDEX_INSIDE_CROSS = -1;
	    this.INDEX_OUTSIDE_OFFSET = 2;
	
	    this.INDEX_OUTSIDE_POS_X = isNumber(parameters.INDEX_OUTSIDE_POS_X) ? parameters.INDEX_OUTSIDE_POS_X : 0;
	    this.INDEX_OUTSIDE_NEG_X = isNumber(parameters.INDEX_OUTSIDE_NEG_X) ? parameters.INDEX_OUTSIDE_NEG_X : 1;
	    this.INDEX_OUTSIDE_POS_Y = isNumber(parameters.INDEX_OUTSIDE_POS_Y) ? parameters.INDEX_OUTSIDE_POS_Y : 2;
	    this.INDEX_OUTSIDE_NEG_Y = isNumber(parameters.INDEX_OUTSIDE_NEG_Y) ? parameters.INDEX_OUTSIDE_NEG_Y : 3;
	    this.INDEX_OUTSIDE_POS_Z = isNumber(parameters.INDEX_OUTSIDE_POS_Z) ? parameters.INDEX_OUTSIDE_POS_Z : 4;
	    this.INDEX_OUTSIDE_NEG_Z = isNumber(parameters.INDEX_OUTSIDE_NEG_Z) ? parameters.INDEX_OUTSIDE_NEG_Z : 5;
	
	    this.INDEX_OUTSIDE_MAP = [];
	    this.INDEX_OUTSIDE_MAP[this.INDEX_OUTSIDE_POS_X] = { index: this.INDEX_OUTSIDE_POS_X, count: 0, x: 1, y: 0, z: 0 };
	    this.INDEX_OUTSIDE_MAP[this.INDEX_OUTSIDE_NEG_X] = { index: this.INDEX_OUTSIDE_NEG_X, count: 0, x: -1, y: 0, z: 0 };
	    this.INDEX_OUTSIDE_MAP[this.INDEX_OUTSIDE_POS_Y] = { index: this.INDEX_OUTSIDE_POS_Y, count: 0, x: 0, y: 1, z: 0 };
	    this.INDEX_OUTSIDE_MAP[this.INDEX_OUTSIDE_NEG_Y] = { index: this.INDEX_OUTSIDE_NEG_Y, count: 0, x: 0, y: -1, z: 0 };
	    this.INDEX_OUTSIDE_MAP[this.INDEX_OUTSIDE_POS_Z] = { index: this.INDEX_OUTSIDE_POS_Z, count: 0, x: 0, y: 0, z: 1 };
	    this.INDEX_OUTSIDE_MAP[this.INDEX_OUTSIDE_NEG_Z] = { index: this.INDEX_OUTSIDE_NEG_Z, count: 0, x: 0, y: 0, z: -1 };
	
	    this.FLAG_POS_X = 1 << this.INDEX_OUTSIDE_POS_X + 1;
	    this.FLAG_NEG_X = 1 << this.INDEX_OUTSIDE_NEG_X + 1;
	    this.FLAG_POS_Y = 1 << this.INDEX_OUTSIDE_POS_Y + 1;
	    this.FLAG_NEG_Y = 1 << this.INDEX_OUTSIDE_NEG_Y + 1;
	    this.FLAG_POS_Z = 1 << this.INDEX_OUTSIDE_POS_Z + 1;
	    this.FLAG_NEG_Z = 1 << this.INDEX_OUTSIDE_NEG_Z + 1;
	
	    this.utilVec31Search = new THREE.Vector3();
	    this.utilVec32Search = new THREE.Vector3();
	
	    // pass scene to see octree structure
	    this.scene = parameters.scene;
	    if (this.scene) {
	      this.visualGeometry = new THREE.BoxGeometry(1, 1, 1);
	      this.visualMaterial = new THREE.MeshBasicMaterial({ color: 0xFF0066, wireframe: true, wireframeLinewidth: 1 });
	    }
	
	    // properties
	    this.objects = [];
	    this.objectsMap = {};
	    this.objectsData = [];
	    this.objectsDeferred = [];
	
	    this.depthMax = isNumber(parameters.depthMax) ? parameters.depthMax : Infinity;
	    this.objectsThreshold = isNumber(parameters.objectsThreshold) ? parameters.objectsThreshold : 8;
	    this.overlapPct = isNumber(parameters.overlapPct) ? parameters.overlapPct : 0.15;
	    this.undeferred = parameters.undeferred || false;
	
	    this.root = parameters.root instanceof OctreeNode ? parameters.root : new OctreeNode(parameters);
	  }
	
	  /**
	   * When octree.add(object) is called and octree.undeferred != true, insertion for that object is deferred until
	   * the octree is updated. Update octree to insert all deferred objects after render cycle to makes sure object
	   * matrices are up to date.
	   * @return {undefined}
	   */
	
	
	  _createClass(Octree, [{
	    key: 'update',
	    value: function update() {
	      if (this.objectsDeferred.length > 0) {
	        for (var _iterator18 = this.objectsDeferred, _isArray18 = Array.isArray(_iterator18), _i18 = 0, _iterator18 = _isArray18 ? _iterator18 : _iterator18[Symbol.iterator]();;) {
	          var _ref18;
	
	          if (_isArray18) {
	            if (_i18 >= _iterator18.length) break;
	            _ref18 = _iterator18[_i18++];
	          } else {
	            _i18 = _iterator18.next();
	            if (_i18.done) break;
	            _ref18 = _i18.value;
	          }
	
	          var deferred = _ref18;
	
	          this.addDeferred(deferred.object, deferred.options);
	        }
	        this.objectsDeferred.length = 0;
	      }
	    }
	
	    /**
	     * Add three object to octree. Note that only vertices OR faces can be used, and useVertices overrides useFaces.
	     * Add generic object with x, y, z position and radius and id reference to 3D object( note this method can improve
	     * performance if you need to load the tree with tens of thousands of objects):
	     * @example
	     * var object = {x: x, y: y, z: z, radius: radius, id: id}
	     * octree.add(object);
	     * @param {object}  object                Three object.
	     * @param {Object}  [options]             Options.
	     * @param {Boolean} [options.useVertices] Whether to use vetices.
	     * @param {Boolean} [options.useFaces]    Whether to use faces.
	     * @return {undefined}
	     */
	
	  }, {
	    key: 'add',
	    value: function add(object, options) {
	      // add immediately
	      if (this.undeferred) {
	        this.updateObject(object);
	        this.addDeferred(object, options);
	      } else {
	        // defer add until update called
	        this.objectsDeferred.push({ object: object, options: options });
	      }
	    }
	
	    /**
	     * Add deferred object.
	     * @private
	     * @param {object}  object                Three object.
	     * @param {object}  [options]             Options.
	     * @param {Boolean} [options.useVertices] Whether to use vetices.
	     * @param {Boolean} [options.useFaces]    Whether to use faces.
	     * @return {undefined}
	     */
	
	  }, {
	    key: 'addDeferred',
	    value: function addDeferred(object, options) {
	      var geometry = void 0,
	          useFaces = void 0,
	          useVertices = void 0;
	
	      // ensure object is not object data
	      if (object instanceof OctreeObjectData) {
	        object = object.object; // eslint-disable-line no-param-reassign
	      }
	
	      // check uuid to avoid duplicates
	      if (!object.uuid) {
	        object.uuid = THREE.Math.generateUUID();
	      }
	
	      if (!this.objectsMap[object.uuid]) {
	        // store
	        this.objects.push(object);
	        this.objectsMap[object.uuid] = object;
	
	        // check options
	        if (options) {
	          useFaces = options.useFaces;
	          useVertices = options.useVertices;
	        }
	
	        if (useVertices === true) {
	          geometry = object.geometry;
	          var vertices = geometry.vertices;
	          for (var _iterator19 = vertices, _isArray19 = Array.isArray(_iterator19), _i19 = 0, _iterator19 = _isArray19 ? _iterator19 : _iterator19[Symbol.iterator]();;) {
	            var _ref19;
	
	            if (_isArray19) {
	              if (_i19 >= _iterator19.length) break;
	              _ref19 = _iterator19[_i19++];
	            } else {
	              _i19 = _iterator19.next();
	              if (_i19.done) break;
	              _ref19 = _i19.value;
	            }
	
	            var vertice = _ref19;
	
	            this.addObjectData(object, vertice);
	          }
	        } else if (useFaces === true) {
	          geometry = object.geometry;
	          var faces = geometry.faces;
	          for (var _iterator20 = faces, _isArray20 = Array.isArray(_iterator20), _i20 = 0, _iterator20 = _isArray20 ? _iterator20 : _iterator20[Symbol.iterator]();;) {
	            var _ref20;
	
	            if (_isArray20) {
	              if (_i20 >= _iterator20.length) break;
	              _ref20 = _iterator20[_i20++];
	            } else {
	              _i20 = _iterator20.next();
	              if (_i20.done) break;
	              _ref20 = _i20.value;
	            }
	
	            var face = _ref20;
	
	            this.addObjectData(object, face);
	          }
	        } else {
	          this.addObjectData(object);
	        }
	      }
	    }
	
	    /**
	     * Add object data to tree objects data list and nodes.
	     * @private
	     * @param {Object}   object Three object.
	     * @param {Object[]} [part] Vertices or faces.
	     * @return {undefined}
	     */
	
	  }, {
	    key: 'addObjectData',
	    value: function addObjectData(object, part) {
	      var objectData = new OctreeObjectData(object, part);
	
	      // add to tree objects data list
	      this.objectsData.push(objectData);
	
	      // add to nodes
	      this.root.addObject(objectData);
	    }
	
	    /**
	     * Remove all octree objects associated with three object.
	     * @param  {Object} object Three object.
	     * @return {undefined}
	     */
	
	  }, {
	    key: 'remove',
	    value: function remove(object) {
	      var index = void 0,
	          objectsDataRemoved = void 0;
	
	      // ensure object is not object data for index search
	      if (object instanceof OctreeObjectData) {
	        object = object.object; // eslint-disable-line no-param-reassign
	      }
	
	      // check uuid
	      if (this.objectsMap[object.uuid]) {
	        // this.objectsMap[object.uuid] = undefined;
	        delete this.objectsMap[object.uuid];
	        index = indexOfValue(this.objects, object);
	        if (index !== -1) {
	          this.objects.splice(index, 1);
	
	          // remove from nodes
	          objectsDataRemoved = this.root.removeObject(object);
	
	          // remove from objects data list
	          for (var _iterator21 = objectsDataRemoved, _isArray21 = Array.isArray(_iterator21), _i21 = 0, _iterator21 = _isArray21 ? _iterator21 : _iterator21[Symbol.iterator]();;) {
	            var _ref21;
	
	            if (_isArray21) {
	              if (_i21 >= _iterator21.length) break;
	              _ref21 = _iterator21[_i21++];
	            } else {
	              _i21 = _iterator21.next();
	              if (_i21.done) break;
	              _ref21 = _i21.value;
	            }
	
	            var objectData = _ref21;
	
	            index = indexOfValue(this.objectsData, objectData);
	            if (index !== -1) {
	              this.objectsData.splice(index, 1);
	            }
	          }
	        }
	      } else if (this.objectsDeferred.length > 0) {
	        // check and remove from deferred
	        index = indexOfPropertyWithValue(this.objectsDeferred, 'object', object);
	        if (index !== -1) {
	          this.objectsDeferred.splice(index, 1);
	        }
	      }
	    }
	
	    /**
	     * Extend octree with another octree.
	     * @param  {Octree} octree Octree.
	     * @return {undefined}
	     */
	
	  }, {
	    key: 'extend',
	    value: function extend(octree) {
	      if (octree instanceof Octree) {
	        // for each object data
	        var objectsData = octree.objectsData;
	
	        for (var _iterator22 = objectsData, _isArray22 = Array.isArray(_iterator22), _i22 = 0, _iterator22 = _isArray22 ? _iterator22 : _iterator22[Symbol.iterator]();;) {
	          var _ref22;
	
	          if (_isArray22) {
	            if (_i22 >= _iterator22.length) break;
	            _ref22 = _iterator22[_i22++];
	          } else {
	            _i22 = _iterator22.next();
	            if (_i22.done) break;
	            _ref22 = _i22.value;
	          }
	
	          var objectData = _ref22;
	
	          this.add(objectData, { useFaces: objectData.faces, useVertices: objectData.vertices });
	        }
	      }
	    }
	
	    /**
	     * Rebuild octree(To account for moving objects within the octree).
	     * @return {undefined}
	     */
	
	  }, {
	    key: 'rebuild',
	    value: function rebuild() {
	      var objectsUpdate = [];
	
	      // check all object data for changes in position.
	      // assume all object matrices are up to date
	      for (var _iterator23 = this.objectsData, _isArray23 = Array.isArray(_iterator23), _i23 = 0, _iterator23 = _isArray23 ? _iterator23 : _iterator23[Symbol.iterator]();;) {
	        var _ref23;
	
	        if (_isArray23) {
	          if (_i23 >= _iterator23.length) break;
	          _ref23 = _iterator23[_i23++];
	        } else {
	          _i23 = _iterator23.next();
	          if (_i23.done) break;
	          _ref23 = _i23.value;
	        }
	
	        var objectData = _ref23;
	
	        var node = objectData.node;
	
	        // update object
	        objectData.update();
	
	        // if position has changed since last organization of object in tree
	        if (node instanceof OctreeNode && !objectData.positionLast.equals(objectData.position)) {
	          // get octant index of object within current node
	          var indexOctantLast = objectData.indexOctant;
	          var indexOctant = node.getOctantIndex(objectData);
	
	          // if object octant index has changed
	          if (indexOctant !== indexOctantLast) {
	            // add to update list
	            objectsUpdate.push(objectData);
	          }
	        }
	      }
	
	      // update changed objects
	      for (var _iterator24 = objectsUpdate, _isArray24 = Array.isArray(_iterator24), _i24 = 0, _iterator24 = _isArray24 ? _iterator24 : _iterator24[Symbol.iterator]();;) {
	        var _ref24;
	
	        if (_isArray24) {
	          if (_i24 >= _iterator24.length) break;
	          _ref24 = _iterator24[_i24++];
	        } else {
	          _i24 = _iterator24.next();
	          if (_i24.done) break;
	          _ref24 = _i24.value;
	        }
	
	        var _objectData = _ref24;
	
	        // remove object from current node
	        _objectData.node.removeObject(_objectData);
	
	        // add object to tree root
	        this.root.addObject(_objectData);
	      }
	    }
	
	    /**
	     * Update world matrix of the uppermost parent of passed object. Note that the passed object must be an instance
	     * of THREE.Obejct3D.
	     * @param  {THREE.Object3D} object Object needed update.
	     * @return {undefined}
	     */
	
	  }, {
	    key: 'updateObject',
	    value: function updateObject(object) {
	      var parentCascade = [object];
	      var parent = object.parent;
	      var parentUpdate = void 0;
	
	      // search all parents between object and root for world matrix update
	      while (parent) {
	        parentCascade.push(parent);
	        parent = parent.parent;
	      }
	
	      for (var _iterator25 = parentCascade, _isArray25 = Array.isArray(_iterator25), _i25 = 0, _iterator25 = _isArray25 ? _iterator25 : _iterator25[Symbol.iterator]();;) {
	        var _ref25;
	
	        if (_isArray25) {
	          if (_i25 >= _iterator25.length) break;
	          _ref25 = _iterator25[_i25++];
	        } else {
	          _i25 = _iterator25.next();
	          if (_i25.done) break;
	          _ref25 = _i25.value;
	        }
	
	        var _parent = _ref25;
	
	        if (_parent.matrixWorldNeedsUpdate === true) {
	          parentUpdate = _parent;
	        }
	      }
	
	      // update world matrix starting at uppermost parent that needs update
	      if (typeof parentUpdate !== 'undefined') {
	        parentUpdate.updateMatrixWorld();
	      }
	    }
	
	    /**
	     * Set root of octree.
	     * @param {OctreeNode} root Root.
	     * @return {undefined}
	     */
	
	  }, {
	    key: 'setRoot',
	    value: function setRoot(root) {
	      if (root instanceof OctreeNode) {
	        // store new root
	        this.root = root;
	
	        // update properties
	        this.root.updateProperties();
	      }
	    }
	
	    /**
	     * Search octree at a position for radius distance
	     * @param  {THREE.Vector3} position           Position.
	     * @param  {Number}        radius             Radius.
	     * @param  {Boolean}       [organizeByObject] Whether to organize the result objects( i.e. all faces/vertices belonging
	     *                                            to three object in one list vs a result for each face/vertex).
	     * @param  {THREE.Vector3} [direction]        Direction.
	     * @return {Object[]}                  [description]
	     */
	
	  }, {
	    key: 'search',
	    value: function search(position, radius, organizeByObject, direction) {
	      var objects = void 0,
	          results = void 0,
	          directionPct = void 0;
	
	      // add root objects
	      objects = [].concat(this.root.objects);
	
	      // ensure radius( i.e. distance of ray) is a number
	      if (!(radius > 0)) {
	        radius = Number.MAX_VALUE; // eslint-disable-line no-param-reassign
	      }
	
	      // if direction passed, normalize and find pct
	      if (direction instanceof THREE.Vector3) {
	        direction = this.utilVec31Search.copy(direction).normalize(); // eslint-disable-line no-param-reassign
	        directionPct = this.utilVec32Search.set(1, 1, 1).divide(direction);
	      }
	
	      // search each node of root
	      for (var _iterator26 = this.root.nodesIndices, _isArray26 = Array.isArray(_iterator26), _i26 = 0, _iterator26 = _isArray26 ? _iterator26 : _iterator26[Symbol.iterator]();;) {
	        var _ref26;
	
	        if (_isArray26) {
	          if (_i26 >= _iterator26.length) break;
	          _ref26 = _iterator26[_i26++];
	        } else {
	          _i26 = _iterator26.next();
	          if (_i26.done) break;
	          _ref26 = _i26.value;
	        }
	
	        var index = _ref26;
	
	        var node = this.root.nodesByIndex[index];
	
	        objects = node.search(position, radius, objects, direction, directionPct);
	      }
	
	      // if should organize results by object
	      if (organizeByObject === true) {
	        var resultsObjectsIndices = [];
	
	        results = [];
	
	        // for each object data found
	        for (var _iterator27 = objects, _isArray27 = Array.isArray(_iterator27), _i27 = 0, _iterator27 = _isArray27 ? _iterator27 : _iterator27[Symbol.iterator]();;) {
	          var _ref27;
	
	          if (_isArray27) {
	            if (_i27 >= _iterator27.length) break;
	            _ref27 = _iterator27[_i27++];
	          } else {
	            _i27 = _iterator27.next();
	            if (_i27.done) break;
	            _ref27 = _i27.value;
	          }
	
	          var objectData = _ref27;
	
	          var object = objectData.object;
	          var resultObjectIndex = indexOfValue(resultsObjectsIndices, object);
	          var resultData = void 0;
	
	          // if needed, create new result data
	          if (resultObjectIndex === -1) {
	            resultData = {
	              object: object,
	              faces: [],
	              vertices: []
	            };
	            results.push(resultData);
	            resultsObjectsIndices.push(object);
	          } else {
	            resultData = results[resultObjectIndex];
	          }
	
	          // object data has faces or vertices, add to list
	          if (objectData.faces) {
	            resultData.faces.push(objectData.faces);
	          } else if (objectData.vertices) {
	            resultData.vertices.push(objectData.vertices);
	          }
	        }
	      } else {
	        results = objects;
	      }
	
	      return results;
	    }
	  }, {
	    key: 'getDepthEnd',
	    value: function getDepthEnd() {
	      return this.root.getDepthEnd();
	    }
	  }, {
	    key: 'getNodeCountEnd',
	    value: function getNodeCountEnd() {
	      return this.root.getNodeCountEnd();
	    }
	  }, {
	    key: 'getObjectCountEnd',
	    value: function getObjectCountEnd() {
	      return this.root.getObjectCountEnd();
	    }
	  }, {
	    key: 'toConsole',
	    value: function toConsole() {
	      this.root.toConsole();
	    }
	  }]);
	
	  return Octree;
	}();
	
	// assign alias
	
	
	OctreeAlias = Octree;
	
	/**
	 * Raycaster utilities.
	 * @private
	 */
	
	var RaycasterUtils = function () {
	  function RaycasterUtils() {
	    _classCallCheck(this, RaycasterUtils);
	  }
	
	  _createClass(RaycasterUtils, null, [{
	    key: 'intersectOctreeObject',
	
	    /**
	     * Checks all intersection between the ray and the object with or without the descendants. Intersections are returned
	     * sorted by distance, closest first.
	     * @param  {THREE.Raycaster}                 raycaster         Raycaster.
	     * @param  {OctreeObjectData|THREE.Object3D} object            The object to check for intersection with the ray.
	     * @param  {Boolean}                         [recursive=false] If true, it also checks all descendants. Otherwise
	     *                                                             it only checks intersecton with the object. Default
	     *                                                             is false.
	     * @return {THREE.Object3D[]}                                  Intersections.
	     */
	    value: function intersectOctreeObject(raycaster, object, recursive) {
	      var intersects = void 0;
	
	      if (object.object instanceof THREE.Object3D) {
	        var octreeObject = object;
	        var tempObject = object.object;
	        var facesSearch = octreeObject.faces;
	        var facesAll = tempObject.geometry.faces;
	
	        // temporarily replace object geometry's faces with octree object faces
	        if (facesSearch.length > 0) {
	          tempObject.geometry.faces = facesSearch;
	        }
	
	        // intersect
	        intersects = raycaster.intersectObject(tempObject, recursive);
	
	        // revert object geometry's faces
	        if (facesSearch.length > 0) {
	          tempObject.geometry.faces = facesAll;
	        }
	      } else {
	        intersects = raycaster.intersectObject(object, recursive);
	      }
	
	      return intersects;
	    }
	
	    /**
	     * Checks all intersection between the ray and the objects with or without the descendants. Intersections are returned
	     * sorted by distance, closest first.
	     * @param  {THREE.Raycaster}                     raycaster         Raycaster.
	     * @param  {OctreeObjectData[]|THREE.Object3D[]} objects           The object to check for intersection with the ray.
	     * @param  {Boolean}                             [recursive=false] If true, it also checks all descendants. Otherwise
	     *                                                                 it only checks intersecton with the object. Default
	     *                                                                 is false.
	     * @return {THREE.Object3D[]}                                      Intersections.
	     */
	
	  }, {
	    key: 'intersectOctreeObjects',
	    value: function intersectOctreeObjects(raycaster, objects, recursive) {
	      var intersects = [];
	      var compareObjects = function compareObjects(a, b) {
	        if (a.distance < b.distance) {
	          return -1;
	        } else if (a.distance > b.distance) {
	          return 1;
	        }
	
	        return 0;
	      };
	
	      for (var _iterator28 = objects, _isArray28 = Array.isArray(_iterator28), _i28 = 0, _iterator28 = _isArray28 ? _iterator28 : _iterator28[Symbol.iterator]();;) {
	        var _ref28;
	
	        if (_isArray28) {
	          if (_i28 >= _iterator28.length) break;
	          _ref28 = _iterator28[_i28++];
	        } else {
	          _i28 = _iterator28.next();
	          if (_i28.done) break;
	          _ref28 = _i28.value;
	        }
	
	        var object = _ref28;
	
	        intersects = intersects.concat(RaycasterUtils.intersectOctreeObject(raycaster, object, recursive));
	      }
	
	      return intersects.sort(compareObjects);
	    }
	  }]);
	
	  return RaycasterUtils;
	}();
	
	/* eslint-enable no-bitwise */
	
	exports.Octree = Octree;
	exports.RaycasterUtils = RaycasterUtils;

/***/ }),
/* 129 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _three = __webpack_require__(2);
	
	var THREE = _interopRequireWildcard(_three);
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	/* eslint-disable */
	function getBevelVec(inPt, inPrev, inNext) {
	
	  // computes for inPt the corresponding point inPt' on a new contour
	  //   shifted by 1 unit (length of normalized vector) to the left
	  // if we walk along contour clockwise, this new contour is outside the old one
	  //
	  // inPt' is the intersection of the two lines parallel to the two
	  //  adjacent edges of inPt at a distance of 1 unit on the left side.
	
	  var v_trans_x,
	      v_trans_y,
	      shrink_by = 1; // resulting translation vector for inPt
	
	  // good reading for geometry algorithms (here: line-line intersection)
	  // http://geomalgorithms.com/a05-_intersect-1.html
	
	  var v_prev_x = inPt.x - inPrev.x,
	      v_prev_y = inPt.y - inPrev.y;
	  var v_next_x = inNext.x - inPt.x,
	      v_next_y = inNext.y - inPt.y;
	
	  var v_prev_lensq = v_prev_x * v_prev_x + v_prev_y * v_prev_y;
	
	  // check for collinear edges
	  var collinear0 = v_prev_x * v_next_y - v_prev_y * v_next_x;
	
	  if (Math.abs(collinear0) > Number.EPSILON) {
	
	    // not collinear
	
	    // length of vectors for normalizing
	
	    var v_prev_len = Math.sqrt(v_prev_lensq);
	    var v_next_len = Math.sqrt(v_next_x * v_next_x + v_next_y * v_next_y);
	
	    // shift adjacent points by unit vectors to the left
	
	    var ptPrevShift_x = inPrev.x - v_prev_y / v_prev_len;
	    var ptPrevShift_y = inPrev.y + v_prev_x / v_prev_len;
	
	    var ptNextShift_x = inNext.x - v_next_y / v_next_len;
	    var ptNextShift_y = inNext.y + v_next_x / v_next_len;
	
	    // scaling factor for v_prev to intersection point
	
	    var sf = ((ptNextShift_x - ptPrevShift_x) * v_next_y - (ptNextShift_y - ptPrevShift_y) * v_next_x) / (v_prev_x * v_next_y - v_prev_y * v_next_x);
	
	    // vector from inPt to intersection point
	
	    v_trans_x = ptPrevShift_x + v_prev_x * sf - inPt.x;
	    v_trans_y = ptPrevShift_y + v_prev_y * sf - inPt.y;
	
	    // Don't normalize!, otherwise sharp corners become ugly
	    //  but prevent crazy spikes
	    var v_trans_lensq = v_trans_x * v_trans_x + v_trans_y * v_trans_y;
	    if (v_trans_lensq <= 2) {
	
	      return new THREE.Vector2(v_trans_x, v_trans_y);
	    } else {
	
	      shrink_by = Math.sqrt(v_trans_lensq / 2);
	    }
	  } else {
	
	    // handle special case of collinear edges
	
	    var direction_eq = false; // assumes: opposite
	    if (v_prev_x > Number.EPSILON) {
	
	      if (v_next_x > Number.EPSILON) {
	
	        direction_eq = true;
	      }
	    } else {
	
	      if (v_prev_x < -Number.EPSILON) {
	
	        if (v_next_x < -Number.EPSILON) {
	
	          direction_eq = true;
	        }
	      } else {
	
	        if (Math.sign(v_prev_y) === Math.sign(v_next_y)) {
	
	          direction_eq = true;
	        }
	      }
	    }
	
	    if (direction_eq) {
	
	      // console.log("Warning: lines are a straight sequence");
	      v_trans_x = -v_prev_y;
	      v_trans_y = v_prev_x;
	      shrink_by = Math.sqrt(v_prev_lensq);
	    } else {
	
	      // console.log("Warning: lines are a straight spike");
	      v_trans_x = v_prev_x;
	      v_trans_y = v_prev_y;
	      shrink_by = Math.sqrt(v_prev_lensq / 2);
	    }
	  }
	
	  return new THREE.Vector2(v_trans_x / shrink_by, v_trans_y / shrink_by);
	}
	/* eslint-enable */
	
	var ShapeUtils = function () {
	  function ShapeUtils() {
	    _classCallCheck(this, ShapeUtils);
	  }
	
	  _createClass(ShapeUtils, null, [{
	    key: 'createExpandedPointsGeometry',
	    value: function createExpandedPointsGeometry(shape) {
	      var bevelSize = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
	      var t = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
	      var curveSegments = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 12;
	
	      var contour = shape.extractPoints(curveSegments).shape;
	      var reverse = !THREE.ShapeUtils.isClockWise(contour);
	      var len = contour.length;
	      var geometry = new THREE.Geometry();
	
	      if (reverse) {
	        contour = contour.reverse();
	        // Maybe we should also check if holes are in the opposite direction, just to be safe ...
	        reverse = false; // If vertices are in order now, we shouldn't need to worry about them again (hopefully)!
	      }
	
	      if (shape.autoClose || contour[0].equals(contour[len - 1])) {
	        contour.pop();
	        len--;
	      }
	
	      for (var i = 0; i < len; i++) {
	        var j = (i - 1 + len) % len;
	        var k = (i + 1) % len;
	        var vec = getBevelVec(contour[i], contour[j], contour[k]);
	        var bs = bevelSize * Math.sin(t * Math.PI / 2); // curved
	        var point = vec.clone().multiplyScalar(bs).add(contour[i]);
	
	        geometry.vertices.push(new THREE.Vector3(point.x, point.y, 0));
	      }
	
	      // close
	      geometry.vertices.push(geometry.vertices[0].clone());
	
	      return geometry;
	    }
	  }]);
	
	  return ShapeUtils;
	}();
	/* eslint-enable */
	
	exports.default = ShapeUtils;

/***/ }),
/* 130 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _three = __webpack_require__(2);
	
	var THREE = _interopRequireWildcard(_three);
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	// import { AnimatorFactory } from '../../src/animation';
	
	var SpriteIcon = function (_THREE$Sprite) {
	  _inherits(SpriteIcon, _THREE$Sprite);
	
	  function SpriteIcon() {
	    _classCallCheck(this, SpriteIcon);
	
	    return _possibleConstructorReturn(this, (SpriteIcon.__proto__ || Object.getPrototypeOf(SpriteIcon)).apply(this, arguments));
	  }
	
	  _createClass(SpriteIcon, [{
	    key: 'getAABB',
	
	    // constructor(material) {
	    //   super(material);
	
	    // const factory = AnimatorFactory.getInstance();
	
	    // this._onUpdate = (animator, target) => {
	    //   this.material.opacity = target.opacity;
	    // };
	    // this._fadeOutObj = { opacity: 1 };
	    // this._fadeOutAnimator = factory
	    //   .ofObject(this._fadeOutObj, { opacity: 0 }, 300)
	    //   .on('update', this._onUpdate)
	    //   .on('start', () => {
	    //     this.visible = true;
	    //   })
	    //   .on('complete', () => {
	    //     this._fadeOutObj.opacity = 1;
	    //     this.visible = false;
	    //   });
	    // this._fadeInObj = { opacity: 0 };
	    // this._fadeInAnimator = factory
	    //   .ofObject(this._fadeInObj, { opacity: 1 }, 300)
	    //   .on('update', this._onUpdate)
	    //   .on('start', () => {
	    //     this.visible = true;
	    //   })
	    //   .on('complete', () => {
	    //     this._fadeInObj.opacity = 0;
	    //   });
	    // }
	
	    value: function getAABB(camera) {
	      var position = new THREE.Vector3(0, 0, 0);
	      var margin = this.margin || 0;
	      var scale = this.scale;
	      var centerX = scale.x / 2;
	      var centerY = scale.y / 2;
	      var aabb = [];
	      var matrix = this.matrixWorld;
	      var anchor = this.material.anchor;
	      var tempX = 0;
	      var tempY = 0;
	
	      position.setFromMatrixPosition(matrix);
	      position = camera.toScreenCoordinate(position.x, position.y, position.z);
	      if (anchor) {
	        tempX = centerX - scale.x * anchor[0];
	        tempY = centerY - scale.y * anchor[1];
	        position.setX(position.x + tempX);
	        position.setY(position.y + tempY);
	      }
	      aabb.push(position.x - centerX - margin);
	      aabb.push(position.y - centerY - margin);
	      aabb.push(0);
	      aabb.push(position.x + centerX + margin);
	      aabb.push(position.y + centerY + margin);
	      aabb.push(0);
	
	      return aabb;
	    }
	  }, {
	    key: 'makeCollision',
	    value: function makeCollision(collision) {
	      this.visible = !collision;
	      this.material.opacity = this.destOpacity ? this.destOpacity : 1;
	
	      return this;
	    }
	  }]);
	
	  return SpriteIcon;
	}(THREE.Sprite);
	
	exports.default = SpriteIcon;

/***/ }),
/* 131 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(module) {"use strict";
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	/* eslint-disable */
	// stats.js - http://github.com/mrdoob/stats.js
	var Stats = function Stats() {
	  function h(a) {
	    c.appendChild(a.dom);return a;
	  }function k(a) {
	    for (var d = 0; d < c.children.length; d++) {
	      c.children[d].style.display = d === a ? "block" : "none";
	    }l = a;
	  }var l = 0,
	      c = document.createElement("div");c.style.cssText = "position:fixed;top:0;left:0;cursor:pointer;opacity:0.9;z-index:10000";c.addEventListener("click", function (a) {
	    a.preventDefault();k(++l % c.children.length);
	  }, !1);var g = (performance || Date).now(),
	      e = g,
	      a = 0,
	      r = h(new Stats.Panel("FPS", "#0ff", "#002")),
	      f = h(new Stats.Panel("MS", "#0f0", "#020"));
	  if (self.performance && self.performance.memory) var t = h(new Stats.Panel("MB", "#f08", "#201"));k(0);return { REVISION: 16, dom: c, addPanel: h, showPanel: k, begin: function begin() {
	      g = (performance || Date).now();
	    }, end: function end() {
	      a++;var c = (performance || Date).now();f.update(c - g, 200);if (c > e + 1E3 && (r.update(1E3 * a / (c - e), 100), e = c, a = 0, t)) {
	        var d = performance.memory;t.update(d.usedJSHeapSize / 1048576, d.jsHeapSizeLimit / 1048576);
	      }return c;
	    }, update: function update() {
	      g = this.end();
	    }, domElement: c, setMode: k };
	};
	Stats.Panel = function (h, k, l) {
	  var c = Infinity,
	      g = 0,
	      e = Math.round,
	      a = e(window.devicePixelRatio || 1),
	      r = 80 * a,
	      f = 48 * a,
	      t = 3 * a,
	      u = 2 * a,
	      d = 3 * a,
	      m = 15 * a,
	      n = 74 * a,
	      p = 30 * a,
	      q = document.createElement("canvas");q.width = r;q.height = f;q.style.cssText = "width:80px;height:48px";var b = q.getContext("2d");b.font = "bold " + 9 * a + "px Helvetica,Arial,sans-serif";b.textBaseline = "top";b.fillStyle = l;b.fillRect(0, 0, r, f);b.fillStyle = k;b.fillText(h, t, u);b.fillRect(d, m, n, p);b.fillStyle = l;b.globalAlpha = .9;b.fillRect(d, m, n, p);return { dom: q, update: function update(f, v) {
	      c = Math.min(c, f);g = Math.max(g, f);b.fillStyle = l;b.globalAlpha = 1;b.fillRect(0, 0, r, m);b.fillStyle = k;b.fillText(e(f) + " " + h + " (" + e(c) + "-" + e(g) + ")", t, u);b.drawImage(q, d + a, m, n - a, p, d, m, n - a, p);b.fillRect(d + n - a, m, a, p);b.fillStyle = l;b.globalAlpha = .9;b.fillRect(d + n - a, m, a, e((1 - f / v) * p));
	    } };
	};"object" === ( false ? "undefined" : _typeof(module)) && (module.exports = Stats);
	/* eslint-enable */
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(30)(module)))

/***/ }),
/* 132 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _assign = __webpack_require__(1);
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _Layer = __webpack_require__(37);
	
	var _Layer2 = _interopRequireDefault(_Layer);
	
	var _MapView = __webpack_require__(26);
	
	var _MapView2 = _interopRequireDefault(_MapView);
	
	var _AnimatorFactory = __webpack_require__(9);
	
	var _AnimatorFactory2 = _interopRequireDefault(_AnimatorFactory);
	
	var _three = __webpack_require__(2);
	
	var THREE = _interopRequireWildcard(_three);
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	/**
	 * Initial options of animation.
	 * @ignore
	 * @type {Object}
	 */
	var initOptions = {
	  duration: 500
	};
	
	/**
	 * A class for handling animation with tube offset.
	 * @memberOf NGR.helper.tubeHelper
	 */
	
	var TubeOffsetAnimation = function () {
	  /**
	   * Constructor.
	   * @param  {MapView} mapView                MapView.
	   * @param  {Layer}   layer                  Layer.
	   * @param  {Object}  [options]              Options.
	   * @param  {Number}  [options.duration=500] Duration of animation.
	   */
	  function TubeOffsetAnimation(mapView, layer, options) {
	    _classCallCheck(this, TubeOffsetAnimation);
	
	    if (!(mapView instanceof _MapView2.default) || !(layer instanceof _Layer2.default)) {
	      throw new Error('PlaneLineOffsetAnimation: Invalid parameter');
	    }
	    this._options = _assign({}, initOptions, options);
	
	    var node = mapView.sceneManager.get(-1);
	    var parent = node._findMesh(layer);
	
	    if (parent && parent.children[0] && parent.children[0].geometry instanceof THREE.TubeGeometry) {
	      this._tube = parent.children[0];
	    } else {
	      throw new Error('PlaneLineOffsetAnimation: Can not find tube');
	    }
	
	    this._onUpdate = this._onUpdate.bind(this);
	
	    this._animator = _AnimatorFactory2.default.getInstance().ofNumber(1, 0, this._options.duration).repeat(Infinity).on('update', this._onUpdate);
	  }
	
	  _createClass(TubeOffsetAnimation, [{
	    key: '_onUpdate',
	    value: function _onUpdate(animator, target) {
	      if (!this._tube.material.map) {
	        return;
	      }
	
	      this._tube.material.map.offset.setX(target.num);
	    }
	
	    /**
	     * Start animation.
	     * @return {undefined}
	     */
	
	  }, {
	    key: 'start',
	    value: function start() {
	      this._animator.start();
	    }
	
	    /**
	     * Stop animation.
	     * @return {undefined}
	     */
	
	  }, {
	    key: 'stop',
	    value: function stop() {
	      this._animator.stop();
	      this._animator = null;
	      this._tube = null;
	    }
	  }]);
	
	  return TubeOffsetAnimation;
	}();
	
	exports.default = TubeOffsetAnimation;

/***/ }),
/* 133 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _NGRObject2 = __webpack_require__(7);
	
	var _NGRObject3 = _interopRequireDefault(_NGRObject2);
	
	var _three = __webpack_require__(2);
	
	var THREE = _interopRequireWildcard(_three);
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	/**
	 * A class for handling tube x scale.
	 * @ignore
	 * @extends {NGRObject}
	 */
	var TubeScaleHandler = function (_NGRObject) {
	  _inherits(TubeScaleHandler, _NGRObject);
	
	  /**
	   * Constructor.
	   * @param  {THREE.Group} parent Parent of tube mesh.
	   */
	  function TubeScaleHandler(parent) {
	    _classCallCheck(this, TubeScaleHandler);
	
	    if (!(parent instanceof THREE.Group)) {
	      throw new Error('Invalid three group');
	    }
	
	    var _this = _possibleConstructorReturn(this, (TubeScaleHandler.__proto__ || Object.getPrototypeOf(TubeScaleHandler)).call(this));
	
	    _this._root = parent;
	    _this._originRadius = _this._root.children[0].geometry.parameters.radius;
	
	    /**
	     * Scale the radius of tube.
	     * @param  {Number} ratio Scale ratio.
	     * @return {TubeScaleHandler}       This.
	     */
	    _this.scaleX = _this.scaleX.bind(_this);
	    return _this;
	  }
	
	  _createClass(TubeScaleHandler, [{
	    key: 'scaleX',
	    value: function scaleX(ratio) {
	      if (isNaN(ratio) || !isFinite(ratio) || ratio <= 0) {
	        console.warn('TubeScaleHandler: Invalid scale');
	        return this;
	      }
	
	      var lastMesh = this._root.children[0];
	      var params = lastMesh.geometry.parameters;
	      var geometry = new THREE.TubeGeometry(params.path, params.segments, this._originRadius * ratio, params.radialSegments, params.closed);
	      var material = lastMesh.material.clone();
	      var newMesh = new THREE.Mesh(geometry, material);
	
	      newMesh._sceneId = lastMesh._sceneId;
	      this._root.remove(lastMesh);
	      lastMesh.geometry.dispose();
	      lastMesh.material.map.dispose();
	      lastMesh.material.dispose();
	      this._root.add(newMesh);
	
	      return this;
	    }
	  }, {
	    key: 'dispose',
	    value: function dispose() {
	      var lastMesh = this._root.children[0];
	      var geometry = lastMesh.geometry;
	
	      this._root.remove(lastMesh);
	      geometry.dispose();
	      lastMesh.material.map.dispose();
	      lastMesh.material.map.dispose();
	      this._root = null;
	    }
	  }]);
	
	  return TubeScaleHandler;
	}(_NGRObject3.default);
	
	exports.default = TubeScaleHandler;

/***/ }),
/* 134 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.TubeOffsetAnimation = exports.TubeScaleHandler = undefined;
	
	var _TubeScaleHandler = __webpack_require__(133);
	
	var _TubeScaleHandler2 = _interopRequireDefault(_TubeScaleHandler);
	
	var _TubeOffsetAnimation = __webpack_require__(132);
	
	var _TubeOffsetAnimation2 = _interopRequireDefault(_TubeOffsetAnimation);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.TubeScaleHandler = _TubeScaleHandler2.default;
	exports.TubeOffsetAnimation = _TubeOffsetAnimation2.default;

/***/ }),
/* 135 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	/* eslint-disable */
	var number = __webpack_require__(107);
	var assign = __webpack_require__(1);
	
	module.exports = function (THREE) {
	  return function (opt) {
	    opt = opt || {};
	
	    var ret = assign({
	      transparent: true,
	      uniforms: {
	        thickness: { value: number(opt.thickness, 0.1) },
	        opacity: { value: number(opt.opacity, 1.0) },
	        diffuse: { value: new THREE.Color(opt.diffuse) },
	        dashSteps: { value: 12 },
	        dashDistance: { value: 0.2 },
	        dashSmooth: { value: 0.01 }
	      },
	      vertexShader: ['uniform float thickness;', 'attribute float lineMiter;', 'attribute vec2 lineNormal;', 'attribute float lineDistance;', 'varying float lineU;', 'void main() {', 'lineU = lineDistance;', 'vec3 pointPos = position.xyz + vec3(lineNormal * thickness/2.0 * lineMiter, 0.0);', 'gl_Position = projectionMatrix * modelViewMatrix * vec4( pointPos, 1.0 );', '}'].join('\n'),
	      fragmentShader: ['varying float lineU;', 'uniform float opacity;', 'uniform vec3 diffuse;', 'uniform float dashSteps;', 'uniform float dashSmooth;', 'uniform float dashDistance;', 'void main() {', 'float lineUMod = mod(lineU, 1.0/dashSteps) * dashSteps;', 'float dash = smoothstep(dashDistance, dashDistance+dashSmooth, length(lineUMod-0.5));', 'gl_FragColor = vec4(diffuse * vec3(dash), opacity * dash);', '}'].join('\n')
	    }, opt);
	
	    // remove to satisfy r73
	    delete ret.thickness;
	    delete ret.opacity;
	    delete ret.diffuse;
	
	    var threeVers = (parseInt(THREE.REVISION, 10) || 0) | 0;
	    if (threeVers < 72) {
	      // Old versions need to specify shader attributes
	      ret.attributes = {
	        lineMiter: { type: 'f', value: 0 },
	        lineDistance: { type: 'f', value: 0 },
	        lineNormal: { type: 'v2', value: new THREE.Vector2() }
	      };
	    }
	
	    return ret;
	  };
	};
	/* eslint-enable */

/***/ }),
/* 136 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;'use strict';
	
	/* eslint-disable */
	(function (window, document, exportName, undefined) {
	    "use strict";
	
	    var isMultiTouch = false;
	    var multiTouchStartPos;
	    var eventTarget;
	    var touchElements = {};
	
	    // polyfills
	    if (!document.createTouch) {
	        document.createTouch = function (view, target, identifier, pageX, pageY, screenX, screenY, clientX, clientY) {
	            // auto set
	            if (clientX == undefined || clientY == undefined) {
	                clientX = pageX - window.pageXOffset;
	                clientY = pageY - window.pageYOffset;
	            }
	
	            return new Touch(target, identifier, {
	                pageX: pageX,
	                pageY: pageY,
	                screenX: screenX,
	                screenY: screenY,
	                clientX: clientX,
	                clientY: clientY
	            });
	        };
	    }
	
	    if (!document.createTouchList) {
	        document.createTouchList = function () {
	            var touchList = new TouchList();
	            for (var i = 0; i < arguments.length; i++) {
	                touchList[i] = arguments[i];
	            }
	            touchList.length = arguments.length;
	            return touchList;
	        };
	    }
	
	    /**
	     * create an touch point
	     * @constructor
	     * @param target
	     * @param identifier
	     * @param pos
	     * @param deltaX
	     * @param deltaY
	     * @returns {Object} touchPoint
	     */
	    function Touch(target, identifier, pos, deltaX, deltaY) {
	        deltaX = deltaX || 0;
	        deltaY = deltaY || 0;
	
	        this.identifier = identifier;
	        this.target = target;
	        this.clientX = pos.clientX + deltaX;
	        this.clientY = pos.clientY + deltaY;
	        this.screenX = pos.screenX + deltaX;
	        this.screenY = pos.screenY + deltaY;
	        this.pageX = pos.pageX + deltaX;
	        this.pageY = pos.pageY + deltaY;
	    }
	
	    /**
	     * create empty touchlist with the methods
	     * @constructor
	     * @returns touchList
	     */
	    function TouchList() {
	        var touchList = [];
	
	        touchList.item = function (index) {
	            return this[index] || null;
	        };
	
	        // specified by Mozilla
	        touchList.identifiedTouch = function (id) {
	            return this[id + 1] || null;
	        };
	
	        return touchList;
	    }
	
	    /**
	     * Simple trick to fake touch event support
	     * this is enough for most libraries like Modernizr and Hammer
	     */
	    function fakeTouchSupport() {
	        var objs = [window, document.documentElement];
	        var props = ['ontouchstart', 'ontouchmove', 'ontouchcancel', 'ontouchend'];
	
	        for (var o = 0; o < objs.length; o++) {
	            for (var p = 0; p < props.length; p++) {
	                if (objs[o] && objs[o][props[p]] == undefined) {
	                    objs[o][props[p]] = null;
	                }
	            }
	        }
	    }
	
	    /**
	     * we don't have to emulate on a touch device
	     * @returns {boolean}
	     */
	    function hasTouchSupport() {
	        return "ontouchstart" in window || // touch events
	        window.Modernizr && window.Modernizr.touch || // modernizr
	        (navigator.msMaxTouchPoints || navigator.maxTouchPoints) > 2; // pointer events
	    }
	
	    /**
	     * disable mouseevents on the page
	     * @param ev
	     */
	    function preventMouseEvents(ev) {
	        ev.preventDefault();
	        ev.stopPropagation();
	    }
	
	    /**
	     * only trigger touches when the left mousebutton has been pressed
	     * @param touchType
	     * @returns {Function}
	     */
	    function onMouse(touchType) {
	        return function (ev) {
	            // prevent mouse events
	            preventMouseEvents(ev);
	
	            if (ev.which !== 1) {
	                return;
	            }
	
	            // The EventTarget on which the touch point started when it was first placed on the surface,
	            // even if the touch point has since moved outside the interactive area of that element.
	            // also, when the target doesnt exist anymore, we update it
	            if (ev.type == 'mousedown' || !eventTarget || eventTarget && !eventTarget.dispatchEvent) {
	                eventTarget = ev.target;
	            }
	
	            // shiftKey has been lost, so trigger a touchend
	            if (isMultiTouch && !ev.shiftKey) {
	                triggerTouch('touchend', ev);
	                isMultiTouch = false;
	            }
	
	            triggerTouch(touchType, ev);
	
	            // we're entering the multi-touch mode!
	            if (!isMultiTouch && ev.shiftKey) {
	                isMultiTouch = true;
	                multiTouchStartPos = {
	                    pageX: ev.pageX,
	                    pageY: ev.pageY,
	                    clientX: ev.clientX,
	                    clientY: ev.clientY,
	                    screenX: ev.screenX,
	                    screenY: ev.screenY
	                };
	                triggerTouch('touchstart', ev);
	            }
	
	            // reset
	            if (ev.type == 'mouseup') {
	                multiTouchStartPos = null;
	                isMultiTouch = false;
	                eventTarget = null;
	            }
	        };
	    }
	
	    /**
	     * trigger a touch event
	     * @param eventName
	     * @param mouseEv
	     */
	    function triggerTouch(eventName, mouseEv) {
	        var touchEvent = document.createEvent('Event');
	        touchEvent.initEvent(eventName, true, true);
	
	        touchEvent.altKey = mouseEv.altKey;
	        touchEvent.ctrlKey = mouseEv.ctrlKey;
	        touchEvent.metaKey = mouseEv.metaKey;
	        touchEvent.shiftKey = mouseEv.shiftKey;
	
	        touchEvent.touches = getActiveTouches(mouseEv, eventName);
	        touchEvent.targetTouches = getActiveTouches(mouseEv, eventName);
	        touchEvent.changedTouches = getChangedTouches(mouseEv, eventName);
	
	        eventTarget.dispatchEvent(touchEvent);
	    }
	
	    /**
	     * create a touchList based on the mouse event
	     * @param mouseEv
	     * @returns {TouchList}
	     */
	    function createTouchList(mouseEv) {
	        var touchList = new TouchList();
	
	        if (isMultiTouch) {
	            var f = TouchEmulator.multiTouchOffset;
	            var deltaX = multiTouchStartPos.pageX - mouseEv.pageX;
	            var deltaY = multiTouchStartPos.pageY - mouseEv.pageY;
	
	            // touchList.push(new Touch(eventTarget, 1, multiTouchStartPos, (deltaX*-1) - f, (deltaY*-1) + f));
	            // touchList.push(new Touch(eventTarget, 2, multiTouchStartPos, deltaX+f, deltaY-f));
	            touchList.push(new Touch(eventTarget, 1, multiTouchStartPos, deltaX * -1 - f, deltaY * -1));
	            touchList.push(new Touch(eventTarget, 2, multiTouchStartPos, deltaX + f, deltaY));
	        } else {
	            touchList.push(new Touch(eventTarget, 1, mouseEv, 0, 0));
	        }
	
	        return touchList;
	    }
	
	    /**
	     * receive all active touches
	     * @param mouseEv
	     * @returns {TouchList}
	     */
	    function getActiveTouches(mouseEv, eventName) {
	        // empty list
	        if (mouseEv.type == 'mouseup') {
	            return new TouchList();
	        }
	
	        var touchList = createTouchList(mouseEv);
	        if (isMultiTouch && mouseEv.type != 'mouseup' && eventName == 'touchend') {
	            touchList.splice(1, 1);
	        }
	        return touchList;
	    }
	
	    /**
	     * receive a filtered set of touches with only the changed pointers
	     * @param mouseEv
	     * @param eventName
	     * @returns {TouchList}
	     */
	    function getChangedTouches(mouseEv, eventName) {
	        var touchList = createTouchList(mouseEv);
	
	        // we only want to return the added/removed item on multitouch
	        // which is the second pointer, so remove the first pointer from the touchList
	        //
	        // but when the mouseEv.type is mouseup, we want to send all touches because then
	        // no new input will be possible
	        if (isMultiTouch && mouseEv.type != 'mouseup' && (eventName == 'touchstart' || eventName == 'touchend')) {
	            touchList.splice(0, 1);
	        }
	
	        return touchList;
	    }
	
	    /**
	     * show the touchpoints on the screen
	     */
	    function showTouches(ev) {
	        var touch, i, el, styles;
	
	        // first all visible touches
	        for (i = 0; i < ev.touches.length; i++) {
	            touch = ev.touches[i];
	            el = touchElements[touch.identifier];
	            if (!el) {
	                el = touchElements[touch.identifier] = document.createElement("div");
	                document.body.appendChild(el);
	            }
	
	            styles = TouchEmulator.template(touch);
	            for (var prop in styles) {
	                el.style[prop] = styles[prop];
	            }
	        }
	
	        // remove all ended touches
	        if (ev.type == 'touchend' || ev.type == 'touchcancel') {
	            for (i = 0; i < ev.changedTouches.length; i++) {
	                touch = ev.changedTouches[i];
	                el = touchElements[touch.identifier];
	                if (el) {
	                    el.parentNode.removeChild(el);
	                    delete touchElements[touch.identifier];
	                }
	            }
	        }
	    }
	
	    /**
	     * TouchEmulator initializer
	     */
	    function TouchEmulator() {
	        if (hasTouchSupport()) {
	            return;
	        }
	
	        fakeTouchSupport();
	
	        window.addEventListener("mousedown", onMouse('touchstart'), true);
	        window.addEventListener("mousemove", onMouse('touchmove'), true);
	        window.addEventListener("mouseup", onMouse('touchend'), true);
	
	        window.addEventListener("mouseenter", preventMouseEvents, true);
	        window.addEventListener("mouseleave", preventMouseEvents, true);
	        window.addEventListener("mouseout", preventMouseEvents, true);
	        window.addEventListener("mouseover", preventMouseEvents, true);
	
	        // it uses itself!
	        window.addEventListener("touchstart", showTouches, false);
	        window.addEventListener("touchmove", showTouches, false);
	        window.addEventListener("touchend", showTouches, false);
	        window.addEventListener("touchcancel", showTouches, false);
	    }
	
	    // start distance when entering the multitouch mode
	    TouchEmulator.multiTouchOffset = 75;
	
	    /**
	     * css template for the touch rendering
	     * @param touch
	     * @returns object
	     */
	    TouchEmulator.template = function (touch) {
	        var size = 30;
	        var transform = 'translate(' + (touch.clientX - size / 2) + 'px, ' + (touch.clientY - size / 2) + 'px)';
	        return {
	            position: 'fixed',
	            left: 0,
	            top: 0,
	            background: '#fff',
	            border: 'solid 1px #999',
	            opacity: .6,
	            borderRadius: '100%',
	            height: size + 'px',
	            width: size + 'px',
	            padding: 0,
	            margin: 0,
	            display: 'block',
	            overflow: 'hidden',
	            pointerEvents: 'none',
	            webkitUserSelect: 'none',
	            mozUserSelect: 'none',
	            userSelect: 'none',
	            webkitTransform: transform,
	            mozTransform: transform,
	            transform: transform
	        };
	    };
	
	    // export
	    if (true) {
	        !(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
	            return TouchEmulator;
	        }.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	    } else if (typeof module != "undefined" && module.exports) {
	        module.exports = TouchEmulator;
	    } else {
	        window[exportName] = TouchEmulator;
	    }
	})(window, document, "TouchEmulator");
	/* eslint-disable */

/***/ }),
/* 137 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _NGRObject2 = __webpack_require__(7);
	
	var _NGRObject3 = _interopRequireDefault(_NGRObject2);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	/**
	 * 动画类,用于创建动态效果及控制动画效果的起始和持续时间。
	 * @emits Animator#start
	 * @emits Animator#update
	 * @emits Animator#complete
	 * @emits Animator#stop
	 * @extends {NGRObject}
	 */
	var Animator = function (_NGRObject) {
	  _inherits(Animator, _NGRObject);
	
	  function Animator() {
	    _classCallCheck(this, Animator);
	
	    return _possibleConstructorReturn(this, (Animator.__proto__ || Object.getPrototypeOf(Animator)).apply(this, arguments));
	  }
	
	  _createClass(Animator, [{
	    key: 'start',
	
	
	    /**
	     * 设定开始动画的时间。
	     * @param  {Number} [time] 开始动画的时间戳，不填则默认为当前时间戳。
	     * @return {Animator}      this。
	     */
	    value: function start(time) {} // eslint-disable-line no-unused-vars
	
	
	    /**
	     * 停止动画。
	     * @return {Animator} this。
	     */
	
	  }, {
	    key: 'stop',
	    value: function stop() {
	      return this;
	    }
	  }, {
	    key: 'end',
	    value: function end() {}
	
	    /**
	     * 设置动画效果重复的次数。不设置则默认不重复(0次)。
	     * @param  {Number} [count=0] 重复次数。
	     * @return {Animator}     this。
	     */
	
	  }, {
	    key: 'repeat',
	    value: function repeat(count) {
	      // eslint-disable-line no-unused-vars
	      return this;
	    }
	
	    /**
	     * 设置动画延迟执行时间。
	     * @param  {Number} amount 动画延迟执行时间(毫秒)。
	     * @return {Animator}      this。
	     */
	
	  }, {
	    key: 'delay',
	    value: function delay(amount) {
	      // eslint-disable-line no-unused-vars
	      return this;
	    }
	  }, {
	    key: 'timeInterpolator',
	    get: function get() {
	      return this._timeInterpolator;
	    },
	    set: function set(timeInterpolator) {
	      this._timeInterpolator = timeInterpolator;
	    }
	  }, {
	    key: 'typeEvaluator',
	    get: function get() {
	      return this._typeEvaluator;
	    },
	    set: function set(typeEvaluator) {
	      this._typeEvaluator = typeEvaluator;
	    }
	  }]);
	
	  return Animator;
	}(_NGRObject3.default);
	
	exports.default = Animator;

/***/ }),
/* 138 */
/***/ (function(module, exports) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var AnimatorProvider = function () {
	  function AnimatorProvider() {
	    _classCallCheck(this, AnimatorProvider);
	  }
	
	  _createClass(AnimatorProvider, [{
	    key: "update",
	    value: function update(timestamp) {// eslint-disable-line no-unused-vars
	    }
	  }, {
	    key: "ofNumber",
	    value: function ofNumber() {// eslint-disable-line no-unused-vars
	    }
	  }, {
	    key: "ofObject",
	    value: function ofObject() {// eslint-disable-line no-unused-vars
	    }
	  }]);
	
	  return AnimatorProvider;
	}();
	
	exports.default = AnimatorProvider;

/***/ }),
/* 139 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _set = function set(object, property, value, receiver) { var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent !== null) { set(parent, property, value, receiver); } } else if ("value" in desc && desc.writable) { desc.value = value; } else { var setter = desc.set; if (setter !== undefined) { setter.call(receiver, value); } } return value; };
	
	var _Animator2 = __webpack_require__(137);
	
	var _Animator3 = _interopRequireDefault(_Animator2);
	
	var _tween = __webpack_require__(103);
	
	var _tween2 = _interopRequireDefault(_tween);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var TweenAnimator = function (_Animator) {
	  _inherits(TweenAnimator, _Animator);
	
	  function TweenAnimator(first, end, duration) {
	    _classCallCheck(this, TweenAnimator);
	
	    var _this = _possibleConstructorReturn(this, (TweenAnimator.__proto__ || Object.getPrototypeOf(TweenAnimator)).call(this));
	
	    _this._t = new _tween2.default.Tween(first).to(end, duration);
	
	    var self = _this;
	    _this._t.onStart(function (object) {
	      /**
	       * 动画开始事件。
	       * @event Animator#start
	       * @param {Animator} animator 动画对象。
	       * @param {Object}   object   动画效果初值。
	       */
	      self.emit('start', self, object);
	    });
	
	    _this._t.onUpdate(function (value) {
	      /**
	       * 动画更新事件。由于动画是个实时变化的效果,所以在动画结束前,动画对象都会按照计算的插值不断改变状态。
	       * @event Animator#update
	       * @param {Animator} animator 动画对象。
	       * @param {Object}   target   动画插值。如果是通过数值生成的动画，则此对象有一个'num'属性表示这个数值。
	       */
	      self.emit('update', self, this, value);
	    });
	
	    _this._t.onComplete(function () {
	      /**
	       * 动画完成事件。
	       * @event Animator#complete
	       * @param {Animator} animator 动画对象。
	       * @param {Object}   target   动画效果终值。
	       */
	      self.emit('complete', self, this);
	    });
	
	    _this._t.onStop(function () {
	      /**
	       * 动画停止事件,即动画效果未全部完成前被终止。
	       * @event Animator#stop
	       * @param {Animator} animator 动画对象。
	       * @param {Object}   object   动画效果终值。
	       */
	      self.emit('stop', self, this);
	    });
	    return _this;
	  }
	
	  _createClass(TweenAnimator, [{
	    key: 'start',
	    value: function start(time) {
	      this._t.start(time);
	      return this;
	    }
	  }, {
	    key: 'stop',
	    value: function stop() {
	      this._t.stop();
	      return this;
	    }
	  }, {
	    key: 'repeat',
	    value: function repeat(count) {
	      this._t.repeat(count);
	      return this;
	    }
	  }, {
	    key: 'delay',
	    value: function delay(amount) {
	      this._t.delay(amount);
	      return this;
	    }
	  }, {
	    key: 'easing',
	    value: function easing(_easing) {
	      this._t.easing(_easing);
	      return this;
	    }
	  }, {
	    key: 'interpolation',
	    value: function interpolation(_interpolation) {
	      this._t.interpolation(_interpolation);
	      return this;
	    }
	  }, {
	    key: 'Easing',
	    get: function get() {
	      return _tween2.default.Easing;
	    }
	  }, {
	    key: 'Interpolation',
	    get: function get() {
	      return _tween2.default.Interpolation;
	    }
	  }, {
	    key: 'timeInterpolator',
	    set: function set(timeInterpolator) {
	      _set(TweenAnimator.prototype.__proto__ || Object.getPrototypeOf(TweenAnimator.prototype), 'timeInterpolator', timeInterpolator, this);
	      this._t.easing(function (k) {
	        return timeInterpolator.getInterpolation(k);
	      });
	    }
	  }, {
	    key: 'typeEvaluator',
	    set: function set(typeEvaluator) {
	      _set(TweenAnimator.prototype.__proto__ || Object.getPrototypeOf(TweenAnimator.prototype), 'typeEvaluator', typeEvaluator, this);
	      this._t.interpolation(function (v, k) {
	        // TODO
	        typeEvaluator.evaluate(k, v, v);
	      });
	    }
	  }]);
	
	  return TweenAnimator;
	}(_Animator3.default);
	
	exports.default = TweenAnimator;

/***/ }),
/* 140 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _AnimatorProvider2 = __webpack_require__(138);
	
	var _AnimatorProvider3 = _interopRequireDefault(_AnimatorProvider2);
	
	var _TweenAnimator = __webpack_require__(139);
	
	var _TweenAnimator2 = _interopRequireDefault(_TweenAnimator);
	
	var _tween = __webpack_require__(103);
	
	var _tween2 = _interopRequireDefault(_tween);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var TweenProvider = function (_AnimatorProvider) {
	  _inherits(TweenProvider, _AnimatorProvider);
	
	  function TweenProvider() {
	    _classCallCheck(this, TweenProvider);
	
	    return _possibleConstructorReturn(this, (TweenProvider.__proto__ || Object.getPrototypeOf(TweenProvider)).apply(this, arguments));
	  }
	
	  _createClass(TweenProvider, [{
	    key: 'update',
	    value: function update(timestamp) {
	      _tween2.default.update(timestamp);
	    }
	  }, {
	    key: 'ofNumber',
	    value: function ofNumber() {
	      var _ref, _ref2;
	
	      if (arguments.length < 3) {
	        throw new Error('At least three parameters are required!');
	      }
	      var first = {
	        num: arguments.length <= 0 ? undefined : arguments[0]
	      };
	      var end = {
	        num: (_ref = arguments.length - 2, arguments.length <= _ref ? undefined : arguments[_ref])
	      };
	      var duration = (_ref2 = arguments.length - 1, arguments.length <= _ref2 ? undefined : arguments[_ref2]);
	      return new _TweenAnimator2.default(first, end, duration);
	    }
	  }, {
	    key: 'ofObject',
	    value: function ofObject() {
	      var _ref3, _ref4;
	
	      if (arguments.length < 3) {
	        throw new Error('At least three parameters are required!');
	      }
	      var first = arguments.length <= 0 ? undefined : arguments[0];
	      var end = (_ref3 = arguments.length - 2, arguments.length <= _ref3 ? undefined : arguments[_ref3]);
	      var duration = (_ref4 = arguments.length - 1, arguments.length <= _ref4 ? undefined : arguments[_ref4]);
	      return new _TweenAnimator2.default(first, end, duration);
	    }
	  }]);
	
	  return TweenProvider;
	}(_AnimatorProvider3.default);
	
	exports.default = TweenProvider;

/***/ }),
/* 141 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.AnimatorFactory = undefined;
	
	var _AnimatorFactory = __webpack_require__(9);
	
	var _AnimatorFactory2 = _interopRequireDefault(_AnimatorFactory);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	// import TimeInterpolator from './TimeInterpolator';
	// import TypeEvaluator from './TypeEvaluator';
	
	exports.AnimatorFactory = _AnimatorFactory2.default;

/***/ }),
/* 142 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _SceneNode2 = __webpack_require__(24);
	
	var _SceneNode3 = _interopRequireDefault(_SceneNode2);
	
	var _jsts = __webpack_require__(5);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	/**
	 * 相机节点，用于创建相机对象,可以更改用户查看地图的视角。
	 * @extends {SceneNode}
	 */
	var CameraNode = function (_SceneNode) {
	  _inherits(CameraNode, _SceneNode);
	
	  /**
	   * 初始化相机，需要提供相机的id。
	   * @param  {Number} id 相机id。
	   */
	  function CameraNode(id) {
	    _classCallCheck(this, CameraNode);
	
	    var _this = _possibleConstructorReturn(this, (CameraNode.__proto__ || Object.getPrototypeOf(CameraNode)).call(this, id));
	
	    _this._position = new _jsts.geom.Coordinate(0, 0, 0);
	    _this._target = new _jsts.geom.Coordinate(0, 0, 0);
	    _this._up = new _jsts.geom.Coordinate(0, 0, 0);
	    return _this;
	  }
	
	  /**
	   * 初始化地图显示区域，需要提供显示区域的大小，并且根据一个比例来调整这个大小。
	   * @ignore
	   * @param  {Array}  rect            一个矩形框，由左下角和右上角组成。
	   * @param  {Number} [ratio=0.667]  矩形框与屏幕的比例。
	   * @param  {Nubmer} [skewAngle=60] 俯仰角度。
	   * @return {undefined}
	   */
	
	
	  _createClass(CameraNode, [{
	    key: 'initRect',
	    value: function initRect(rect) {
	      var ratio = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0.667;
	      var skewAngle = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 60;
	    } // eslint-disable-line no-unused-vars
	
	
	    /**
	     * 重置相机的视锥体大小，需要提供地图显示区域的宽度和高度。
	     * @param  {Number} width  宽度。
	     * @param  {Number} height 高度。
	     * @return {undefined}
	     */
	
	  }, {
	    key: 'reSize',
	    value: function reSize(width, height) {} // eslint-disable-line no-unused-vars
	
	
	    /**
	     * A function will be called when camera node was setted as active camera
	     * of a mapView.
	     * @ignore
	     * @param  {MapView} mapView MapView.
	     * @return {undefine} Undefine.
	     */
	
	  }, {
	    key: 'onActiveCamera',
	    value: function onActiveCamera(mapView) {
	      this._mapView = mapView;
	    }
	
	    /**
	     * 将一个3D世界坐标转换成屏幕坐标。
	     * @param  {Number} x        3D世界坐标x。
	     * @param  {Number} y        3D世界坐标y。
	     * @param  {Number} z        3D世界坐标z。
	     * @return {THREE.Vecotr3}   屏幕坐标。
	     */
	
	  }, {
	    key: 'toScreenCoordinate',
	    value: function toScreenCoordinate(x, y, z) {} // eslint-disable-line no-unused-vars
	
	
	    /**
	     * 将一个屏幕坐标转换成3D世界坐标。
	     * @param  {Number} x        屏幕坐标x。
	     * @param  {Number} y        屏幕坐标y。
	     * @param  {Number} z        忽略。
	     * @return {THREE.Vecotr3}   3D世界坐标。
	     */
	
	  }, {
	    key: 'toCameraCoordinate',
	    value: function toCameraCoordinate(x, y, z) {// eslint-disable-line no-unused-vars
	    }
	  }, {
	    key: 'lookAt',
	
	
	    /**
	     * 设置相机摆放的位置，并且指定一个朝向。
	     * @param  {geom.Coordinate} position 相机位置，使用3D世界坐标系表示。
	     * @param  {geom.Coordinate} target   相机正对的地图中心位置的坐标。
	     * @param  {geom.Coordinate} up       相机的方位，即地图画面上垂直线指向的方向，由一个向量表示。
	     * @return {undefined}
	     */
	    value: function lookAt(position, target, up) {// eslint-disable-line no-unused-vars
	    }
	  }, {
	    key: 'position',
	    get: function get() {
	      return this._position;
	    }
	
	    /**
	     * 相机的位置,用3D世界坐标系表示。
	     * @type   {geom.Coordinate}
	     * @param  {geom.Coordinate} position 相机位置。
	     */
	    ,
	    set: function set(position) {
	      this._position = position;
	    }
	  }, {
	    key: 'target',
	    get: function get() {
	      return this._target;
	    }
	
	    /**
	     * 相机视角正对的地图中心位置的坐标。
	     * @type   {geom.Coordinate}
	     * @param  {geom.Coordinate} target 位置的坐标。
	     */
	    ,
	    set: function set(target) {
	      this._target = target;
	    }
	  }, {
	    key: 'up',
	    get: function get() {
	      return this._up;
	    }
	
	    /**
	     * Up setter.
	     * @ignore
	     * @type   {geom.Coordinate}
	     * @param  {geom.Coordinate} up Up.
	     */
	    ,
	    set: function set(up) {
	      this._up = up;
	    }
	  }]);
	
	  return CameraNode;
	}(_SceneNode3.default);
	
	exports.default = CameraNode;

/***/ }),
/* 143 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _NGRObject2 = __webpack_require__(7);
	
	var _NGRObject3 = _interopRequireDefault(_NGRObject2);
	
	var _three = __webpack_require__(2);
	
	var THREE = _interopRequireWildcard(_three);
	
	var _Math = __webpack_require__(38);
	
	var MathExt = _interopRequireWildcard(_Math);
	
	var _TouchEvent = __webpack_require__(48);
	
	var _TouchEvent2 = _interopRequireDefault(_TouchEvent);
	
	var _CollisionAnimation = __webpack_require__(25);
	
	var _AnimatorFactory = __webpack_require__(9);
	
	var _AnimatorFactory2 = _interopRequireDefault(_AnimatorFactory);
	
	var _lang = __webpack_require__(4);
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	// import { touchEmulator } from '../../../config';
	
	
	var TOROTATE = 180 / Math.PI;
	var TOANGLE = Math.PI / 180;
	
	/**
	 * 提供一个第三人称相机控制类,可用于更改用户查看地图的视角。绑定鼠标和触控事件。
	 * @extends {NGRObject}
	 */
	
	var ThirdPersonControl = function (_NGRObject) {
	  _inherits(ThirdPersonControl, _NGRObject);
	
	  /**
	   * 构造相机控制类,用于配置查看地图视角的高度、方向等。
	   * @param  {CameraNode} camera  相机节点,用于创建相机对象。
	   * @param  {NGR.view.MapView}    mapView 应用该相机对象的地图。
	   */
	  function ThirdPersonControl(camera, mapView) {
	    _classCallCheck(this, ThirdPersonControl);
	
	    var _this = _possibleConstructorReturn(this, (ThirdPersonControl.__proto__ || Object.getPrototypeOf(ThirdPersonControl)).call(this));
	
	    _this._activeCamera = camera;
	    _this._camera = camera.camera;
	    _this._mapView = mapView;
	
	    _this._EPS = 0.000001;
	
	    _this._target = new THREE.Vector3();
	
	    _this._minDistance = 30;
	    _this._maxDistance = Infinity;
	    _this._curDistance = 0;
	    _this._curZoomStatus = 0;
	
	    _this._minSkewAngle = 0;
	    _this._maxSkewAngle = 60;
	
	    _this._boundScale = 1.5;
	
	    _this._enableVerticalMove = false;
	    _this._passMinMove = true;
	    _this._staticMove = true;
	    _this._staticZoom = false;
	
	    // this._minAzimuthAngle = -Infinity;
	    // this._maxAzimuthAngle = Infinity;
	
	    _this._target0 = _this._target.clone();
	    _this._position0 = _this._camera.position.clone();
	
	    _this._spherical = new THREE.Spherical();
	    _this._sphericalDelta = new THREE.Spherical();
	    _this._scale = 1;
	    _this._panOffset = new THREE.Vector3();
	    _this._zoomChanged = false;
	
	    _this.__rotateStart = 0;
	    _this.__rotateEnd = 0;
	    _this.__rotateDelta = 0;
	
	    _this._panStart = new THREE.Vector2();
	    _this._panEnd = new THREE.Vector2();
	    _this._panDelta = new THREE.Vector2();
	
	    _this._shoveStart = 0;
	    _this._shoveEnd = 0;
	    _this._shoveDelta = 0;
	    _this._shoveStart0 = 0;
	    _this._shoveStart1 = 0;
	    _this._shoveDelta0 = 0;
	    _this._shoveDelta1 = 0;
	
	    _this._dollyStart = 0;
	    _this._dollyEnd = 0;
	    _this._dollyDelta = 0;
	
	    _this._offset = new THREE.Vector3();
	
	    _this._quat = new THREE.Quaternion().setFromUnitVectors(_this._camera.up, new THREE.Vector3(0, 1, 0));
	    _this._quatInverse = _this._quat.clone().inverse();
	
	    _this._rotateMatrixAngle = new THREE.Matrix4();
	    _this._rotateAxis = new THREE.Vector3(0, 0, 1);
	    _this._rotatePan = new THREE.Vector3(0, 0, 0);
	    _this._rotateCenter = new THREE.Vector3(0, 0, 0);
	
	    _this._skewMatrixAngle = new THREE.Matrix4();
	
	    _this._lastPosition = new THREE.Vector3();
	    _this._lastQuaternion = new THREE.Quaternion();
	
	    _this._moveStart = _this._moveStart.bind(_this);
	    _this._moveEnd = _this._moveEnd.bind(_this);
	    _this._move = _this._move.bind(_this);
	    _this._rotateStart = _this._rotateStart.bind(_this);
	    _this._rotateEnd = _this._rotateEnd.bind(_this);
	    _this._rotate = _this._rotate.bind(_this);
	    _this._zoomStart = _this._zoomStart.bind(_this);
	    _this._zoomEnd = _this._zoomEnd.bind(_this);
	    _this._zoom = _this._zoom.bind(_this);
	    _this._skewStart = _this._skewStart.bind(_this);
	    _this._skewEnd = _this._skewEnd.bind(_this);
	    _this._skew = _this._skew.bind(_this);
	    _this._doubleTapZoom = _this._doubleTapZoom.bind(_this);
	    _this._changePlanarGraph = _this._changePlanarGraph.bind(_this);
	
	    _this._mapView.gestureManager.on('moveStart', _this._moveStart);
	    _this._mapView.gestureManager.on('moveEnd', _this._moveEnd);
	    _this._mapView.gestureManager.on('move', _this._move);
	    _this._mapView.gestureManager.on('rotateStart', _this._rotateStart);
	    _this._mapView.gestureManager.on('rotateEnd', _this._rotateEnd);
	    _this._mapView.gestureManager.on('rotate', _this._rotate);
	    _this._mapView.gestureManager.on('zoomStart', _this._zoomStart);
	    _this._mapView.gestureManager.on('zoomEnd', _this._zoomEnd);
	    _this._mapView.gestureManager.on('zoom', _this._zoom);
	    _this._mapView.gestureManager.on('skewStart', _this._skewStart);
	    _this._mapView.gestureManager.on('skewEnd', _this._skewEnd);
	    _this._mapView.gestureManager.on('skewUp', _this._skew);
	    _this._mapView.gestureManager.on('skewDown', _this._skew);
	    _this._mapView.gestureManager.on('doubleTap', _this._doubleTapZoom);
	    _this._mapView.on('changePlanarGraph', _this._changePlanarGraph);
	    return _this;
	  }
	
	  _createClass(ThirdPersonControl, [{
	    key: '_doubleTapZoom',
	    value: function _doubleTapZoom() {
	      var _this2 = this;
	
	      _AnimatorFactory2.default.getInstance().ofNumber(1.5, 0, 300).on('update', function () {
	        _this2.zoom(0.95, true, false, false);
	      }).on('start', function () {}).on('complete', function () {}).start();
	
	      var event = new _TouchEvent2.default();
	      event.type = 'cameraControl';
	      this._mapView.gestureManager.emit('zoomEnd', event);
	    }
	  }, {
	    key: '_moveStart',
	    value: function _moveStart(e) {
	      var touch = e.touches[0];
	      var clientX = touch.clientX;
	      var clientY = touch.clientY;
	      this._panStart.set(clientX, clientY);
	      this._moveOrigin = this._panStart.clone();
	      // console.log(this._moveOrigin);
	    }
	  }, {
	    key: '_moveEnd',
	    value: function _moveEnd(_ref) {
	      var _this3 = this;
	
	      var type = _ref.type;
	
	      var moveDelta = new THREE.Vector2();
	
	      if (this._moveOrigin) {
	        moveDelta.subVectors(this._panEnd, this._moveOrigin);
	      } else {
	        this._passMinMove = false;
	      }
	      // console.log(`moveEnd: ${moveDelta.length()}`);
	      if (moveDelta.length() < 50) {
	        this._passMinMove = false;
	      }
	      if (this._staticMove && this._passMinMove) {
	        _AnimatorFactory2.default.getInstance().ofNumber(1.5, 0, 300).on('update', function (animator, _ref2) {
	          var num = _ref2.num;
	
	          _this3.move(_this3._panDelta.x * num, _this3._panDelta.y * num, 0, true, false, false);
	        }).on('start', function () {}).on('complete', function () {}).start();
	      }
	      if (type === 'cameraControl') {
	
	        return;
	      }
	      this._mapView.collisionSceneManager.animation(_CollisionAnimation.CAType.Opacity).updateCollision(true);
	      this._moveOrigin = null;
	    }
	  }, {
	    key: '_move',
	    value: function _move(e) {
	      var touch = e.touches[0];
	      var clientX = touch.clientX;
	      var clientY = touch.clientY;
	
	      this._panEnd.set(clientX, clientY);
	      this._panDelta.subVectors(this._panEnd, this._panStart);
	      // console.log(this._panDelta.length());
	      this.move(this._panDelta.x, this._panDelta.y, 0, false, false, false);
	      this._passMinMove = true;
	      if (this._panDelta.length() < 19) {
	        // this._passMinMove = false;
	      }
	      this._panStart.copy(this._panEnd);
	      this.update();
	    }
	  }, {
	    key: '_rotateStart',
	    value: function _rotateStart(_ref3) {
	      var rotate = _ref3.rotate;
	
	      this.__rotateStart = rotate;
	    }
	  }, {
	    key: '_rotateEnd',
	    value: function _rotateEnd(_ref4) {
	      var type = _ref4.type;
	
	      if (type === 'cameraControl') {
	
	        return;
	      }
	      this._mapView.collisionSceneManager.animation(_CollisionAnimation.CAType.Opacity).updateCollision(true);
	    }
	  }, {
	    key: '_rotate',
	    value: function _rotate(_ref5) {
	      var rotate = _ref5.rotate;
	
	      var _activeCamera$toCamer = this._activeCamera.toCameraCoordinate(this._mapView.width / 2, this._mapView.length / 2, 0),
	          x = _activeCamera$toCamer.x,
	          y = _activeCamera$toCamer.y;
	
	      this.__rotateEnd = rotate;
	      this.__rotateDelta = this.__rotateEnd - this.__rotateStart;
	      if (Math.abs(this.__rotateDelta) > 0.2) {
	        this.rotate(x, y, this.__rotateDelta, false, false, false);
	      }
	      this.__rotateStart = this.__rotateEnd;
	      this.update();
	    }
	  }, {
	    key: '_zoomStart',
	    value: function _zoomStart(_ref6) {
	      var scale = _ref6.scale;
	
	      this._dollyStart = scale;
	    }
	  }, {
	    key: '_zoomEnd',
	    value: function _zoomEnd(_ref7) {
	      var _this4 = this;
	
	      var type = _ref7.type;
	
	      // if (this._staticZoom) {
	      //   AnimatorFactory.getInstance().ofNumber(0.05, 0, 300)
	      //     .on('update', (animator, target) => {
	      //       if ((this._dollyDelta * target.num) < 1) {
	      //         if ((1 - this._dollyDelta * target.num) < 0.5) {
	      //           this.zoom(0.5, true, false, false);
	      //         } else {
	      //           this.zoom(1 - this._dollyDelta * target.num, true, false, false);
	      //         }
	      //       }
	      //     }).on('start', () => {
	      //     }).on('complete', (animator) => {
	      //     }).start();
	      // }
	      if (this._staticZoom) {
	        _AnimatorFactory2.default.getInstance().ofNumber(1.5, 1, 300).on('update', function (animator, _ref8) {
	          var num = _ref8.num;
	
	          _this4.zoom(num, true, false, false);
	        }).on('start', function () {}).on('complete', function () {}).start();
	      }
	      if (type === 'cameraControl') {
	
	        return;
	      }
	      this._mapView.collisionSceneManager.animation(_CollisionAnimation.CAType.Opacity).updateCollision(true);
	    }
	  }, {
	    key: '_zoom',
	    value: function _zoom(_ref9) {
	      var scale = _ref9.scale,
	          length = _ref9.touches.length;
	
	      this._dollyEnd = scale;
	      if (length === 1) {
	        this._dollyDelta = this._dollyEnd - this._dollyStart;
	        this.zoom(1 - this._dollyDelta, false, false, false);
	      } else {
	        this._dollyDelta = this._dollyStart / this._dollyEnd;
	        this.zoom(this._dollyDelta, false, false, false);
	      }
	      this._dollyStart = this._dollyEnd;
	      this.update();
	    }
	  }, {
	    key: '_skewStart',
	    value: function _skewStart(_ref10) {
	      var touches = _ref10.touches;
	
	      this._shoveStart = touches[0].clientY;
	      if (touches.length > 1) {
	        // this._shoveStart = (event.touches[0].clientY + event.touches[1].clientY) / 2;
	        this._shoveStart0 = touches[0].clientY;
	        this._shoveStart1 = touches[1].clientY;
	      }
	    }
	  }, {
	    key: '_skewEnd',
	    value: function _skewEnd(_ref11) {
	      var type = _ref11.type;
	
	      if (type === 'cameraControl') {
	
	        return;
	      }
	      this._mapView.collisionSceneManager.animation(_CollisionAnimation.CAType.Opacity).updateCollision(true);
	    }
	  }, {
	    key: '_skew',
	    value: function _skew(_ref12) {
	      var type = _ref12.type,
	          touches = _ref12.touches;
	
	      this._shoveEnd = touches[0].clientY;
	      if (touches.length > 1) {
	        this._shoveDelta0 = touches[0].clientY - this._shoveStart0;
	        this._shoveDelta1 = touches[1].clientY - this._shoveStart1;
	        // this._shoveEnd = (event.touches[0].clientY + event.touches[1].clientY) / 2;
	      }
	      this._shoveDelta = this._shoveEnd - this._shoveStart;
	      if (this._shoveDelta0 * this._shoveDelta1 > 0 || touches.length === 1) {
	        if (Math.abs(this._shoveDelta / 4) > 0.1) {
	          if (type === 'skewUp') {
	            this.skew(this._shoveDelta / 4, false, false, false);
	          } else if (type === 'skewDown') {
	            this.skew(this._shoveDelta / 4, false, false, false);
	          }
	        }
	      }
	      this._shoveStart = this._shoveEnd;
	      // console.log(this._shoveDelta);
	      if (touches.length > 1) {
	        this._shoveStart0 = touches[0].clientY;
	        this._shoveStart1 = touches[1].clientY;
	      }
	      this.update();
	    }
	  }, {
	    key: '_changePlanarGraph',
	    value: function _changePlanarGraph(mapView, p1 /* , p2*/) {
	      this._bound = this._activeCamera.bound.clone();
	      this._bound.scaleRadius(this._boundScale);
	      if (p1.length === 1) {
	        this._maxDistance = this._activeCamera.originDistance * 1.2;
	      } else {
	        this._maxDistance = this._activeCamera.originDistance + this._mapView._floorHeight * (p1.length - 1);
	      }
	      if (this._minDistance >= this._maxDistance) {
	        this._minDistance = this._maxDistance * 0.6;
	      }
	      this._position0.setZ(this._camera.position.z);
	      this._calculateCameraZ();
	      this.update();
	    }
	
	    /**
	     * 设置最小缩放距离，即允许相机(视角)距离地面的最短高度。
	     * @type {Number}
	     * @param  {Number} distance 缩放距离，单位米。
	     */
	
	  }, {
	    key: 'dispose',
	
	
	    /**
	     * 销毁相机控制类，解除事件绑定。
	     * @return {ThirdPersonControl} this。
	     */
	    value: function dispose() {
	      // if (!touchEmulator) {
	      //   const targetDom = this._mapView.targetDom;
	      //   targetDom.removeEventListener('contextmenu', this._contextMenu, false);
	      //   targetDom.removeEventListener('mousewheel', this._mouseWheel, false);
	      //   targetDom.removeEventListener('MozMousePixelScroll', this._mouseWheel, false);
	      //   targetDom.removeEventListener('mousedown', this._mouseDown, false);
	      // }
	
	      this._mapView.gestureManager.off('moveStart', this._moveStart);
	      this._mapView.gestureManager.off('moveEnd', this._moveEnd);
	      this._mapView.gestureManager.off('move', this._move);
	
	      this._mapView.gestureManager.off('rotateStart', this._rotateStart);
	      this._mapView.gestureManager.off('rotateEnd', this._rotateEnd);
	      this._mapView.gestureManager.off('rotate', this._rotate);
	
	      this._mapView.gestureManager.off('skewStart', this._skewStart);
	      this._mapView.gestureManager.off('skewEnd', this._skewEnd);
	      this._mapView.gestureManager.off('skew', this._skew);
	
	      this._mapView.gestureManager.off('doubleTap', this._doubleTapZoom);
	
	      this._mapView.off('changePlanarGraph', this._changePlanarGraph);
	
	      this._activeCamera = null;
	      this._camera = null;
	      this._mapView = null;
	      this._skewMatrixAngle = null;
	      this._rotateMatrixAngle = null;
	      return this;
	    }
	
	    /**
	     * 重置相机控制对象。
	     * @return {ThirdPersonControl} this。
	     */
	
	  }, {
	    key: 'reset',
	    value: function reset() {
	      // this._activeCamera.target = this._target0;
	      this._target = this._target0;
	      this._activeCamera.position = this._position0;
	      this._activeCamera.up = new THREE.Vector3(0, 1, 0);
	      this._camera.updateProjectionMatrix();
	
	      this.update();
	      return this;
	    }
	
	    /**
	     * 更新相机操作。当使用诸如{@link ThirdPersonControl#rotate}方法对视角进行调整时,需要调用这个方法使之生效。
	     * @return {Boolean} 如果更新成功则返回true。
	     */
	
	  }, {
	    key: 'update',
	    value: function update() {
	      var position = this._camera.position;
	
	      this._offset.copy(position).sub(this._target);
	      this._offset.applyQuaternion(this._quat);
	      this._spherical.setFromVector3(this._offset);
	
	      // this._spherical.theta += this._sphericalDelta.theta;
	      // this._spherical.phi += this._sphericalDelta.phi;
	
	      // this._spherical.theta = Math.max(this._minAzimuthAngle, Math.min(this._maxAzimuthAngle, this._spherical.theta));
	      // this._spherical.phi = Math.max(this._minPolarAngle, Math.min(this._maxPolarAngle, this._spherical.phi));
	
	      this._spherical.makeSafe();
	
	      this._spherical.radius *= this._scale;
	      this._spherical.radius = Math.max(this._minDistance, Math.min(this._maxDistance, this._spherical.radius));
	
	      if (this._scale !== 1) {
	        if (this._spherical.radius >= this._maxDistance) {
	          this._changeZoomStatus(1);
	        } else if (this._spherical.radius <= this._minDistance) {
	          this._changeZoomStatus(2);
	        } else {
	          this._changeZoomStatus(0);
	        }
	      }
	      var tempTarget = this._target.clone();
	      // this._target.add(this._panOffset);
	      tempTarget.add(this._panOffset);
	      // if (!this._bound.containsPoint(this._target)) {
	      //  this._target.copy(tempTarget);
	      // }
	      if (this._bound && this._bound.containsPoint(tempTarget)) {
	        this._target.copy(tempTarget);
	      }
	
	      this._offset.setFromSpherical(this._spherical);
	      this._offset.applyQuaternion(this._quatInverse);
	      position.copy(this._target).add(this._offset);
	      this._activeCamera.target = this._target;
	      this._camera.lookAt(this._target);
	      this._curDistance = position.distanceTo(this._target);
	
	      this._sphericalDelta.set(0, 0, 0);
	      this._scale = 1;
	      this._panOffset.set(0, 0, 0);
	
	      if (this._zoomChanged || this._lastPosition.distanceToSquared(this._camera.position) > this._EPS || 8 * (1 - this._lastQuaternion.dot(this._camera.quaternion)) > this._EPS) {
	        this._lastPosition.copy(this._camera.position);
	        this._lastQuaternion.copy(this._camera.quaternion);
	        this._zoomChanged = false;
	        return true;
	      }
	
	      this._lastPosition.copy(this._camera.position);
	      return false;
	    }
	
	    /**
	     * 允许相机垂直移动。默认为不允许。
	     * @ignore
	     * @return {ThirdPersonControl} this.
	     */
	
	  }, {
	    key: 'enableVerticalMove',
	    value: function enableVerticalMove() {
	      this._enableVerticalMove = true;
	      return this;
	    }
	
	    /**
	     * 不允许相机垂直移动。
	     * @ignore
	     * @return {ThirdPersonControl} this.
	     */
	
	  }, {
	    key: 'disableVerticalMove',
	    value: function disableVerticalMove() {
	      this._enableVerticalMove = false;
	      return this;
	    }
	
	    /**
	     * 以某一增量值移动相机视角。
	     * @param  {Number}  dx                   在x轴方向上移动的距离。如在x轴移动1个距离单位。
	     * @param  {Number}  dy                   在y轴方向上移动的距离。如在y轴移动1个距离单位。
	     * @param  {Number}  dz                   在z轴方向上移动的距离。如在z轴移动1个距离单位。
	     * @param  {Boolean} [needUpdate=true]    是否调用update方法更新视角，是则设置为true。
	     * @param  {Boolean} [needCollision=true] 是否调用collision方法进行碰撞检测，是则设置为true。
	     * @param  {Boolean} [emitEnd=true]       是否分发事件给相应的监听器处理，是则设置为true。
	     * @return {ThirdPersonControl}           this。
	     */
	
	  }, {
	    key: 'move',
	    value: function move(dx, dy) {
	      var dz = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
	      var needUpdate = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
	      var needCollision = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : true;
	      var emitEnd = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : true;
	
	      var actualDz = dz;
	
	      if (this._enableVerticalMove === false) {
	        actualDz = 0;
	      } else {
	        actualDz = dz;
	      }
	
	      var position = this._camera.position;
	      var offset = new THREE.Vector3().copy(position).sub(this._target);
	      var targetDistance = offset.length();
	
	      targetDistance *= Math.tan(this._camera.fov / 2 * TOANGLE);
	      this._moveLeft(2 * dx * targetDistance / this._mapView.height, this._camera.matrix);
	      this._moveForward(2 * dy * targetDistance / this._mapView.height, this._camera.matrix);
	
	      this._camera.position.z -= actualDz;
	      this._target.z -= actualDz;
	
	      if (needUpdate) {
	        this.update();
	      }
	      if (needCollision) {
	        this._mapView.collisionSceneManager.animation(_CollisionAnimation.CAType.Opacity).updateCollision(true);
	      }
	      if (emitEnd) {
	        var event = new _TouchEvent2.default();
	
	        event.type = 'cameraControl';
	        this._mapView.gestureManager.emit('moveEnd', event);
	      }
	
	      return this;
	    }
	
	    /**
	     * 移动相机视角到某个绝对坐标位置。
	     * @param  {Number}  x                    x轴坐标点。如移动到x轴50。
	     * @param  {Number}  y                    y轴坐标点。如移动到y轴50。
	     * @param  {Number}  z                    z轴坐标点。如移动到z轴50。
	     * @param  {Boolean} [needUpdate=true]    如需调用update方法更新视角，请设置true。
	     * @param  {Boolean} [needCollision=true] 如需调用collision方法进行碰撞检测，请设置true。
	     * @param  {Boolean} [emitEnd=true]       如需分发事件给相应的监听器处理，请设置true。
	     * @return {ThirdPersonControl}           this。
	     */
	
	  }, {
	    key: 'moveToPoint',
	    value: function moveToPoint(x, y) {
	      var z = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
	      var needUpdate = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
	      var needCollision = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : true;
	      var emitEnd = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : true;
	
	      var dx = x - this._target.x;
	      var dy = y - this._target.y;
	
	      if (this._enableVerticalMove === true && (0, _lang.isPresent)(z)) {
	        var dz = z - this._target.z;
	
	        this._panOffset.set(dx, dy, dz);
	      } else {
	        this._panOffset.setX(dx);
	        this._panOffset.setY(dy);
	      }
	
	      if (needUpdate) {
	        this.update();
	      }
	      if (needCollision) {
	        this._mapView.collisionSceneManager.animation(_CollisionAnimation.CAType.Opacity).updateCollision(true);
	      }
	      if (emitEnd) {
	        var event = new _TouchEvent2.default();
	        event.type = 'cameraControl';
	        this._mapView.gestureManager.emit('moveEnd', event);
	      }
	
	      return this;
	    }
	
	    /**
	     * 移动相机视角到一个自定义的区域。
	     * @param  {Array}   bounds                  矩形自定义区域，使用该区域左下角和右上角的世界坐标确定位置。
	     * @param  {Number}  ratio                   自定义区域的缩放比，如果是1，表示不缩放。
	     * @param  {Boolean} hasOffset               是否对坐标区域进行偏移,是则设置为true。
	     * @param  {Boolean} [needUpdate=true]       是否调用update方法更新视角，是则设置为true。
	     * @param  {Boolean} [needCollision=true]    是否调用collision方法进行碰撞检测，是则设置为true。
	     * @param  {Boolean} [emitEnd=true]          是否分发事件给相应的监听器处理，是则设置为true。
	     * @param  {Boolean} [needAnimation=true]    是否启用动画，是则设置为true。
	     * @param  {Boolean} [needRotateToZero=true] 是否将地图旋转至正北角度，是则设置为true。
	     * @return {ThirdPersonControl}              this。
	     */
	
	  }, {
	    key: 'fitBounds',
	    value: function fitBounds(bounds) {
	      var ratio = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
	      var hasOffset = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
	      var needUpdate = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
	      var needCollision = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : true;
	      var emitEnd = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : true;
	      var needAnimation = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : false;
	      var needRotateToZero = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : true;
	
	      if (bounds.length !== 4 && bounds.length !== 6) {
	        throw new Error('Invalid bounds');
	      }
	
	      var crtRotate = this.getRotate();
	      var crtSkew = this.getSkew();
	
	      this.skewTo(0.1, needUpdate, needCollision, emitEnd);
	      this._fitBoundsInVerticalView(bounds, crtSkew, ratio, hasOffset, needUpdate, needCollision, emitEnd, needAnimation);
	      this.skewTo(crtSkew, needUpdate, needCollision, emitEnd);
	      if (!needRotateToZero) {
	        this.rotateTo(this._target.x, this._target.y, crtRotate, needUpdate, needCollision, emitEnd);
	      }
	
	      return this;
	    }
	  }, {
	    key: '_fitBoundsInVerticalView',
	    value: function _fitBoundsInVerticalView(bounds, crtSkew) {
	      var ratio = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
	      var hasOffset = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
	      var needUpdate = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : true;
	      var needCollision = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : true;
	
	      var _this5 = this;
	
	      var emitEnd = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : true;
	      var needAnimation = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : false;
	
	      // referrnce ThreeCamera.initRect
	      var rect = bounds.slice();
	      var camera = this._mapView.activeCamera;
	
	      camera.camera.updateMatrix();
	      camera.camera.updateMatrixWorld();
	
	      if (bounds.length === 4) {
	        // const left = rect[0];
	        // const bottom = rect[1];
	        // const right = rect[2];
	        // const top = rect[3];
	        // const centerX = (left + right) / 2;
	        // const centerY = (top + bottom) / 2;
	
	        // this.moveToPoint(centerX, centerY, null, needUpdate, needCollision, emitEnd);
	        // this.rotateTo(centerX, centerY, 0);
	
	        // const leftBottomVector = new THREE.Vector3(left - centerX, bottom - centerY, 1);
	        // const rightTopVector = new THREE.Vector3(right - centerX, top - centerY, 1);
	        // const leftBottomScreen = camera.toScreenCoordinate(leftBottomVector.x, leftBottomVector.y, leftBottomVector.z);
	        // const rightTopScreen = camera.toScreenCoordinate(rightTopVector.x, rightTopVector.y, rightTopVector.z);
	        // const widthRatio = Math.abs((rightTopScreen.x - leftBottomScreen.x) / this._mapView.width);
	        // const heightRatio = Math.abs((leftBottomScreen.y - rightTopScreen.y) / this._mapView.height);
	        // maxRatio = Math.max(widthRatio, heightRatio);
	        rect = [bounds[0], bounds[1], 0, bounds[2], bounds[3], 0];
	      }
	
	      var centerX = (rect[0] + rect[3]) / 2;
	      var centerY = (rect[1] + rect[4]) / 2;
	      var centerZ = (rect[2] + rect[5]) / 2;
	
	      this.moveToPoint(centerX, centerY, centerZ, needUpdate, needCollision, emitEnd);
	      this.rotateTo(centerX, centerY, 0);
	
	      var minVector = new THREE.Vector3(rect[0] - centerX, rect[1] - centerY, rect[2] - centerZ);
	      var maxVector = new THREE.Vector3(rect[3] - centerX, rect[4] - centerY, rect[5] - centerZ);
	
	      var screenPt1 = camera.toScreenCoordinate(minVector.x, minVector.y, minVector.z);
	      var screenPt2 = camera.toScreenCoordinate(minVector.x, maxVector.y, minVector.z);
	      var screenPt3 = camera.toScreenCoordinate(maxVector.x, minVector.y, minVector.z);
	      var screenPt4 = camera.toScreenCoordinate(maxVector.x, maxVector.y, minVector.z);
	      var screenPt5 = camera.toScreenCoordinate(minVector.x, minVector.y, maxVector.z);
	      var screenPt6 = camera.toScreenCoordinate(minVector.x, maxVector.y, maxVector.z);
	      var screenPt7 = camera.toScreenCoordinate(maxVector.x, minVector.y, maxVector.z);
	      var screenPt8 = camera.toScreenCoordinate(maxVector.x, maxVector.y, maxVector.z);
	
	      var minX = Math.min(screenPt1.x, screenPt2.x, screenPt3.x, screenPt4.x, screenPt5.x, screenPt6.x, screenPt7.x, screenPt8.x);
	      var maxX = Math.max(screenPt1.x, screenPt2.x, screenPt3.x, screenPt4.x, screenPt5.x, screenPt6.x, screenPt7.x, screenPt8.x);
	      var minY = Math.min(screenPt1.y, screenPt2.y, screenPt3.y, screenPt4.y, screenPt5.y, screenPt6.y, screenPt7.y, screenPt8.y);
	      var maxY = Math.max(screenPt1.y, screenPt2.y, screenPt3.y, screenPt4.y, screenPt5.y, screenPt6.y, screenPt7.y, screenPt8.y);
	
	      var widthRatio = (maxX - minX) / this._mapView.width;
	      var heightRatio = (maxY - minY) / this._mapView.height;
	      var maxRatio = Math.max(widthRatio, heightRatio);
	
	      var position = this._camera.position.clone();
	      var target = this._target;
	      var vector = position.clone().sub(target).multiplyScalar(maxRatio / ratio);
	      var newPosition = target.clone().add(vector);
	
	      if (!needAnimation || !needUpdate) {
	        this._camera.position.copy(newPosition);
	        if (needUpdate) {
	          this.update();
	        }
	        if (needCollision) {
	          this._mapView.collisionSceneManager.animation(_CollisionAnimation.CAType.Opacity).updateCollision(true);
	        }
	        if (emitEnd) {
	          var event = new _TouchEvent2.default();
	
	          event.type = 'cameraControl';
	          this._mapView.gestureManager.emit('zoomEnd', event);
	        }
	      } else {
	        var crtPosition = new THREE.Vector3();
	
	        _AnimatorFactory2.default.getInstance().ofNumber(1, 0, 500).on('update', function (animator, _ref13) {
	          var num = _ref13.num;
	
	          crtPosition.setX(num * position.x + (1 - num) * newPosition.x);
	          crtPosition.setY(num * position.y + (1 - num) * newPosition.y);
	          crtPosition.setZ(num * position.z + (1 - num) * newPosition.z);
	          _this5._camera.position.copy(crtPosition);
	          _this5.skewTo(crtSkew, true, false, false);
	        }).on('start', function () {}).on('complete', function () {
	          if (needCollision) {
	            _this5._mapView.collisionSceneManager.animation(_CollisionAnimation.CAType.Opacity).updateCollision(true);
	          }
	          if (emitEnd) {
	            var _event = new _TouchEvent2.default();
	
	            _event.type = 'cameraControl';
	            _this5._mapView.gestureManager.emit('zoomEnd', _event);
	          }
	        }).start();
	      }
	
	      return this;
	    }
	
	    /**
	     * 缩放地图。
	     * @param  {Number}  scale                1表示不缩放，2表示地图长宽增大1倍，0.5表示地图长宽缩短一半。
	     * @param  {Boolean} [needUpdate=true]    是否调用update方法更新视角，是则设置为true。
	     * @param  {Boolean} [needCollision=true] 是否调用collision方法进行碰撞检测，是则设置为true。
	     * @param  {Boolean} [emitEnd=true]       是否分发事件给相应的监听器处理，是则设置为true。
	     * @return {ThirdPersonControl}           this。
	     */
	
	  }, {
	    key: 'zoom',
	    value: function zoom(scale) {
	      var needUpdate = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
	      var needCollision = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
	      var emitEnd = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
	
	      this._scale = scale;
	      // this._bound.scaleRadius(this._boundScale / scale);
	
	      if (needUpdate) {
	        this.update();
	      }
	      if (needCollision) {
	        this._mapView.collisionSceneManager.animation(_CollisionAnimation.CAType.Opacity).updateCollision(true);
	      }
	      if (emitEnd) {
	        var event = new _TouchEvent2.default();
	
	        event.type = 'cameraControl';
	        this._mapView.gestureManager.emit('zoomEnd', event);
	      }
	
	      return this;
	    }
	
	    /**
	     * 根据焦距缩放地图，即通过相机视角的位置，与其所正对的地面位置之间的距离，调整地图显示的区域。
	     * @param  {Number}  focalLength          焦距。即相机视角距其正对的地图中心位置的距离。
	     * @param  {Boolean} [needUpdate=true]    是否调用update方法更新视角，是则设置为true。
	     * @param  {Boolean} [needCollision=true] 是否调用collision方法进行碰撞检测，是则设置为true。
	     * @param  {Boolean} [emitEnd=true]       是否分发事件给相应的监听器处理，是则设置为true。
	     * @return {ThirdPersonControl}           this。
	      */
	
	  }, {
	    key: 'zoomByFocalLength',
	    value: function zoomByFocalLength(focalLength) {
	      var needUpdate = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
	      var needCollision = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
	      var emitEnd = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
	
	      var tgToCamVec = new THREE.Vector3();
	
	      tgToCamVec.subVectors(this._camera.position, this._target);
	      this._scale = focalLength / tgToCamVec.length();
	
	      if (needUpdate) {
	        this.update();
	      }
	      if (needCollision) {
	        this._mapView.collisionSceneManager.animation(_CollisionAnimation.CAType.Opacity).updateCollision(true);
	      }
	      if (emitEnd) {
	        var event = new _TouchEvent2.default();
	
	        event.type = 'cameraControl';
	        this._mapView.gestureManager.emit('zoomEnd', event);
	      }
	
	      return this;
	    }
	
	    /**
	     * 将相机视角俯仰到某个角度。
	     * @param  {Number}  angle                俯仰角度，指相机视角与垂直地面直线的夹角，范围0°~90°之间。
	     * @param  {Boolean} [needUpdate=true]    是否调用update方法更新视角，是则设置为true。
	     * @param  {Boolean} [needCollision=true] 是否调用collision方法进行碰撞检测，是则设置为true。
	     * @param  {Boolean} [emitEnd=true]       是否分发事件给相应的监听器处理，是则设置为true。
	     * @return {ThirdPersonControl}           this。
	     */
	
	  }, {
	    key: 'skewTo',
	    value: function skewTo(angle) {
	      var needUpdate = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
	      var needCollision = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
	      var emitEnd = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
	
	      var temp = angle;
	
	      if (angle > this._maxSkewAngle + 0.01) {
	        temp = this._maxSkewAngle + 0.01;
	      } else if (angle < this._minSkewAngle + 0.01) {
	        temp = this._minSkewAngle + 0.01;
	      }
	
	      if (temp === 0) {
	        temp = 0.01;
	      }
	
	      var position = this._camera.position;
	      var target = this._target;
	      var sub = position.clone().sub(target);
	      var preTarget = target.clone().setZ(sub.length() + target.z);
	
	      sub = preTarget.sub(target);
	      this._camera.up.setZ(0);
	
	      var pan = new THREE.Vector3(this._camera.up.y, -this._camera.up.x, 0).normalize();
	
	      this._skewMatrixAngle.makeRotationAxis(pan, temp * TOANGLE);
	      sub.applyMatrix4(this._skewMatrixAngle);
	      position.copy(target).add(sub);
	
	      this._camera.up.applyMatrix4(this._skewMatrixAngle);
	
	      // const tgToCamVec = new THREE.Vector3();
	      // tgToCamVec.subVectors(this._camera.position, this._target);
	      // if ((Math.abs(tgToCamVec.x) < 0.0001) && (Math.abs(tgToCamVec.y) < 0.0001)) {
	      //   this._camera.up.applyMatrix4(this._skewMatrixAngle);
	      // } else {
	      //   this._camera.up.x = -tgToCamVec.x;
	      //   this._camera.up.y = -tgToCamVec.y;
	      //   this._camera.up.z = (tgToCamVec.x * tgToCamVec.x + tgToCamVec.y * tgToCamVec.y) / tgToCamVec.z;
	      //   this._camera.up.normalize();
	      // }
	
	      if (needUpdate) {
	        this.update();
	      }
	      if (needCollision) {
	        this._mapView.collisionSceneManager.animation(_CollisionAnimation.CAType.Opacity).updateCollision(true);
	      }
	      if (emitEnd) {
	        var event = new _TouchEvent2.default();
	
	        event.type = 'cameraControl';
	        this._mapView.gestureManager.emit('skewEnd', event);
	      }
	
	      return this;
	    }
	
	    /**
	     * 获取相机视角俯仰角度。
	     * @return {Number} 俯仰角度,即相机视角与垂直地面直线的夹角。单位度。
	     */
	
	  }, {
	    key: 'getSkew',
	    value: function getSkew() {
	      var sub = this._camera.position.clone().sub(this._target).normalize();
	
	      return sub.angleTo(this._rotateAxis) * TOROTATE;
	    }
	
	    // skew(angle, needUpdate = true, needCollision = true, emitEnd = true) {
	    //   let temp = angle;
	    //   const position = this._camera.position;
	    //   const target = this._target;
	    //   const sub = new THREE.Vector3().copy(position).sub(target);
	    //   const curAngle = sub.angleTo(this._rotateAxis) * TOROTATE;
	    //   // console.log(curAngle);
	    //   if (temp + curAngle > this._maxSkewAngle || temp + curAngle < this._minSkewAngle) {
	    //     temp = 0;
	    //   }
	    //   const pan = this._camera.up.clone();
	    //   pan.cross(sub).normalize();
	    //   this._skewMatrixAngle.makeRotationAxis(pan, temp * TOANGLE);
	    //   sub.applyMatrix4(this._skewMatrixAngle);
	    //   position.copy(target).add(sub);
	    //   this._camera.up.applyMatrix4(this._skewMatrixAngle);
	
	    //   if (needUpdate) {
	    //     this.update();
	    //   }
	    //   if (needCollision) {
	    //     this._mapView.collisionSceneManager.animation(CAType.Opacity).updateCollision(true);
	    //   }
	    //   if (emitEnd) {
	    //     const event = new TouchEvent();
	    //     event.type = 'cameraControl';
	    //     this._mapView.gestureManager.emit('skewEnd', event);
	    //   }
	
	    //   return this;
	    // }
	
	    /**
	     * 在当前相机俯仰角度上再增加一个俯仰的角度。
	     * @param  {Number}  angle                增加的俯仰角度。
	     * @param  {Boolean} [needUpdate=true]    是否调用update方法更新视角，是则设置为true。
	     * @param  {Boolean} [needCollision=true] 是否调用collision方法进行碰撞检测，是则设置为true。
	     * @param  {Boolean} [emitEnd=true]       是否分发事件给相应的监听器处理，是则设置为true。
	     * @return {ThirdPersonControl}           this。
	     */
	
	  }, {
	    key: 'skew',
	    value: function skew(angle) {
	      var needUpdate = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
	      var needCollision = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
	      var emitEnd = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
	
	      var position = this._camera.position;
	      var target = this._target;
	      var sub = new THREE.Vector3().copy(position).sub(target);
	      var curAngle = sub.angleTo(this._rotateAxis) * TOROTATE;
	      var temp = angle;
	
	      if (temp + curAngle > this._maxSkewAngle + 0.01 || temp + curAngle < this._minSkewAngle + 0.01) {
	        temp = 0;
	      } else {
	        var pan = this._camera.up.clone();
	
	        pan.cross(sub).normalize();
	        this._skewMatrixAngle.makeRotationAxis(pan, temp * TOANGLE);
	        sub.applyMatrix4(this._skewMatrixAngle);
	        position.copy(target).add(sub);
	
	        this._camera.up.applyMatrix4(this._skewMatrixAngle);
	
	        // const tgToCamVec = new THREE.Vector3();
	        // tgToCamVec.subVectors(this._camera.position, this._target);
	        // if ((Math.abs(tgToCamVec.x) < 0.0001) && (Math.abs(tgToCamVec.y) < 0.0001)) {
	        //   this._camera.up.applyMatrix4(this._skewMatrixAngle);
	        // } else {
	        //   this._camera.up.x = -tgToCamVec.x;
	        //   this._camera.up.y = -tgToCamVec.y;
	        //   this._camera.up.z = (tgToCamVec.x * tgToCamVec.x + tgToCamVec.y * tgToCamVec.y) / tgToCamVec.z;
	        //   this._camera.up.normalize();
	        // }
	      }
	
	      if (needUpdate) {
	        this.update();
	      }
	      if (needCollision) {
	        this._mapView.collisionSceneManager.animation(_CollisionAnimation.CAType.Opacity).updateCollision(true);
	      }
	      if (emitEnd) {
	        var event = new _TouchEvent2.default();
	
	        event.type = 'cameraControl';
	        this._mapView.gestureManager.emit('skewEnd', event);
	      }
	
	      return this;
	    }
	
	    /**
	     * 获取当前地图旋转角度,即地图正北方向与地图显示画面正上方顺时针夹角。
	     * @return {Number} 旋转角度。
	     */
	
	  }, {
	    key: 'getRotate',
	    value: function getRotate() {
	      var sub = this._camera.position.clone().sub(this._target);
	      var up = this._camera.up.clone().cross(sub).normalize();
	
	      return 360 - this._getAngle(up);
	    }
	
	    // rotate(x, y, angle, needUpdate = true, needCollision = true, emitEnd = true) {
	    //   this._rotateCenter.set(x, y, 0);
	    //   this._rotateMatrixAngle.makeRotationAxis(this._rotateAxis, angle * TOANGLE);
	    //   this._rotatePan.subVectors(this._camera.position, this._rotateCenter);
	    //   this._rotateMatrixAngle.setPosition(this._rotateCenter);
	    //   this._rotatePan.applyMatrix4(this._rotateMatrixAngle);
	    //   this._camera.position.copy(this._rotatePan);
	    //   this._rotatePan.subVectors(this._target, this._rotateCenter);
	    //   this._rotatePan.applyMatrix4(this._rotateMatrixAngle);
	    //   this._target.copy(this._rotatePan);
	    //   this._target.z = 0;
	    //   this._activeCamera.target = this._target;
	    //   this._camera.up.applyMatrix4(this._rotateMatrixAngle);
	
	    //   if (needUpdate) {
	    //     this.update();
	    //   }
	    //   if (needCollision) {
	    //     this._mapView.collisionSceneManager.animation(CAType.Opacity).updateCollision(true);
	    //   }
	    //   if (emitEnd) {
	    //     const event = new TouchEvent();
	    //     event.type = 'cameraControl';
	    //     this._mapView.gestureManager.emit('rotateEnd', event);
	    //   }
	
	    //   return this;
	    // }
	
	    /**
	     * 相机视角围绕Z轴旋转一个增量角度,视觉效果即地图画面绕着一个固定点顺时针或逆时针旋转。
	     * @param  {Number}  x                    旋转中心点的x轴坐标。
	     * @param  {Number}  y                    旋转中心点的y轴坐标。
	     * @param  {Number}  angle                旋转角度。
	     * @param  {Boolean} [needUpdate=true]    是否调用update方法更新视角，是则设置为true。
	     * @param  {Boolean} [needCollision=true] 是否调用collision方法进行碰撞检测，是则设置为true。
	     * @param  {Boolean} [emitEnd=true]       是否分发事件给相应的监听器处理，是则设置为true。
	     * @return {ThirdPersonControl}           this。
	     */
	
	  }, {
	    key: 'rotate',
	    value: function rotate(x, y, angle) {
	      var needUpdate = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
	      var needCollision = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : true;
	      var emitEnd = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : true;
	
	      this._rotateCenter.set(x, y, this._target.z);
	      this._rotateMatrixAngle.makeRotationAxis(this._rotateAxis, angle * TOANGLE);
	      this._rotateMatrixAngle.setPosition(this._rotateCenter);
	
	      var camToCtVecOnPlane = new THREE.Vector3();
	      var tgToCtRelVec = new THREE.Vector3();
	
	      camToCtVecOnPlane.subVectors(this._camera.position, this._rotateCenter);
	      camToCtVecOnPlane.setZ(0);
	      tgToCtRelVec.subVectors(this._target, this._rotateCenter);
	      tgToCtRelVec.setZ(0);
	      tgToCtRelVec = MathExt.default.getRelCoordOnPlane(tgToCtRelVec, camToCtVecOnPlane, new THREE.Vector3(-camToCtVecOnPlane.y, camToCtVecOnPlane.x, 0));
	
	      this._rotatePan.subVectors(this._camera.position, this._rotateCenter);
	      this._rotatePan.applyMatrix4(this._rotateMatrixAngle);
	      this._camera.position.copy(this._rotatePan);
	
	      camToCtVecOnPlane.subVectors(this._camera.position, this._rotateCenter);
	      camToCtVecOnPlane.setZ(0);
	      this._target = MathExt.default.directionalAdd(this._rotateCenter, camToCtVecOnPlane, tgToCtRelVec.x);
	      this._target = MathExt.default.directionalAdd(this._target, new THREE.Vector3(-camToCtVecOnPlane.y, camToCtVecOnPlane.x, 0), tgToCtRelVec.y);
	      this._activeCamera.target = this._target;
	
	      var tgToCamVec = new THREE.Vector3();
	
	      tgToCamVec.subVectors(this._camera.position, this._target);
	      if (Math.abs(tgToCamVec.x) < 0.0001 && Math.abs(tgToCamVec.y) < 0.0001) {
	        this._camera.up.applyMatrix4(this._rotateMatrixAngle);
	      } else {
	        this._camera.up.x = -tgToCamVec.x;
	        this._camera.up.y = -tgToCamVec.y;
	        this._camera.up.z = (tgToCamVec.x * tgToCamVec.x + tgToCamVec.y * tgToCamVec.y) / tgToCamVec.z;
	        this._camera.up.normalize();
	      }
	
	      if (needUpdate) {
	        this.update();
	      }
	      if (needCollision) {
	        this._mapView.collisionSceneManager.animation(_CollisionAnimation.CAType.Opacity).updateCollision(true);
	      }
	      if (emitEnd) {
	        var event = new _TouchEvent2.default();
	
	        event.type = 'cameraControl';
	        this._mapView.gestureManager.emit('rotateEnd', event);
	      }
	
	      return this;
	    }
	
	    /**
	     * 相机视角围绕Z轴旋转至特定角度,视觉效果即地图画面绕着一个固定点顺时针或逆时针旋转了一个角度。
	     * @param  {Number}  x                    旋转中心点的x轴坐标。
	     * @param  {Number}  y                    旋转中心点的y轴坐标。
	     * @param  {Number}  absAngle             一个指定的角度，比如90°。
	     * @param  {Boolean} [needUpdate=true]    是否调用update方法更新视角，是则设置为true。
	     * @param  {Boolean} [needCollision=true] 是否调用collision方法进行碰撞检测，是则设置为true。
	     * @param  {Boolean} [emitEnd=true]       是否分发事件给相应的监听器处理，是则设置为true。
	     * @return {ThirdPersonControl}           this。
	     */
	
	  }, {
	    key: 'rotateTo',
	    value: function rotateTo(x, y, absAngle) {
	      var needUpdate = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
	      var needCollision = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : true;
	      var emitEnd = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : true;
	
	      this.rotate(x, y, -this.getRotate(), false, false, false);
	      this.rotate(x, y, absAngle, false, false, false);
	
	      if (needUpdate) {
	        this.update();
	      }
	      if (needCollision) {
	        this._mapView.collisionSceneManager.updateCollision();
	      }
	      if (emitEnd) {
	        var event = new _TouchEvent2.default();
	
	        event.type = 'cameraControl';
	        this._mapView.gestureManager.emit('rotateEnd', event);
	      }
	
	      return this;
	    }
	
	    /**
	     * Change the zoom status. Zoom status will be 2 if the distance is less than the minimal
	     * distance, 1 if is greater than the maximal distance otherwise 0.
	     * @private
	     * @param  {Number} status Zoom status.
	     * @return {ThirdPersonControl} This.
	     */
	
	  }, {
	    key: '_changeZoomStatus',
	    value: function _changeZoomStatus(status) {
	      if (status === this._curZoomStatus) {
	        return null;
	      }
	      this._curZoomStatus = status;
	      this.emit('changeZoomStatus', this, this._curZoomStatus);
	
	      return this;
	    }
	
	    /**
	     * Move the map to the left for passed distance.
	     * @private
	     * @param  {Number}        distance     Movement distance.
	     * @param  {THREE.Matrix4} objectMatrix Camera matrix.
	     * @return {ThirdPersonControl} This.
	     */
	
	  }, {
	    key: '_moveLeft',
	    value: function _moveLeft(distance, objectMatrix) {
	      var v = new THREE.Vector3();
	
	      v.setFromMatrixColumn(objectMatrix, 0);
	      v.multiplyScalar(-distance);
	
	      this._panOffset.add(v);
	      this._panOffset.z = 0;
	
	      return this;
	    }
	
	    /**
	     * Move forward the map for passed distance.
	     * @private
	     * @param  {Number}        distance     Movement distance.
	     * @param  {THREE.Matrix4} objectMatrix Camera matrix.
	     * @return {ThirdPersonControl} This.
	     */
	
	  }, {
	    key: '_moveForward',
	    value: function _moveForward(distance, objectMatrix) {
	      var v = new THREE.Vector3();
	
	      v.setFromMatrixColumn(objectMatrix, 1);
	      v.multiplyScalar(distance);
	
	      this._panOffset.add(v);
	      this._panOffset.z = 0;
	
	      return this;
	    }
	
	    /**
	     * Set a vector from a spherical.
	     * @private
	     * @param {THREE.Vector3}   v Vector.
	     * @param {THREE.Spherical} s Spherical.
	     * @return {THREE.Vector3} Vector.
	     */
	
	  }, {
	    key: '_setFromSpherical',
	    value: function _setFromSpherical(v, s) {
	      var sinPhiRadius = Math.sin(s.phi) * s.radius;
	
	      v.y = sinPhiRadius * Math.sin(s.theta);
	      v.z = Math.cos(s.phi) * s.radius;
	      v.x = sinPhiRadius * Math.cos(s.theta);
	
	      return v;
	    }
	
	    /**
	     * Calcaulate the z of camera position.
	     * @private
	     * @return {ThirdPersonControl} This.
	     */
	
	  }, {
	    key: '_calculateCameraZ',
	    value: function _calculateCameraZ() {
	      if (this._curDistance === 0) {
	        return null;
	      }
	
	      var position = this._camera.position;
	      var newDistance = position.distanceTo(this._target);
	
	      if (newDistance > this._maxDistance) {
	        newDistance = this._maxDistance;
	      }
	      if (newDistance < this._minDistance) {
	        newDistance = this._minDistance;
	      }
	      this._offset.copy(this._lastPosition).sub(this._target);
	      this._offset.normalize().multiplyScalar(newDistance);
	      position.copy(this._target).add(this._offset);
	
	      return this;
	    }
	
	    /**
	     * Set a spherical from a vector.
	     * @private
	     * @param {THREE.Spherical} spherical Spherical.
	     * @param {THREE.Vector3}   vec3      Vector.
	     * @return {THREE.Spherical} Spherical.
	     */
	
	  }, {
	    key: '_setFromVector3',
	    value: function _setFromVector3(spherical, vec3) {
	      spherical.radius = vec3.length();
	      if (spherical.radius === 0) {
	        spherical.theta = 0;
	        spherical.phi = 0;
	      } else {
	        spherical.theta = Math.atan2(vec3.y, vec3.x);
	        spherical.phi = Math.acos(THREE.Math.clamp(vec3.z / spherical.radius, -1, 1));
	      }
	
	      return spherical;
	    }
	
	    /**
	     * Get the angle between 2 vector.
	     * @private
	     * @param  {THREE.Vector3} from From vector.
	     * @param  {THREE.Vector3} to   To vector.
	     * @return {Number}      angle.
	     */
	
	  }, {
	    key: '_getVectorAngle',
	    value: function _getVectorAngle(from, to) {
	      var fromLength = from.length();
	      var toLength = to.length();
	
	      if (fromLength === 0 || toLength === 0) {
	        return 0;
	      }
	
	      return Math.acos(to.dot(from) / (fromLength * toLength)) * TOROTATE;
	    }
	
	    // _skewAngle(angle, sub) {
	    // }
	
	    /**
	     * Get rotation angle from a vector (up of camera in most cases).
	     * @private
	     * @param  {THREE.Vector3} v Vector.
	     * @return {Number}   Angle.
	     */
	
	  }, {
	    key: '_getAngle1',
	    value: function _getAngle1(v) {
	      if (v.z === 0) {
	        return v.y > 0 ? 180 : 0;
	      } else if (v.y === 0) {
	        return v.z > 0 ? 90 : 270;
	      }
	
	      var tmp = THREE.Math.clamp(v.z / Math.sqrt(v.y * v.y + v.z * v.z), -1, 1);
	      var angle = Math.atan(Math.sqrt(1 - tmp * tmp) / tmp) * TOROTATE;
	
	      if (v.y < 0 && v.z < 0) {
	        return angle + 270;
	      } else if (v.y < 0 && v.z > 0) {
	        return angle + 90;
	      } else if (v.y > 0 && v.z > 0) {
	        return 90 - angle;
	      } else if (v.y > 0 && v.z < 0) {
	        return 270 - angle;
	      }
	      return angle;
	    }
	
	    /**
	     * Get rotation angle from a vector (up of camera in most cases).
	     * @private
	     * @param  {THREE.Vector3} v Vector.
	     * @return {Number}   Angle.
	     */
	
	  }, {
	    key: '_getAngle',
	    value: function _getAngle(v) {
	      if (v.y === 0) {
	        return v.x < 0 ? 180 : 0;
	      } else if (v.x === 0) {
	        return v.y < 0 ? 90 : 270;
	      }
	
	      var tmp = THREE.Math.clamp(v.y / Math.sqrt(v.x * v.x + v.y * v.y), -1, 1);
	      var angle = Math.atan(Math.sqrt(1 - tmp * tmp) / tmp) * TOROTATE;
	
	      if (v.x > 0 && v.y > 0) {
	        return angle + 270;
	      } else if (v.x > 0 && v.y < 0) {
	        return angle + 90;
	      } else if (v.x < 0 && v.y < 0) {
	        return 90 - angle;
	      } else if (v.x < 0 && v.y > 0) {
	        return 270 - angle;
	      }
	      return angle;
	    }
	  }, {
	    key: 'minDistance',
	    set: function set(distance) {
	      if (distance >= 0 && distance < this._maxDistance) {
	        this._minDistance = distance;
	      }
	    }
	
	    /**
	     * minDistance getter.
	     * @ignore
	     * @return {Number} minDistance
	     */
	    ,
	    get: function get() {
	      return this._minDistance;
	    }
	
	    /**
	     * 设置最大缩放距离，即允许相机(视角)距离地面的最大高度。
	     * @type {Number}
	     * @param  {Number} distance 缩放距离,单位米。
	     */
	
	  }, {
	    key: 'maxDistance',
	    set: function set(distance) {
	      if (distance > this._minDistance) {
	        this._maxDistance = distance;
	      }
	    }
	
	    /**
	     * maxDistance getter.
	     * @ignore
	     * @return {Number} maxDistance.
	     */
	    ,
	    get: function get() {
	      return this._maxDistance;
	    }
	
	    /**
	     * 设置最小俯仰角度，即相机视角与垂直地面直线最小的夹角。
	     * @type {Number}
	     * @param  {Number} skew 俯仰角度,单位度。
	     */
	
	  }, {
	    key: 'minSkewAngle',
	    set: function set(skew) {
	      if (skew >= 0 && skew <= this._maxSkewAngle) {
	        this._minSkewAngle = skew;
	        if (this.getSkew() < this._minSkewAngle) {
	          this.skewTo(this._minSkewAngle);
	        }
	      }
	    }
	
	    /**
	     * minSkewAngle getter.
	     * @ignore
	     * @return {Number} minSkewAngle.
	     */
	    ,
	    get: function get() {
	      return this._minSkewAngle;
	    }
	
	    /**
	     * 设置最大俯仰角度，即相机视角与垂直地面直线最大的夹角。
	     * @type {Number}
	     * @param  {Number} skew 俯仰角度,单位度。
	     */
	
	  }, {
	    key: 'maxSkewAngle',
	    set: function set(skew) {
	      if (skew <= 90 && skew >= this._minSkewAngle) {
	        this._maxSkewAngle = skew;
	        if (this.getSkew() > this._maxSkewAngle) {
	          this.skewTo(this._maxSkewAngle);
	        }
	      }
	    }
	
	    /**
	     * maxSkewAngle getter.
	     * @ignore
	     * @return {Number} maxSkewAngle.
	     */
	    ,
	    get: function get() {
	      return this._maxSkewAngle;
	    }
	
	    /**
	     * boundScale setter. The parameter must be a number greater than 0.
	     * @ignore
	     * @param  {Number} scale Scale of bound.
	     */
	
	  }, {
	    key: 'boundScale',
	    set: function set(scale) {
	      if (isNaN(scale) || !isFinite(scale) || scale <= 0) {
	        throw new Error('Invalid bound scale');
	      }
	      this._boundScale = scale;
	    }
	
	    /**
	     * boundScale getter.
	     * @ignore
	     * @return {Number} Scale.
	     */
	    ,
	    get: function get() {
	      return this._boundScale;
	    }
	  }, {
	    key: 'target',
	    set: function set(target) {
	      this._target = target;
	    },
	    get: function get() {
	      return this._target;
	    }
	  }, {
	    key: 'focalLength',
	    get: function get() {
	      var tgToCamVec = new THREE.Vector3();
	      return tgToCamVec.subVectors(this._camera.position, this._target).length();
	    }
	  }]);
	
	  return ThirdPersonControl;
	}(_NGRObject3.default);
	
	exports.default = ThirdPersonControl;

/***/ }),
/* 144 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.ThreeCamera = undefined;
	
	var _ThreeCamera = __webpack_require__(32);
	
	var _ThreeCamera2 = _interopRequireDefault(_ThreeCamera);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	// import ThirdPersonControl from './control/ThirdPersonControl';
	
	exports.ThreeCamera = _ThreeCamera2.default; // import CameraNode from './CameraNode';

/***/ }),
/* 145 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _assign = __webpack_require__(1);
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };
	
	var _Control2 = __webpack_require__(16);
	
	var _Control3 = _interopRequireDefault(_Control2);
	
	var _dom = __webpack_require__(11);
	
	var _AnimatorFactory = __webpack_require__(9);
	
	var _AnimatorFactory2 = _interopRequireDefault(_AnimatorFactory);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	/**
	 * 指南针控件,用于在地图上放置指南针控件实时指示地图朝向。
	 * @extends {NGR.control.Control}
	 * @memberOf NGR.control
	 */
	var CompassControl = function (_Control) {
	  _inherits(CompassControl, _Control);
	
	  /**
	   * 构造方法。
	   * @param  {Object}     [options]         控件选项,即构成控件的一些配置元素。
	   * @param  {HTMLElment} [options.element] 放置控件的DOM元素。
	   * @param  {String}     [options.name]    控件的名字，比如设置此参数为'name'，控件的名字为'compass-name'。
	   */
	  function CompassControl() {
	    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
	
	    _classCallCheck(this, CompassControl);
	
	    var name = options.name ? 'compass-' + options.name : 'compass';
	
	    var _this = _possibleConstructorReturn(this, (CompassControl.__proto__ || Object.getPrototypeOf(CompassControl)).call(this, name, _assign({
	      position: 'topright'
	    }, options)));
	
	    _this._currentAngle = null;
	    _this._disabled = true;
	    if (!_this._element) {
	      _this._element = _dom.DOMUtils.createElement('div', 'ngr-compass');
	      // TODO toggle activity via clicking button.
	      _this._button = _dom.DOMUtils.createElement('div', 'compass-button', _this._element);
	      // this._button.href = '#';
	      _this._divCompass = _dom.DOMUtils.createElement('div', 'compass-icon', _this._button);
	    }
	
	    _this.rotateCompass = _this.rotateCompass.bind(_this);
	    _this._onClick = _this._onClick.bind(_this);
	    return _this;
	  }
	
	  /**
	   * @override
	   */
	
	
	  _createClass(CompassControl, [{
	    key: '_onAdd',
	    value: function _onAdd(mapView) {
	      _get(CompassControl.prototype.__proto__ || Object.getPrototypeOf(CompassControl.prototype), '_onAdd', this).call(this, mapView);
	      this._disabled = false;
	      this._map.gestureManager.on('rotate', 'rotateEnd', this.rotateCompass);
	
	      this._button.addEventListener('click', this._onClick);
	
	      return this;
	    }
	
	    /**
	     * @override
	     */
	
	  }, {
	    key: '_onRemove',
	    value: function _onRemove(mapView) {
	      _get(CompassControl.prototype.__proto__ || Object.getPrototypeOf(CompassControl.prototype), '_onRemove', this).call(this, mapView);
	      this._disabled = true;
	      this._map.gestureManager.off('rotate', 'rotateEnd', this.rotateCompass);
	
	      this._button.removeEventListener('click', this._onClick);
	
	      return this;
	    }
	  }, {
	    key: 'disable',
	    value: function disable() {
	      this._disabled = true;
	      // TODO
	    }
	  }, {
	    key: 'enable',
	    value: function enable() {
	      this._disabled = false;
	      // TODO
	    }
	  }, {
	    key: 'rotateCompass',
	    value: function rotateCompass() {
	      if (this._map.activeControl) {
	        var angle = this._map.activeControl.getRotate();
	
	        this._currentAngle = angle;
	        this.onUpdate(this._divCompass || this._element, angle);
	      }
	    }
	  }, {
	    key: 'onUpdate',
	    value: function onUpdate(element, angle) {
	      element.style.webkitTransform = 'rotate(' + angle + 'deg)';
	    }
	  }, {
	    key: 'onClick',
	    value: function onClick() {
	      var actCtrl = this._map.activeControl;
	      var startAng = this._currentAngle;
	      var endAng = startAng > 180 ? 360 : 0;
	
	      _AnimatorFactory2.default.getInstance().ofNumber(startAng, endAng, 300).on('update', function (animator, _ref) {
	        var num = _ref.num;
	
	        actCtrl.rotateTo(0, 0, num, true, false, false);
	      }).on('complete', function () {
	        actCtrl.rotateTo(0, 0, endAng, true, true, true);
	      }).start();
	    }
	  }, {
	    key: '_onClick',
	    value: function _onClick() {
	      this.onClick();
	    }
	
	    /**
	     * 获取指南针当前所指角度。
	     * @return {Number} 当前角度，即地图正北方向与屏幕正上方的夹角。
	     */
	
	  }, {
	    key: 'getCurrentAngle',
	    value: function getCurrentAngle() {
	      return this._currentAngle;
	    }
	  }]);
	
	  return CompassControl;
	}(_Control3.default);
	
	exports.default = CompassControl;

/***/ }),
/* 146 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _assign = __webpack_require__(1);
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };
	
	var _ToggleControl2 = __webpack_require__(33);
	
	var _ToggleControl3 = _interopRequireDefault(_ToggleControl2);
	
	var _AnimatorFactory = __webpack_require__(9);
	
	var _AnimatorFactory2 = _interopRequireDefault(_AnimatorFactory);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var DimensionControl = function (_ToggleControl) {
	  _inherits(DimensionControl, _ToggleControl);
	
	  function DimensionControl() {
	    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
	
	    _classCallCheck(this, DimensionControl);
	
	    var _this = _possibleConstructorReturn(this, (DimensionControl.__proto__ || Object.getPrototypeOf(DimensionControl)).call(this, _assign({
	      name: 'dimension',
	      innerHTML: '2D',
	      className: 'toggle-dimension',
	      minSkewAngle: 0,
	      maxSkewAngle: 60
	    }, options)));
	
	    _this._onToggle = _this._onToggle.bind(_this);
	    return _this;
	  }
	
	  _createClass(DimensionControl, [{
	    key: '_onToggle',
	    value: function _onToggle(e) {
	      var selected = e.selected;
	      var activeControl = this._map.activeControl,
	          _options = this._options,
	          maxSkewAngle = _options.maxSkewAngle,
	          minSkewAngle = _options.minSkewAngle,
	          button = this._button;
	
	      var curSkewAngle = activeControl.getSkew();
	      var destSkewAngle = 0;
	
	      if (selected) {
	        button.innerHTML = '3D';
	        destSkewAngle = minSkewAngle;
	      } else {
	        button.innerHTML = '2D';
	        destSkewAngle = maxSkewAngle;
	      }
	
	      _AnimatorFactory2.default.getInstance().ofNumber(curSkewAngle, destSkewAngle, 300).on('update', function (animator, _ref) {
	        var num = _ref.num;
	
	        activeControl.skewTo(num, true, false, false);
	      }).on('complete', function () {
	        activeControl.skewTo(destSkewAngle, true, true, true);
	      }).start();
	
	      return this;
	    }
	  }, {
	    key: '_onAdd',
	    value: function _onAdd(mapView) {
	      _get(DimensionControl.prototype.__proto__ || Object.getPrototypeOf(DimensionControl.prototype), '_onAdd', this).call(this, mapView);
	      this.on('toggle', this._onToggle);
	
	      return this;
	    }
	  }, {
	    key: '_onRemove',
	    value: function _onRemove(mapView) {
	      _get(DimensionControl.prototype.__proto__ || Object.getPrototypeOf(DimensionControl.prototype), '_onRemove', this).call(this, mapView);
	      this.off('toggle', this._onToggle);
	
	      return this;
	    }
	  }]);
	
	  return DimensionControl;
	}(_ToggleControl3.default);
	
	exports.default = DimensionControl;

/***/ }),
/* 147 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _assign = __webpack_require__(1);
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };
	
	var _ToggleControl2 = __webpack_require__(33);
	
	var _ToggleControl3 = _interopRequireDefault(_ToggleControl2);
	
	var _AnimatorFactory = __webpack_require__(9);
	
	var _AnimatorFactory2 = _interopRequireDefault(_AnimatorFactory);
	
	var _dom = __webpack_require__(11);
	
	var _lang = __webpack_require__(4);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	/**
	 * Initial options.
	 * @ignore
	 * @type {Object}
	 */
	var initOpts = {
	  className: 'ngr-toggle-facility',
	  selectedDisplay: 'block',
	  floorControlName: 'multiFloor',
	  blurOpacity: 0.3,
	  animation: {
	    type: 'scale',
	    minScale: 25,
	    maxScale: 50
	  }
	};
	
	/**
	 * 公共设施控件类。公共设施控件可用于选择需要显示的公共设施,如电梯、扶梯等。点击该控件后可展开公共设施类型。
	 * @emits NGR.control.FacilityControl#toggle
	 * @extends {NGR.control.ToggleControl}
	 * @memberOf NGR.control
	 */
	
	var FacilityControl = function (_ToggleControl) {
	  _inherits(FacilityControl, _ToggleControl);
	
	  /**
	   * 构造方法
	   * @param  {Object[]}   facilityList                              公共设施控件对象数组。这个对象数组内的每一个元素必须包含类别(categories)属性。该属性
	   *                                                                是一个数字的数组，每个数字代表一个类别。每个控件内的元素还可以包含以下其他属性：
	   *                                                                id - 显示公共设施按钮的id；
	   *                                                                innerHTML - 公共设施按钮的innerHTML；
	   *                                                                backgroundImage - 公共设施按钮的背景图。
	   * @param  {Object}     [options]                                 控件选项，即构成控件的一些配置元素。
	   * @param  {HTMLElment} [options.element]                         控件的DOM元素。
	   * @param  {String}     [options.name]                            控件的名字，比如设置此参数为'name'，控件的名字为'facility-name'。
	   * @param  {String}     [options.className='ngr-toggle-facility'] 控件DOM元素的类名。
	   * @param  {Boolean}    [options.disabled=false]                  初始化时是否可用，默认为false，即可用。
	   * @param  {Boolean}    [options.selected=false]                  初始化时是否被选中。
	   * @param  {String}     [options.innerHTML='']                    公共设施控件按钮的innerHTML。
	   * @param  {String}     [options.selectedDisplay='block']         当公共设施控件被选中时，是否显示其子控件。子控件用于表示不同种类的公共设施。
	   * @param  {String}     [options.floorControlName='multiFloor']   楼层控件的name。
	   * @param  {Number}     [options.blurOpacity=0.3]                 非焦点楼层的透明度。
	   */
	  function FacilityControl(facilityList) {
	    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
	
	    _classCallCheck(this, FacilityControl);
	
	    var fList = (0, _lang.isArray)(facilityList) ? facilityList : [];
	
	    var _this = _possibleConstructorReturn(this, (FacilityControl.__proto__ || Object.getPrototypeOf(FacilityControl)).call(this, _assign({}, initOpts, options)));
	
	    _this._name = _this._options.name ? 'facility-' + _this._options.name : 'facility';
	
	    _this.facilityContainer = _dom.DOMUtils.createElement('div', 'ngr-facility-container');
	
	    _this.facilityItems = [];
	    for (var _iterator = fList, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
	      var _ref;
	
	      if (_isArray) {
	        if (_i >= _iterator.length) break;
	        _ref = _iterator[_i++];
	      } else {
	        _i = _iterator.next();
	        if (_i.done) break;
	        _ref = _i.value;
	      }
	
	      var obj = _ref;
	
	      var item = _dom.DOMUtils.createElement('div', 'ngr-facility-button', _this.facilityContainer);
	      var id = obj.id,
	          backgroudImage = obj.backgroudImage,
	          innerHTML = obj.innerHTML,
	          categories = obj.categories;
	
	
	      item.categories = categories;
	      if (id) {
	        item.id = id;
	      }
	      if (innerHTML) {
	        item.innerHTML = innerHTML;
	      }
	      if (backgroudImage) {
	        item.style['background-image'] = 'url(' + obj.backgroudImage + ')';
	      }
	
	      _this.facilityItems.push(item);
	    }
	
	    _this._blurOpacity = _this._options.blurOpacity;
	
	    _this.unblur = false;
	    _this.facilityAnimationId = 0;
	    _this.facilityAnimationCounts = {};
	
	    _this.onToggle = _this.onToggle.bind(_this);
	    _this.onFacilityClick = _this.onFacilityClick.bind(_this);
	    return _this;
	  }
	
	  /**
	   * @override
	   */
	
	
	  _createClass(FacilityControl, [{
	    key: '_onAdd',
	    value: function _onAdd(mapView) {
	      _get(FacilityControl.prototype.__proto__ || Object.getPrototypeOf(FacilityControl.prototype), '_onAdd', this).call(this, mapView);
	      this._container.appendChild(this.facilityContainer);
	
	      this.onToggle({
	        selected: this._selected,
	        targetControl: this
	      });
	      this.on('toggle', this.onToggle);
	      for (var _iterator2 = this.facilityItems, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator]();;) {
	        var _ref2;
	
	        if (_isArray2) {
	          if (_i2 >= _iterator2.length) break;
	          _ref2 = _iterator2[_i2++];
	        } else {
	          _i2 = _iterator2.next();
	          if (_i2.done) break;
	          _ref2 = _i2.value;
	        }
	
	        var item = _ref2;
	
	        item.addEventListener('click', this.onFacilityClick, false);
	      }
	
	      return this;
	    }
	
	    /**
	     * @override
	     */
	
	  }, {
	    key: '_onRemove',
	    value: function _onRemove(mapView) {
	      _get(FacilityControl.prototype.__proto__ || Object.getPrototypeOf(FacilityControl.prototype), '_onRemove', this).call(this, mapView);
	      this._container.removeChild(this.facilityContainer);
	
	      this.off('toggle', this.onToggle);
	      for (var _iterator3 = this.facilityItems, _isArray3 = Array.isArray(_iterator3), _i3 = 0, _iterator3 = _isArray3 ? _iterator3 : _iterator3[Symbol.iterator]();;) {
	        var _ref3;
	
	        if (_isArray3) {
	          if (_i3 >= _iterator3.length) break;
	          _ref3 = _iterator3[_i3++];
	        } else {
	          _i3 = _iterator3.next();
	          if (_i3.done) break;
	          _ref3 = _i3.value;
	        }
	
	        var item = _ref3;
	
	        item.removeEventListener('click', this.onFacilityClick);
	      }
	
	      return this;
	    }
	  }, {
	    key: 'onToggle',
	    value: function onToggle(_ref4) {
	      var selected = _ref4.selected;
	
	      this.facilityContainer.style.display = selected ? this._options.selectedDisplay : 'none';
	
	      return this;
	    }
	  }, {
	    key: 'onFacilityClick',
	    value: function onFacilityClick(_ref5) {
	      var categories = _ref5.target.categories;
	
	      if (categories) {
	        this._initFacilityAnimationByCategory(categories);
	      }
	
	      return this;
	    }
	
	    /**
	     * Initialize animation for facilities in some categories.
	     * @private
	     * @param  {Number[]} categories Categories list.
	     * @return {undefined}
	     */
	
	  }, {
	    key: '_initFacilityAnimationByCategory',
	    value: function _initFacilityAnimationByCategory(categories) {
	      var _this2 = this;
	
	      var mapView = this._map;
	      var curPGs = mapView.currentPlanarGraphIds;
	      var floorControl = mapView.getDomControl(this._options.floorControlName);
	      var _options$animation = this._options.animation,
	          minScale = _options$animation.minScale,
	          maxScale = _options$animation.maxScale;
	
	
	      if (!floorControl) {
	        throw new Error('FacilityControl: Invalid floor control name');
	      }
	
	      var focusPG = floorControl.getCurrentFloor();
	      var counts = {
	        maxCount: curPGs.length,
	        curCount: 0
	      };
	      var id = this.facilityAnimationId++;
	
	      // every facility animation has its own counts
	      this.facilityAnimationCounts[id] = counts;
	
	      for (var _iterator4 = curPGs, _isArray4 = Array.isArray(_iterator4), _i4 = 0, _iterator4 = _isArray4 ? _iterator4 : _iterator4[Symbol.iterator]();;) {
	        var _ref6;
	
	        if (_isArray4) {
	          if (_i4 >= _iterator4.length) break;
	          _ref6 = _iterator4[_i4++];
	        } else {
	          _i4 = _iterator4.next();
	          if (_i4.done) break;
	          _ref6 = _i4.value;
	        }
	
	        var PGId = _ref6;
	
	        var layer = mapView.getLayer(PGId).getLayer('Facility');
	
	        // set visible and opacity at first because target facilities may be hided by
	        // collision detection
	        mapView.sceneManager.setVisible(layer, 'category', categories, true);
	        mapView.sceneManager.setOpacity(layer, 'category', categories, this.unblur || PGId === Number(focusPG) ? 1 : this.blurOpacity);
	        this._startFacilityAnimation(layer, categories, minScale, maxScale, function () {
	          var counts = _this2.facilityAnimationCounts[id];
	
	          counts.curCount++;
	          if (counts.curCount >= counts.maxCount) {
	            // if all animations of each planargraph were completed, update collision
	            delete _this2.facilityAnimationCounts[id];
	            mapView.collisionSceneManager.updateCollision();
	          }
	        });
	      }
	    }
	  }, {
	    key: '_startFacilityAnimation',
	    value: function _startFacilityAnimation(layer, category, startScale, endScale, onComplete) {
	      var delay = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;
	
	      var _this3 = this;
	
	      var duration = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : 300;
	      var repeat = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : 2;
	
	      _AnimatorFactory2.default.getInstance().ofNumber(startScale, endScale + startScale, duration).on('update', function (animator, _ref7) {
	        var num = _ref7.num;
	        // eslint-disable-line no-unused-vars
	        // simulate uniform-velocity scale-down after scale-up
	        var scale = num > 2 * startScale ? 2 * endScale - num : num;
	        _this3._map.sceneManager.setScale(layer, 'category', category, scale, scale, 0);
	      }).on('complete', onComplete).delay(delay).repeat(repeat).start();
	    }
	
	    /**
	     * @override
	     */
	
	  }, {
	    key: 'hide',
	    value: function hide() {
	      _get(FacilityControl.prototype.__proto__ || Object.getPrototypeOf(FacilityControl.prototype), 'hide', this).call(this);
	      this.facilityContainer.style.display = 'none';
	    }
	
	    /**
	     * @override
	     */
	
	  }, {
	    key: 'display',
	    value: function display() {
	      var _display = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'block';
	
	      _get(FacilityControl.prototype.__proto__ || Object.getPrototypeOf(FacilityControl.prototype), 'display', this).call(this, _display);
	      if (_display !== 'none' && this.getSelected()) {
	        this.facilityContainer.style.display = this._options.selectedDisplay;
	      }
	    }
	  }, {
	    key: 'unblur',
	    set: function set(unblur) {
	      this._unblur = unblur;
	    },
	    get: function get() {
	      return this._unblur;
	    }
	  }, {
	    key: 'blurOpacity',
	    set: function set(opacity) {
	      this._blurOpacity = opacity;
	    },
	    get: function get() {
	      return this._blurOpacity;
	    }
	  }]);
	
	  return FacilityControl;
	}(_ToggleControl3.default);
	
	exports.default = FacilityControl;

/***/ }),
/* 148 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _assign = __webpack_require__(1);
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };
	
	var _FloorControl2 = __webpack_require__(60);
	
	var _FloorControl3 = _interopRequireDefault(_FloorControl2);
	
	var _ToggleControl = __webpack_require__(33);
	
	var _ToggleControl2 = _interopRequireDefault(_ToggleControl);
	
	var _AnimatorFactory = __webpack_require__(9);
	
	var _AnimatorFactory2 = _interopRequireDefault(_AnimatorFactory);
	
	var _CollisionAnimation = __webpack_require__(25);
	
	var _lang = __webpack_require__(4);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	/**
	 * Initial floor control options.
	 * @ignore
	 * @type {Object}
	 */
	var initFlrOpts = {
	  className: 'ngr-multi-floor-switcher',
	  scrollOptions: {
	    disabled: false,
	    barHeight: 27,
	    maxBarCount: null
	  }
	};
	
	/**
	 * Initial floor toggle control options.
	 * @ignore
	 * @type {Object}
	 */
	var initTogOpts = {
	  selected: true,
	  className: 'ngr-toggle-floor',
	  position: 'bottomright',
	  name: 'floor'
	};
	
	/**
	 * 多楼层控件类,可同时显示多个楼层。此控件内已经写好楼层改变时的回调，可以不在应用层另外监听楼层切换事件。
	 * @eimits NGR.control.multiFloorControl#change
	 * @extends {NGR.control.FloorControl}
	 * @memberOf NGR.control
	 */
	
	var multiFloorControl = function (_FloorControl) {
	  _inherits(multiFloorControl, _FloorControl);
	
	  /**
	   * 构造方法。
	   * @param  {Object}     [options]                                      控件选项，即构成控件的一些配置元素。
	   * @param  {HTMLElment} [options.element]                              控件的DOM元素。
	   * @param  {String}     [options.name]                                 控件的名字，比如设置此参数为'name'，控件的名字为'multiFloor-name'。
	   * @param  {String}     [options.className='ngr-multi-floor-switcher'] 控件DOM元素的类名。
	   */
	  function multiFloorControl(options) {
	    _classCallCheck(this, multiFloorControl);
	
	    var opts = _assign({}, initFlrOpts, options);
	    var toggleOpts = _assign({}, initTogOpts, opts.toggleOptions);
	
	    var _this = _possibleConstructorReturn(this, (multiFloorControl.__proto__ || Object.getPrototypeOf(multiFloorControl)).call(this, opts));
	
	    _this._name = opts.name ? 'multiFloor-' + opts.name : 'multiFloor';
	
	    _this.toggle = new _ToggleControl2.default(toggleOpts);
	
	    _this._defaulPriority = _this._options.defaulPriority ? _this._options.defaulPriority : 4;
	    _this._ignoreOpacityLayers = _this._options.ignoreOpacityLayers ? _this._options.ignoreOpacityLayers : ['pickMarker'];
	    _this._blurOpacity = _this._options.blurOpacity ? _this._options.blurOpacity : 0.3;
	
	    _this._floorAnimationCount = 0;
	
	    if (_this._options.scrollOptions.maxBarCount) {
	      _this._element.style['max-height'] = _this._options.scrollOptions.maxBarCount * _this._options.scrollOptions.barHeight + 'px';
	    }
	
	    _this.onToggle = _this.onToggle.bind(_this);
	    _this.onFloorChange = _this.onFloorChange.bind(_this);
	    return _this;
	  }
	
	  /**
	   * @override
	   */
	
	
	  _createClass(multiFloorControl, [{
	    key: 'setContainer',
	    value: function setContainer(container) {
	      _get(multiFloorControl.prototype.__proto__ || Object.getPrototypeOf(multiFloorControl.prototype), 'setContainer', this).call(this, container);
	
	      // set container of toggle
	      this.toggle.setContainer(container);
	
	      return this;
	    }
	
	    /**
	     * @override
	     */
	
	  }, {
	    key: '_onAdd',
	    value: function _onAdd(mapView) {
	      _get(multiFloorControl.prototype.__proto__ || Object.getPrototypeOf(multiFloorControl.prototype), '_onAdd', this).call(this, mapView);
	
	      // add toggle to map
	      this.toggle._onAdd(mapView);
	
	      // listen event
	      this.on('change', this.onFloorChange);
	      this.toggle.on('toggle', this.onToggle);
	    }
	
	    /**
	     * @override
	     */
	
	  }, {
	    key: '_onRemove',
	    value: function _onRemove(mapView) {
	      _get(multiFloorControl.prototype.__proto__ || Object.getPrototypeOf(multiFloorControl.prototype), '_onRemove', this).call(this, mapView);
	
	      // remove toggle
	      this.toggle._onRemove(mapView);
	      this.toggle._map = null;
	
	      // unbind event listener
	      this.off('change', this.onFloorChange);
	      this.toggle.off('toggle', this.onToggle);
	    }
	
	    /**
	     * @override
	     */
	
	  }, {
	    key: 'hide',
	    value: function hide() {
	      _get(multiFloorControl.prototype.__proto__ || Object.getPrototypeOf(multiFloorControl.prototype), 'hide', this).call(this);
	
	      // hide toggle
	      this.toggle.hide();
	
	      return this;
	    }
	
	    /**
	     * @override
	     */
	
	  }, {
	    key: 'display',
	    value: function display() {
	      var _display = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'block';
	
	      _get(multiFloorControl.prototype.__proto__ || Object.getPrototypeOf(multiFloorControl.prototype), 'display', this).call(this, _display);
	
	      // display toggle
	      this.toggle.display(_display);
	
	      return this;
	    }
	  }, {
	    key: 'disable',
	    value: function disable() {
	      _get(multiFloorControl.prototype.__proto__ || Object.getPrototypeOf(multiFloorControl.prototype), 'disable', this).call(this);
	      this.toggle.disable();
	
	      return this;
	    }
	  }, {
	    key: 'enable',
	    value: function enable() {
	      _get(multiFloorControl.prototype.__proto__ || Object.getPrototypeOf(multiFloorControl.prototype), 'enable', this).call(this);
	      this.toggle.enable();
	
	      return this;
	    }
	
	    /**
	     * Initialize and start floor position animation.
	     * @private
	     * @param  {Number|String} id                Layer id.
	     * @param  {Number}        startZ            Start z position.
	     * @param  {Number}        endZ              End z position.
	     * @param  {Function}      [onComplete=null] Callback on complete.
	     * @param  {Number}        [delay=0]         Delay milisecoonds.
	     * @param  {Number}        [duration=300]    Duration miliseconds.
	     * @return {NGR.control.MultiFloorControl}   this.
	     */
	
	  }, {
	    key: '_startFloorAnimation',
	    value: function _startFloorAnimation(id, startZ, endZ) {
	      var onComplete = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
	
	      var _this2 = this;
	
	      var delay = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;
	      var duration = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 300;
	
	      if (!this._map) {
	        return this;
	      }
	
	      var layer = this._map.getLayer(id);
	
	      _AnimatorFactory2.default.getInstance().ofNumber(startZ, endZ, duration).on('update', function (animator, _ref) {
	        var num = _ref.num;
	        // eslint-disable-line no-unused-vars
	        _this2._map.sceneManager.quickSetPosition(layer, null, null, 0, 0, num);
	      }).on('complete', onComplete).delay(delay).start();
	
	      return this;
	    }
	
	    /**
	     * Set the collision detection priority of area text and facility in a planargraph.
	     * @private
	     * @param {Number|String} PGId             Planargraph id.
	     * @param {Number|String} oldPGId          Old planangraph id.
	     * @param {Number}        priority         Priority.
	     * @return {NGR.control.MultiFloorControl} this.
	     */
	
	  }, {
	    key: '_setPGPriority',
	    value: function _setPGPriority(PGId, oldPGId, priority) {
	      var _this3 = this;
	
	      if (oldPGId) {
	        this._setPGPriority(oldPGId, null, this._defaulPriority + 1);
	      }
	      if (!PGId) {
	        return this;
	      }
	
	      var layerGroup = this._map.getLayer(PGId);
	      var areaText = layerGroup.getLayer('AreaText');
	      var facility = layerGroup.getLayer('Facility');
	
	      if (areaText) {
	        areaText.visit(function (feature) {
	          feature.priority = priority === _this3._defaulPriority ? priority - 1 : priority;
	        });
	      }
	      if (facility) {
	        facility.visit(function (feature) {
	          feature.priority = priority;
	        });
	      }
	
	      return this;
	    }
	
	    /**
	     * Batch set the opacity of a planargraph.
	     * @private
	     * @param {String|Number} id               Planargraph id.
	     * @param {Number}        opacity          Number in the range of [0, 1].
	     * @return {NGR.control.MultiFloorControl} this.
	     */
	
	  }, {
	    key: '_setPGOpacity',
	    value: function _setPGOpacity(id, opacity) {
	      var _this4 = this;
	
	      var layerGroup = this._map.getLayer(id);
	
	      if (!layerGroup) {
	        return this;
	      }
	
	      layerGroup.foreach(function (name, layer) {
	        var index = _this4._ignoreOpacityLayers.indexOf(name);
	
	        if (index === -1) {
	          _this4._map.sceneManager.setOpacity(layer, null, null, opacity);
	        }
	      });
	
	      return this;
	    }
	
	    /**
	     * Highlight a planargraph in a list of planargraphs by setting their opacity.
	     * @private
	     * @param  {String|Number}     targetPG          Id of target planargraph.
	     * @param  {String[]|Number[]} PGs               Planargraph ids.
	     * @param  {Number}            otherOpacity      Opacity of none-highlight planargraph.
	     * @param  {Number}            [targetOpacity=1] Opacity of highlight planargraph.
	     * @return {NGR.control.MultiFloorControl}       this.
	     */
	
	  }, {
	    key: '_highlightPG',
	    value: function _highlightPG(targetPG, PGs, otherOpacity) {
	      var targetOpacity = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;
	
	      for (var _iterator = PGs, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
	        var _ref2;
	
	        if (_isArray) {
	          if (_i >= _iterator.length) break;
	          _ref2 = _iterator[_i++];
	        } else {
	          _i = _iterator.next();
	          if (_i.done) break;
	          _ref2 = _i.value;
	        }
	
	        var PGId = _ref2;
	
	        if (PGId === Number(targetPG)) {
	          this._setPGOpacity(PGId, targetOpacity);
	        } else {
	          this._setPGOpacity(PGId, otherOpacity);
	        }
	      }
	
	      return this;
	    }
	
	    /**
	     * 高亮显示楼层。通常用于多楼层显示，一般用来显示当前楼层。
	     * @param  {Number[]} targetPGs            需要高亮显示的楼层数组。
	     * @return {NGR.control.MultiFloorControl} this。
	     */
	
	  }, {
	    key: 'highlightPGs',
	    value: function highlightPGs(targetPGs) {
	      if ((0, _lang.isArray)(targetPGs)) {
	        if (targetPGs.length === 1) {
	          this._highlightPG(targetPGs[0], this._map.currentPlanarGraphIds, this._blurOpacity);
	          this._setPGPriority(targetPGs[0], null, this._defaulPriority);
	        } else {
	          for (var _iterator2 = targetPGs, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator]();;) {
	            var _ref3;
	
	            if (_isArray2) {
	              if (_i2 >= _iterator2.length) break;
	              _ref3 = _iterator2[_i2++];
	            } else {
	              _i2 = _iterator2.next();
	              if (_i2.done) break;
	              _ref3 = _i2.value;
	            }
	
	            var PGId = _ref3;
	
	            this._setPGOpacity(PGId, 1);
	          }
	          this._setPGPriority(null, this.currentFloor, this._defaulPriority);
	        }
	      }
	
	      return this;
	    }
	
	    /**
	     * 多楼层模式时楼层改变的回调，可重写。
	     * @param  {Event} e                       多楼层切换事件。
	     * @return {NGR.control.MultiFloorControl} this。
	     */
	
	  }, {
	    key: 'onMultiFloorChange',
	    value: function onMultiFloorChange(e) {
	      var _this5 = this;
	
	      var mapView = this._map;
	      var allPGs = mapView.planarGraphs;
	      var _mapView$activeContro = mapView.activeControl._target,
	          x = _mapView$activeContro.x,
	          y = _mapView$activeContro.y,
	          z = _mapView$activeContro.z;
	
	
	      _AnimatorFactory2.default.getInstance().ofNumber(z, allPGs.indexOf(Number(e.to)) * mapView._floorHeight, 300).on('update', function (animator, _ref4) {
	        var num = _ref4.num;
	
	        mapView.activeControl.moveToPoint(x, y, num, true, false, false);
	      }).on('complete', function () {
	        mapView.collisionSceneManager.animation(_CollisionAnimation.CAType.Opacity).updateCollision(true);
	
	        _this5.enable();
	        _this5.toggle.disabled = false;
	
	        _this5.fire('animationCompleted', { targetControl: _this5 });
	      }).start();
	
	      // set opacity and priority
	      this._highlightPG(e.to, allPGs, this._blurOpacity);
	      this._setPGPriority(e.to, e.from, this._defaulPriority);
	
	      return this;
	    }
	
	    /**
	     * 只显示单个楼层时楼层改变的回调，可重写。
	     * @param  {Event} e                       楼层切换事件。
	     * @return {NGR.control.MultiFloorControl} this。
	     */
	
	  }, {
	    key: 'onSingleFloorChange',
	    value: function onSingleFloorChange(e) {
	      var _this6 = this;
	
	      var mapView = this._map;
	      var indexFrom = mapView.planarGraphs.indexOf(Number(e.from));
	      var indexTo = mapView.planarGraphs.indexOf(Number(e.to));
	      var maxZ = mapView.activeControl.maxDistance + 50;
	
	      if (indexTo === -1 || indexFrom === -1) {
	        throw new Error('MultiFloorControl: Invalid index');
	      }
	
	      var layerGroup = mapView.getLayer(e.to);
	      var areaText = layerGroup.getLayer('AreaText');
	      var facility = layerGroup.getLayer('Facility');
	
	      // recover opacity
	      this._setPGOpacity(e.to, 1);
	
	      mapView.showPlanarGraphs([e.to], false);
	      mapView.sceneManager.setOpacity(areaText, null, null, 0);
	      mapView.sceneManager.setOpacity(facility, null, null, 0);
	
	      mapView.collisionSceneManager.animation(_CollisionAnimation.CAType.Opacity).updateCollision(true);
	      this._startFloorAnimation(e.to, indexTo < indexFrom ? -maxZ : maxZ, 0, function () {
	        mapView.sceneManager.setOpacity(areaText, null, null, 1);
	        mapView.sceneManager.setOpacity(facility, null, null, 1);
	        mapView.collisionSceneManager.animation(_CollisionAnimation.CAType.Opacity).updateCollision(true);
	        // mapView.collisionSceneManager.updateCollision();
	
	        _this6.enable();
	        _this6.toggle.disabled = false;
	
	        _this6.fire('animationCompleted', { targetControl: _this6 });
	      });
	
	      return this;
	    }
	  }, {
	    key: 'onToggle',
	    value: function onToggle(_ref5) {
	      var _this7 = this;
	
	      var selected = _ref5.selected;
	
	      var mapView = this._map;
	      var curFloor = this.getCurrentFloor();
	      var allPGs = mapView.planarGraphs;
	      var floorHeight = mapView._floorHeight;
	      var maxZ = mapView.activeControl.maxDistance + 50;
	      var _mapView$activeContro2 = mapView.activeControl._target,
	          x = _mapView$activeContro2.x,
	          y = _mapView$activeContro2.y;
	
	      var curHeight = 0;
	      var below = true;
	      var startZ = void 0,
	          endZ = void 0;
	
	      this.disable();
	      this.toggle.disabled = false;
	
	      // initialize animation
	      if (selected) {
	        // set floor change callback
	        // window.floorChangeFunction = onMultiFloorChange;
	
	        var onComplete = function onComplete() {
	          // enable floor control after all floor animations complete
	          _this7._floorAnimationCount++;
	          if (_this7._floorAnimationCount >= allPGs.length) {
	            mapView.next(1, function () {
	              mapView.collisionSceneManager.animation(_CollisionAnimation.CAType.Opacity).updateCollision(true);
	            });
	
	            _this7.enable();
	            _this7.toggle.disabled = false;
	
	            _this7.fire('animationCompleted', { targetControl: _this7 });
	
	            _this7._floorAnimationCount = 0;
	
	            _this7._map.sceneManager._octreeManager.rebuild();
	          }
	        };
	        this._setPGPriority(curFloor, null, this._defaulPriority);
	        mapView.showPlanarGraphs(allPGs);
	        this._highlightPG(curFloor, allPGs, this._blurOpacity);
	        for (var _iterator3 = allPGs, _isArray3 = Array.isArray(_iterator3), _i3 = 0, _iterator3 = _isArray3 ? _iterator3 : _iterator3[Symbol.iterator]();;) {
	          var _ref6;
	
	          if (_isArray3) {
	            if (_i3 >= _iterator3.length) break;
	            _ref6 = _iterator3[_i3++];
	          } else {
	            _i3 = _iterator3.next();
	            if (_i3.done) break;
	            _ref6 = _i3.value;
	          }
	
	          var PGId = _ref6;
	
	          if (PGId === Number(curFloor)) {
	            startZ = 0;
	            below = false;
	          } else {
	            startZ = below ? -maxZ : maxZ;
	          }
	          this._startFloorAnimation(PGId, startZ, curHeight, onComplete);
	          curHeight += floorHeight;
	        }
	
	        mapView.activeControl.moveToPoint(x, y, allPGs.indexOf(Number(curFloor)) * floorHeight, true, true, false);
	      } else {
	        // set floor change callback
	        // window.floorChangeFunction = onSingleFloorChange;
	
	        var _onComplete = function _onComplete() {
	          // show planar graph after all floor animations complete
	          _this7._floorAnimationCount++;
	          if (_this7._floorAnimationCount >= allPGs.length) {
	            mapView.showPlanarGraphs([curFloor]);
	            // mapView.collisionSceneManager.animation(NGR.webGL.CAType.Opacity).updateCollision(true);
	            _this7.enable();
	            _this7.toggle.disabled = false;
	
	            _this7.fire('animationCompleted', { targetControl: _this7 });
	
	            _this7._floorAnimationCount = 0;
	
	            _this7._map.sceneManager._octreeManager.rebuild();
	          }
	        };
	        this._setPGPriority(null, curFloor, this._defaulPriority);
	        for (var _iterator4 = allPGs, _isArray4 = Array.isArray(_iterator4), _i4 = 0, _iterator4 = _isArray4 ? _iterator4 : _iterator4[Symbol.iterator]();;) {
	          var _ref7;
	
	          if (_isArray4) {
	            if (_i4 >= _iterator4.length) break;
	            _ref7 = _iterator4[_i4++];
	          } else {
	            _i4 = _iterator4.next();
	            if (_i4.done) break;
	            _ref7 = _i4.value;
	          }
	
	          var _PGId = _ref7;
	
	          if (_PGId === Number(curFloor)) {
	            endZ = 0;
	            below = false;
	          } else {
	            endZ = below ? -maxZ : maxZ;
	          }
	          this._startFloorAnimation(_PGId, curHeight, endZ, _onComplete);
	        }
	
	        mapView.activeControl.moveToPoint(x, y, 0, true, false, false);
	      }
	    }
	
	    /**
	     * Scroll floor control by current floor id.
	     * @private
	     * @param  {Number} floorId                Floor id.
	     * @return {NGR.control.MultiFloorControl} this.
	     */
	
	  }, {
	    key: '_scrollByFloor',
	    value: function _scrollByFloor(floorId) {
	      var mapHeight = this._map.height;
	      var switcher = this._element;
	      var floors = this._map.planarGraphs.concat().reverse();
	      var index = floors.indexOf(Number(floorId));
	      var barHeight = this._options.scrollOptions.barHeight;
	      var maxBarCount = this._options.scrollOptions.maxBarCount;
	      var offset = void 0;
	
	      if (index === -1) {
	        return this;
	      }
	
	      // get max bar count of floor control
	      if (maxBarCount) {
	        // pass
	      } else if (mapHeight <= 510) {
	        maxBarCount = 4;
	      } else if (mapHeight <= 550) {
	        maxBarCount = 5;
	      } else {
	        maxBarCount = 7;
	      }
	
	      var maxOffset = (floors.length - maxBarCount) * barHeight;
	
	      if (maxOffset <= 0) {
	        return this;
	      }
	
	      // compute the final scroll top
	      offset = barHeight * (index - window.Math.floor((maxBarCount - 1) / 2));
	      if (offset < 0) {
	        offset = 0;
	      } else if (offset > maxOffset) {
	        offset = maxOffset;
	      }
	
	      // start animation
	      _AnimatorFactory2.default.getInstance().ofNumber(switcher.scrollTop, offset, 300).on('update', function (animator, _ref8) {
	        var num = _ref8.num;
	
	        switcher.scrollTop = num;
	      }).start();
	
	      return this;
	    }
	  }, {
	    key: 'onFloorChange',
	    value: function onFloorChange(e) {
	      if (e.from === e.to) {
	        return this;
	      }
	
	      if (!this._options.scrollOptions.disabled) {
	        this._scrollByFloor(Number(e.to));
	      }
	
	      this.disable();
	      this.toggle.disabled = false;
	
	      if (this.toggle.getSelected()) {
	        this.onMultiFloorChange(e);
	      } else {
	        this.onSingleFloorChange(e);
	      }
	
	      this.setCurrentFloor(e.to);
	
	      return this;
	    }
	
	    /**
	     * Set current floor.
	     * @override
	     * @private
	     * @param {Nubmer} floorId                 Floor id.
	     * @return {NGR.control.MultiFloorControl} this.
	     */
	
	  }, {
	    key: 'setCurrentFloor',
	    value: function setCurrentFloor(floorId) {
	      _get(multiFloorControl.prototype.__proto__ || Object.getPrototypeOf(multiFloorControl.prototype), 'setCurrentFloor', this).call(this, floorId);
	      if (!this._options.scrollOptions.disabled) {
	        this._scrollByFloor(Number(floorId));
	      }
	
	      return this;
	    }
	  }]);
	
	  return multiFloorControl;
	}(_FloorControl3.default);
	
	exports.default = multiFloorControl;

/***/ }),
/* 149 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _assign = __webpack_require__(1);
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };
	
	var _Control2 = __webpack_require__(16);
	
	var _Control3 = _interopRequireDefault(_Control2);
	
	var _dom = __webpack_require__(11);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	/**
	 * 比例尺控件,用以在地图上显示地图与实际距离的比例。
	 * @extends {NGR.control.Control}
	 * @memberOf NGR.control
	 */
	var ScaleControl = function (_Control) {
	  _inherits(ScaleControl, _Control);
	
	  /**
	   * 构造方法。
	   * @param  {Object}     [options]              控件选项，即构成控件的一些配置元素。
	   * @param  {HTMLElment} [options.element]      控件的DOM元素。
	   * @param  {String}     [options.name]         控件的名字，比如设置此参数为'name'，控件的名字为'scale-name'。
	   * @param  {Number}     [options.maxWidth=100] 比例尺最大像素长度，默认为100。
	   */
	  function ScaleControl() {
	    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
	
	    _classCallCheck(this, ScaleControl);
	
	    var name = options.name ? 'scale-' + options.name : 'scale';
	
	    var _this = _possibleConstructorReturn(this, (ScaleControl.__proto__ || Object.getPrototypeOf(ScaleControl)).call(this, name, _assign({
	      maxWidth: 100,
	      position: 'bottomleft'
	    }, options)));
	
	    _this._element = _dom.DOMUtils.createElement('div', 'ngr-control-scale');
	
	    _this.update = _this.update.bind(_this);
	    return _this;
	  }
	
	  _createClass(ScaleControl, [{
	    key: 'disable',
	    value: function disable() {
	      this.hide();
	
	      return this;
	    }
	  }, {
	    key: 'enable',
	    value: function enable() {
	      this.display();
	
	      return this;
	    }
	  }, {
	    key: 'update',
	    value: function update() {
	      var _this2 = this;
	
	      this._map.next(1, function () {
	        var maxMeters = _this2._map.activeCamera.getMetersPerPixel() * _this2._options.maxWidth;
	        var meters = _this2._getRoundNum(maxMeters);
	        var scaleWidth = Math.round(meters / maxMeters * _this2._options.maxWidth);
	
	        _this2._scaleMiddle.style.width = scaleWidth + 'px';
	        _this2._scaleEdgeRight.style.left = scaleWidth + 1 + 'px';
	        _this2._scaleText.innerHTML = meters + '\u7C73';
	        _this2._scaleText.style.width = scaleWidth + 'px';
	      });
	    }
	
	    /**
	     * @override
	     */
	
	  }, {
	    key: '_onAdd',
	    value: function _onAdd(mapView) {
	      _get(ScaleControl.prototype.__proto__ || Object.getPrototypeOf(ScaleControl.prototype), '_onAdd', this).call(this, mapView);
	
	      var className = 'ngr-control-scale';
	
	      this._scaleText = _dom.DOMUtils.createElement('div', className + '-text', this._element);
	      this._scaleLine = _dom.DOMUtils.createElement('div', className + '-line', this._element);
	      this._scaleEdgeLeft = _dom.DOMUtils.createElement('div', className + '-edgeleft', this._scaleLine);
	      this._scaleEdgeRight = _dom.DOMUtils.createElement('div', className + '-edgeright', this._scaleLine);
	      this._scaleMiddle = _dom.DOMUtils.createElement('div', className + '-middle', this._scaleLine);
	
	      this._map.gestureManager.on('zoomEnd', this.update);
	      // this._map.next(1, this.update);
	
	      return this;
	    }
	
	    /**
	     * @override
	     */
	
	  }, {
	    key: '_onRemove',
	    value: function _onRemove(mapView) {
	      _get(ScaleControl.prototype.__proto__ || Object.getPrototypeOf(ScaleControl.prototype), '_onRemove', this).call(this, mapView);
	      this._map.gestureManager.off('zoomEnd', this.update);
	
	      return this;
	    }
	
	    /**
	     * Get the round number (e.g. 10, 20, 50).
	     * @private
	     * @param  {Number} num Number to be rounded.
	     * @return {Number}     Round number
	     */
	
	  }, {
	    key: '_getRoundNum',
	    value: function _getRoundNum(num) {
	      var pow10 = Math.pow(10, ('' + Math.floor(num)).length - 1);
	      var d = num / pow10;
	
	      if (d >= 10) {
	        d = 10;
	      } else if (d >= 5) {
	        d = 5;
	      } else if (d >= 2) {
	        d = 2;
	      } else {
	        d = 1;
	      }
	
	      return pow10 * d;
	    }
	  }]);
	
	  return ScaleControl;
	}(_Control3.default);
	
	exports.default = ScaleControl;

/***/ }),
/* 150 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _assign = __webpack_require__(1);
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };
	
	var _Control2 = __webpack_require__(16);
	
	var _Control3 = _interopRequireDefault(_Control2);
	
	var _dom = __webpack_require__(11);
	
	var _lang = __webpack_require__(4);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	/**
	 * initial options.
	 * @ignore
	 * @type {Object}
	 */
	var initOptions = {
	  size: '100px', // width or height of the slider.
	  min: 0, // minimal value of the slider.
	  max: 250, // maximal value of the slider.
	  step: 1, // incremental step of values in range.
	  id: 'slider', // name of the slider.
	  value: 50, // onload value of the slider.
	  collapsed: true, // whether the slider collapses when it looses focus.
	  title: 'NGR Slider', // value of the title attribute.
	  logo: 'S', // innerHTML of the button when collapsed.
	  orientation: 'horizontal', // orientation of the slider, either 'horizontal' or 'vertical'.
	  increment: false, // whether or not there should be increment and decrement buttons next to the slider.
	  getValue: function getValue(value) {
	    // the function called to transform the input of the slider into the value shown by showValue.
	    return value;
	  },
	  showValue: true, // whether or not the value of the input should be shown next to the slider.
	  syncSlider: false };
	
	/**
	 * 滑块控件，可用于滑动操作控制缩放效果等。
	 * @extends {NGR.control.Control}
	 * @memberOf NGR.control
	 */
	
	var SliderControl = function (_Control) {
	  _inherits(SliderControl, _Control);
	
	  /**
	   * Constructor.
	   * @param  {Function}   func                               滑块控件位置更新时的回调。
	   * @param  {Object}     [options]                          控件选项，即构成控件的一些配置元素。
	   * @param  {HTMLElment} [options.element]                  控件的DOM元素。
	   * @param  {String}     [options.name]                     控件的名字，比如设置此参数为'name'，控件的名字为'slider-name'。
	   * @param  {String}     [options.size='100px']             控件大小。根据orientation属性确定，当orientation为“horizontal”时表示宽，当为“vertical”则表示高。
	   * @param  {Number}     [options.min=0]                    控件能表示的最小值。
	   * @param  {Number}     [options.max=250]                  控件能表示的最大值。
	   * @param  {Number}     [options.step=1]                   移动控件时值变化的步长。
	   * @param  {String}     [options.id='slider']              控件元素的id。
	   * @param  {Number}     [options.value=50]                 控件所表示的初始值。
	   * @param  {Boolean}    [options.collapsed=true]           控件失去焦点时是否隐藏。
	   * @param  {String}     [options.title='NGR Slider']       控件元素的title。
	   * @param  {String}     [options.logo='S']                 控件折叠时的innerHTML。
	   * @param  {String}     [options.orientation='horizontal'] 控件朝向，还可以选'vertical'。
	   * @param  {Boolean}    [options.icrement=false]           滑块条两端是否加上增减按钮。
	   * @param  {Function}   [options.getValue]                 这个方法在值变化时调用，参数为值，在滑块顶端显示值。
	   * @param  {Boolean}    [options.showValue=true]           是否在滑块顶端显示值。
	   * @param  {Boolean}    [options.syncSlider=true]          如果设为true，每次值变化时都会调用update，否则在值变化结束时才调用update。
	   */
	  function SliderControl(func) {
	    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
	
	    _classCallCheck(this, SliderControl);
	
	    var _this = _possibleConstructorReturn(this, (SliderControl.__proto__ || Object.getPrototypeOf(SliderControl)).call(this, options.name ? 'slider-' + options.name : 'slider', _assign({}, initOptions, options)));
	
	    if ((0, _lang.isFunction)(func)) {
	      _this.update = func;
	    } else {
	      _this.update = function (value) {
	        console.log(value);
	      };
	    }
	    if (!(0, _lang.isFunction)(_this._options.getValue)) {
	      _this._options.getValue = function (value) {
	        return value;
	      };
	    }
	    if (_this._options.orientation !== 'vertical') {
	      _this._options.orientation = 'horizontal';
	    }
	
	    _this._updateValue = _this._updateValue.bind(_this);
	    _this._expand = _this._expand.bind(_this);
	    _this._collapse = _this._collapse.bind(_this);
	    _this._increment = _this._increment.bind(_this);
	    _this._decrement = _this._decrement.bind(_this);
	    return _this;
	  }
	
	  /**
	   * @override
	   */
	
	
	  _createClass(SliderControl, [{
	    key: '_onAdd',
	    value: function _onAdd(mapView) {
	      this._initLayout();
	      _get(SliderControl.prototype.__proto__ || Object.getPrototypeOf(SliderControl.prototype), '_onAdd', this).call(this, mapView);
	      // this.update(this._options.value);
	
	      return this;
	    }
	  }, {
	    key: '_updateValue',
	    value: function _updateValue() {
	      var _options = this._options,
	          showValue = _options.showValue,
	          getValue = _options.getValue;
	
	
	      this.value = this.slider.value;
	      if (showValue) {
	        this._sliderValue.innerHTML = getValue(this.value);
	      }
	      this.update(this.value);
	    }
	  }, {
	    key: '_expand',
	    value: function _expand() {
	      _dom.DOMUtils.addClass(this._element, 'ngr-control-slider-expanded');
	      this.slider.focus();
	    }
	  }, {
	    key: '_collapse',
	    value: function _collapse() {
	      _dom.DOMUtils.removeClass(this._element, 'ngr-control-slider-expanded');
	    }
	  }, {
	    key: '_increment',
	    value: function _increment() {
	      // console.log(`${this.slider.value - this.slider.step} ${this.slider.value + this.slider.step}`);
	      this.slider.value = Number(this.slider.value) + Number(this.slider.step);
	      this._updateValue();
	    }
	  }, {
	    key: '_decrement',
	    value: function _decrement() {
	      // console.log(`${this.slider.value - this.slider.step} ${this.slider.value + this.slider.step}`);
	      this.slider.value = Number(this.slider.value) - Number(this.slider.step);
	      this._updateValue();
	    }
	
	    /**
	     * 设置控件表示的值。
	     * @param {Number} value               控件所表示的值。
	     * @return {NGR.control.SliderControl} this。
	     */
	
	  }, {
	    key: 'setValue',
	    value: function setValue(value) {
	      var _options2 = this._options,
	          min = _options2.min,
	          max = _options2.max,
	          showValue = _options2.showValue,
	          getValue = _options2.getValue;
	
	
	      if ((0, _lang.isNumber)(value) && value >= min && value <= max) {
	        this.slider.value = value;
	        this.value = this.slider.value;
	        if (showValue) {
	          this._sliderValue.innerHTML = getValue(this.value);
	        }
	      }
	
	      return this;
	    }
	
	    /**
	     * Iinitialize layout elements.
	     * @private
	     * @return {NGR.control.SliderControl} this.
	     */
	
	  }, {
	    key: '_initLayout',
	    value: function _initLayout() {
	      var _this2 = this;
	
	      var className = 'ngr-control-slider';
	      var _options3 = this._options,
	          orientation = _options3.orientation,
	          title = _options3.title,
	          logo = _options3.logo,
	          getValue = _options3.getValue,
	          value = _options3.value,
	          showValue = _options3.showValue,
	          increment = _options3.increment,
	          id = _options3.id,
	          min = _options3.min,
	          max = _options3.max,
	          step = _options3.step,
	          syncSlider = _options3.syncSlider,
	          size = _options3.size,
	          collapsed = _options3.collapsed;
	
	
	      if (this._element) {
	        console.warn('SliderControl: Element will be overrided');
	      }
	
	      this._element = _dom.DOMUtils.createElement('div', className + ' ' + className + '-' + orientation);
	      this._sliderLink = _dom.DOMUtils.createElement('a', className + '-toggle', this._element);
	      this._sliderLink.setAttribute('title', title);
	      this._sliderLink.setAttribute('href', '#');
	      this._sliderLink.innerHTML = logo;
	
	      if (showValue) {
	        this._sliderValue = _dom.DOMUtils.createElement('p', className + '-value', this._element);
	        this._sliderValue.innerHTML = getValue(value);
	      }
	
	      if (increment) {
	        this._plus = _dom.DOMUtils.createElement('a', className + '-plus', this._element);
	        this._plus.innerHTML = '+';
	        this._plus.addEventListener('click', this._increment, false);
	        _dom.DOMUtils.addClass(this._element, 'ngr-control-slider-incdec');
	      }
	
	      this._sliderContainer = _dom.DOMUtils.createElement('div', 'ngr-slider-container', this._element);
	      this.slider = _dom.DOMUtils.createElement('input', 'ngr-slider', this._sliderContainer);
	      if (orientation === 'vertical') {
	        this.slider.setAttribute('orient', 'vertical');
	      }
	      this.slider.setAttribute('title', title);
	      this.slider.setAttribute('id', id);
	      this.slider.setAttribute('type', 'range');
	      this.slider.setAttribute('min', min);
	      this.slider.setAttribute('max', max);
	      this.slider.setAttribute('step', step);
	      this.slider.setAttribute('value', value);
	      if (syncSlider) {
	        this.slider.addEventListener('input', this._updateValue, false);
	      } else {
	        this.slider.addEventListener('change', this._updateValue, false);
	      }
	
	      this.slider.addEventListener('change', function () {
	        _this2.emit('slideEnd', _this2.slider.value);
	      }, false);
	
	      // control html layout through element appendding order?
	      if (increment) {
	        this._minius = _dom.DOMUtils.createElement('a', className + '-minus', this._element);
	        this._minius.innerHTML = '-';
	        this._minius.addEventListener('click', this._decrement, false);
	      }
	
	      if (showValue) {
	        if (window.matchMedia('screen and (-webkit-min-device-pixel-ratio:0)').matches && orientation === 'vertical') {
	          this.slider.style.width = size.replace('px', '') - 36 + 'px';
	          this._sliderContainer.style.height = size.replace('px', '') - 36 + 'px';
	        } else if (orientation === 'vertical') {
	          this._sliderContainer.style.height = size.replace('px', '') - 36 + 'px';
	        } else {
	          this._sliderContainer.style.width = size.replace('px', '') - 56 + 'px';
	        }
	      } else {
	        if (window.matchMedia('screen and (-webkit-min-device-pixel-ratio:0)').matches && orientation === 'vertical') {
	          // eslint-disable-line
	          this.slider.style.width = size.replace('px', '') - 10 + 'px';
	          this._sliderContainer.style.height = size.replace('px', '') - 10 + 'px';
	        } else if (orientation === 'vertical') {
	          this._sliderContainer.style.height = size.replace('px', '') - 10 + 'px';
	        } else {
	          this._sliderContainer.style.width = size.replace('px', '') - 25 + 'px';
	        }
	      }
	
	      _dom.DOMUtils.disableClickPropagation(this._element);
	
	      if (collapsed) {
	        this._sliderLink.addEventListener('click', _dom.DOMUtils.stop);
	        this._sliderLink.addEventListener('click', this._expand);
	        this.slider.addEventListener('blur', this._collapse);
	      } else {
	        this._expand();
	      }
	    }
	  }]);
	
	  return SliderControl;
	}(_Control3.default);
	
	exports.default = SliderControl;

/***/ }),
/* 151 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _assign = __webpack_require__(1);
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };
	
	var _Control2 = __webpack_require__(16);
	
	var _Control3 = _interopRequireDefault(_Control2);
	
	var _dom = __webpack_require__(11);
	
	var _AnimatorFactory = __webpack_require__(9);
	
	var _AnimatorFactory2 = _interopRequireDefault(_AnimatorFactory);
	
	var _lang = __webpack_require__(4);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	/**
	 * 缩放控件,用于控制地图显示的范围和细节。
	 * @extends {NGR.control.Control}
	 * @memberOf NGR.control
	 */
	var ZoomControl = function (_Control) {
	  _inherits(ZoomControl, _Control);
	
	  /**
	   * 构造方法。
	   * @param  {Object}     [options] 控件选项，即构成控件的一些配置元素。
	   * @param  {HTMLElment} [options.element]             控件的DOM元素。
	   * @param  {String}     [options.name]                控件的名字，比如设置此参数为'name'，控件的名字为'zoom-name'。
	   * @param  {String}     [options.zoomInText='+']      放大按钮的innerHTML。
	   * @param  {String}     [options.zoomInTitle='放大']  放大按钮的名称。
	   * @param  {String}     [options.zoomOutText='-']     缩小按钮的innerHTML。
	   * @param  {String}     [options.zoomOutTitle='缩小'] 缩小按钮的名称。
	   */
	  function ZoomControl(options) {
	    _classCallCheck(this, ZoomControl);
	
	    var opts = _assign({
	      zoomInText: '+',
	      zoomInTitle: '放大',
	      zoomOutText: '-',
	      zoomOutTitle: '缩小',
	      animation: {
	        disabled: false,
	        duration: 300
	      },
	      position: 'bottomright'
	    }, options);
	    var name = opts.name ? 'zoom-' + opts.name : 'zoom';
	
	    var _this = _possibleConstructorReturn(this, (ZoomControl.__proto__ || Object.getPrototypeOf(ZoomControl)).call(this, name, opts));
	
	    if (!_this._element) {
	      _this._element = _dom.DOMUtils.createElement('div', 'ngr-control-zoom ngr-bar');
	      _this._zoomInButton = _this._createButton(_this._options.zoomInText, _this._options.zoomInTitle, 'ngr-control-zoom-in', _this._element, _this.zoomIn);
	      _this._zoomOutButton = _this._createButton(_this._options.zoomOutText, _this._options.zoomOutTitle, 'ngr-control-zoom-out', _this._element, _this.zoomOut);
	    }
	
	    _this.updateDisabled = _this.updateDisabled.bind(_this);
	    _this.zoomIn = _this.zoomIn.bind(_this);
	    _this.zoomOut = _this.zoomOut.bind(_this);
	    return _this;
	  }
	
	  /**
	   * @override
	   */
	
	
	  _createClass(ZoomControl, [{
	    key: '_onAdd',
	    value: function _onAdd(mapView) {
	      _get(ZoomControl.prototype.__proto__ || Object.getPrototypeOf(ZoomControl.prototype), '_onAdd', this).call(this, mapView);
	      if (this._map.activeControl && this._zoomInButton && this._zoomOutButton) {
	        this._map.activeControl.on('changeZoomStatus', this.updateDisabled);
	      }
	
	      return this;
	    }
	
	    /**
	     * @override
	     */
	
	  }, {
	    key: '_onRemove',
	    value: function _onRemove(mapView) {
	      _get(ZoomControl.prototype.__proto__ || Object.getPrototypeOf(ZoomControl.prototype), '_onRemove', this).call(this, mapView);
	      if (this._map.activeControl && this._zoomInButton && this._zoomOutButton) {
	        this._map.activeControl.off('changeZoomStatus', this.updateDisabled);
	      }
	
	      return this;
	    }
	
	    /**
	     * Create a button and bind cilck handle.
	     * @private
	     * @param  {String}      html      Inner html.
	     * @param  {String}      title     Html element title.
	     * @param  {String}      className Html element class name.
	     * @param  {HTMLElement} container Parent of element.
	     * @param  {Function}    fn        Callback function.
	     * @return {HTMLElement}           Button element.
	     */
	
	  }, {
	    key: '_createButton',
	    value: function _createButton(html, title, className, container, fn) {
	      var _this2 = this;
	
	      var link = _dom.DOMUtils.createElement('a', className, container);
	
	      link.innerHTML = html;
	      link.href = '#';
	      link.title = title;
	
	      link.addEventListener('click', function (e) {
	        var ret = null;
	
	        _dom.DOMUtils.stopPropagation(e);
	        _dom.DOMUtils.preventDefault(e);
	        ret = fn.call(_this2, e);
	        _this2._refocusOnMap();
	
	        return ret;
	      }, false);
	      link.addEventListener('mousedown', _dom.DOMUtils.stopPropagation, false);
	      link.addEventListener('dblclick', _dom.DOMUtils.stopPropagation, false);
	
	      return link;
	    }
	  }, {
	    key: 'updateDisabled',
	    value: function updateDisabled(event, status) {
	      var className = 'ngr-disabled';
	
	      if (this._zoomInButton && this._zoomOutButton) {
	        _dom.DOMUtils.removeClass(this._zoomInButton, className);
	        _dom.DOMUtils.removeClass(this._zoomOutButton, className);
	
	        if (status === 2) {
	          _dom.DOMUtils.addClass(this._zoomInButton, className);
	        }
	        if (status === 1) {
	          _dom.DOMUtils.addClass(this._zoomOutButton, className);
	        }
	      }
	
	      return this;
	    }
	
	    /**
	     * Start zoom animation
	     * @private
	     * @param  {Number} startDist        Start distance.
	     * @param  {Number} endDist          End distance.
	     * @param  {Number} duration         Animation duration.
	     * @return {NGR.control.ZoomControl} this.
	     */
	
	  }, {
	    key: '_startZoomAnimation',
	    value: function _startZoomAnimation(startDist, endDist, duration) {
	      var _this3 = this;
	
	      _AnimatorFactory2.default.getInstance().ofNumber(startDist, endDist, duration).on('update', function (animator, _ref) {
	        var num = _ref.num;
	
	        _this3._map.activeControl.zoomByFocalLength(num, true, false, false);
	      }).on('complete', function () {
	        _this3._map.activeControl.zoomByFocalLength(endDist, true, true, true);
	      }).start();
	
	      return this;
	    }
	  }, {
	    key: 'zoomIn',
	    value: function zoomIn() {
	      if (this._map && this._map.activeControl) {
	        if (!this._options.animation.disabled) {
	          var curDist = this._map.activeControl._curDistance;
	          var duration = (0, _lang.isNumber)(this._options.animation.duration) ? this._options.animation.duration : 300;
	
	          this._startZoomAnimation(curDist, curDist / 2, duration);
	        } else {
	          this._map.activeControl.zoom(0.5, true, true, false);
	        }
	      }
	
	      return this;
	    }
	  }, {
	    key: 'zoomOut',
	    value: function zoomOut() {
	      if (this._map && this._map.activeControl) {
	        if (!this._options.animation.disabled) {
	          var curDist = this._map.activeControl._curDistance;
	          var duration = (0, _lang.isNumber)(this._options.animation.duration) ? this._options.animation.duration : 300;
	
	          this._startZoomAnimation(curDist, curDist * 2, duration);
	        } else {
	          this._map.activeControl.zoom(2, true, true, false);
	        }
	      }
	
	      return this;
	    }
	  }]);
	
	  return ZoomControl;
	}(_Control3.default);
	
	exports.default = ZoomControl;

/***/ }),
/* 152 */
/***/ (function(module, exports) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	/**
	 * Starting id
	 * @ignore
	 * @type {Number}
	 */
	var id = 1;
	
	/**
	 * A class from generating id.
	 * @ignore
	 */
	
	var IdGenerator = function () {
	  function IdGenerator() {
	    _classCallCheck(this, IdGenerator);
	  }
	
	  _createClass(IdGenerator, null, [{
	    key: "generate",
	
	    /**
	     * Generate a id.
	     * @static
	     * @return {Number} Id.
	     */
	    value: function generate() {
	      return id++;
	    }
	  }]);
	
	  return IdGenerator;
	}();
	
	exports.default = IdGenerator;

/***/ }),
/* 153 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _assign = __webpack_require__(1);
	
	var _extends = _assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	// import fetch from '../../lib/fetch';
	
	
	var _package = __webpack_require__(49);
	
	var _request = __webpack_require__(115);
	
	var _request2 = _interopRequireDefault(_request);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	/**
	 * 数据源类，是用于请求地图信息等的接口，需要通过AppKey验证之后才能正常使用。
	 * @memberOf NGR.data
	 */
	var DataSource = function () {
	  /**
	   * 构造方法。
	   * @param {Object} options                                    数据源选项。
	   * @param {String} options.appKey                             即从开放平台获取的AppKey。具体获取方法参照{@link https://www.ipalmap.com/docs/index.php/js-key/}。
	   * @param {String} [options.server='https://api.ipalmap.com'] 获取数据的服务器地址。
	   */
	  function DataSource() {
	    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
	
	    _classCallCheck(this, DataSource);
	
	    var server = options.server,
	        appKey = options.appKey,
	        headers = options.headers,
	        rest = _objectWithoutProperties(options, ['server', 'appKey', 'headers']);
	
	    var mHeaders = _extends({
	      Accept: 'application/json',
	      'NAG-Version': _package.version,
	      'NAG-Key': appKey
	    }, headers);
	
	    if (server) {
	      this.server = server;
	    }
	
	    this.options = _extends({
	      headers: mHeaders
	    }, rest);
	  }
	
	  _createClass(DataSource, [{
	    key: 'requestRegions',
	
	
	    /**
	     * 通过国家代码和父POI请求地区信息列表。
	     * @param {Object} [params]         过滤器，包含各类过滤条件，如国家代码和POI信息。
	     * @param {String} [params.country] 国家代码。
	     * @param {Number} [params.parent]  父POI。
	     * @return {Promise}                通过Promise形式返回的地区列表。
	     */
	    value: function requestRegions(params) {
	      return _request2.default.get('region', _extends({}, this.options, { params: params }));
	    }
	
	    /**
	     * 通过类别ID请求类别信息。
	     * @param  {String|Nubmer} categoryId 类别id。
	     * @return {Promise}                  通过Promise形式返回的类别信息。
	     */
	
	  }, {
	    key: 'requestCategory',
	    value: function requestCategory(categoryId) {
	      return _request2.default.get('category/' + categoryId, this.options);
	    }
	
	    /**
	     * 通过地图ID和POI的ID请求类别信息列表。
	     * @param {Object}        [params]     过滤器，包含各类过滤条件，如各类ID信息。
	     * @param {String|Number} [params.map] 地图id。
	     * @param {String|Number} [params.poi] POI id。
	     * @return {Promise}                   通过Promise形式返回的类别信息列表。
	     */
	
	  }, {
	    key: 'requestCategories',
	    value: function requestCategories(params) {
	      return _request2.default.get('category/list', _extends({}, this.options, { params: params }));
	    }
	
	    /**
	     * 通过地图ID请求地图信息。
	     * @param  {String|number} mapId 地图id。
	     * @return {Promise}             通过Promise形式返回的地图信息。
	     */
	
	  }, {
	    key: 'requestMap',
	    value: function requestMap(mapId) {
	      return _request2.default.get('map/' + mapId, this.options);
	    }
	
	    /**
	     * 通过地区代码和类别ID请求地图信息列表。
	     * @param {Object}        [params]          过滤器，包含各类过滤条件，如地区代码和各类ID。
	     * @param {String}        [params.region]   地区代码。
	     * @param {String|Number} [params.category] 类别id。
	     * @return {Promise}                        通过Promise形式返回地图信息列表。
	     */
	
	  }, {
	    key: 'requestMaps',
	    value: function requestMaps(params) {
	      return _request2.default.get('map/list', _extends({}, this.options, { params: params }));
	    }
	
	    /**
	     * 通过平面图ID请求平面图信息。
	     * @param {string|number} floorId 平面图id。
	     * @return {Promise}              通过Promise形式返回的符合GeoJSON格式的平面图信息。
	     */
	
	  }, {
	    key: 'requestPlanarGraph',
	    value: function requestPlanarGraph(floorId) {
	      return _request2.default.get('planar_graph/' + floorId, this.options);
	    }
	
	    /**
	     * 通过POI的ID请求POI信息。
	     * @param {string|number} poiId POI的id。
	     * @return {Promise}            通过Promise形式返回的POI信息。
	     */
	
	  }, {
	    key: 'requestPOI',
	    value: function requestPOI(poiId) {
	      return _request2.default.get('poi/' + poiId, this.options);
	    }
	
	    /**
	     * 通过POI的ID请求它的子POI。
	     * @param {string|number} poiId POI的id。
	     * @return {Promise}            通过Promise形式返回的符合条件的子POI列表。
	     */
	
	  }, {
	    key: 'requestPOIChildren',
	    value: function requestPOIChildren(poiId) {
	      return _request2.default.get('poi/' + poiId + '/children', this.options);
	    }
	
	    /**
	     * 通过关键词搜索POI。
	     * @param {Object}            [body]            过滤器，包含各类过滤条件，如POI信息。
	     * @param {String[]}          [body.keywords]   关键词。
	     * @param {String[]|Number[]} [body.parents]    父POI列表。
	     * @param {String[]|Number[]} [body.categories] 类别列表。搜索的categories集合。可将此参数作为限制条件，传空时该参数无效。
	     * @return {Promise}                            通过Promise形式返回的符合搜索条件的POI信息列表。
	     */
	
	  }, {
	    key: 'searchPOI',
	    value: function searchPOI(body) {
	      return _request2.default.post('poi/search', _extends({}, this.options, { body: JSON.stringify(body) }));
	    }
	
	    /**
	     * 根据坐标搜索包含该坐标的POI。
	     * @param {Object}            [body]              过滤器，包含各类过滤条件，如POI信息。
	     * @param {Object}            [body.coordinate]   WGS 84 墨卡托投影坐标。
	     * @param {Object}            [body.coordinate.x] WGS 84 墨卡托投影坐标x轴坐标值。
	     * @param {Object}            [body.coordinate.y] WGS 84 墨卡托投影坐标y轴坐标值。
	     * @param {String}            [body.keywords]     关键词。
	     * @param {String[]|Number[]} [body.parents]      父POI列表。
	     * @param {String[]|Number[]} [body.categories]   类别列表。搜索的categories集合。可将此参数作为限制条件，传空时该参数无效。
	     * @return {Promise}                              通过Promise形式的符合搜索条件的POI信息列表。
	     */
	
	  }, {
	    key: 'searchPOIByCoord',
	    value: function searchPOIByCoord(body) {
	      return _request2.default.post('poi/coord', _extends({}, this.options, { body: JSON.stringify(body) }));
	    }
	
	    /**
	     * Get navigation between two points.
	     * @ignore
	     * @param {Object} params                   Parameters.
	     * @param {Number} params.from_x            From x.
	     * @param {Number} params.from_y            From y.
	     * @param {Number} params.from_planar_graph From Planargraph.
	     * @param {Number} params.to_x              To x.
	     * @param {Number} params.to_y              To y.
	     * @param {Number} params.to_planar_graph   To Planargraph.
	     * @return {Promise}                        The navigation with Promise.
	     */
	
	  }, {
	    key: 'requestNavigation',
	    value: function requestNavigation(params) {
	      return _request2.default.get('navi', _extends({}, this.options, { params: params }));
	    }
	
	    /**
	     * Get navigation across serveral points.
	     * @ignore
	     * @param {Array} body Each item should include keys with { x, y, planarGraphId }.
	     * @return {Promise}   return the navigation across serveral points with Promise.
	     */
	
	  }, {
	    key: 'requestTransitNavigation',
	    value: function requestTransitNavigation(body) {
	      return _request2.default.post('navi/transit', _extends({}, this.options, { body: JSON.stringify(body) }));
	    }
	  }, {
	    key: 'server',
	    set: function set(url) {
	      _request2.default.defaults.baseURL = url;
	    }
	  }]);
	
	  return DataSource;
	}();
	
	exports.default = DataSource;

/***/ }),
/* 154 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _JTSParser = __webpack_require__(67);
	
	var _JTSParser2 = _interopRequireDefault(_JTSParser);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	/**
	 * 平面图类，用于封装渲染地图所需要的数据。
	 * @memberOf NGR.data
	 */
	var PlanarGraph = function () {
	  /**
	   * 构造方法。
	   * @param  {Object} data 平面图数据，可以通过dataSource获取。
	   */
	  function PlanarGraph(data) {
	    _classCallCheck(this, PlanarGraph);
	
	    var res = null;
	
	    if (typeof data === 'string') {
	      res = JSON.parse(data);
	    } else {
	      res = data;
	    }
	
	    this.features = {};
	    for (var name in res) {
	      // this.features[name] = OL3Parser.parse(name, res[name]);
	      if (_typeof(res[name]) === 'object') {
	        this.features[name] = _JTSParser2.default.parse(name, res[name]);
	      }
	    }
	    ret: for (var _name in this.features) {
	      var features = this.features[_name].features;
	
	      for (var _iterator = features, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
	        var _ref;
	
	        if (_isArray) {
	          if (_i >= _iterator.length) break;
	          _ref = _iterator[_i++];
	        } else {
	          _i = _iterator.next();
	          if (_i.done) break;
	          _ref = _i.value;
	        }
	
	        var feature = _ref;
	
	        var planarGraphId = feature.properties.planar_graph;
	
	        if (planarGraphId) {
	          this._planarGraphId = planarGraphId;
	          break ret;
	        }
	      }
	    }
	  }
	
	  /**
	   * 平面图id。
	   * @type {Number}
	   * @return {Number} Planargraph id。
	   */
	
	
	  _createClass(PlanarGraph, [{
	    key: 'planarGraphId',
	    get: function get() {
	      return this._planarGraphId;
	    }
	  }, {
	    key: 'features',
	    get: function get() {
	      return this._features;
	    },
	    set: function set(features) {
	      this._features = features;
	    }
	  }]);
	
	  return PlanarGraph;
	}();
	
	exports.default = PlanarGraph;

/***/ }),
/* 155 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _NGRObject2 = __webpack_require__(7);
	
	var _NGRObject3 = _interopRequireDefault(_NGRObject2);
	
	var _config = __webpack_require__(18);
	
	var _touchEmulator = __webpack_require__(136);
	
	var _touchEmulator2 = _interopRequireDefault(_touchEmulator);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	if (_config.touchEmulator) {
	  (0, _touchEmulator2.default)();
	}
	
	/**
	 * 所有渲染引擎的管理类，用于管理{@link NGR.view.MapView}地图对象。
	 * @class NGREngine
	 * @extends {NGRObject}
	 */
	
	var NGREngine = function (_NGRObject) {
	  _inherits(NGREngine, _NGRObject);
	
	  function NGREngine() {
	    _classCallCheck(this, NGREngine);
	
	    var _this = _possibleConstructorReturn(this, (NGREngine.__proto__ || Object.getPrototypeOf(NGREngine)).call(this));
	
	    _this._mapViews = {};
	    return _this;
	  }
	
	  /**
	   * 初始化{@link NGR.view.MapView}地图对象，设置各种自定义的参数。
	   * @param {NGR.view.MapView} mapView 构造一个地图对象MapView，并进行初始化。
	   * @param {Object}           options 设置自定义参数。
	   * @return {Boolean}                 如果初始化成功则返回true。
	   */
	
	
	  _createClass(NGREngine, [{
	    key: 'initMapView',
	    value: function initMapView(mapView, options) {
	      // eslint-disable-line no-unused-vars
	      if (!this.hasMapView(mapView)) {
	        this._mapViews[mapView.name] = mapView;
	
	        return true;
	      }
	
	      return false;
	    }
	
	    /**
	     * 重新设置{@link NGR.view.MapView}地图对象的大小。
	     * @param {NGR.view.MapView} mapView 地图对象。
	     * @param {Number}           width   宽度，单位为像素。
	     * @param {Number}           height  高度，单位为像素。
	     * @return {undefined}
	     */
	
	  }, {
	    key: 'reSize',
	    value: function reSize(mapView, width, height) {} // eslint-disable-line no-unused-vars
	
	
	    /**
	     * 判断一个{@link NGR.view.MapView}对象是否已经存在。
	     * @param {NGR.view.MapView} mapView 地图对象。
	     * @return {Boolean}                 如果存在，返回true，否则返回false。
	     */
	
	  }, {
	    key: 'hasMapView',
	    value: function hasMapView(mapView) {
	      return !!mapView && (mapView in this._mapViews || mapView.name in this._mapViews);
	    }
	
	    /**
	     * 从显示界面中删除地图{@link NGR.view.MapView}。这个方法会停止渲染，回收渲染元素，
	     * 销毁对象。这会导致{@link NGR.view.MapView}不可用。如果需要重新使用，需重新创建，并调用{@link NGREngine#initMapView}方法。
	     * @param {NGR.view.MapView} mapView 地图对象。
	     * @return {Boolean}                 删除成功则返回true。
	     */
	
	  }, {
	    key: 'remove',
	    value: function remove(mapView) {
	      if (this.hasMapView(mapView)) {
	        delete this._mapViews[mapView.name];
	
	        return true;
	      }
	
	      return false;
	    }
	
	    /**
	     * 返回这个引擎的类型。
	     * @ignore
	     * @return {String} 根据不同的引擎返回类型。
	     */
	
	  }, {
	    key: 'type',
	    value: function type() {
	      return null;
	    }
	  }]);
	
	  return NGREngine;
	}(_NGRObject3.default);
	
	exports.default = NGREngine;

/***/ }),
/* 156 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.ThreeEngine = undefined;
	
	var _ThreeEngine = __webpack_require__(66);
	
	var _ThreeEngine2 = _interopRequireDefault(_ThreeEngine);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.ThreeEngine = _ThreeEngine2.default; // import NGREngine from './NGREngine';

/***/ }),
/* 157 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _jsts = __webpack_require__(5);
	
	var _JTSUtils = __webpack_require__(12);
	
	var _JTSUtils2 = _interopRequireDefault(_JTSUtils);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var GeometryTransformer = function () {
	  function GeometryTransformer(callback) {
	    _classCallCheck(this, GeometryTransformer);
	
	    this.pruneEmptyGeometry = true;
	    this.preserveGeometryCollectionType = true;
	    this.preserveCollections = false;
	    this.preserveType = false;
	    this._callback = callback;
	  }
	
	  _createClass(GeometryTransformer, [{
	    key: 'transformPoint',
	    value: function transformPoint(geom /* , parent*/) {
	      return _JTSUtils2.default.getFactory().createPoint(this.transformCoordinates(geom.getCoordinateSequence(), geom));
	    }
	  }, {
	    key: 'transformPolygon',
	    value: function transformPolygon(geom /* , parent*/) {
	      // let isAllValidLinearRings = true;
	      var shell = this.transformLinearRing(geom.getExteriorRing(), geom);
	      if (shell === null || !(shell instanceof _jsts.geom.LinearRing) || shell.isEmpty()) {
	        // isAllValidLinearRings = false;
	      }
	      var holes = [];
	      for (var i = 0; i < geom.getNumInteriorRing(); i++) {
	        var hole = this.transformLinearRing(geom.getInteriorRingN(i), geom);
	        if (hole === null || hole.isEmpty()) {
	          continue;
	        }
	        if (!(hole instanceof _jsts.geom.LinearRing)) {
	          // isAllValidLinearRings = false;
	        }
	        holes.push(hole);
	      }
	      return _JTSUtils2.default.getFactory().createPolygon(shell, holes);
	      // if (isAllValidLinearRings) {
	      //   return JTSUtils.getFactory().createPolygon(shell, holes);
	      // }
	      // else {
	      //   var components = new ArrayList();
	      //   if (shell !== null) components.add(shell);
	      //   components.addAll(holes);
	      //   return JTSUtils.getFactory().buildGeometry(components);
	      // }
	    }
	  }, {
	    key: 'createCoordinateSequence',
	    value: function createCoordinateSequence(coords) {
	      return _JTSUtils2.default.getFactory().getCoordinateSequenceFactory().create(coords);
	    }
	  }, {
	    key: 'transformMultiLineString',
	    value: function transformMultiLineString(geom /* , parent*/) {
	      var transGeomList = [];
	      for (var i = 0; i < geom.getNumGeometries(); i++) {
	        var transformGeom = this.transformLineString(geom.getGeometryN(i), geom);
	        if (transformGeom === null) {
	          continue;
	        }
	        if (transformGeom.isEmpty()) {
	          continue;
	        }
	        transGeomList.push(transformGeom);
	      }
	      return _JTSUtils2.default.getFactory().createMultiLineString(transGeomList);
	    }
	  }, {
	    key: 'transformCoordinates',
	    value: function transformCoordinates(coords, parent) {
	      return this._callback(coords, parent);
	      // return this.copy(coords);
	    }
	  }, {
	    key: 'transformLineString',
	    value: function transformLineString(geom /* , parent*/) {
	      return _JTSUtils2.default.getFactory().createLineString(this.transformCoordinates(geom.getCoordinateSequence(), geom));
	    }
	  }, {
	    key: 'transformMultiPoint',
	    value: function transformMultiPoint(geom /* , parent*/) {
	      var transGeomList = [];
	      for (var i = 0; i < geom.getNumGeometries(); i++) {
	        var transformGeom = this.transformPoint(geom.getGeometryN(i), geom);
	
	        if (transformGeom === null) {
	          continue;
	        }
	        if (transformGeom.isEmpty()) {
	          continue;
	        }
	        transGeomList.push(transformGeom);
	      }
	      return _JTSUtils2.default.getFactory().createMultiPoint(transGeomList);
	    }
	  }, {
	    key: 'transformMultiPolygon',
	    value: function transformMultiPolygon(geom /* , parent*/) {
	      var transGeomList = [];
	      for (var i = 0; i < geom.getNumGeometries(); i++) {
	        var transformGeom = this.transformPolygon(geom.getGeometryN(i), geom);
	
	        if (transformGeom === null) {
	          continue;
	        }
	        if (transformGeom.isEmpty()) {
	          continue;
	        }
	        transGeomList.push(transformGeom);
	      }
	      return _JTSUtils2.default.getFactory().createMultiPolygon(transGeomList);
	    }
	  }, {
	    key: 'copy',
	    value: function copy(seq) {
	      return seq.copy();
	    }
	  }, {
	    key: 'transformGeometryCollection',
	    value: function transformGeometryCollection(geom /* , parent*/) {
	      var transGeomList = [];
	
	      for (var i = 0; i < geom.getNumGeometries(); i++) {
	        var transformGeom = this.transform(geom.getGeometryN(i));
	
	        if (transformGeom === null) {
	          continue;
	        }
	        if (this.pruneEmptyGeometry && transformGeom.isEmpty()) {
	          continue;
	        }
	        transGeomList.push(transformGeom);
	      }
	      if (this.preserveGeometryCollectionType) {
	        return _JTSUtils2.default.getFactory().createGeometryCollection(_JTSUtils2.default.getFactory().toGeometryArray(transGeomList));
	      }
	      return _JTSUtils2.default.getFactory().createGeometryCollection(transGeomList);
	    }
	  }, {
	    key: 'transform',
	    value: function transform(inputGeom) {
	      if (inputGeom instanceof _jsts.geom.Point) {
	        return this.transformPoint(inputGeom, null);
	      }
	      if (inputGeom instanceof _jsts.geom.MultiPoint) {
	        return this.transformMultiPoint(inputGeom, null);
	      }
	      if (inputGeom instanceof _jsts.geom.LinearRing) {
	        return this.transformLinearRing(inputGeom, null);
	      }
	      if (inputGeom instanceof _jsts.geom.LineString) {
	        return this.transformLineString(inputGeom, null);
	      }
	      if (inputGeom instanceof _jsts.geom.MultiLineString) {
	        return this.transformMultiLineString(inputGeom, null);
	      }
	      if (inputGeom instanceof _jsts.geom.Polygon) {
	        return this.transformPolygon(inputGeom, null);
	      }
	      if (inputGeom instanceof _jsts.geom.MultiPolygon) {
	        return this.transformMultiPolygon(inputGeom, null);
	      }
	      if (inputGeom instanceof _jsts.geom.GeometryCollection) {
	        return this.transformGeometryCollection(inputGeom, null);
	      }
	      return null;
	    }
	  }, {
	    key: 'transformLinearRing',
	    value: function transformLinearRing(geom /* , parent*/) {
	      var seq = this.transformCoordinates(geom.getCoordinateSequence(), geom);
	
	      if (seq === null) {
	        return _JTSUtils2.default.getFactory().createLinearRing(null);
	      }
	
	      var seqSize = seq.size();
	
	      if (seqSize > 0 && seqSize < 4 && !this.preserveType) {
	        return _JTSUtils2.default.getFactory().createLineString(seq);
	      }
	      return _JTSUtils2.default.getFactory().createLinearRing(seq);
	    }
	  }]);
	
	  return GeometryTransformer;
	}();
	
	exports.default = GeometryTransformer;

/***/ }),
/* 158 */
/***/ (function(module, exports) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var PolygonIterator = function () {
	  function PolygonIterator(polygon) {
	    _classCallCheck(this, PolygonIterator);
	
	    this._polygon = polygon;
	    this._linearRingCouet = polygon.getNumInteriorRing();
	  }
	
	  _createClass(PolygonIterator, [{
	    key: "shellCreator",
	    value: function shellCreator(callback) {
	      this._shellCreator = callback;
	      return this;
	    }
	  }, {
	    key: "shell",
	    value: function shell(callback) {
	      var shellCreator = this._shellCreator();
	
	      if (shellCreator) {
	        var shell = this._polygon.getExteriorRing();
	        var shellCoords = shell.getCoordinates();
	
	        for (var i = 0; i < shellCoords.length; i++) {
	          callback(shellCreator, shellCoords[i], i);
	        }
	      }
	      return this;
	    }
	  }, {
	    key: "holeCreator",
	    value: function holeCreator(callback) {
	      this._holeCreator = callback;
	      return this;
	    }
	  }, {
	    key: "holes",
	    value: function holes(callback) {
	      if (this._linearRingCouet > 0) {
	        for (var i = 0; i < this._linearRingCouet; i++) {
	          var holeCreator = this._holeCreator();
	
	          if (holeCreator) {
	            var hole = this._polygon.getInteriorRingN(i);
	            var holdCoords = hole.getCoordinates();
	
	            for (var j = 0; j < holdCoords.length; j++) {
	              callback(holeCreator, holdCoords[j], j);
	            }
	          }
	        }
	      }
	      return this;
	    }
	  }]);
	
	  return PolygonIterator;
	}();
	
	exports.default = PolygonIterator;

/***/ }),
/* 159 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.JTSUtils = exports.Coordinate = exports.GeometryFactory = undefined;
	
	var _GeometryFactory = __webpack_require__(35);
	
	var _GeometryFactory2 = _interopRequireDefault(_GeometryFactory);
	
	var _jsts = __webpack_require__(5);
	
	var _JTSUtils = __webpack_require__(12);
	
	var _JTSUtils2 = _interopRequireDefault(_JTSUtils);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	// import PolygonIterator from './PolygonIterator';
	
	var Coordinate = _jsts.geom.Coordinate;
	
	/**
	 * 实例化时可以不传入参数：Coordinate()；
	 * 传入x和y：Coordinate(x, y);
	 * 或传入x，y和z：Coordinate(x, y, z)。
	 * @class Coordinate
	 * @memberOf NGR.geom
	 */
	
	// import GeometryTransformer from './GeometryTransformer';
	// import JTSParser from './JTSParser';
	exports.GeometryFactory = _GeometryFactory2.default;
	exports.Coordinate = Coordinate;
	exports.JTSUtils = _JTSUtils2.default;

/***/ }),
/* 160 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;/* WEBPACK VAR INJECTION */(function(module) {'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	var _assign = __webpack_require__(1);
	
	// import css
	
	
	var _config = __webpack_require__(18);
	
	var _package = __webpack_require__(49);
	
	__webpack_require__(232);
	
	__webpack_require__(226);
	
	__webpack_require__(228);
	
	__webpack_require__(230);
	
	__webpack_require__(225);
	
	__webpack_require__(234);
	
	__webpack_require__(231);
	
	__webpack_require__(233);
	
	__webpack_require__(227);
	
	__webpack_require__(229);
	
	var _three = __webpack_require__(2);
	
	var THREE = _interopRequireWildcard(_three);
	
	var _jsts = __webpack_require__(5);
	
	var JSTS = _interopRequireWildcard(_jsts);
	
	var _animation = __webpack_require__(141);
	
	var animation = _interopRequireWildcard(_animation);
	
	var _camera = __webpack_require__(144);
	
	var camera = _interopRequireWildcard(_camera);
	
	var _control = __webpack_require__(61);
	
	var control = _interopRequireWildcard(_control);
	
	var _core = __webpack_require__(62);
	
	var core = _interopRequireWildcard(_core);
	
	var _data = __webpack_require__(64);
	
	var data = _interopRequireWildcard(_data);
	
	var _dom = __webpack_require__(11);
	
	var dom = _interopRequireWildcard(_dom);
	
	var _engine = __webpack_require__(156);
	
	var engine = _interopRequireWildcard(_engine);
	
	var _geom = __webpack_require__(159);
	
	var geom = _interopRequireWildcard(_geom);
	
	var _layer = __webpack_require__(163);
	
	var layer = _interopRequireWildcard(_layer);
	
	var _location = __webpack_require__(68);
	
	var location = _interopRequireWildcard(_location);
	
	var _map = __webpack_require__(170);
	
	var map = _interopRequireWildcard(_map);
	
	var _math = __webpack_require__(171);
	
	var math = _interopRequireWildcard(_math);
	
	var _navi = __webpack_require__(189);
	
	var navi = _interopRequireWildcard(_navi);
	
	var _overlay = __webpack_require__(77);
	
	var overlay = _interopRequireWildcard(_overlay);
	
	var _particle = __webpack_require__(193);
	
	var particle = _interopRequireWildcard(_particle);
	
	var _scene = __webpack_require__(208);
	
	var scene = _interopRequireWildcard(_scene);
	
	var _sensor = __webpack_require__(210);
	
	var sensor = _interopRequireWildcard(_sensor);
	
	var _style = __webpack_require__(213);
	
	var style = _interopRequireWildcard(_style);
	
	var _view = __webpack_require__(219);
	
	var view = _interopRequireWildcard(_view);
	
	var _fetch = __webpack_require__(13);
	
	var _fetch2 = _interopRequireDefault(_fetch);
	
	var _tube = __webpack_require__(134);
	
	var tubeHelper = _interopRequireWildcard(_tube);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	if (_config.isDev) {
	  window.THREE = THREE;
	}
	
	window.JSTS = JSTS;
	
	// import TouchEmulator from 'hammer-touchemulator';
	// TouchEmulator();
	
	// import src
	
	// import * as renderer from './renderer';
	
	
	// import lib
	
	
	/**
	 * @namespace planeLineHelper
	 * @ignore
	 * @memberOf NGR.helper
	 */
	// import * as planeLineHelper from '../lib/three-ext/planeLine';
	/**
	 * @namespace tubeHelper
	 * @ignore
	 * @memberOf NGR.helper
	 */
	
	/**
	 * @namespace outLineHelper
	 * @ignore
	 * @memberOf NGR.helper
	 */
	// import * as outLineHelper from '../lib/three-ext/outline';
	
	/**
	 * @namespace
	 */
	var NGR = {
	  /**
	   * 动画。
	   * @namespace
	   * @memberOf NGR
	   */
	  animation: animation,
	  /**
	   * 相机。
	   * @namespace
	   * @memberOf NGR
	   */
	  camera: camera,
	  /**
	   * 基本类。
	   * @namespace
	   * @memberOf NGR
	   */
	  core: core,
	  /**
	   * 数据源。
	   * @namespace
	   * @memberOf NGR
	   */
	  data: data,
	  /**
	   * DOM。
	   * @namespace
	   * @memberOf NGR
	   */
	  dom: dom,
	  /**
	   * 渲染引擎。
	   * @namespace
	   * @memberOf NGR
	   */
	  engine: engine,
	  /**
	   * 几何图形。
	   * @namespace
	   * @memberOf NGR
	   */
	  geom: geom,
	  /**
	   * 发送网络请求。
	   * @function
	   * @param {String} input URL.
	   * @param {Object} init  初始化选项，一般填{}。
	   * @return {Promise}     Promise。
	   * @memberOf NGR
	   */
	  fetch: _fetch2.default, // function
	  /**
	   * 数据层。
	   * @namespace
	   * @memberOf NGR
	   */
	  layer: layer,
	  /**
	   * 定位。
	   * @namespace
	   * @memberOf NGR
	   */
	  location: location,
	  /**
	   * 地图。
	   * @namespace
	   * @memberOf NGR
	   */
	  map: map,
	  /**
	   * 数学计算方法。
	   * @namespace
	   * @memberOf NGR
	   */
	  math: math,
	  /**
	   * 导航。
	   * @namespace
	   * @memberOf NGR
	   */
	  navi: navi,
	  /**
	   * 覆盖物。
	   * @namespace
	   * @memberOf NGR
	   */
	  overlay: overlay,
	  // renderer,
	  /**
	   * 渲染场景。
	   * @namespace
	   * @memberOf NGR
	   */
	  scene: scene,
	  /**
	   * 传感器
	   * @namespace
	   * @memberOf NGR
	   */
	  sensor: sensor,
	  /**
	   * 样式。
	   * @namespace
	   * @memberOf NGR
	   */
	  style: style,
	  /**
	   * 视图。
	   * @namespace
	   * @memberOf NGR
	   */
	  view: view,
	  /**
	   * 获取SDK的版本信息
	   * @memberOf NGR
	   */
	  version: _package.version
	};
	
	// add particle package
	if (_config.supportParticle) {
	  _assign(NGR, {
	    particle: particle
	  });
	}
	
	if (!_config.isLite) {
	  /**
	   * 辅助。
	   * @ignore
	   * @namespace helper
	   * @memberOf NGR
	   */
	  var helper = {
	    // planeLineHelper,
	    tubeHelper: tubeHelper
	  };
	  NGR.helper = helper;
	  /**
	   * 控件。
	   * @namespace control
	   * @memberOf NGR
	   */
	  NGR.control = control;
	}
	
	/* eslint-disable no-undef */
	if (( false ? 'undefined' : _typeof(module)) === 'object' && _typeof(module.exports) === 'object') {
	  module.exports = NGR;
	} else if (true) {
	  !(__WEBPACK_AMD_DEFINE_FACTORY__ = (NGR), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	}
	/* eslint-enable no-undef */
	
	window.NGR = NGR;
	
	// compatibility for JSTS in chrome 37
	// http://stackoverflow.com/questions/1107681/javascript-hiding-prototype-methods-in-for-loop
	if (Array.prototype.fill) {
	  Object.defineProperty(Array.prototype, 'fill', { // eslint-disable-line
	    enumerable: false
	  });
	}
	
	// if (isDev) {
	//   require('../examples/quickstart/app.js');
	//   require('../examples/quickstart/template.js');
	// }
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(30)(module)))

/***/ }),
/* 161 */
/***/ (function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	var serialize = exports.serialize = function serialize(obj) {
	  var serialStr = '';
	  var ret = [];
	
	  for (var key in obj) {
	    if (obj.hasOwnProperty(key)) {
	      var value = obj[key];
	
	      ret.push(encodeURIComponent(key) + '=' + encodeURIComponent(value));
	    }
	  }
	  if (ret.join('&').length > 0) {
	    serialStr = '?' + ret.join('&');
	  }
	
	  return serialStr;
	};
	
	var checkStatus = exports.checkStatus = function checkStatus(response) {
	  if (response.status >= 200 && response.status < 300) {
	    return response;
	  }
	
	  var error = new Error(response.statusText);
	
	  error.response = response;
	  throw error;
	};

/***/ }),
/* 162 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _three = __webpack_require__(2);
	
	var THREE = _interopRequireWildcard(_three);
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var LoaderCache = function () {
	  function LoaderCache(loader) {
	    _classCallCheck(this, LoaderCache);
	
	    this._loader = loader;
	    this._loader.setCrossOrigin('');
	    this._cache = {};
	  }
	
	  _createClass(LoaderCache, [{
	    key: 'load',
	    value: function load(url, onLoad, onProgress, onError) {
	      var _this = this;
	
	      var data = THREE.Cache.get(url);
	      if (data) {
	        this._loader.load(url, onLoad, onProgress, onError);
	        delete this._cache[url];
	        return;
	      }
	      var caches = this._cache[url];
	      if (!caches) {
	        caches = [];
	        this._cache[url] = caches;
	        this._loader.load(url, function (data) {
	          if (onLoad) {
	            onLoad(data);
	          }
	          _this._forCache(caches, function (cache) {
	            if (cache.load) {
	              cache.load(data);
	            }
	          });
	          delete _this._cache[url];
	        }, function (e) {
	          if (onProgress) {
	            onProgress(e);
	          }
	        }, function (e) {
	          _this._forCache(caches, function (cache) {
	            if (cache.error) {
	              cache.error(e);
	            }
	          });
	          delete _this._cache[url];
	          if (onError) {
	            onError(e);
	          }
	        });
	        return;
	      }
	      caches.push({
	        load: onLoad,
	        error: onError
	      });
	    }
	  }, {
	    key: '_forCache',
	    value: function _forCache(caches, callback) {
	      while (caches.length !== 0) {
	        callback(caches.pop());
	      }
	    }
	  }]);
	
	  return LoaderCache;
	}();
	
	exports.default = LoaderCache;

/***/ }),
/* 163 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.LayerGroup = exports.FeatureLayer = undefined;
	
	var _FeatureLayer = __webpack_require__(36);
	
	var _FeatureLayer2 = _interopRequireDefault(_FeatureLayer);
	
	var _LayerGroup = __webpack_require__(43);
	
	var _LayerGroup2 = _interopRequireDefault(_LayerGroup);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	// import LayerCreator from './LayerCreator';
	
	// import Layer from './Layer';
	exports.FeatureLayer = _FeatureLayer2.default;
	exports.LayerGroup = _LayerGroup2.default;

/***/ }),
/* 164 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _BleLocationWorker = __webpack_require__(288);
	
	var _BleLocationWorker2 = _interopRequireDefault(_BleLocationWorker);
	
	var _Protocal4 = __webpack_require__(222);
	
	var _Protocal5 = _interopRequireDefault(_Protocal4);
	
	var _WorkerExecutor = __webpack_require__(223);
	
	var _WorkerExecutor2 = _interopRequireDefault(_WorkerExecutor);
	
	var _fetch = __webpack_require__(13);
	
	var _fetch2 = _interopRequireDefault(_fetch);
	
	var _emitter = __webpack_require__(55);
	
	var _emitter2 = _interopRequireDefault(_emitter);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var InitBeaconConfigProtocal = function (_Protocal) {
	  _inherits(InitBeaconConfigProtocal, _Protocal);
	
	  function InitBeaconConfigProtocal(beaconContext, config) {
	    _classCallCheck(this, InitBeaconConfigProtocal);
	
	    var _this = _possibleConstructorReturn(this, (InitBeaconConfigProtocal.__proto__ || Object.getPrototypeOf(InitBeaconConfigProtocal)).call(this));
	
	    _this._beaconContext = beaconContext;
	    _this._config = config || {};
	    return _this;
	  }
	
	  _createClass(InitBeaconConfigProtocal, [{
	    key: 'name',
	    value: function name() {
	      return 'InitBeaconConfigProtocal';
	    }
	  }, {
	    key: 'params',
	    value: function params() {
	      return {
	        beaconContext: this._beaconContext,
	        config: this._config
	      };
	    }
	  }, {
	    key: 'success',
	    value: function success(promise, resolve, params) {// eslint-disable-line no-unused-vars
	    }
	  }]);
	
	  return InitBeaconConfigProtocal;
	}(_Protocal5.default);
	
	var LocationProtocal = function (_Protocal2) {
	  _inherits(LocationProtocal, _Protocal2);
	
	  function LocationProtocal(beacons) {
	    _classCallCheck(this, LocationProtocal);
	
	    var _this2 = _possibleConstructorReturn(this, (LocationProtocal.__proto__ || Object.getPrototypeOf(LocationProtocal)).call(this));
	
	    _this2._beacons = beacons;
	    return _this2;
	  }
	
	  _createClass(LocationProtocal, [{
	    key: 'name',
	    value: function name() {
	      return 'LocationProtocal';
	    }
	  }, {
	    key: 'params',
	    value: function params() {
	      return {
	        beacons: this._beacons
	      };
	    }
	  }, {
	    key: 'success',
	    value: function success(promise, resolve, params) {
	      resolve(params.result.location);
	    }
	  }]);
	
	  return LocationProtocal;
	}(_Protocal5.default);
	
	var BeaconsProtocal = function (_Protocal3) {
	  _inherits(BeaconsProtocal, _Protocal3);
	
	  function BeaconsProtocal(beacons) {
	    _classCallCheck(this, BeaconsProtocal);
	
	    var _this3 = _possibleConstructorReturn(this, (BeaconsProtocal.__proto__ || Object.getPrototypeOf(BeaconsProtocal)).call(this));
	
	    _this3._beacons = beacons;
	    return _this3;
	  }
	
	  _createClass(BeaconsProtocal, [{
	    key: 'name',
	    value: function name() {
	      return 'BeaconsProtocal';
	    }
	  }, {
	    key: 'params',
	    value: function params() {
	      return {
	        beacons: this._beacons
	      };
	    }
	  }, {
	    key: 'success',
	    value: function success(promise, resolve, params) {
	      resolve(params.result.location);
	    }
	  }]);
	
	  return BeaconsProtocal;
	}(_Protocal5.default);
	
	var BleWorkerManager = function (_Emitter) {
	  _inherits(BleWorkerManager, _Emitter);
	
	  function BleWorkerManager() {
	    _classCallCheck(this, BleWorkerManager);
	
	    var _this4 = _possibleConstructorReturn(this, (BleWorkerManager.__proto__ || Object.getPrototypeOf(BleWorkerManager)).call(this));
	
	    var worker = new _BleLocationWorker2.default();
	    _this4._workerExecutor = new _WorkerExecutor2.default(worker);
	
	    _this4.startPositioning = false;
	    return _this4;
	  }
	
	  _createClass(BleWorkerManager, [{
	    key: 'fetchBeaconConfig',
	    value: function fetchBeaconConfig(option) {
	      if (!option || !option.appKey || !option.mapId) {
	        throw new Error('Invalid appKey or mapId');
	      }
	
	      var server = option.server || 'https://www.ipalmap.com/open/scene/ble/beacons';
	      var url = server + '?appKey=' + option.appKey + '&mapId=' + option.mapId;
	
	      return (0, _fetch2.default)(url, {
	        headers: {
	          Accept: 'application/json'
	        }
	      }).then(function (response) {
	        return response.json();
	      });
	    }
	  }, {
	    key: 'initBeaconConfig',
	    value: function initBeaconConfig(beaconConfig, c) {
	      var op = c || {};
	      this._intervalID = setInterval(this.calculatingPos.bind(this), op.interval || 1000);
	      return this._workerExecutor.exec(new InitBeaconConfigProtocal(JSON.stringify(beaconConfig), op));
	    }
	  }, {
	    key: 'updateReceivedBeacons',
	    value: function updateReceivedBeacons(beacons) {
	      var _this5 = this;
	
	      return this._workerExecutor.exec(new BeaconsProtocal(JSON.stringify(beacons))).then(function () {
	        _this5.startPositioning = true;
	      });
	    }
	  }, {
	    key: 'destroy',
	    value: function destroy() {
	      clearInterval(this._intervalID);
	      this._workerExecutor.destroy();
	    }
	  }, {
	    key: 'calculatingPos',
	    value: function calculatingPos() {
	      var _this6 = this;
	
	      if (this.startPositioning) {
	        this._workerExecutor.exec(new LocationProtocal()).then(function (data) {
	          _this6.emit('locationChange', data);
	        });
	      }
	    }
	  }]);
	
	  return BleWorkerManager;
	}(_emitter2.default);
	
	exports.default = BleWorkerManager;

/***/ }),
/* 165 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _bleLocationEngine = __webpack_require__(117);
	
	var _bleLocationEngine2 = _interopRequireDefault(_bleLocationEngine);
	
	var _fetch = __webpack_require__(13);
	
	var _fetch2 = _interopRequireDefault(_fetch);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	/**
	 * 蓝牙定位引擎管理类，通过与蓝牙设备Beacon进行信息交互，完成定位和导航。
	 * @memberOf NGR.location
	 */
	var BluetoothLocationManager = function () {
	  /**
	   * 构造方法。
	   */
	  function BluetoothLocationManager() {
	    _classCallCheck(this, BluetoothLocationManager);
	
	    this._bluetoothLocationEngine = null;
	  }
	
	  /**
	   * 通过Beacon的点位数据库和Beacon设备的配置参数来初始化定位引擎。
	   * @param  {Object} beaconConfig          Beacon的点位数据库。
	   * @param  {Object} [config]              Beacon设备的配置参数。
	   * @param  {Number} [config.rssiBoundary] 信号强度(rssi)的范围。
	   * @param  {Number} [config.distBoundary] 距离的范围，单位米。
	   * @return {NGR.location.BlelocationEngine}            蓝牙定位引擎管理对象。
	   */
	
	
	  _createClass(BluetoothLocationManager, [{
	    key: 'initBeaconConfig',
	    value: function initBeaconConfig(beaconConfig, config) {
	      var beaconCfg = {};
	      beaconCfg.BeaconsCfgArray = beaconConfig;
	      beaconCfg = JSON.stringify(beaconCfg);
	      this._bluetoothLocationEngine = new _bleLocationEngine2.default(beaconCfg, config);
	
	      return this;
	    }
	
	    /**
	     * 获取Beacon点位数据库。
	     * @param  {Object} option          配置选项，如AppKey、mapId等。
	     * @param  {String} option.appKey   即从开放平台获取的AppKey。具体获取方法参照{@link https://www.ipalmap.com/docs/index.php/js-key/}。
	     * @param  {Number} option.mapId    地图id。
	     * @param  {String} [option.server] 获取数据的服务器地址。
	     * @return {Promise}                Promise形式返回的Beacon点位数据。
	     */
	
	  }, {
	    key: 'fetchBeaconConfig',
	    value: function fetchBeaconConfig(option) {
	      if (!option || !option.appKey || !option.mapId) {
	        throw new Error('Invalid appKey or mapId');
	      }
	
	      var server = option.server || 'https://www.ipalmap.com/open/scene/ble/beacons';
	      var url = server + '?appKey=' + option.appKey + '&mapId=' + option.mapId;
	
	      return (0, _fetch2.default)(url, {
	        headers: {
	          Accept: 'application/json'
	        }
	      }).then(function (response) {
	        return response.json();
	      });
	    }
	
	    /**
	     * 通过Beacon设备的集合计算定位点。
	     * @param  {Object[]} beacons 扫描到的Beacon设备。每个Beacon设备的属性都需包含uuid、major、minor及rssi(或distance)。
	     * @return {Object}           定位点信息。
	     */
	
	  }, {
	    key: 'locate',
	    value: function locate(beacons) {
	      if (!this._bluetoothLocationEngine) {
	        throw new Error('Invalid BleLocationEngine');
	      }
	
	      var beaconsInfo = {};
	
	      beaconsInfo.BeaconsArray = beacons;
	      beaconsInfo = JSON.stringify(beaconsInfo);
	
	      return JSON.parse(this._bluetoothLocationEngine.locate(beaconsInfo));
	    }
	
	    /**
	     * 获取定位信息,格式如下。<br>
	     * { <br>
	     *   "type": "FeatureCollection", <br>
	     *   "features": [{ <br>
	     *     "type": "Feature", <br>
	     *     "geometry": { <br>
	     *       "type": "Point", <br>
	     *       "coordinates": [0, 0], <br>
	     *     }, <br>
	     *     "properties": { <br>
	     *       "floor_id": 0, <br>
	     *     } <br>
	     *   }] <br>
	     * }; <br>
	     * @return {Object} Location 定位信息。
	     */
	
	  }, {
	    key: 'getBleLocationInfo',
	    value: function getBleLocationInfo() {
	      return JSON.parse(this._bluetoothLocationEngine.getBleLocationInfo());
	    }
	  }]);
	
	  return BluetoothLocationManager;
	}();
	
	exports.default = BluetoothLocationManager;

/***/ }),
/* 166 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _assign = __webpack_require__(1);
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _fetch = __webpack_require__(13);
	
	var _fetch2 = _interopRequireDefault(_fetch);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var SBBLELocator = function () {
	  function SBBLELocator(options) {
	    _classCallCheck(this, SBBLELocator);
	
	    var baseUrl = options.baseUrl,
	        MAC = options.MAC;
	
	
	    if (!baseUrl || !MAC) {
	      throw new Error('Invalid options');
	    }
	
	    this._options = _assign({}, options);
	  }
	
	  _createClass(SBBLELocator, [{
	    key: '_parseBeacon',
	    value: function _parseBeacon(beacon) {
	      var major = beacon.major,
	          minor = beacon.minor,
	          accuracy = beacon.accuracy,
	          rssi = beacon.rssi;
	
	
	      return {
	        mac: major + ':' + minor,
	        accuracy: Number(accuracy),
	        rssi: Number(rssi)
	      };
	    }
	  }, {
	    key: 'fetchLocation',
	    value: function fetchLocation(beacons) {
	      var _this = this;
	
	      var _options = this._options,
	          url = _options.baseUrl,
	          MAC = _options.MAC;
	
	      var body = {};
	
	      if (!Array.isArray(beacons)) {
	        throw new Error('Invalid beacons');
	      }
	
	      body.ble = beacons.map(function (beacon) {
	        return _this._parseBeacon(beacon);
	      }).filter(function (_ref) {
	        var accuracy = _ref.accuracy;
	        return accuracy > -1;
	      });
	      body.userid = MAC;
	      body.wifi = [];
	
	      return (0, _fetch2.default)(url, {
	        headers: {
	          Accept: 'application/json',
	          'Content-Type': 'application/json'
	        },
	        method: 'POST',
	        body: JSON.stringify(body)
	      }).then(function (response) {
	        return response.json();
	      });
	    }
	  }]);
	
	  return SBBLELocator;
	}();
	
	exports.default = SBBLELocator;

/***/ }),
/* 167 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _SBBLELocator = __webpack_require__(166);
	
	var _SBBLELocator2 = _interopRequireDefault(_SBBLELocator);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	// シャビーフアンアイゴ
	var SBLocationProvider = function () {
	  function SBLocationProvider() {
	    _classCallCheck(this, SBLocationProvider);
	  }
	
	  _createClass(SBLocationProvider, [{
	    key: 'provide',
	    value: function provide(options) {
	      var type = options.type,
	          MAC = options.MAC,
	          _options$baseUrl = options.baseUrl,
	          baseUrl = _options$baseUrl === undefined ? 'http://locationtest.palmap.cn:80' : _options$baseUrl;
	
	
	      if (!MAC) {
	        throw new Error('MAC');
	      }
	
	      switch (type) {
	        case 'BLE':
	          {
	            return new _SBBLELocator2.default({ baseUrl: baseUrl, MAC: MAC });
	          }
	        default:
	          {
	            throw new Error('Invalid locator type');
	          }
	      }
	    }
	  }]);
	
	  return SBLocationProvider;
	}();
	
	exports.default = SBLocationProvider;

/***/ }),
/* 168 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.LocationStatus = exports.LocationType = exports.WiFiLocationManager = undefined;
	
	var _assign = __webpack_require__(1);
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _NGRObject3 = __webpack_require__(7);
	
	var _NGRObject4 = _interopRequireDefault(_NGRObject3);
	
	var _fetch = __webpack_require__(13);
	
	var _fetch2 = _interopRequireDefault(_fetch);
	
	var _IOUtils = __webpack_require__(161);
	
	var _package = __webpack_require__(49);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var initOptions = {
	  server: 'https://api.ipalmap.com',
	  headers: {
	    'NAG-Version': _package.version,
	    Accept: 'application/json'
	  }
	};
	
	/**
	 * Wi-Fi定位的构造类型。
	 * @memberOf NGR.location
	 * @type {Object}
	 * @property {String} MAC
	 * @property {String} PLANARGRAPH
	 * @property {String} IP
	 * @property {String} UUID
	 * @property {String} TAG
	 */
	var LocationType = {
	  MAC: 'mac',
	  PLANARGRAPH: 'floorId',
	  IP: 'ip',
	  UUID: 'uuid',
	  TAG: 'tag'
	};
	
	/**
	 * Wi-Fi定位状态。
	 * @memberOf NGR.location
	 * @type {Object}
	 * @property {Number} ENTER     移动设备进入定位范围。
	 * @property {Number} MOVE      移动。
	 * @property {Number} OUT       离开定位范围。
	 * @property {Number} HEARTBEAT 移动设备发送信号的频率，用以保证设备在线。
	 */
	var LocationStatus = {
	  ENTER: 0,
	  MOVE: 1,
	  OUT: 2,
	  HEARTBEAT: 3
	};
	
	var Looper = function (_NGRObject) {
	  _inherits(Looper, _NGRObject);
	
	  function Looper(type, value, options) {
	    _classCallCheck(this, Looper);
	
	    var _this = _possibleConstructorReturn(this, (Looper.__proto__ || Object.getPrototypeOf(Looper)).call(this));
	
	    if (typeof options.appKey === 'undefined') {
	      throw new Error('should provide an appKey');
	    }
	    _this.server = options.server || initOptions.server;
	    _this.options = {
	      headers: _assign({}, initOptions.headers, {
	        'NAG-Key': options.appKey
	      })
	    };
	    _this._parseURL(type, value);
	    _this._working = false;
	    _this._cooldDownTime = 1000;
	    _this._type = type;
	    _this._value = value;
	    return _this;
	  }
	
	  _createClass(Looper, [{
	    key: 'start',
	    value: function start() {
	      if (!this._working) {
	        this._working = true;
	        this._loop();
	      }
	    }
	  }, {
	    key: 'stop',
	    value: function stop() {
	      if (this._working) {
	        this._working = false;
	      }
	    }
	  }, {
	    key: '_parseURL',
	    value: function _parseURL(type, value) {
	      var result = void 0;
	      var types = type;
	      if (value instanceof Array) {
	        result = value.join(',');
	        types = type + 's';
	      } else {
	        result = value;
	      }
	      switch (type) {
	        case LocationType.MAC:
	        case LocationType.PLANARGRAPH:
	        case LocationType.IP:
	        case LocationType.UUID:
	        case LocationType.TAG:
	          this._url = this.server + '/pos?' + types + '=' + result;
	          break;
	        default:
	          this._url = this.server + '/pos?mac=' + result;
	          break;
	      }
	    }
	  }, {
	    key: '_loop',
	    value: function _loop() {
	      var _this2 = this;
	
	      if (this._url) {
	        this._loopRequest = function () {
	          return function () {
	            return (0, _fetch2.default)(_this2._url, _this2.options).then(_IOUtils.checkStatus).then(function (response) {
	              if (_this2._working) {
	                _this2._parse(response._bodyText);
	                if (_this2._cooldDownTime !== 1000) {
	                  _this2._cooldDownTime = 1000;
	                }
	                _this2._loopRequest();
	              }
	            }).catch(function (e) {
	              console.error(e);
	              if (_this2._working) {
	                setTimeout(function () {
	                  _this2._loopRequest();
	                }, _this2._cooldDownTime *= 2);
	              }
	            });
	          };
	        }();
	        this._loopRequest();
	      }
	    }
	  }, {
	    key: '_parse',
	    value: function _parse(response) {
	      if (response && response.length !== 0) {
	        try {
	          var data = JSON.parse(response);
	          if (data.type === 'Feature') {
	            this._parseFeature(data);
	          } else if (data.type === 'FeatureCollection') {
	            for (var _iterator = data.features, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
	              var _ref;
	
	              if (_isArray) {
	                if (_i >= _iterator.length) break;
	                _ref = _iterator[_i++];
	              } else {
	                _i = _iterator.next();
	                if (_i.done) break;
	                _ref = _i.value;
	              }
	
	              var feature = _ref;
	
	              this._parseFeature(feature);
	            }
	          }
	        } catch (e) {
	          console.error('parse error!');
	        }
	      }
	    }
	  }, {
	    key: '_parseFeature',
	    value: function _parseFeature(feature) {
	      this.emit('onParseFeature', {
	        result: feature,
	        type: this._type,
	        value: this._value
	      });
	    }
	  }]);
	
	  return Looper;
	}(_NGRObject4.default);
	
	/**
	 * Wi-Fi定位管理类，用以获取定位状态等信息。通过与Wi-Fi设备进行信息交互，完成定位和导航。
	 * @emits NGR.location.WiFiLocationManager#onLocationChange
	 * @extends {NGRObject}
	 * @memberOf NGR.location
	 */
	
	
	var WiFiLocationManager = function (_NGRObject2) {
	  _inherits(WiFiLocationManager, _NGRObject2);
	
	  /**
	   * 构造函数。
	   */
	  function WiFiLocationManager() {
	    _classCallCheck(this, WiFiLocationManager);
	
	    var _this3 = _possibleConstructorReturn(this, (WiFiLocationManager.__proto__ || Object.getPrototypeOf(WiFiLocationManager)).call(this));
	
	    _this3._loops = {};
	    _this3._macPool = {};
	
	    var self = _this3;
	    _this3._onParseFeature = function (data) {
	      self._fireFeature(data);
	    };
	    return _this3;
	  }
	
	  /**
	   * 开始监听位置信息。
	   * @param  {String} type             {@link NGR.location.LocationType|定位终端类型}。
	   * @param  {String} value            Wi-Fi定位构造类型对应的值。
	   * @param  {Object} options          配置项，如AppKey等。
	   * @param  {String} options.appKey   即从开放平台获取的AppKey。具体获取方法参照{@link https://www.ipalmap.com/docs/index.php/js-key/}。
	   * @param  {String} [options.server] 服务器地址。
	   * @return {undefined}
	   */
	
	
	  _createClass(WiFiLocationManager, [{
	    key: 'watch',
	    value: function watch(type, value, options) {
	      var key = this._generatorKey(type, value);
	      if (!this.has(key)) {
	        var looper = new Looper(type, value, options);
	        this._loops[key] = looper;
	        looper.on('onParseFeature', this._onParseFeature);
	        looper.start();
	      }
	    }
	
	    /**
	     * 停止定位监听。
	     * @param  {String} type  {@link NGR.location.LocationType|定位终端类型}。
	     * @param  {String} value Wi-Fi定位构造类型对应的值。
	     * @return {undefined}
	     */
	
	  }, {
	    key: 'unWatch',
	    value: function unWatch(type, value) {
	      var key = this._generatorKey(type, value);
	      if (this.has(key)) {
	        var looper = this._loops[key];
	        looper.off('onParseFeature', this._onParseFeature);
	        looper.stop();
	        delete this._loops[key];
	      }
	    }
	
	    /**
	     * 判断一个Wi-Fi定位的键值key是否存在监听列表内。
	     * @param  {String}  key Wi-Fi定位构造类型 + 对应的值组成的字符串。如“PLANARGRAPH127”。
	     * @return {Boolean}     若key存在于监听列表内则返回true，否则返回false。
	     */
	
	  }, {
	    key: 'has',
	    value: function has(key) {
	      return key in this._loops;
	    }
	  }, {
	    key: '_generatorKey',
	    value: function _generatorKey(type, value) {
	      return type + value;
	    }
	  }, {
	    key: '_fireFeature',
	    value: function _fireFeature(data) {
	      var feature = data.result;
	      if (!feature) {
	        return;
	      }
	      var properties = feature.properties;
	      if (properties && properties.status) {
	        var mac = properties.id_data;
	        var locationStatus = void 0;
	        switch (properties.status) {
	          case 'ENTER':
	            if (mac in this._macPool) {
	              locationStatus = LocationStatus.MOVE;
	            } else {
	              locationStatus = LocationStatus.ENTER;
	              this._macPool[mac] = 1;
	            }
	            break;
	          case 'MOVE':
	            locationStatus = LocationStatus.MOVE;
	            break;
	          case 'OUT':
	            locationStatus = LocationStatus.OUT;
	            delete this._macPool[mac];
	            break;
	          case 'HEARTBEAT':
	            locationStatus = LocationStatus.HEARTBEAT;
	            break;
	          default:
	            locationStatus = LocationStatus.OUT;
	            delete this._macPool[mac];
	            break;
	        }
	        data.locationStatus = locationStatus;
	        /**
	         * 定位信息更新事件。
	         * @event NGR.location.WiFiLocationManager#onLocationChange
	         * @type {Object}
	         * @property {String} locationStatus {@link NGR.location.LocationStatus|定位状态。}
	         * @property {Object} result         定位数据。
	         */
	        this.emit('onLocationChange', data);
	      }
	    }
	  }]);
	
	  return WiFiLocationManager;
	}(_NGRObject4.default);
	
	exports.WiFiLocationManager = WiFiLocationManager;
	exports.LocationType = LocationType;
	exports.LocationStatus = LocationStatus;

/***/ }),
/* 169 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.lifecycleEnum = undefined;
	
	var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();
	
	var _extends = _assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
	
	var _assign = __webpack_require__(1);
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _fetch = __webpack_require__(13);
	
	var _fetch2 = _interopRequireDefault(_fetch);
	
	var _data = __webpack_require__(64);
	
	var _JSONStyleGenerator = __webpack_require__(82);
	
	var _JSONStyleGenerator2 = _interopRequireDefault(_JSONStyleGenerator);
	
	var _ThreeEngine = __webpack_require__(66);
	
	var _ThreeEngine2 = _interopRequireDefault(_ThreeEngine);
	
	var _ThreeCamera = __webpack_require__(32);
	
	var _ThreeCamera2 = _interopRequireDefault(_ThreeCamera);
	
	var _MapView = __webpack_require__(26);
	
	var _MapView2 = _interopRequireDefault(_MapView);
	
	var _FeatureLayer = __webpack_require__(36);
	
	var _FeatureLayer2 = _interopRequireDefault(_FeatureLayer);
	
	var _GeometryFactory = __webpack_require__(35);
	
	var _GeometryFactory2 = _interopRequireDefault(_GeometryFactory);
	
	var _control = __webpack_require__(61);
	
	var _lang = __webpack_require__(4);
	
	var _jsts = __webpack_require__(5);
	
	var _overlay = __webpack_require__(77);
	
	var _NavigateManager = __webpack_require__(45);
	
	var _NavigateManager2 = _interopRequireDefault(_NavigateManager);
	
	var _DynamicNavigation = __webpack_require__(74);
	
	var _DynamicNavigation2 = _interopRequireDefault(_DynamicNavigation);
	
	var _location = __webpack_require__(68);
	
	var _AnimatorFactory = __webpack_require__(9);
	
	var _AnimatorFactory2 = _interopRequireDefault(_AnimatorFactory);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }
	
	function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var _Promise = typeof Promise === 'undefined' ? __webpack_require__(20).Promise : Promise;
	
	/**
	 * 地图对象生命周期的状态。
	 * @ignore
	 * @type {...}
	 * @property {Number} UNLOADED  未载入地图对象。
	 * @property {Number} LOADING   正在载入地图对象。
	 * @property {Number} LOADED    完成地图对象的载入。
	 * @property {Number} RUNNING
	 * @property {Number} STOPPING    停止载入地图对象？
	 * @property {Number} DESTROYED   销毁地图对象。
	 */
	var lifecycleEnum = {
	  UNLOADED: 0, //
	  LOADING: 1, //
	  LOADED: 2,
	  RUNNING: 3,
	  STOPPING: 4,
	  DESTROYED: 5
	};
	
	/**
	 * 地图类。
	 * @memberOf NGR.map
	 */
	
	var Map = function () {
	  /**
	   * 构造方法。
	   * @param {Object}             options 地图选项。
	   * @param {String}             options.appkey 即从开放平台获取的AppKey。具体获取方法参照{@link https://www.ipalmap.com/docs/index.php/js-key/}。
	   * @param {String|Object}      options.styleTemplate 样式JSON对象或者获取样式JSON对象的url。
	   * @param {String}             [options.server='https://api.ipalmap.com'] 获取数据的服务器地址。
	   * @param {Number}             [options.initRotationAngle=0] 初始化时地图正北方向与屏幕正上方旋转角度，顺时针为正。
	   * @param {Number}             [options.initSkewAngle=60] 地图初始化俯仰角度，即相机视角与垂直地面直线最小的夹角。
	   * @param {HTMLElement|String} [options.target='#ngr-webgl'] 地图渲染目标，可以是HTML元素或者CSS选择器字符串，不建议修改默认设置。
	   * @param {String}             [options.clearColor] 地图背景颜色。
	   * @param {String}             [options.clearImage] 地图背景图片url，优先级高于clearColor。
	   * @param {Number}             [options.fps] fps最高值，可以取1-60。
	   * @param {Number}             [options.defaultFloorId] 默认显示楼层，不设置则取地图数据中的默认楼层。
	   * @param {Number}             [options.floorHeight=60] 多楼层显示时的楼层高度。
	   * @param {Obejct}             [options.navi] 路径规划设置。
	   * @param {Boolean}            [options.navi.enable=true] 启用选项。
	   * @param {Obejct}             [options.location] 定位设置。
	   * @param {String}             [options.location.type] 定位类型，可以填'Wi-Fi'或者'bluetooth'。
	   * @param {Obejct}             [options.dynamicNavi] 动态导航设置。
	   * @param {Boolean}            [options.dynamicNavi.enable=false] 启用选项。
	   * @param {Obejct}             [options.floorControl] 楼层控件设置。
	   * @param {Boolean}            [options.floorControl.enable=true] 启用选项。
	   * @param {Obejct}             [options.zoomControl] 缩放控件设置。
	   * @param {Boolean}            [options.zoomControl.enable=true] 启用选项。
	   * @param {Obejct}             [options.compassControl] 指南针控件设置。
	   * @param {Boolean}            [options.compassControl.enable=true] 启用选项。
	   * @param {Obejct}             [options.scaleControl] 比例尺控件设置。
	   * @param {Boolean}            [options.scaleControl.enable=true] 启用选项。
	   * @param {Obejct}             [options.dimensionControl] 2D/3D切换控件设置。
	   * @param {Boolean}            [options.dimensionControl.enable=false] 启用选项。
	   * @param {Obejct}             [options.multiFloorControl] 多楼层控件设置。
	   * @param {Boolean}            [options.multiFloorControl.enable=false] 启用选项。需要楼层控件禁用时才能启用。
	   * @param {Obejct}             [options.buildingControl] 建筑控件设置。
	   * @param {Boolean}            [options.buildingControl.enable=true] 启用选项。需要多建筑模式启用才有效。
	   */
	  function Map() {
	    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
	
	    _classCallCheck(this, Map);
	
	    var appKey = options.appKey,
	        styleTemplate = options.styleTemplate;
	
	    // sanity check
	
	    if (!appKey || !styleTemplate) {
	      throw new Error('Invalid appKey or sytleTemplate');
	    }
	
	    this._options = _assign({ target: '#ngr-webgl',
	      server: 'https://api.ipalmap.com',
	      initRotationAngle: 0,
	      initSkewAngle: 60,
	      floorControl: {},
	      zoomControl: {},
	      compassControl: {},
	      scaleControl: {},
	      dimensionControl: {},
	      multiFloorControl: {},
	      buildingControl: {},
	      light: {},
	      navi: {},
	      location: {},
	      dynamicNavi: {}
	    }, options);
	
	    var _options = this._options,
	        server = _options.server,
	        navi = _options.navi,
	        location = _options.location;
	
	
	    this._status = lifecycleEnum.UNLOADED;
	    this._engine = new _ThreeEngine2.default();
	    this.planarGraphs = {};
	    this.dataSource = new _data.DataSource({ appKey: appKey, server: server });
	    this.navigationManager = this._initNaviManager(this.dataSource, navi);
	    this.locationManager = this._initLocationManager(location);
	
	    this._onClick = this._onClick.bind(this);
	    this.renderPlanarGraph = this.renderPlanarGraph.bind(this);
	    this.addOverlay = this.addOverlay.bind(this);
	    this.removeOverlay = this.removeOverlay.bind(this);
	    this.addLayer = this.addLayer.bind(this);
	    this.removeLayer = this.removeLayer.bind(this);
	  }
	
	  /**
	   * 地图默认显示楼层的id。
	   * @type  {Number}
	   * @return {Number} 楼层的id。
	   */
	
	
	  _createClass(Map, [{
	    key: '_initNaviManager',
	    value: function _initNaviManager(dataSource, _ref) {
	      var _ref$enable = _ref.enable,
	          enable = _ref$enable === undefined ? true : _ref$enable,
	          naviOpt = _objectWithoutProperties(_ref, ['enable']);
	
	      if (enable) {
	        return new _NavigateManager2.default(dataSource, naviOpt);
	      }
	      return null;
	    }
	  }, {
	    key: '_initDynimicNaviManager',
	    value: function _initDynimicNaviManager(_ref2) {
	      var _ref2$enable = _ref2.enable,
	          enable = _ref2$enable === undefined ? false : _ref2$enable,
	          messageOptions = _ref2.messageOptions,
	          cameraOptions = _ref2.cameraOptions,
	          locationOptions = _ref2.locationOptions;
	
	      // f__k fzz
	      var mapView = this.mapView,
	          navigationManager = this.navigationManager;
	
	
	      if (enable && navigationManager) {
	        return new _DynamicNavigation2.default(mapView, navigationManager, messageOptions, cameraOptions, locationOptions);
	      }
	      return null;
	    }
	  }, {
	    key: '_initLocationManager',
	    value: function _initLocationManager(_ref3) {
	      var type = _ref3.type;
	
	      switch (type) {
	        case 'Wi-Fi':
	          {
	            return new _location.WiFiLocationManager();
	          }
	        case 'bluetooth':
	          {
	            return new _location.BleWorkerManager();
	          }
	        default:
	          {
	            return null;
	          }
	      }
	    }
	  }, {
	    key: '_genLightLayer',
	    value: function _genLightLayer(styleGenerator, _ref4) {
	      var _ref4$enable = _ref4.enable,
	          enable = _ref4$enable === undefined ? true : _ref4$enable,
	          _ref4$position = _ref4.position,
	          position = _ref4$position === undefined ? [0, 300, 300] : _ref4$position,
	          _ref4$id = _ref4.id,
	          id = _ref4$id === undefined ? 1 : _ref4$id;
	
	      var layer = null;
	
	      if (enable) {
	        var feature = new _data.Feature(_GeometryFactory2.default.createPoint(position.concat()), { id: id });
	
	        layer = new _FeatureLayer2.default('light', styleGenerator);
	        layer.addFeature(feature);
	      }
	
	      return layer;
	    }
	  }, {
	    key: '_genControl',
	    value: function _genControl(name, _ref5) {
	      var _this = this;
	
	      var _ref5$enable = _ref5.enable,
	          enable = _ref5$enable === undefined ? true : _ref5$enable,
	          rest = _objectWithoutProperties(_ref5, ['enable']);
	
	      var control = null;
	
	      if (enable) {
	        switch (name) {
	          case 'zoom':
	            {
	              control = new _control.ZoomControl(rest);
	              break;
	            }
	          case 'scale':
	            {
	              control = new _control.ScaleControl(rest);
	              break;
	            }
	          case 'compass':
	            {
	              control = new _control.CompassControl(rest);
	              break;
	            }
	          case 'dimension':
	            {
	              control = new _control.DimensionControl(rest);
	              break;
	            }
	          case 'floor':
	            {
	              var floorList = rest.floorList,
	                  flrCtrlOpt = _objectWithoutProperties(rest, ['floorList']);
	
	              control = new _control.FloorControl(flrCtrlOpt);
	              control.setFloorList(floorList.concat().reverse());
	              // alias for preventing reserved word
	              control.on('change', function (_ref6) {
	                var fromFloor = _ref6.from,
	                    toFloor = _ref6.to,
	                    targetControl = _ref6.targetControl;
	
	                var toAltitude = Number(targetControl.floorMap[toFloor].altitude) || 0;
	                var fromAltitude = Number(targetControl.floorMap[fromFloor].altitude) || 0;
	
	                console.log('floor change from ' + fromFloor + ' to ' + toFloor);
	                targetControl.setCurrentFloor(toFloor);
	                _this.renderPlanarGraph(Number(toFloor), {
	                  direction: toAltitude - fromAltitude > 0 ? 'up' : 'down'
	                });
	              });
	              break;
	            }
	          case 'multiFloor':
	            {
	              var _floorList = rest.floorList,
	                  multiFlrCtrlOpt = _objectWithoutProperties(rest, ['floorList']);
	
	              control = new _control.MultiFloorControl(multiFlrCtrlOpt);
	              control.setFloorList(_floorList.concat().reverse());
	              break;
	            }
	          case 'building':
	            {
	              var _rest$baseAddress = rest.baseAddress,
	                  baseAddress = _rest$baseAddress === undefined ? 'base' : _rest$baseAddress,
	                  buildingList = rest.buildingList,
	                  bldgCtrlOpt = _objectWithoutProperties(rest, ['baseAddress', 'buildingList']);
	
	              var mBuildingList = buildingList.concat();
	
	              mBuildingList.push({
	                id: this._baseFloorId,
	                address: baseAddress
	              });
	              control = new _control.FloorControl(_extends({
	                name: 'multiBuilding',
	                className: 'ngr-building-switcher'
	              }, bldgCtrlOpt));
	              control.setFloorList(mBuildingList.reverse());
	              control.on('change', function (_ref7) {
	                var fromBuilding = _ref7.from,
	                    toBuilding = _ref7.to,
	                    targetControl = _ref7.targetControl;
	
	                console.log('building change from ' + fromBuilding + ' to ' + toBuilding);
	                targetControl.setCurrentFloor(toBuilding, function (toBuilding) {
	                  _this._clearFloorControl();
	                  if (toBuilding === _this.baseFloorId) {
	                    _this.loadBaseFloor();
	                  } else {
	                    _this.renderBuilding(toBuilding);
	                  }
	                });
	              });
	              break;
	            }
	          default:
	            {
	              console.warn('Invalid control type');
	            }
	        }
	        if (control) {
	          control.addTo(this.mapView);
	        }
	      }
	
	      return control;
	    }
	  }, {
	    key: '_clear',
	    value: function _clear() {
	      this._clearBuildingControl();
	      this._clearFloorControl();
	
	      this.planarGraphs = {};
	      this._baseFloorId = null;
	      this._buildingInfoList = null;
	      this._buildingList = null;
	      this._floorInfoMap = null;
	      this._mapId = null;
	      this._offsetCoord = null;
	
	      return this;
	    }
	  }, {
	    key: '_createOverlay',
	    value: function _createOverlay(_ref8) {
	      var element = _ref8.element,
	          url = _ref8.url,
	          rest = _objectWithoutProperties(_ref8, ['element', 'url']);
	
	      var overlay = null;
	
	      if (element && element instanceof HTMLElement) {
	        overlay = new _overlay.Overlay(element);
	      } else if (url) {
	        overlay = new _overlay.IconOverlay(_extends({}, rest, { url: url }));
	      } else {
	        throw new Error('Invalid element or url');
	      }
	
	      return overlay;
	    }
	  }, {
	    key: '_createLayer',
	    value: function _createLayer(name, features) {
	      var _this2 = this;
	
	      if (!(0, _lang.isString)(name)) {
	        throw new Error('Invalid layer name');
	      }
	
	      var layer = new _FeatureLayer2.default(name, this.mapView.styleGenerator);
	
	      features.forEach(function (plainFeature) {
	        return layer.addFeature(_this2.createFeature(plainFeature));
	      }, this);
	
	      return layer;
	    }
	  }, {
	    key: '_checkRunning',
	    value: function _checkRunning() {
	      if (this._status !== lifecycleEnum.RUNNING) {
	        throw new Error('map is not running');
	      }
	
	      return this;
	    }
	
	    /**
	     * 偏移坐标。
	     * @param {Number} x x轴坐标值。
	     * @param {Number} y y轴坐标值。
	     * @return {NGR.geom.Coordinate} 偏移后的坐标点。
	     */
	
	  }, {
	    key: 'offset',
	    value: function offset(x, y) {
	      var offset = this.getOffset();
	
	      return {
	        x: x + offset.x,
	        y: y + offset.y
	      };
	    }
	
	    /**
	     * 反偏移
	     * @param {Number} x x轴坐标值。
	     * @param {Number} y y轴坐标值。
	     * @return {NGR.geom.Coordinate} 反偏移后的坐标点。
	     */
	
	  }, {
	    key: 'unoffset',
	    value: function unoffset(x, y) {
	      var offset = this.getOffset();
	
	      return {
	        x: x - offset.x,
	        y: y - offset.y
	      };
	    }
	  }, {
	    key: '_onClick',
	    value: function _onClick(_ref9) {
	      var _ref9$touches = _slicedToArray(_ref9.touches, 1),
	          _ref9$touches$ = _ref9$touches[0],
	          clientX = _ref9$touches$.clientX,
	          clientY = _ref9$touches$.clientY;
	
	      if (!(0, _lang.isFunction)(this.onClick) || this._status !== lifecycleEnum.RUNNING) {
	        return this;
	      }
	
	      var objs = this.mapView.searchObjectsByClient(clientX, clientY);
	
	      if (objs.length === 0) {
	        return this;
	      }
	
	      var _objs$ = objs[0],
	          feature = _objs$.feature,
	          _objs$$point = _objs$.point,
	          x = _objs$$point.x,
	          y = _objs$$point.y,
	          z = _objs$$point.z;
	
	      var _unoffset = this.unoffset(x, y),
	          gx = _unoffset.x,
	          gy = _unoffset.y;
	
	      this.onClick({
	        point: {
	          x: gx,
	          y: gy,
	          z: z
	        },
	        feature: feature,
	        layer: feature.parent
	      });
	
	      return this;
	    }
	  }, {
	    key: '_clearFloorControl',
	    value: function _clearFloorControl() {
	      var control = this.floorControl || this.multiFloorControl;
	
	      if (this.mapView && control) {
	        this.mapView.removeDomControl(control);
	        this.floorControl = null;
	        this.multiFloorControl = null;
	      }
	
	      return this;
	    }
	  }, {
	    key: '_clearBuildingControl',
	    value: function _clearBuildingControl() {
	      var control = this.buildingControl;
	
	      if (this.mapView && control) {
	        this.mapView.removeDomControl(control);
	        this.buildingControl = null;
	      }
	
	      return this;
	    }
	  }, {
	    key: '_initMapView',
	    value: function _initMapView() {
	      if (this.mapView) {
	        return this;
	      }
	
	      var _options2 = this._options,
	          dynamicNavi = _options2.dynamicNavi,
	          target = _options2.target,
	          initRotationAngle = _options2.initRotationAngle,
	          initSkewAngle = _options2.initSkewAngle,
	          light = _options2.light,
	          zoomControl = _options2.zoomControl,
	          compassControl = _options2.compassControl,
	          scaleControl = _options2.scaleControl,
	          dimensionControl = _options2.dimensionControl,
	          width = _options2.width,
	          height = _options2.height,
	          devicePixelRatio = _options2.devicePixelRatio,
	          clearColor = _options2.clearColor,
	          clearImage = _options2.clearImage,
	          fps = _options2.fps;
	
	      var aspect = (width || window.innerWidth) / (height || window.innerHeight);
	      var camera = new _ThreeCamera2.default(45, aspect, 1, 80000);
	      var styleGenerator = new _JSONStyleGenerator2.default(this._styleJson);
	      var mapView = new _MapView2.default(target, { styleGenerator: styleGenerator, initSkewAngle: initSkewAngle, initRotationAngle: initRotationAngle });
	
	      camera.camera.position.set(0, 0, 100);
	      mapView.activeCamera = camera;
	      this._engine.initMapView(mapView, { width: width, height: height, devicePixelRatio: devicePixelRatio, clearColor: clearColor, clearImage: clearImage, fps: fps });
	
	      // initialize properties
	      this.mapView = mapView;
	      this._sceneManager = mapView.sceneManager;
	      this._activeControl = mapView.activeControl;
	      this._light = this._genLightLayer(styleGenerator, light);
	
	      // handle controls
	      this.zoomControl = this._genControl('zoom', zoomControl);
	      this.compassControl = this._genControl('compass', compassControl);
	      this.scaleControl = this._genControl('scale', scaleControl);
	      this.dimensionControl = this._genControl('dimension', _extends({ enable: false }, dimensionControl));
	
	      // start loop
	      mapView.start();
	
	      // listen click event
	      mapView.gestureManager.on('tap', this._onClick);
	
	      // add dynamic navigation
	      this.dynamicNavigationManager = this._initDynimicNaviManager(dynamicNavi);
	
	      return this;
	    }
	  }, {
	    key: '_renderBuilding',
	    value: function _renderBuilding(id) {
	      var _this3 = this;
	
	      this._status = lifecycleEnum.LOADED;
	
	      var _options3 = this._options,
	          defaultFloorId = _options3.defaultFloorId,
	          floorControl = _options3.floorControl,
	          multiFloorControl = _options3.multiFloorControl,
	          mapView = this.mapView,
	          onLoad = this.onLoad;
	
	      var floorList = this._floorInfoMap[id].concat();
	      var firstFloorId = void 0;
	
	      // handle controls
	      this.floorControl = this._genControl('floor', _extends({}, floorControl, { floorList: floorList }));
	
	      if (!this.floorControl) {
	        this.multiFloorControl = this._genControl('multiFloor', _extends({ enable: false, floorList: floorList }, multiFloorControl));
	      }
	
	      // get the first floor id
	      if (defaultFloorId) {
	        firstFloorId = defaultFloorId;
	      } else {
	        firstFloorId = floorList[0].id;
	        for (var _iterator = floorList, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
	          var _ref10;
	
	          if (_isArray) {
	            if (_i >= _iterator.length) break;
	            _ref10 = _iterator[_i++];
	          } else {
	            _i = _iterator.next();
	            if (_i.done) break;
	            _ref10 = _i.value;
	          }
	
	          var floor = _ref10;
	
	          if (floor.default || floor.defaultFloor) {
	            firstFloorId = floor.id;
	            break;
	          }
	        }
	      }
	
	      this._status = lifecycleEnum.RUNNING;
	
	      if (this.multiFloorControl) {
	        // multi-floor mode
	        this.multiFloorControl.defaultFloorId = firstFloorId;
	        this.multiFloorControl.setCurrentFloor(firstFloorId);
	        this._renderMultiPlanarGraphs(id);
	        this.multiFloorControl.highlightPGs([firstFloorId]);
	      } else {
	        // single-floor mode
	        // render the first planarGraph
	        this.renderPlanarGraph(firstFloorId);
	        if (this.floorControl) {
	          this.floorControl.defaultFloorId = firstFloorId;
	          this.floorControl.setCurrentFloor(firstFloorId);
	        }
	      }
	
	      if (!this._baseFloorId) {
	        mapView.next(1, function () {
	          if (_this3.scaleControl) {
	            _this3.scaleControl.update();
	          }
	          if ((0, _lang.isFunction)(onLoad)) {
	            onLoad(_this3);
	          }
	        });
	      }
	
	      return this;
	    }
	  }, {
	    key: '_renderMultiPlanarGraphs',
	    value: function _renderMultiPlanarGraphs(buildingId) {
	      var _this4 = this;
	
	      var _options$floorHeight = this._options.floorHeight,
	          floorHeight = _options$floorHeight === undefined ? 60 : _options$floorHeight,
	          light = this._light,
	          mapView = this.mapView;
	
	      var planarGraphs = this._floorInfoMap[buildingId].concat().map(function (_ref11) {
	        var id = _ref11.id;
	
	        return new _data.PlanarGraph(_this4.planarGraphs[id]);
	      });
	
	      mapView.floorHeight = floorHeight;
	      mapView.activeControl._enableVerticalMove = true;
	      mapView.drawMultiPlanarGraph(planarGraphs);
	
	      if (light) {
	        mapView.addLayer(light);
	      }
	    }
	
	    /**
	     * 根据图层名称获图层。
	     * @param  {String} layerName   图层名称。
	     * @return {NGR.layer.Layer} 图层对象。
	     */
	
	  }, {
	    key: 'getLayer',
	    value: function getLayer(layerName) {
	      var layer = null;
	
	      if (this.mapView) {
	        layer = this.mapView.getLayer(layerName);
	      }
	
	      return layer;
	    }
	
	    /**
	     * 当前地图是否包含特定图层。
	     * @param  {String} layerName   图层名称。
	     * @return {Boolean} 图层对象。
	     */
	
	  }, {
	    key: 'hasLayer',
	    value: function hasLayer(layerName) {
	      return !!this.getLayer(layerName);
	    }
	
	    /**
	     * 显示指定楼层的平面图。该接口在多楼层模式时才能使用。
	     * @param  {Number[]} ids   图层名称。
	     * @return {Number} 当前显示的平面图数量。
	     */
	
	  }, {
	    key: 'showPlanarGraphs',
	    value: function showPlanarGraphs(ids) {
	      this._checkRunning();
	      if (!this.multiFloorControl) {
	        console.warn('map is not in multi-floor mode');
	      }
	
	      return this.mapView.showPlanarGraphs(ids);
	    }
	
	    /**
	     * 绘制平面图。
	     * @param  {String} id   图层名称。
	     * @param  {Boolean} animation   是否使用动画效果。
	     * @return {NGR.map.Map} this。
	     */
	
	  }, {
	    key: 'renderPlanarGraph',
	    value: function renderPlanarGraph(id, animation) {
	      var _this5 = this;
	
	      this._checkRunning();
	      if (this.multiFloorControl) {
	        console.warn('map is in multi-floor mode');
	      }
	
	      var rawPlanarGraph = this.planarGraphs[id];
	
	      if (rawPlanarGraph) {
	        this.mapView.drawPlanarGraph(new _data.PlanarGraph(rawPlanarGraph));
	        if (this._light) {
	          this.mapView.addLayer(this._light);
	        }
	      } else {
	        throw new Error('planarGraph unloaded');
	      }
	
	      if (animation) {
	        var direction = animation.direction;
	
	        var _target = this.mapView.activeControl.target;
	
	        var _unoffset2 = this.unoffset(_target.x, _target.y),
	            x = _unoffset2.x,
	            y = _unoffset2.y;
	
	        var startZ = 0;
	
	        this.enableVerticalMove();
	
	        if (direction === 'up') {
	          startZ = -100;
	        } else if (direction === 'down') {
	          startZ = 100;
	        }
	
	        _AnimatorFactory2.default.getInstance().ofNumber(startZ, 0, 300).on('update', function (animator, _ref12) {
	          var num = _ref12.num;
	
	          _this5.moveToPoint({ x: x, y: y, z: num }, {
	            needUpdate: true,
	            needCollision: false,
	            emitEnd: false
	          });
	        }).on('complete', function () {
	          _this5.move({ x: x, y: y, z: 0 }, {
	            needUpdate: true,
	            needCollision: true,
	            emitEnd: true
	          });
	        }).start();
	      }
	
	      return this;
	    }
	
	    /**
	     * 绘制建筑。
	     * @param  {String} id   建筑物id。
	     * @return {NGR.map.Map} this。
	     */
	
	  }, {
	    key: 'renderBuilding',
	    value: function renderBuilding(id) {
	      var _this6 = this;
	
	      if (this._buildingList.indexOf(id) === -1) {
	        throw new Error('Invalid building id');
	      }
	
	      var dataSource = this.dataSource;
	
	
	      this._status = lifecycleEnum.LOADING;
	      if (this._floorInfoMap[id]) {
	        this._renderBuilding(id);
	      } else {
	        dataSource.requestPOIChildren(id).then(function (floors) {
	          _this6._floorInfoMap[id] = floors.concat();
	
	          return _Promise.all(floors.map(function (floor) {
	            return dataSource.requestPlanarGraph(floor.id);
	          }));
	        }).then(function (rawPlanarGraphList) {
	          var floors = _this6._floorInfoMap[id].map(function (floor) {
	            return floor.id;
	          });
	
	          rawPlanarGraphList.forEach(function (rawPlanarGraph, index) {
	            _this6.planarGraphs[floors[index]] = rawPlanarGraph;
	          });
	          _this6._renderBuilding(id);
	        });
	      }
	
	      return this;
	    }
	
	    /**
	     * 创建Feature。
	     * @param  {String} options.id  Feature的id。
	     * @param  {String} options.type 渲染元素的类型，如'Point'、'Polygon'、'LineString'。
	     * @param  {Array} options.coordinates  当Feature为'Point'时，Array中为坐标点，如[1,1]；
	     *                                      当Feature为'LineString'时，Array为二维数组，如[[0,0],[1,1]]；
	     *                                      当Feature为'MultiLineString'时，Array为三维数组，如[[[0,0],[1,1]],[[2,2],[3,3]]]。
	     * @param  {Object} [options.properties] Feature的其它属性。
	     * @return {NGR.data.Feature} Feature对象。
	     */
	
	  }, {
	    key: 'createFeature',
	    value: function createFeature(_ref13) {
	      var id = _ref13.id,
	          type = _ref13.type,
	          coordinates = _ref13.coordinates,
	          properties = _ref13.properties;
	
	      var geometry = null;
	
	      if (!(0, _lang.isNumber)(id)) {
	        throw new Error('Invalid id: id must be a number');
	      }
	      switch (type) {
	        case 'Point':
	          {
	            geometry = _GeometryFactory2.default.createPoint(coordinates);
	            break;
	          }
	        case 'Polygon':
	          {
	            geometry = _GeometryFactory2.default.createPolygon(coordinates);
	            break;
	          }
	        case 'LineString':
	          {
	            geometry = _GeometryFactory2.default.createLineString(coordinates);
	            break;
	          }
	        case 'MultiPoint':
	          {
	            geometry = _GeometryFactory2.default.createMultiPoint(coordinates);
	            break;
	          }
	        case 'MultiPolygon':
	          {
	            geometry = _GeometryFactory2.default.createMultiPolygon(coordinates);
	            break;
	          }
	        case 'MultiLineString':
	          {
	            geometry = _GeometryFactory2.default.createMultiLineString(coordinates);
	            break;
	          }
	        default:
	          {
	            throw new Error('Invalid geometry type');
	          }
	      }
	
	      return new _data.Feature(geometry, _extends({}, properties, { id: id }));
	    }
	
	    /**
	     * 创建图层。
	     * @param  {String} options.name  图层名称。
	     * @param  {Boolean} [options.needOffset=true] 是否需要偏移，默认为true，即需要偏移。
	     * @param  {Feature[]} [options.features]  图层的Feature列表。
	     * @return {NGR.layer.Layer} 图层。
	     */
	
	  }, {
	    key: 'createLayer',
	    value: function createLayer(_ref14) {
	      var _this7 = this;
	
	      var name = _ref14.name,
	          _ref14$needOffset = _ref14.needOffset,
	          needOffset = _ref14$needOffset === undefined ? true : _ref14$needOffset,
	          features = _ref14.features;
	
	      if (!(0, _lang.isString)(name)) {
	        throw new Error('Invalid layer name');
	      }
	
	      var layer = new _FeatureLayer2.default(name, this.mapView.styleGenerator);
	
	      // offset should be assigned before adding features
	      if (needOffset) {
	        try {
	          layer.coordinateSystem = this.mapView.coordinateSystem;
	        } catch (e) {
	          throw new Error('Invalid map coordinate system');
	        }
	      }
	
	      features.forEach(function (plainFeature) {
	        return layer.addFeature(_this7.createFeature(plainFeature));
	      }, this);
	
	      return layer;
	    }
	
	    /**
	     * 添加图层。
	     * @param  {Object} options   配置选项。
	     * @param  {String} options.name  图层名称。
	     * @param  {Boolean} [options.needOffset=true] 是否需要偏移，默认为true，即需要偏移。
	     * @param  {Feature[]} [options.features]  图层的Feature列表。
	     * @return {NGR.layer.Layer} 图层。
	     */
	
	  }, {
	    key: 'addLayer',
	    value: function addLayer(options) {
	      var layer = null;
	
	      this._checkRunning();
	      if (options instanceof _FeatureLayer2.default) {
	        layer = options;
	      } else {
	        layer = this.createLayer(options);
	      }
	
	      this.mapView.addLayer(layer);
	
	      return layer;
	    }
	
	    /**
	     * 移除图层。
	     * @param  {NGR.layer.Layer} layer   需要被移除的图层对象.
	     * @return {NGR.map.Map} this。
	     */
	
	  }, {
	    key: 'removeLayer',
	    value: function removeLayer(layer) {
	      this._checkRunning();
	
	      this.mapView.removeLayer(layer);
	
	      return this;
	    }
	
	    /**
	     * 添加覆盖物。
	     * @param {Object}  options 覆盖物选项。
	     * @param  {Boolean} [options.needOffset=true]   是否需要偏移，默认为true，即需要偏移。
	     * @param  {Coordinates} options.position   需要添加的位置坐标。若'needOffset'设为true，则传如WGS 84墨卡托投影坐标；否则，传入3D世界坐标。
	     * @param {HTMLElement} [options.element]  HTML元素。'element'和'url'必须传入一项。如果二者都传入，则'element'优先级更高。
	     * @param {String} [options.url] 图片的url。仅当没有传入'element'时有效。
	     * @param {String}  [options.defaultDisplay]  CSS中的display属性的值。
	     * @param {Number[]} [options.size]          图片大小。仅'url'生效时有效。
	     * @param {Number[]} [options.anchor=[0, 0]] 锚点，用于确定图片旋转的中心点。仅'url'生效时有效。
	     * @param {String}   [options.className='']  img类名。仅'url'生效时有效。
	     * @param {String} [options.crossOrigin] 图片的crossOrgin属性。仅'url'生效时有效。
	     * @param {String} [options.alt] 图片alt属性。仅'url'生效时有效。
	     * @return {NGR.overlayer.Overlayer} 覆盖物对象。
	     */
	
	  }, {
	    key: 'addOverlay',
	    value: function addOverlay(options) {
	      var _options$needOffset = options.needOffset,
	          needOffset = _options$needOffset === undefined ? true : _options$needOffset,
	          position = options.position,
	          overlayOpt = _objectWithoutProperties(options, ['needOffset', 'position']);
	
	      this._checkRunning();
	      if (!(0, _lang.isArray)(position)) {
	        throw new Error('Invalid position: position must be an array');
	      }
	
	      var overlay = this._createOverlay(overlayOpt);
	
	      if (needOffset) {
	        overlay.coordinateSystem = this.mapView.coordinateSystem;
	      }
	
	      this.mapView.addOverlay(overlay);
	
	      overlay.position = new (Function.prototype.bind.apply(_jsts.geom.Coordinate, [null].concat(_toConsumableArray(position))))();
	
	      return overlay;
	    }
	
	    /**
	     * 删除一个地图覆盖物。
	     * @param {NGR.overlay.Overlay} overlay 覆盖物对象。
	     * @return {NGR.map.Map}  this。
	     */
	
	  }, {
	    key: 'removeOverlay',
	    value: function removeOverlay(overlay) {
	      this._checkRunning();
	
	      this.mapView.removeOverlay(overlay);
	
	      return this;
	    }
	
	    /**
	     * 获取当前地图的偏移量。
	     * @return {NGR.geom.Coordinate} 偏移量。
	     */
	
	  }, {
	    key: 'getOffset',
	    value: function getOffset() {
	      if (this._offsetCoord) {
	        return this._offsetCoord.copy();
	      }
	      try {
	        this._offsetCoord = new (Function.prototype.bind.apply(_jsts.geom.Coordinate, [null].concat(_toConsumableArray(this.mapView.coordinateSystem.getOffset()))))();
	
	        return this._offsetCoord.copy();
	      } catch (e) {
	        return null;
	      }
	    }
	
	    /**
	     * 根据指定的参数查找符合条件的渲染场景集合，并且修改它们缩放的大小。
	     * @param  {NGR.layer.Layer}  layer 需要修改数据的图层。
	     * @param  {String} key   查找条件的字段。
	     * @param  {Object} value 字段的值。
	     * @param  {Number} x     缩放的方向，x轴坐标。
	     * @param  {Number} y     缩放的方向，y轴坐标。
	     * @param  {Number} z     缩放的方向，z轴坐标。
	     * @return {NGR.map.Map} this。
	     */
	
	  }, {
	    key: 'setScale',
	    value: function setScale(layer, key, value, x, y, z) {
	      this._sceneManager.setScale(layer, key, value, x, y, z);
	
	      return this;
	    }
	
	    /**
	     * 根据指定的参数查找符合条件的渲染场景集合，并且修改它们的位置。
	     * @param  {NGR.layer.Layer}   layer  需要修改数据的图层。
	     * @param  {String}  key   查找条件的字段。
	     * @param  {Object}  value 字段的值。
	     * @param  {Number}  x      x轴坐标值。
	     * @param  {Number}  y      y轴坐标值。
	     * @param  {Number}  z      z轴坐标值。
	     * @return {NGR.map.Map}   this。
	     */
	
	  }, {
	    key: 'setPosition',
	    value: function setPosition(layer, key, value, x, y, z) {
	      this._sceneManager.setPosition(layer, key, value, x, y, z);
	
	      return this;
	    }
	
	    /**
	     * 根据指定的参数查找符合条件的渲染场景集合，并且修改它们的位置。此方法不
	     * 会更新八叉树，适用于上层动画。
	     * @ignore
	     * @param  {Layer}   layer  需要修改数据的图层。
	     * @param  {String}  key    匹配的键。
	     * @param  {Object}  value  匹配的值。
	     * @param  {Number}  x      x。
	     * @param  {Number}  y      y。
	     * @param  {Number}  z      z。
	     * @return {NGR.map.Map}   this。
	     */
	
	  }, {
	    key: 'quickSetPosition',
	    value: function quickSetPosition(layer, key, value, x, y, z) {
	      this._sceneManager.quickSetPosition(layer, key, value, x, y, z);
	
	      return this;
	    }
	
	    /**
	     * 根据指定的参数查找符合条件的渲染场景集合，并且修改它们的角度。
	     * @param  {NGR.layer.Layer}  layer 需要修改数据的图层。
	     * @param  {String} key   查找条件的字段。
	     * @param  {Object} value 字段的值。
	     * @param  {Number} x     x轴坐标值。
	     * @param  {Number} y     y轴坐标值。
	     * @param  {Number} z     z轴坐标值。
	     * @return {NGR.map.Map} this。
	     */
	
	  }, {
	    key: 'setRotation',
	    value: function setRotation(layer, key, value, x, y, z) {
	      this._sceneManager.setRotation(layer, key, value, x, y, z);
	
	      return this;
	    }
	
	    /**
	     * 根据指定的参数查找符合条件的渲染场景场景集合，并且设置它们是否可见。
	     * @param  {NGR.layer.Layer}   layer   需要修改数据的图层。
	     * @param  {String}  key   查找条件的字段。
	     * @param  {Object}  value 字段的值。
	     * @param  {Boolean} visible 是否显示，true为可见，false为不可见。
	     * @return {NGR.map.Map}    this。
	     */
	
	  }, {
	    key: 'setVisible',
	    value: function setVisible(layer, key, value, visible) {
	      this._sceneManager.setVisible(layer, key, value, visible);
	
	      return this;
	    }
	
	    /**
	     * 根据指定的参数查找符合条件的渲染场景集合，并且修改它们的颜色。
	     * @param  {NGR.layer.Layer}  layer      需要修改数据的图层。
	     * @param  {String}        key   查找条件的字段。
	     * @param  {Object}        value 字段的值。
	     * @param  {Number|String} color      颜色。
	     * @return {NGR.map.Map}             this。
	     */
	
	  }, {
	    key: 'setColor',
	    value: function setColor(layer, key, value, color) {
	      this._sceneManager.setColor(layer, key, value, color);
	
	      return this;
	    }
	
	    /**
	     * 根据指定的参数查找符合条件的渲染场景集合，并且重置颜色。
	     * @param  {NGR.layer.Layer} layer 需要修改数据的图层。
	     * @param  {String}       key   查找条件的字段。
	     * @param  {Object}       value 字段的值。
	     * @return {NGR.map.Map}       this。
	     */
	
	  }, {
	    key: 'resetColor',
	    value: function resetColor(layer, key, value) {
	      this._sceneManager.resetColor(layer, key, value);
	
	      return this;
	    }
	
	    /**
	     * 根据指定的参数查找符合条件的渲染场景集合，并且修改它们的透明度。
	     * @param  {NGR.layer.Layer}  layer      需要修改数据的图层。
	     * @param  {String}        key   查找条件的字段。
	     * @param  {Object}        value 字段的值。
	     * @param  {Number|String} opacity    透明度。
	     * @return {NGR.map.Map}             this。
	     */
	
	  }, {
	    key: 'setOpacity',
	    value: function setOpacity(layer, key, value, opacity) {
	      this._sceneManager.setOpacity(layer, key, value, opacity);
	
	      return this;
	    }
	
	    /**
	     * 重设管理器中符合条件的渲染场景的样式。
	     * @param  {NGR.layer.Layer}    layer    需要修改数据的图层。
	     * @param  {String}          key   查找条件的字段。
	     * @param  {Object}          value 字段的值。
	     * @param  {NGR.style.Style} newStyle 新的样式。
	     * @return {NGR.map.Map}             this。
	     */
	
	  }, {
	    key: 'resetStyle',
	    value: function resetStyle(layer, key, value, newStyle) {
	      this._sceneManager.resetStyle(layer, key, value, newStyle);
	
	      return this;
	    }
	
	    /**
	     * 批量设置Feature。
	     * @ignore
	     * @param {string}                              method   修改方法。
	     * @param {Layer|String}                        layer    所以这里是feature数据还是楼层高数据？需要设置的Feature对象所在的楼层。需要修改的数据修改哪个层中的数据。
	     * @param {NGR.data.Feature|NGR.data.Feature[]} features 待修改的Feature。
	     * @param {...Object}                           values   修改值。
	     * @return {SceneManager}                                this。
	     */
	
	  }, {
	    key: 'setValueChangeByFeatures',
	    value: function setValueChangeByFeatures(method, layer, features) {
	      var _sceneManager;
	
	      for (var _len = arguments.length, values = Array(_len > 3 ? _len - 3 : 0), _key = 3; _key < _len; _key++) {
	        values[_key - 3] = arguments[_key];
	      }
	
	      (_sceneManager = this._sceneManager).setValueChangeByFeatures.apply(_sceneManager, [method, layer, features].concat(values));
	
	      return this;
	    }
	
	    /**
	     * 设置相机位置（position）与其视角所正对的地面位置（target）之间的最大最小距离。
	     * @param {Number}  options.minDistance 最小距离。
	     * @param {Number}  options.maxDistance 最大距离。
	     * @return {NGR.map.Map}  this。
	     */
	
	  }, {
	    key: 'setDistanceRange',
	    value: function setDistanceRange(_ref15) {
	      var minDistance = _ref15.minDistance,
	          maxDistance = _ref15.maxDistance;
	
	      if ((0, _lang.isNumber)(minDistance)) {
	        this._activeControl.minDistance = minDistance;
	      }
	      if ((0, _lang.isNumber)(maxDistance)) {
	        this._activeControl.maxDistance = maxDistance;
	      }
	
	      return this;
	    }
	
	    /**
	     * 获取相机位置（position）与其视角所正对的地面位置（target）之间的距离。
	     * @return {Number}  距离。
	     */
	
	  }, {
	    key: 'getDistance',
	    value: function getDistance() {
	      return this._activeControl.getfocalLength();
	    }
	
	    /**
	     * 设置俯仰角度的范围。
	     * @param {Number}  minAngle   最小俯仰角度，即相机视角与垂直地面直线最小的夹角。
	     * @param {Number}  maxAngle   最大俯仰角度，即相机视角与垂直地面直线最大的夹角。
	     * @return {NGR.map.Map}    this。
	     */
	
	  }, {
	    key: 'setSkewAngleRange',
	    value: function setSkewAngleRange(_ref16) {
	      var minAngle = _ref16.minAngle,
	          maxAngle = _ref16.maxAngle;
	
	      if ((0, _lang.isNumber)(minAngle)) {
	        this._activeControl.minAngle = minAngle;
	      }
	      if ((0, _lang.isNumber)(maxAngle)) {
	        this._activeControl.maxAngle = maxAngle;
	      }
	
	      return this;
	    }
	
	    /**
	     * 获取相机视角俯仰角度。
	     * @return {Number} 俯仰角度，即相机视角与垂直地面直线的夹角。单位度。
	     */
	
	  }, {
	    key: 'getSkewAngle',
	    value: function getSkewAngle() {
	      return this._activeControl.getSkew();
	    }
	
	    /**
	     * 获取相机视角相对于屏幕正上方的旋转角度。顺时针为正。
	     * @return {Number} 旋转角度。
	     */
	
	  }, {
	    key: 'getRotationAngle',
	    value: function getRotationAngle() {
	      return this._activeControl.getRotate();
	    }
	
	    /**
	     * 允许相机垂直移动。默认为不允许。
	     * @ignore
	     * @return {ThirdPersonControl} this。
	     */
	
	  }, {
	    key: 'enableVerticalMove',
	    value: function enableVerticalMove() {
	      this._activeControl.enableVerticalMove();
	
	      return this;
	    }
	
	    /**
	     * 不允许相机垂直移动。
	     * @ignore
	     * @return {ThirdPersonControl} this.
	     */
	
	  }, {
	    key: 'disableVerticalMove',
	    value: function disableVerticalMove() {
	      this._activeControl.disableVerticalMove();
	
	      return this;
	    }
	
	    /**
	     * 以某一增量值移动相机视角。
	     * @param  {NGR.geom.Coordinate}  deltaCoord  在x、y、z轴上移动的增量距离。
	     * @param  {Object}  [options] 相机视角更新选项。
	     * @param  {Boolean} [options.needUpdate=true]    是否调用update方法更新视角，是则设置为true。
	     * @param  {Boolean} [options.needCollision=true] 是否调用collision方法进行碰撞检测，是则设置为true。
	     * @param  {Boolean} [options.emitEnd=true]       是否分发事件给相应的监听器处理，是则设置为true。
	     * @return {NGR.map.Map}   this。
	     */
	
	  }, {
	    key: 'move',
	    value: function move(deltaCoord) {
	      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
	      var x = deltaCoord.x,
	          y = deltaCoord.y,
	          _deltaCoord$z = deltaCoord.z,
	          z = _deltaCoord$z === undefined ? 0 : _deltaCoord$z;
	      var needUpdate = options.needUpdate,
	          needCollision = options.needCollision,
	          emitEnd = options.emitEnd;
	
	
	      this._activeControl.move(x, y, z, needUpdate, needCollision, emitEnd);
	
	      return this;
	    }
	
	    /**
	     * 移动相机视角到某个绝对坐标位置。
	     * @param  {NGR.geom.Coordinate}  coord  地理坐标。
	     * @param  {Object}  [options] 相机视角更新选项。
	     * @param  {Boolean} [options.needUpdate=true]    是否调用update方法更新视角，是则设置为true。
	     * @param  {Boolean} [options.needCollision=true] 是否调用collision方法进行碰撞检测，是则设置为true。
	     * @param  {Boolean} [options.emitEnd=true]       是否分发事件给相应的监听器处理，是则设置为true。
	     * @return {NGR.map.Map}   this。
	     */
	
	  }, {
	    key: 'moveToPoint',
	    value: function moveToPoint(coord) {
	      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
	      var x = coord.x,
	          y = coord.y,
	          _coord$z = coord.z,
	          z = _coord$z === undefined ? 0 : _coord$z;
	
	      var _offset = this.offset(x, y),
	          wx = _offset.x,
	          wy = _offset.y;
	
	      var needUpdate = options.needUpdate,
	          needCollision = options.needCollision,
	          emitEnd = options.emitEnd;
	
	
	      this._activeControl.moveToPoint(wx, wy, z, needUpdate, needCollision, emitEnd);
	
	      return this;
	    }
	
	    /**
	     * 移动相机视角到一个自定义的区域。
	     * @param  {Array}   bounds                  矩形自定义区域，使用该区域左下角和右上角的世界坐标确定位置。
	     * @param  {Object}  [options]                 配置选项。
	     * @param  {Boolean} [options.needUpdate=true]    是否调用update方法更新视角，是则设置为true。
	     * @param  {Boolean} [options.needCollision=true] 是否调用collision方法进行碰撞检测，是则设置为true。
	     * @param  {Boolean} [options.emitEnd=true]       是否分发事件给相应的监听器处理，是则设置为true。
	     * @return {NGR.map.Map}              this。
	     */
	
	  }, {
	    key: 'fitBounds',
	    value: function fitBounds() {
	      var bounds = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
	      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
	
	      if (bounds.length !== 4 && bounds.length !== 6) {
	        throw new Error('Invalid bounds');
	      }
	
	      var ratio = options.ratio,
	          hasOffset = options.hasOffset,
	          needUpdate = options.needUpdate,
	          needCollision = options.needCollision,
	          emitEnd = options.emitEnd,
	          needAnimation = options.needAnimation,
	          needRotateToZero = options.needRotateToZero;
	
	      var wBounds = null;
	
	      if (bounds.length === 4) {
	        var _bounds = _slicedToArray(bounds, 4),
	            minX = _bounds[0],
	            minY = _bounds[1],
	            maxX = _bounds[2],
	            maxY = _bounds[3];
	
	        var _offset2 = this.offset(minX, minY),
	            mMinX = _offset2.x,
	            mMinY = _offset2.y;
	
	        var _offset3 = this.offset(maxX, maxY),
	            mMaxX = _offset3.x,
	            mMaxY = _offset3.y;
	
	        wBounds = [mMinX, mMinY, mMaxX, mMaxY];
	      } else if (bounds.length === 6) {
	        var _bounds2 = _slicedToArray(bounds, 6),
	            _minX = _bounds2[0],
	            _minY = _bounds2[1],
	            minZ = _bounds2[2],
	            _maxX = _bounds2[3],
	            _maxY = _bounds2[4],
	            maxZ = _bounds2[5];
	
	        var _offset4 = this.offset(_minX, _minY),
	            _mMinX = _offset4.x,
	            _mMinY = _offset4.y;
	
	        var _offset5 = this.offset(_maxX, _maxY),
	            _mMaxX = _offset5.x,
	            _mMaxY = _offset5.y;
	
	        wBounds = [_mMinX, _mMinY, minZ, _mMaxX, _mMaxY, maxZ];
	      } else {
	        throw new Error('Invalid bounds');
	      }
	
	      this._activeControl(wBounds, ratio, hasOffset, needUpdate, needCollision, emitEnd, needAnimation, needRotateToZero);
	    }
	
	    /**
	     * 缩放地图。
	     * @param  {Number}  scale       1表示不缩放，2表示地图长宽增大1倍，0.5表示地图长宽缩短一半。
	     * @param  {Object}  [options]    配置选项。
	     * @param  {Boolean} [options.needUpdate=true]    是否调用update方法更新视角，是则设置为true。
	     * @param  {Boolean} [options.needCollision=true] 是否调用collision方法进行碰撞检测，是则设置为true。
	     * @param  {Boolean} [options.emitEnd=true]       是否分发事件给相应的监听器处理，是则设置为true。
	     * @return {NGR.map.Map}           this。
	     */
	
	  }, {
	    key: 'zoom',
	    value: function zoom(scale) {
	      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
	      var needUpdate = options.needUpdate,
	          needCollision = options.needCollision,
	          emitEnd = options.emitEnd;
	
	
	      this._activeControl.zoom(scale, needUpdate, needCollision, emitEnd);
	
	      return this;
	    }
	
	    /**
	     * 根据焦距缩放地图,即根据相机视角距地面的高度调整地图显示的区域。
	     * @param  {Number}  focalLength          焦距。即相机视角距其正对的地图中心位置的距离。
	     * @param  {Object}  options                 配置选项。
	     * @param  {Boolean} [options.needUpdate=true]    是否调用update方法更新视角，是则设置为true。
	     * @param  {Boolean} [options.needCollision=true] 是否调用collision方法进行碰撞检测，是则设置为true。
	     * @param  {Boolean} [options.emitEnd=true]       是否分发事件给相应的监听器处理，是则设置为true。
	     * @return {NGR.map.Map}           this。
	     */
	
	  }, {
	    key: 'zoomByFocalLength',
	    value: function zoomByFocalLength(focalLength) {
	      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
	      var needUpdate = options.needUpdate,
	          needCollision = options.needCollision,
	          emitEnd = options.emitEnd;
	
	
	      this._activeControl.zoomByFocalLength(focalLength, needUpdate, needCollision, emitEnd);
	
	      return this;
	    }
	
	    /**
	     * 将相机视角俯仰到某个角度。
	     * @param  {Number}  angle                俯仰角度，指相机视角与垂直地面直线的夹角，范围0°~90°之间。
	     * @param  {Object}  options                 配置选项。
	     * @param  {Boolean} [options.needUpdate=true]    是否调用update方法更新视角，是则设置为true。
	     * @param  {Boolean} [options.needCollision=true] 是否调用collision方法进行碰撞检测，是则设置为true。
	     * @param  {Boolean} [options.emitEnd=true]       是否分发事件给相应的监听器处理，是则设置为true。
	     * @return {NGR.map.Map}           this。
	     */
	
	  }, {
	    key: 'skewTo',
	    value: function skewTo(angle) {
	      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
	      var needUpdate = options.needUpdate,
	          needCollision = options.needCollision,
	          emitEnd = options.emitEnd;
	
	
	      this._activeControl.skewTo(angle, needUpdate, needCollision, emitEnd);
	
	      return this;
	    }
	
	    /**
	     * 在当前相机俯仰角度上再增加一个俯仰的角度。
	     * @param  {Number}  angle                增加的俯仰角度。
	     * @param  {Object}  options                 配置选项。
	     * @param  {Boolean} [options.needUpdate=true]    是否调用update方法更新视角，是则设置为true。
	     * @param  {Boolean} [options.needCollision=true] 是否调用collision方法进行碰撞检测，是则设置为true。
	     * @param  {Boolean} [options.emitEnd=true]       是否分发事件给相应的监听器处理，是则设置为true。
	     * @return {NGR.map.Map}           this。
	     */
	
	  }, {
	    key: 'skew',
	    value: function skew(angle) {
	      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
	      var needUpdate = options.needUpdate,
	          needCollision = options.needCollision,
	          emitEnd = options.emitEnd;
	
	
	      this._activeControl.skew(angle, needUpdate, needCollision, emitEnd);
	
	      return this;
	    }
	
	    /**
	     * 相机视角围绕Z轴旋转一个增量角度,视觉效果即地图画面绕着一个固定点顺时针或逆时针旋转。
	     * @param  {Number}  angle                旋转角度。
	     * @param  {Object}  options                 配置选项。
	     * @param  {Boolean} [options.needUpdate=true]    是否调用update方法更新视角，是则设置为true。
	     * @param  {Boolean} [options.needCollision=true] 是否调用collision方法进行碰撞检测，是则设置为true。
	     * @param  {Boolean} [options.emitEnd=true]       是否分发事件给相应的监听器处理，是则设置为true。
	     * @return {NGR.map.Map}           this。
	     */
	
	  }, {
	    key: 'rotate',
	    value: function rotate(angle) {
	      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
	      var center = options.center,
	          needUpdate = options.needUpdate,
	          needCollision = options.needCollision,
	          emitEnd = options.emitEnd;
	
	      var wx = 0;
	      var wy = 0;
	
	      if (center && center.x && center.y) {
	        var _offset6 = this.offset(center.x, center.y),
	            x = _offset6.x,
	            y = _offset6.y;
	
	        wx = x;
	        wy = y;
	      }
	
	      this._activeControl.rotate(wx, wy, angle, needUpdate, needCollision, emitEnd);
	
	      return this;
	    }
	
	    /**
	     * 相机视角围绕Z轴旋转至特定角度,视觉效果即地图画面绕着一个固定点顺时针或逆时针旋转了一个角度。
	     * @param  {Number}  angle             一个指定的角度，比如90°。
	     * @param  {Object}  options                 配置选项。
	     * @param  {Boolean} [options.needUpdate=true]    是否调用update方法更新视角，是则设置为true。
	     * @param  {Boolean} [options.needCollision=true] 是否调用collision方法进行碰撞检测，是则设置为true。
	     * @param  {Boolean} [options.emitEnd=true]       是否分发事件给相应的监听器处理，是则设置为true。
	     * @return {NGR.map.Map}           this。
	     */
	
	  }, {
	    key: 'rotateTo',
	    value: function rotateTo(angle) {
	      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
	      var center = options.center,
	          needUpdate = options.needUpdate,
	          needCollision = options.needCollision,
	          emitEnd = options.emitEnd;
	
	      var wx = 0;
	      var wy = 0;
	
	      if (center && center.x && center.y) {
	        var _offset7 = this.offset(center.x, center.y),
	            x = _offset7.x,
	            y = _offset7.y;
	
	        wx = x;
	        wy = y;
	      }
	
	      this._activeControl.rotateTo(wx, wy, angle, needUpdate, needCollision, emitEnd);
	
	      return this;
	    }
	
	    /**
	     * 获取建筑物列表。
	     * @return {Number[]}    建筑物id的列表。
	     */
	
	  }, {
	    key: 'getBuildingIdList',
	    value: function getBuildingIdList() {
	      return [].concat(this._buildingList || []);
	    }
	
	    /**
	     * 多建筑模式下加载基础平面图（所有建筑物图层都是绘制在该平面图上）。
	     * @return {NGR.map.Map}    this。
	     */
	
	  }, {
	    key: 'loadBaseFloor',
	    value: function loadBaseFloor() {
	      var _this8 = this;
	
	      var dataSource = this.dataSource,
	          mapView = this.mapView,
	          baseFloorId = this._baseFloorId,
	          onLoad = this.onLoad,
	          buildingControl = this._options.buildingControl;
	
	      var promises = [];
	
	      if (!baseFloorId) {
	        console.warn('no base floor');
	        return this;
	      }
	
	      this._status = lifecycleEnum.LOADING;
	
	      if (!this._buildingList || this._buildingList.length === 0) {
	        promises.push(dataSource.requestPOIChildren(baseFloorId));
	      } else {
	        promises.push(false);
	      }
	      if (!this.planarGraphs[baseFloorId]) {
	        promises.push(dataSource.requestPlanarGraph(baseFloorId));
	      } else {
	        promises.push(false);
	      }
	
	      _Promise.all(promises).then(function (_ref17) {
	        var _ref18 = _slicedToArray(_ref17, 2),
	            children = _ref18[0],
	            rawPlanarGraph = _ref18[1];
	
	        _this8._status = lifecycleEnum.LOADED;
	        if (children) {
	          _this8._buildingInfoList = children.filter(function (child) {
	            return child.type === 'BUILDING';
	          });
	          _this8._buildingList = _this8._buildingInfoList.map(function (info) {
	            return info.id;
	          });
	        }
	        if (rawPlanarGraph) {
	          _this8.planarGraphs[baseFloorId] = rawPlanarGraph;
	        }
	
	        if (!_this8.buildingControl) {
	          _this8.buildingControl = _this8._genControl('building', _extends({}, buildingControl, { buildingList: _this8._buildingInfoList.concat() }));
	        }
	
	        _this8._status = lifecycleEnum.RUNNING;
	        _this8.renderPlanarGraph(baseFloorId);
	        mapView.next(1, function () {
	          if (_this8.scaleControl) {
	            _this8.scaleControl.update();
	          }
	          if ((0, _lang.isFunction)(onLoad)) {
	            onLoad(_this8);
	          }
	        });
	      }).catch(function (err) {
	        return console.error(err, err.stack);
	      });
	
	      return this;
	    }
	
	    /**
	     * 开始渲染
	     * @param {Number|String} [mapId] 地图的Id。若不传如该参数时会显示AppKey下的第一张地图。
	     * @return {NGR.map.Map}     this。
	     */
	
	  }, {
	    key: 'render',
	    value: function render(mapId) {
	      var _this9 = this;
	
	      // sanity check
	      if (this._status === lifecycleEnum.LOADING || this._status === lifecycleEnum.DESTROYED) {
	        throw new Error('map is loading or destroyed');
	      }
	      // if (mapId && mapId === this._mapId) {
	      //   console.warn('The same mapId');
	
	      //   return this;
	      // }
	
	      var styleTemplate = this._options.styleTemplate,
	          dataSource = this.dataSource;
	
	      var stylePromise = void 0;
	
	      this._clear();
	
	      // fetch data
	      if (this._styleJson) {
	        stylePromise = new _Promise(function (resolve) {
	          return resolve(_this9._styleJson);
	        });
	      } else if ((0, _lang.isString)(styleTemplate)) {
	        stylePromise = (0, _fetch2.default)(styleTemplate, {}).then(function (response) {
	          return response.json();
	        });
	      } else {
	        stylePromise = new _Promise(function (resolve) {
	          return resolve(styleTemplate);
	        });
	      }
	
	      this._status = lifecycleEnum.LOADING;
	
	      stylePromise.then(function (json) {
	        _this9._styleJson = json;
	
	        return mapId ? dataSource.requestMap(mapId) : dataSource.requestMaps();
	      }).then(function (map) {
	        _this9._mapId = map.list ? map.list[0].poi : map.poi;
	
	        return dataSource.requestPOI(_this9._mapId);
	      }).then(function (poi) {
	        _this9._floorInfoMap = {};
	        _this9._initMapView();
	        if (poi.type === 'BUILDING') {
	          _this9._buildingList = [poi.id];
	          _this9.renderBuilding(poi.id);
	        } else if (poi.type === 'PLANAR_GRAPH') {
	          _this9._baseFloorId = poi.id;
	          _this9._buildingList = [];
	          _this9.loadBaseFloor();
	        } else {
	          throw new Error('Invalid poi type');
	        }
	      }).catch(function (err) {
	        return console.error(err, err.stack);
	      });
	
	      return this;
	    }
	
	    /**
	     * 销毁地图对象。
	     * @return {NGR.map.Map}           this。
	     */
	
	  }, {
	    key: 'destroy',
	    value: function destroy() {
	      if (this._status === lifecycleEnum.DESTROYED) {
	        throw new Error('map is already destroyed');
	      }
	      this._clear();
	      this.mapView.gestureManager.off('tap', this._onClick);
	      this._engine.remove(this.mapView);
	      this.navigationManager = null;
	      this.dynamicNavigationManager = null;
	      this.locationManager = null;
	      this.planarGraphs = null;
	      this.mapView = null;
	      this.dataSource = null;
	      this.floorControl = null;
	      this.zoomControl = null;
	      this.compassControl = null;
	      this.scaleControl = null;
	      this._styleJson = null;
	      this._options = null;
	      this._light = null;
	      this._engine = null;
	      this._status = lifecycleEnum.DESTROYED;
	
	      if ((0, _lang.isFunction)(this.onDestoy)) {
	        this.onDestroy(this);
	      }
	
	      return this;
	    }
	  }, {
	    key: 'baseFloorId',
	    get: function get() {
	      return this._baseFloorId;
	    },
	    set: function set(id) {
	      // eslint-disable-line no-unused-vars
	      console.warn('baseFloorId is readonly');
	    }
	
	    /**
	     * 当前显示楼层的id列表。
	     * @type {Array}
	     * @return {Array} 楼层id。
	     */
	
	  }, {
	    key: 'currentPlanarGraphIds',
	    get: function get() {
	      return this.mapView.currentPlanarGraphIds;
	    }
	  }]);
	
	  return Map;
	}();
	
	exports.default = Map;
	exports.lifecycleEnum = lifecycleEnum;

/***/ }),
/* 170 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.Map = undefined;
	
	var _Map = __webpack_require__(169);
	
	var _Map2 = _interopRequireDefault(_Map);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.Map = _Map2.default;

/***/ }),
/* 171 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.Math = undefined;
	
	var _Math = __webpack_require__(38);
	
	var _Math2 = _interopRequireDefault(_Math);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.Math = _Math2.default;

/***/ }),
/* 172 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _hashset = __webpack_require__(111);
	
	var _hashset2 = _interopRequireDefault(_hashset);
	
	var _JTSUtils = __webpack_require__(12);
	
	var _JTSUtils2 = _interopRequireDefault(_JTSUtils);
	
	var _Path = __webpack_require__(71);
	
	var _Path2 = _interopRequireDefault(_Path);
	
	var _Vertex = __webpack_require__(73);
	
	var _Vertex2 = _interopRequireDefault(_Vertex);
	
	var _AStarConnectionPath = __webpack_require__(39);
	
	var _AStarConnectionPath2 = _interopRequireDefault(_AStarConnectionPath);
	
	var _AStarLanePath = __webpack_require__(44);
	
	var _AStarLanePath2 = _interopRequireDefault(_AStarLanePath);
	
	var _AStarVertex = __webpack_require__(40);
	
	var _AStarVertex2 = _interopRequireDefault(_AStarVertex);
	
	var _jsts = __webpack_require__(5);
	
	var _priorityqueuejs = __webpack_require__(89);
	
	var _priorityqueuejs2 = _interopRequireDefault(_priorityqueuejs);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var OFFSET = 1E-8;
	
	var AStar = function () {
	  function AStar(g, h, vertexLoader) {
	    _classCallCheck(this, AStar);
	
	    this._g = g;
	    this._h = h;
	    this._vertexLoader = vertexLoader;
	  }
	
	  _createClass(AStar, [{
	    key: 'astar',
	    value: function astar(from, fromPlanarGraphId, to, toPlanarGraphId) {
	      var planarGraphIdList = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;
	
	      var openList = new _priorityqueuejs2.default(_AStarVertex2.default.compareTo);
	      var closeList = new _hashset2.default(function (a, b) {
	        return a.equals(b);
	      });
	      var paths = [];
	
	      var fromNearestPath = this._vertexLoader.findNearestPath(from, fromPlanarGraphId);
	      var toNearestPath = this._vertexLoader.findNearestPath(to, toPlanarGraphId);
	
	      var start = this._vertexLoader.findNearestVertexOnNearestPath(from, fromNearestPath);
	      var end = this._vertexLoader.findNearestVertexOnNearestPath(to, toNearestPath);
	      if (!start || !end) {
	        return [];
	      }
	
	      if (start.equals(end)) {
	        if (_jsts.operation.distance.DistanceOp.distance(from, to) < 0.01) {
	          return paths;
	        }
	        var path = void 0;
	        if (fromNearestPath === toNearestPath) {
	          path = this.genPathForOneLine(fromNearestPath, from, to);
	          // TODO
	        } else if (_jsts.operation.distance.DistanceOp.distance(from, start.vertex.shape) <= _jsts.operation.distance.DistanceOp.distance(to, start.vertex.shape)) {
	          path = this.genPathForOneLine(toNearestPath, start.vertex.shape, to);
	        } else {
	          path = this.genPathForOneLine(fromNearestPath, from, to.vertex.shape);
	        }
	        if (path) {
	          paths.push(path);
	        }
	        return paths;
	      }
	      // const onSamFloor = fromPlanarGraphId === toPlanarGraphId;
	      var floorDiff = void 0;
	      if (planarGraphIdList) {
	        floorDiff = Math.abs(planarGraphIdList.indexOf(fromPlanarGraphId) - planarGraphIdList.indexOf(toPlanarGraphId));
	      } else {
	        floorDiff = fromPlanarGraphId === toPlanarGraphId ? 0 : 1;
	      }
	      if (!start.equals(end)) {
	        openList.enq(start);
	        var current = void 0;
	        ret: while (openList.size() > 0) {
	          current = openList.deq();
	          closeList.add(current);
	          // if (this._needCalcExtraPath(toNearestPath, start, end, current)) {
	          //   current.needCalcExtraPath = true;
	          // }
	          current.needCalcExtraPath = true;
	          var iterator = current.paths;
	          for (var _iterator = iterator, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
	            var _ref;
	
	            if (_isArray) {
	              if (_i >= _iterator.length) break;
	              _ref = _iterator[_i++];
	            } else {
	              _i = _iterator.next();
	              if (_i.done) break;
	              _ref = _i.value;
	            }
	
	            var _path = _ref;
	
	            var vertex = _path.to;
	            if (closeList.contains(vertex)) {
	              continue;
	            }
	            var g = this._g.g(current, _path, floorDiff) + current.g;
	            var h = this._h.h(current, end);
	
	            // TODO
	            if (this._isContainsByQueue(openList, vertex)) {
	              if (g + h < vertex.g + vertex.h) {
	                vertex.g = g;
	                vertex.h = h;
	                vertex.parent = current;
	                // TODO
	                this._removeByQueue(openList, vertex);
	                openList.enq(vertex);
	              }
	            } else {
	              vertex.g = g;
	              vertex.h = h;
	              vertex.parent = current;
	              openList.enq(vertex);
	            }
	            if (vertex.equals(end)) {
	              do {
	                paths.push(vertex.parent.findPath(vertex));
	                vertex = vertex.parent;
	              } while (!vertex.equals(start));
	              break ret;
	            }
	          }
	        }
	      }
	
	      paths.reverse();
	      this._adjustPaths(paths, fromNearestPath, toNearestPath, from, to);
	      this._filterExtraPath(paths);
	      return paths;
	    }
	  }, {
	    key: 'genPathForOneLine',
	    value: function genPathForOneLine(fromNearestPath, from, to) {
	      var coordinates = fromNearestPath.shape.getCoordinates();
	      var segments = this.genLineStringByCoordinates(coordinates);
	      var fromProject = _JTSUtils2.default.getFactory().createPoint(this.getProjectOnLine(from, fromNearestPath.shape));
	      var toProject = _JTSUtils2.default.getFactory().createPoint(this.getProjectOnLine(to, fromNearestPath.shape));
	      var fromIndexOfProjectLiedOn = this.getIndexProjectliedOn(fromProject, segments);
	      var toIndexOfProjectLiedOn = this.getIndexProjectliedOn(toProject, segments);
	      var reverse = void 0;
	      if (fromIndexOfProjectLiedOn === toIndexOfProjectLiedOn) {
	        var checkLine = segments[fromIndexOfProjectLiedOn];
	        reverse = _jsts.operation.distance.DistanceOp.distance(from, checkLine.getStartPoint()) > _jsts.operation.distance.DistanceOp.distance(to, checkLine.getStartPoint());
	      } else {
	        reverse = fromIndexOfProjectLiedOn > toIndexOfProjectLiedOn;
	      }
	      if (reverse) {
	        coordinates.reverse();
	      }
	      segments = this.genLineStringByCoordinates(coordinates);
	      fromIndexOfProjectLiedOn = this.getIndexProjectliedOn(fromProject, segments);
	      toIndexOfProjectLiedOn = this.getIndexProjectliedOn(toProject, segments);
	      var coordinateSequence = [];
	      coordinateSequence.push(fromProject.getCoordinate());
	      if (toIndexOfProjectLiedOn - fromIndexOfProjectLiedOn === 1) {
	        coordinateSequence.push(segments[fromIndexOfProjectLiedOn].getEndPoint().getCoordinate());
	      } else {
	        for (var i = fromIndexOfProjectLiedOn + 1; i < toIndexOfProjectLiedOn; i++) {
	          coordinateSequence.push(segments[i].getStartPoint().getCoordinate());
	          if (i === toIndexOfProjectLiedOn - 1) {
	            coordinateSequence.push(segments[i].getEndPoint().getCoordinate());
	          }
	        }
	      }
	      coordinateSequence.push(toProject.getCoordinate());
	      var lineString = new _jsts.geom.LineString(_JTSUtils2.default.getFactory().getCoordinateSequenceFactory().create(coordinateSequence), _JTSUtils2.default.getFactory());
	      var path = this._getNewAStarPath(fromNearestPath, lineString);
	      return path;
	    }
	  }, {
	    key: 'genLineStringByCoordinates',
	    value: function genLineStringByCoordinates(coordinates) {
	      if (!coordinates || coordinates.length === 0) {
	        return null;
	      }
	      var segments = new Array(coordinates.length - 1);
	      for (var i = 0; i < coordinates.length - 1; i++) {
	        var c1 = coordinates[i];
	        var c2 = coordinates[i + 1];
	        var segment = new _jsts.geom.LineString(_JTSUtils2.default.getFactory().getCoordinateSequenceFactory().create([c1, c2]), _JTSUtils2.default.getFactory());
	        segments[i] = segment;
	      }
	      return segments;
	    }
	  }, {
	    key: 'getProjectOnLine',
	    value: function getProjectOnLine(point, line) {
	      var project = _jsts.operation.distance.DistanceOp.nearestPoints(point, line)[0];
	      return project;
	    }
	  }, {
	    key: 'getIndexProjectliedOn',
	    value: function getIndexProjectliedOn(point, segments) {
	      var target = void 0;
	      for (var index in segments) {
	        if (this._checkIfPointOnLine(point, segments[index])) {
	          target = index;
	        }
	      }
	      return target;
	    }
	  }, {
	    key: '_getNewAStarPath',
	    value: function _getNewAStarPath(path, lineString) {
	      var planarGraphId = path.planarGraphId;
	      var newPath = new _Path2.default();
	      newPath.planarGraphId = planarGraphId;
	      newPath.direction = path.direction;
	      newPath.rank = path.rank;
	      newPath.shape = lineString;
	      newPath.from = this._getNewVertex(lineString.getStartPoint(), planarGraphId);
	      newPath.to = this._getNewVertex(lineString.getEndPoint(), planarGraphId);
	      var exactPath = new _AStarLanePath2.default(newPath, this._vertexLoader, false);
	      return exactPath;
	    }
	  }, {
	    key: '_getNewVertex',
	    value: function _getNewVertex(point, planarGraphId) {
	      if (!point) {
	        return null;
	      }
	      var vertex = new _Vertex2.default();
	      vertex.planarGraphId = planarGraphId;
	      vertex.shape = point;
	      return vertex;
	    }
	  }, {
	    key: '_checkIfPointOnLine',
	    value: function _checkIfPointOnLine(point, segment) {
	      return _jsts.operation.distance.DistanceOp.distance(point, segment) < OFFSET;
	    }
	  }, {
	    key: '_needCalcExtraPath',
	    value: function _needCalcExtraPath(toNearestPath, start, end, current) {
	      var currentId = current.vertex.id;
	      return currentId === start.vertex.id || currentId === end.vertex.id || currentId === toNearestPath.from.id || currentId === toNearestPath.to.id;
	    }
	  }, {
	    key: '_adjustPaths',
	    value: function _adjustPaths(paths, fromNearestPath, toNearestPath, from, to) {
	      if (!paths || paths.length === 0) {
	        return;
	      }
	      this._adjustFirstPath(paths, fromNearestPath, from);
	      this._adjustLastPath(paths, toNearestPath, to);
	      this._filterExtraPath(paths);
	    }
	  }, {
	    key: '_adjustFirstPath',
	    value: function _adjustFirstPath(paths, fromNearestPath, from) {
	      var fromProject = this.getProjectOnLine(from, fromNearestPath.shape);
	      var point = _JTSUtils2.default.getFactory().createPoint(fromProject);
	      this._addFromExactPath(paths, point, fromNearestPath);
	    }
	  }, {
	    key: '_adjustLastPath',
	    value: function _adjustLastPath(paths, toNearestPath, to) {
	      var toProject = this.getProjectOnLine(to, toNearestPath.shape);
	      var point = _JTSUtils2.default.getFactory().createPoint(toProject);
	      this._addToExtraPath(paths, point, toNearestPath);
	    }
	  }, {
	    key: '_addToExtraPath',
	    value: function _addToExtraPath(paths, point, nearestPath) {
	      var index = paths.length - 1;
	      var isPathConnectionProject = this._checkIfPointOnLine(point, nearestPath.shape);
	      if (!isPathConnectionProject) {
	        return;
	      }
	      if (paths[index] instanceof _AStarConnectionPath2.default) {
	        return;
	      }
	      var aStarLanePath = paths[index];
	      var exactPath = this._genToExactPath(aStarLanePath, nearestPath, point);
	      if (aStarLanePath.path.id === nearestPath.id) {
	        paths.splice(index, 0, exactPath);
	      } else {
	        paths[0] = exactPath;
	      }
	    }
	  }, {
	    key: '_addFromExactPath',
	    value: function _addFromExactPath(paths, point, nearestPath) {
	      var isPathContainsProject = this._checkIfPointOnLine(point, nearestPath.shape);
	      if (isPathContainsProject) {
	        return;
	      }
	      if (paths[0] instanceof _AStarConnectionPath2.default) {
	        return;
	      }
	      var aStarLanePath = paths[0];
	      var exactPath = this._genFromExtraPath(point, nearestPath, aStarLanePath);
	      if (aStarLanePath.path.id === nearestPath.id) {
	        paths[0] = exactPath;
	      } else {
	        paths.splice(0, 0, exactPath);
	      }
	    }
	  }, {
	    key: '_genFromExtraPath',
	    value: function _genFromExtraPath(point, nearestPath, aStarLanePath) {
	      var segments = this._splitPath(aStarLanePath, nearestPath, true);
	      var coordinates = [];
	      var indexOfProjectLiedOn = this.getIndexProjectliedOn(point, segments);
	      coordinates.push(point.getCoordinate());
	      for (var i = indexOfProjectLiedOn + 1; i < segments.length; i++) {
	        coordinates.push(segments[i].getStartPoint().getCoordinate());
	        if (i === segments.length - 1) {
	          coordinates.push(segments[i].getEndPoint().getCoordinate());
	        }
	      }
	      if (coordinates.length === 1) {
	        var index = segments.length > indexOfProjectLiedOn ? indexOfProjectLiedOn : segments.length - 1;
	        coordinates.push(segments[index].getEndPoint().getCoordinate());
	      }
	      var lineString = new _jsts.geom.LineString(_JTSUtils2.default.getFactory().getCoordinateSequenceFactory().create(coordinates), _JTSUtils2.default.getFactory());
	      return this._getNewAStarPath(nearestPath, lineString);
	    }
	  }, {
	    key: '_genToExactPath',
	    value: function _genToExactPath(aStarLanePath, nearestPath, point) {
	      var segments = this._splitPath(aStarLanePath, nearestPath, true);
	      var coordinates = [];
	      var indexOfProjectLiedOn = this.getIndexProjectliedOn(point, segments);
	      for (var i = 0; i < indexOfProjectLiedOn; i++) {
	        coordinates.push(segments[i].getStartPoint().getCoordinate());
	        if (i === indexOfProjectLiedOn - 1) {
	          coordinates.push(segments[i].getEndPoint().getCoordinate());
	        }
	      }
	
	      if (coordinates.length === 0) {
	        var index = segments.length > indexOfProjectLiedOn ? indexOfProjectLiedOn : segments.length - 1;
	        coordinates.push(segments[index].getStartPoint().getCoordinate());
	      }
	      coordinates.push(point.getCoordinate());
	      var lineString = new _jsts.geom.LineString(_JTSUtils2.default.getFactory().getCoordinateSequenceFactory().create(coordinates), _JTSUtils2.default.getFactory());
	      var exactPath = this._getNewAStarPath(nearestPath, lineString);
	      return exactPath;
	    }
	  }, {
	    key: '_splitPath',
	    value: function _splitPath(aStarLanePath, path, isFromAdj) {
	      // const shape = path.shape.clone();
	      // const coordinates = shape.getCoordinates();
	      var coordinates = [];
	      for (var _iterator2 = path.shape.getCoordinates(), _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator]();;) {
	        var _ref2;
	
	        if (_isArray2) {
	          if (_i2 >= _iterator2.length) break;
	          _ref2 = _iterator2[_i2++];
	        } else {
	          _i2 = _iterator2.next();
	          if (_i2.done) break;
	          _ref2 = _i2.value;
	        }
	
	        var coordinate = _ref2;
	
	        coordinates.push(new _jsts.geom.Coordinate(coordinate.x, coordinate.y, coordinate.z));
	      }
	      var reverse = void 0;
	      if (aStarLanePath.path.id === path.id) {
	        reverse = aStarLanePath.reverse;
	      } else if (isFromAdj) {
	        // TODO
	        var checkPoint = aStarLanePath.reverse ? aStarLanePath.path.shape.getEndPoint() : aStarLanePath.path.shape.getStartPoint();
	        reverse = _jsts.operation.distance.DistanceOp.distance(checkPoint, path.shape.getEndPoint()) > _jsts.operation.distance.DistanceOp.distance(checkPoint, path.shape.getStartPoint());
	      } else {
	        var _checkPoint = aStarLanePath.reverse ? aStarLanePath.path.shape.getStartPoint() : aStarLanePath.path.shape.getEndPoint();
	        reverse = _jsts.operation.distance.DistanceOp.distance(_checkPoint, path.shape.getStartPoint()) > _jsts.operation.distance.DistanceOp.distance(_checkPoint, path.shape.getEndPoint());
	      }
	      if (reverse) {
	        coordinates.reverse();
	      }
	      var segments = this.genLineStringByCoordinates(coordinates);
	      return segments;
	    }
	  }, {
	    key: '_filterExtraPath',
	    value: function _filterExtraPath(paths) {
	      if (!paths || paths.length === 0) {
	        return;
	      }
	      var first = paths[0];
	      var last = void 0;
	      if (paths.length > 1) {
	        last = paths[paths.length - 1];
	      }
	      this._checkThenRemove(paths, first);
	      this._checkThenRemove(paths, last);
	    }
	  }, {
	    key: '_checkThenRemove',
	    value: function _checkThenRemove(paths, path) {
	      if (!path) {
	        return;
	      }
	      if (path instanceof _AStarLanePath2.default) {
	        var firstNodeRank = path.path.rank;
	        if (firstNodeRank === 10) {
	          var index = paths.indexOf(path);
	          paths.splice(index, 1);
	        }
	      }
	    }
	  }, {
	    key: '_isContainsByQueue',
	    value: function _isContainsByQueue(queue, vertex) {
	      var isContains = false;
	      queue.forEach(function (e) {
	        if (e.equals(vertex)) {
	          // vertex.g = e.g;
	          // vertex.h = e.h;
	          isContains = true;
	        }
	      });
	      return isContains;
	    }
	  }, {
	    key: '_removeByQueue',
	    value: function _removeByQueue(queuq, vertex) {
	      var avs = queuq._elements;
	      var index = null;
	      for (var i in avs) {
	        var temp = avs[i];
	        if (temp.equals(vertex)) {
	          index = i;
	        }
	      }
	      if (index) {
	        avs.splice(index, 1);
	      }
	    }
	  }]);
	
	  return AStar;
	}();
	
	exports.default = AStar;

/***/ }),
/* 173 */
/***/ (function(module, exports) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var Connection = function () {
	  function Connection(mapId, direction, rank, fromLocationId, toLocationId) {
	    _classCallCheck(this, Connection);
	
	    this.mapId = mapId;
	    this.direction = direction;
	    this.rank = rank;
	    this.fromLocationId = fromLocationId;
	    this.toLocationId = toLocationId;
	  }
	
	  _createClass(Connection, [{
	    key: "id",
	    get: function get() {
	      return this._id;
	    },
	    set: function set(id) {
	      this._id = id;
	    }
	  }, {
	    key: "mapId",
	    get: function get() {
	      return this._mapId;
	    },
	    set: function set(mapId) {
	      this._mapId = mapId;
	    }
	  }, {
	    key: "direction",
	    get: function get() {
	      return this._direction;
	    },
	    set: function set(direction) {
	      this._direction = direction;
	    }
	  }, {
	    key: "rank",
	    get: function get() {
	      return this._rank;
	    },
	    set: function set(rank) {
	      this._rank = rank;
	    }
	  }, {
	    key: "fromLocationId",
	    get: function get() {
	      return this._fromLocationId;
	    },
	    set: function set(fromLocationId) {
	      this._fromLocationId = fromLocationId;
	    }
	  }, {
	    key: "toLocationId",
	    get: function get() {
	      return this._toLocationId;
	    },
	    set: function set(toLocationId) {
	      this._toLocationId = toLocationId;
	    }
	  }, {
	    key: "from",
	    get: function get() {
	      return this._from;
	    },
	    set: function set(from) {
	      this._from = from;
	    }
	  }, {
	    key: "to",
	    get: function get() {
	      return this._to;
	    },
	    set: function set(to) {
	      this._to = to;
	    }
	  }, {
	    key: "categoryId",
	    get: function get() {
	      return this._categoryId;
	    },
	    set: function set(categoryId) {
	      this._categoryId = categoryId;
	    }
	  }]);
	
	  return Connection;
	}();
	
	exports.default = Connection;

/***/ }),
/* 174 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };
	
	var _DefaultG2 = __webpack_require__(70);
	
	var _DefaultG3 = _interopRequireDefault(_DefaultG2);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var CustomG = function (_DefaultG) {
	  _inherits(CustomG, _DefaultG);
	
	  function CustomG(func) {
	    _classCallCheck(this, CustomG);
	
	    var _this = _possibleConstructorReturn(this, (CustomG.__proto__ || Object.getPrototypeOf(CustomG)).call(this));
	
	    _this._func = func;
	    return _this;
	  }
	
	  _createClass(CustomG, [{
	    key: 'g',
	    value: function g(current, path, onSameFloor) {
	      var temp = _get(CustomG.prototype.__proto__ || Object.getPrototypeOf(CustomG.prototype), 'g', this).call(this, current, path, onSameFloor);
	      temp += this._func(current, path, onSameFloor);
	      return temp;
	    }
	  }]);
	
	  return CustomG;
	}(_DefaultG3.default);
	
	exports.default = CustomG;

/***/ }),
/* 175 */
/***/ (function(module, exports) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var DefaultH = function () {
	  function DefaultH() {
	    _classCallCheck(this, DefaultH);
	  }
	
	  _createClass(DefaultH, [{
	    key: "h",
	    value: function h(current, target) {
	      return Math.abs(target.vertex.altitude - current.vertex.altitude) + current.vertex.shape.distance(target.vertex.shape);
	    }
	  }]);
	
	  return DefaultH;
	}();
	
	exports.default = DefaultH;

/***/ }),
/* 176 */
/***/ (function(module, exports) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var G = function () {
	  function G() {
	    _classCallCheck(this, G);
	  }
	
	  _createClass(G, [{
	    key: "g",
	    value: function g(current, path, onSameFloor) {// eslint-disable-line no-unused-vars
	    }
	  }]);
	
	  return G;
	}();
	
	exports.default = G;

/***/ }),
/* 177 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.naviFilter = exports.NaviUtils = undefined;
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _NavigateManager = __webpack_require__(45);
	
	var _NavigateManager2 = _interopRequireDefault(_NavigateManager);
	
	var _MapView = __webpack_require__(26);
	
	var _MapView2 = _interopRequireDefault(_MapView);
	
	var _FeatureCollection = __webpack_require__(23);
	
	var _FeatureCollection2 = _interopRequireDefault(_FeatureCollection);
	
	var _Feature = __webpack_require__(34);
	
	var _Feature2 = _interopRequireDefault(_Feature);
	
	var _JTSUtils = __webpack_require__(12);
	
	var _JTSUtils2 = _interopRequireDefault(_JTSUtils);
	
	var _lang = __webpack_require__(4);
	
	var _jsts = __webpack_require__(5);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	/**
	 * 自定义导航过滤类，用以过滤冗余的导航信息，如过短的导航距离、相同的POI信息等。
	 * @memberOf NGR.navi.naviFilter
	 */
	var NaviCustomFilter = function () {
	  function NaviCustomFilter() {
	    _classCallCheck(this, NaviCustomFilter);
	  }
	
	  _createClass(NaviCustomFilter, [{
	    key: 'onFilter',
	
	    /**
	     * 过滤方法。
	     * @param  {Number[]} distances      某楼层导航线的长度。
	     * @param  {Object[]} connectionInfo 某楼层的连通信息。
	     * @return {Blooean}                 过滤结果。
	     */
	    value: function onFilter(distances, connectionInfo) {
	      // eslint-disable-line no-unused-vars
	      return false;
	    }
	  }]);
	
	  return NaviCustomFilter;
	}();
	
	/**
	 * 导航距离过滤类。导航距离小于设定阈值则被过滤。
	 * @extends {NGR.navi.naviFilter.NaviCustomFilter}
	 * @memberOf NGR.navi.naviFilter
	 */
	
	
	var NaviDistanceFilter = function (_NaviCustomFilter) {
	  _inherits(NaviDistanceFilter, _NaviCustomFilter);
	
	  /**
	   * 构造方法。
	   * @param  {Number} distanceThreshold 距离阈值。
	   */
	  function NaviDistanceFilter(distanceThreshold) {
	    _classCallCheck(this, NaviDistanceFilter);
	
	    var _this = _possibleConstructorReturn(this, (NaviDistanceFilter.__proto__ || Object.getPrototypeOf(NaviDistanceFilter)).call(this));
	
	    _this._distanceThreshold = distanceThreshold;
	    return _this;
	  }
	
	  _createClass(NaviDistanceFilter, [{
	    key: 'onFilter',
	    value: function onFilter(distances, connectionInfo) {
	      // eslint-disable-line no-unused-vars
	      var distanceSum = 0;
	
	      for (var _iterator = distances, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
	        var _ref;
	
	        if (_isArray) {
	          if (_i >= _iterator.length) break;
	          _ref = _iterator[_i++];
	        } else {
	          _i = _iterator.next();
	          if (_i.done) break;
	          _ref = _i.value;
	        }
	
	        var distance = _ref;
	
	        distanceSum += distance;
	      }
	
	      if (distanceSum > this._distanceThreshold) {
	        return false;
	      }
	      return true;
	    }
	  }]);
	
	  return NaviDistanceFilter;
	}(NaviCustomFilter);
	
	/**
	 * 过滤导航线经过的POI和POI的类别。若同层的两个连通设施类型相同则也过滤。
	 * @extends {NGR.navi.naviFilter.NaviCustomFilter}
	 * @memberOf NGR.navi.naviFilter
	 */
	
	
	var NaviSameCateFilter = function (_NaviCustomFilter2) {
	  _inherits(NaviSameCateFilter, _NaviCustomFilter2);
	
	  function NaviSameCateFilter() {
	    _classCallCheck(this, NaviSameCateFilter);
	
	    return _possibleConstructorReturn(this, (NaviSameCateFilter.__proto__ || Object.getPrototypeOf(NaviSameCateFilter)).apply(this, arguments));
	  }
	
	  _createClass(NaviSameCateFilter, [{
	    key: 'onFilter',
	    // eslint-disable-line no-unused-vars
	    value: function onFilter(distances, connectionInfo) {
	      if (!connectionInfo || connectionInfo.length !== 2 || connectionInfo[0].category !== connectionInfo[1].category) {
	        return false;
	      }
	      return true;
	    }
	  }]);
	
	  return NaviSameCateFilter;
	}(NaviCustomFilter);
	
	/**
	 * 导航工具类，可获取更多的导航信息，便于规划出符合各类需求的导航路线。
	 * @memberOf NGR.navi
	 */
	
	
	var NaviUtils = function () {
	  function NaviUtils() {
	    _classCallCheck(this, NaviUtils);
	  }
	
	  _createClass(NaviUtils, null, [{
	    key: 'getMultiNavigation',
	
	    /**
	     * 获取多层导航线的FeatureCollection，即所有导航线段。
	     * @param  {NGR.view.MapView}                       targetMapView                    导航线所在的地图。
	     * @param  {NGR.navi.NavigateManager}               naviMng                          导航管理对象。
	     * @param  {Number[]}                               naviPGs                          导航线经过的楼层的id。
	     * @param  {NGR.navi.naviFilter.NaviCustomFilter[]} filters                          导航线过滤列表，即按照过滤方法筛选出的导航线列表。
	     * @param  {Object}                                 [options]                        选项，如楼层高度等。
	     * @param  {Number}                                 [options.floorHeight=40]         楼层高度。
	     * @param  {Number}                                 [options.id=1]                   Feature id。
	     * @param  {String}                                 [options.name='multiNavigation'] FeatureCollection 的名称。
	     * @return {NGR.data.FeatureCollection}                                              根据导航管理对象NavigateManager返回单层或多层导航线FeatureCollection。
	     */
	    value: function getMultiNavigation(targetMapView, naviMng, naviPGs, filters) {
	      var options = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};
	
	      if (!(targetMapView instanceof _MapView2.default) || !(naviMng instanceof _NavigateManager2.default) || !(0, _lang.isArray)(naviPGs)) {
	        throw new Error('NaviUtils: Invalid parameters');
	      }
	
	      var naviOrder = naviMng.getPlanarGraphOrder();
	
	      if ((0, _lang.isEmpty)(naviOrder)) {
	        throw new Error('NaviUtils: Empty navigation data');
	      }
	
	      var _options$floorHeight = options.floorHeight,
	          floorHeight = _options$floorHeight === undefined ? 40 : _options$floorHeight,
	          _options$id = options.id,
	          id = _options$id === undefined ? 1 : _options$id,
	          _options$name = options.name,
	          name = _options$name === undefined ? 'multiNavigation' : _options$name,
	          _options$zOffset = options.zOffset,
	          zOffset = _options$zOffset === undefined ? 0 : _options$zOffset;
	
	      var planarGraphOrder = targetMapView._planarGraphs.concat();
	      var floorHeightMap = {};
	      var featureCountMap = {};
	      var compare = function compare(a, b) {
	        var indexA = planarGraphOrder.indexOf(a);
	        var indexB = planarGraphOrder.indexOf(b);
	
	        if (indexA < indexB) {
	          return -1;
	        } else if (indexA > indexB) {
	          return 1;
	        }
	
	        return 0;
	      };
	      var curHeight = zOffset;
	      var coords = [];
	
	      // filter and sort result planargraphs and generate floor height map
	      for (var index in naviOrder) {
	        var planarGraphId = naviOrder[index];
	
	        if (planarGraphOrder.indexOf(planarGraphId) === -1) {
	          continue;
	        }
	
	        var distances = naviMng.getDistancesByPlanarGraph(planarGraphId);
	        var connectionInfo = naviMng.getConnectionInfoByPlanarGraph(planarGraphId);
	        var tempFilters = (0, _lang.isArray)(filters) ? filters : [];
	        var needPush = false;
	
	        if (naviPGs.indexOf(planarGraphId) === -1) {
	          var filtered = true;
	
	          // use 'and' between filters
	          needPush = true;
	          if (tempFilters.length === 0) {
	            filtered = false;
	          }
	          for (var _iterator2 = tempFilters, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator]();;) {
	            var _ref2;
	
	            if (_isArray2) {
	              if (_i2 >= _iterator2.length) break;
	              _ref2 = _iterator2[_i2++];
	            } else {
	              _i2 = _iterator2.next();
	              if (_i2.done) break;
	              _ref2 = _i2.value;
	            }
	
	            var filter = _ref2;
	
	            if (!filter.onFilter(distances, connectionInfo)) {
	              filtered = false;
	              break;
	            }
	          }
	          if (filtered) {
	            needPush = false;
	          }
	        }
	
	        if (needPush) {
	          naviPGs.push(planarGraphId);
	        }
	      }
	      naviPGs.sort(compare);
	
	      // set floor height
	      for (var _iterator3 = naviPGs, _isArray3 = Array.isArray(_iterator3), _i3 = 0, _iterator3 = _isArray3 ? _iterator3 : _iterator3[Symbol.iterator]();;) {
	        var _ref3;
	
	        if (_isArray3) {
	          if (_i3 >= _iterator3.length) break;
	          _ref3 = _iterator3[_i3++];
	        } else {
	          _i3 = _iterator3.next();
	          if (_i3.done) break;
	          _ref3 = _i3.value;
	        }
	
	        var _planarGraphId = _ref3;
	
	        floorHeightMap[_planarGraphId] = curHeight;
	        curHeight += floorHeight;
	      }
	
	      // generate featureCollection
	      for (var _iterator4 = naviOrder, _isArray4 = Array.isArray(_iterator4), _i4 = 0, _iterator4 = _isArray4 ? _iterator4 : _iterator4[Symbol.iterator]();;) {
	        var _ref4;
	
	        if (_isArray4) {
	          if (_i4 >= _iterator4.length) break;
	          _ref4 = _iterator4[_i4++];
	        } else {
	          _i4 = _iterator4.next();
	          if (_i4.done) break;
	          _ref4 = _i4.value;
	        }
	
	        var _planarGraphId2 = _ref4;
	
	        if (!(_planarGraphId2 in floorHeightMap)) {
	          continue;
	        }
	
	        var curFc = naviMng.getNavigateByPlanarGraph(_planarGraphId2);
	        var _floorHeight = floorHeightMap[_planarGraphId2];
	        var curF = void 0;
	
	        if ((0, _lang.isPresent)(featureCountMap[_planarGraphId2])) {
	          curF = curFc.features[++featureCountMap[_planarGraphId2]];
	        } else {
	          curF = curFc.features[0];
	          featureCountMap[_planarGraphId2] = 0;
	        }
	        if (!curF) {
	          throw new Error('getMultiNavigation: Invalid feature');
	        }
	
	        var curCoords = curF.geometry.points.coordinates;
	
	        for (var _iterator5 = curCoords, _isArray5 = Array.isArray(_iterator5), _i5 = 0, _iterator5 = _isArray5 ? _iterator5 : _iterator5[Symbol.iterator]();;) {
	          var _ref5;
	
	          if (_isArray5) {
	            if (_i5 >= _iterator5.length) break;
	            _ref5 = _iterator5[_i5++];
	          } else {
	            _i5 = _iterator5.next();
	            if (_i5.done) break;
	            _ref5 = _i5.value;
	          }
	
	          var coord = _ref5;
	
	          coord.z = _floorHeight;
	        }
	        coords = coords.concat(curCoords);
	      }
	
	      // generater feature collection
	      var geometry = _JTSUtils2.default.getFactory().createLineString(coords);
	      var featureCollection = new _FeatureCollection2.default(name);
	
	      featureCollection.addFeature(new _Feature2.default(geometry, { id: id }));
	
	      return featureCollection;
	    }
	
	    /**
	     * Get multi-transit-points feature collection.
	     * @ignore
	     * @todo TODO
	     * @static
	     * @return {FeatureCollection} FeatureCollection.
	     */
	
	  }, {
	    key: 'getMultiTransits',
	    value: function getMultiTransits() {}
	
	    /**
	     * Get distance between 2 points.
	     * @ignore
	     * @param  {NGR.geom.Coordinate} p1 Point 1.
	     * @param  {NGR.geom.Coordinate} p2 Point 2.
	     * @return {Number}              Distance.
	     */
	
	  }, {
	    key: '_getDistance',
	    value: function _getDistance(p1, p2) {
	      var distance = 0;
	
	      // To be compatible with Chrome 37.
	      if (Math.hypot) {
	        distance = Math.hypot(p2.x - p1.x, p2.y - p1.y);
	      } else {
	        distance = Math.sqrt(Math.pow(p2.x - p1.x, 2) + Math.pow(p2.y - p1.y, 2));
	      }
	
	      return distance;
	    }
	
	    /**
	     * Get distance between 2 points.
	     * @ignore
	     * @param  {NGR.geom.Coordinate | Array} p1 Point 1.
	     * @param  {NGR.geom.Coordinate | Array} p2 Point 2.
	     * @return {Number}                      Distance.
	     */
	
	  }, {
	    key: 'getDistance',
	    value: function getDistance(p1, p2) {
	      var c1 = p1;
	      var c2 = p2;
	
	      if ((0, _lang.isArray)(p1)) {
	        c1 = new _jsts.geom.Coordinate(p1[0], p1[1]);
	      }
	      if ((0, _lang.isArray)(p2)) {
	        c2 = new _jsts.geom.Coordinate(p2[0], p2[1]);
	      }
	
	      return NaviUtils._getDistance(c1, c2);
	    }
	  }]);
	
	  return NaviUtils;
	}();
	
	/**
	 * 导航过滤。用以过滤冗余的导航信息，如过短的导航距离、相同的POI信息等。
	 * @namespace
	 * @memberOf NGR.navi
	 */
	
	
	var naviFilter = {
	  NaviCustomFilter: NaviCustomFilter,
	  NaviDistanceFilter: NaviDistanceFilter,
	  NaviSameCateFilter: NaviSameCateFilter
	};
	
	exports.NaviUtils = NaviUtils;
	exports.naviFilter = naviFilter;

/***/ }),
/* 178 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _AStarVertex = __webpack_require__(40);
	
	var _AStarVertex2 = _interopRequireDefault(_AStarVertex);
	
	var _AStarConnectionPath = __webpack_require__(39);
	
	var _AStarConnectionPath2 = _interopRequireDefault(_AStarConnectionPath);
	
	var _AStarLanePath = __webpack_require__(44);
	
	var _AStarLanePath2 = _interopRequireDefault(_AStarLanePath);
	
	var _jsts = __webpack_require__(5);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var VertexLoader = function () {
	  function VertexLoader(pathService) {
	    _classCallCheck(this, VertexLoader);
	
	    this._pathService = pathService;
	  }
	
	  _createClass(VertexLoader, [{
	    key: 'findNearestVertexOnNearestPath',
	    value: function findNearestVertexOnNearestPath(point, nearestPath) {
	      if (nearestPath === null) {
	        return null;
	      }
	      var from = nearestPath.from;
	      var to = nearestPath.to;
	      var connections = this._pathService.queryConnectionsByVertex(from);
	      if (connections.length !== 0) {
	        return new _AStarVertex2.default(to, this);
	      }
	      connections = this._pathService.queryConnectionsByVertex(to);
	      if (connections.length !== 0) {
	        return new _AStarVertex2.default(from, this);
	      }
	      var vertex = point.distance(nearestPath.from.shape) < point.distance(nearestPath.to.shape) ? nearestPath.from : nearestPath.to;
	      return new _AStarVertex2.default(vertex, this);
	    }
	  }, {
	    key: 'findNearestPath',
	    value: function findNearestPath(point, planarGraphId) {
	      var quadTree = this._pathService.queryQuadTree(planarGraphId);
	      if (!quadTree) {
	        return null;
	      }
	      var envelop = point.getEnvelopeInternal();
	      envelop.minx -= 200;
	      envelop.miny -= 200;
	      envelop.maxx += 200;
	      envelop.maxy += 200;
	      var paths = quadTree.query(envelop);
	      if (paths.isEmpty()) {
	        paths = this._pathService.queryAllPathFromIndex(planarGraphId);
	      }
	      var result = void 0;
	      var minDistance = Number.MAX_VALUE;
	      for (var _iterator = paths.array_, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
	        var _ref;
	
	        if (_isArray) {
	          if (_i >= _iterator.length) break;
	          _ref = _iterator[_i++];
	        } else {
	          _i = _iterator.next();
	          if (_i.done) break;
	          _ref = _i.value;
	        }
	
	        var path = _ref;
	
	        var shape = path.shape;
	        var distance = _jsts.operation.distance.DistanceOp.distance(point, shape);
	        if (minDistance > distance) {
	          minDistance = distance;
	          result = path;
	        }
	      }
	      return result;
	    }
	  }, {
	    key: 'loadPaths',
	    value: function loadPaths(vertex, needCalcExtraPath) {
	      var _this = this;
	
	      var aStarPaths = [];
	      var paths = this._pathService.queryPathsByVertex(vertex);
	      if (!needCalcExtraPath) {
	        paths = paths.filter(function (path) {
	          return path.rank !== 10;
	        });
	      }
	      if (paths.length !== 0) {
	        aStarPaths.push.apply(aStarPaths, _toConsumableArray(paths.map(function (path) {
	          return path.from.id === vertex.id ? new _AStarLanePath2.default(path, _this, false) : new _AStarLanePath2.default(path, _this, true);
	        })));
	      }
	
	      var connections = this._pathService.queryConnectionsByVertex(vertex);
	      if (connections.length === 0) {
	        return aStarPaths;
	      }
	      aStarPaths.push.apply(aStarPaths, _toConsumableArray(connections.map(function (c) {
	        return c.from.id === vertex.id ? new _AStarConnectionPath2.default(c, _this, false) : new _AStarConnectionPath2.default(c, _this, true);
	      })));
	      return aStarPaths;
	    }
	  }]);
	
	  return VertexLoader;
	}();
	
	exports.default = VertexLoader;

/***/ }),
/* 179 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _DOMUtils = __webpack_require__(65);
	
	var _fetch = __webpack_require__(13);
	
	var _fetch2 = _interopRequireDefault(_fetch);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var AudioProvider = function () {
	  function AudioProvider() {
	    var _this = this;
	
	    _classCallCheck(this, AudioProvider);
	
	    this.cuid = 'palmap';
	    this.accessToken = '24.ad5029324bbdd18b08ade3ae8d477cb9.2592000.1496474155.282335-9602705';
	    this.audioElmt = (0, _DOMUtils.createElement)('audio');
	    this.audioElmt.id = 'audioElmt';
	    document.body.appendChild(this.audioElmt);
	    this.tokenReqUrl = 'https://api.ipalmap.com/baidu/oauth/2.0/token?grant_type=client_credentials&client_id=R1DRhpUC1k1B7GhNe5Ol9myt&client_secret=7d37b04b8d197409cef1d385edca99c0';
	    (0, _fetch2.default)(this.tokenReqUrl, {}).then(function (response) {
	      response.json().then(function (res) {
	        _this.accessToken = res.access_token;
	      });
	    }).catch(function (e) {
	      throw Error(e);
	    });
	  }
	
	  _createClass(AudioProvider, [{
	    key: 'playMessage',
	    value: function playMessage(message) {
	      var audioReqUrl = 'http://tsn.baidu.com/text2audio?lan=zh&cuid=' + this.cuid + '&ctp=1&tok=' + this.accessToken + '&tex=' + message;
	      this.audioElmt.setAttribute('src', audioReqUrl);
	      this.audioElmt.play();
	    }
	  }]);
	
	  return AudioProvider;
	}();
	
	exports.default = AudioProvider;

/***/ }),
/* 180 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _SegmetProvider = __webpack_require__(185);
	
	var _SegmetProvider2 = _interopRequireDefault(_SegmetProvider);
	
	var _State2 = __webpack_require__(187);
	
	var _State3 = _interopRequireDefault(_State2);
	
	var _StateMate2 = __webpack_require__(75);
	
	var _StateMate3 = _interopRequireDefault(_StateMate2);
	
	var _MergeMate = __webpack_require__(183);
	
	var _MergeMate2 = _interopRequireDefault(_MergeMate);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var Vector2D = function () {
	  function Vector2D(to, from) {
	    _classCallCheck(this, Vector2D);
	
	    this.x = to.x - from.x;
	    this.y = to.y - from.y;
	  }
	
	  _createClass(Vector2D, [{
	    key: 'length',
	    value: function length() {
	      return Math.sqrt(this.x * this.x + this.y * this.y);
	    }
	  }], [{
	    key: 'dot',
	    value: function dot(vec1, vec2) {
	      return vec1.x * vec2.x + vec1.y * vec2.y;
	    }
	  }]);
	
	  return Vector2D;
	}();
	
	var WalkingMate = function (_StateMate) {
	  _inherits(WalkingMate, _StateMate);
	
	  function WalkingMate() {
	    _classCallCheck(this, WalkingMate);
	
	    return _possibleConstructorReturn(this, (WalkingMate.__proto__ || Object.getPrototypeOf(WalkingMate)).apply(this, arguments));
	  }
	
	  _createClass(WalkingMate, [{
	    key: 'mate',
	    value: function mate(spot) {
	      var state = {};
	      var property = spot.property;
	      var lastSpot = spot.lastLineSpot;
	      var nextSpot = spot.nextLineSpot;
	
	      var crtSpotCoord = state.startPt = spot.lineString.getCoordinate();
	      var nextSpotCoord = void 0,
	          crtMovingVec = void 0;
	
	      // arrival case
	      if (!nextSpot) {
	        nextSpotCoord = spot.lineString.points.coordinates[1];
	        crtMovingVec = new Vector2D(nextSpotCoord, crtSpotCoord);
	        state.isEndSegment = true;
	      }
	
	      // starting (maybe from elevator exit) case
	      if (!lastSpot || lastSpot.property.altitude && property.altitude && property.altitude !== lastSpot.property.altitude) {
	        if (!state.isEndSegment) {
	          nextSpotCoord = nextSpot.lineString.getCoordinate();
	          crtMovingVec = new Vector2D(nextSpotCoord, crtSpotCoord);
	        }
	        state.distance = crtMovingVec.length();
	        state.orientation = this._computeOrientation(crtMovingVec.x, crtMovingVec.y);
	      } else if (property.altitude && nextSpot.property.altitude && property.altitude !== nextSpot.property.altitude) {
	        // passing elevator case
	        nextSpotCoord = spot.lineString.points.coordinates[1];
	        crtMovingVec = new Vector2D(nextSpotCoord, crtSpotCoord);
	        state.distance = crtMovingVec.length();
	        state.direction = this._computeDirection(lastSpot.lineString.getCoordinate(), crtSpotCoord, nextSpotCoord);
	        state.isUp = property.altitude - nextSpot.property.altitude < 0;
	        state.targetFloor = nextSpot.property.floorAddress;
	      } else {
	        // normal case
	        if (!state.isEndSegment) {
	          nextSpotCoord = nextSpot.lineString.getCoordinate();
	          crtMovingVec = new Vector2D(nextSpotCoord, crtSpotCoord);
	        }
	        state.distance = crtMovingVec.length();
	        state.direction = this._computeDirection(lastSpot.lineString.getCoordinate(), crtSpotCoord, nextSpotCoord);
	      }
	
	      state.orientationAngle = Math.atan2(crtMovingVec.y, crtMovingVec.x) * 360 / (2 * Math.PI) - 90;
	      return state;
	    }
	  }, {
	    key: '_computeOrientation',
	    value: function _computeOrientation(x, y) {
	      var paraAngle = -Math.atan2(y, x) * 360 / (2 * Math.PI);
	      if (paraAngle >= -15 && paraAngle < 15) {
	        return 'east';
	      } else if (paraAngle >= 15 && paraAngle < 75) {
	        return 'southeast';
	      } else if (paraAngle >= -75 && paraAngle < -15) {
	        return 'northeast';
	      } else if (paraAngle >= 75 && paraAngle < 105) {
	        return 'south';
	      } else if (paraAngle >= -105 && paraAngle < -75) {
	        return 'north';
	      } else if (paraAngle >= -165 && paraAngle < -105) {
	        return 'northwest';
	      } else if (paraAngle >= 105 && paraAngle < 165) {
	        return 'southwest';
	      } else if (paraAngle >= 165 && paraAngle < 180 || paraAngle >= -180 && paraAngle < -165) {
	        return 'west';
	      }
	
	      return '';
	    }
	  }, {
	    key: '_computeDirection',
	    value: function _computeDirection(lastSpotCoord, crtSpotCoord, nextSpotCoord) {
	      var crtMovingVec = new Vector2D(nextSpotCoord, crtSpotCoord);
	      var lastMovingVec = new Vector2D(crtSpotCoord, lastSpotCoord);
	      var cosAngle = Vector2D.dot(crtMovingVec, lastMovingVec) / (crtMovingVec.length() * lastMovingVec.length());
	      var Angle = Math.acos(cosAngle) * 360 / (2 * Math.PI);
	
	      var para = (lastSpotCoord.x - nextSpotCoord.x) * (crtSpotCoord.y - nextSpotCoord.y) - (lastSpotCoord.y - nextSpotCoord.y) * (crtSpotCoord.x - nextSpotCoord.x);
	      var generalDir = void 0;
	      if (para > 0) {
	        generalDir = 'left';
	      } else {
	        generalDir = 'right';
	      }
	
	      var direction = null;
	      if (Angle >= 0 && Angle < 15) {
	        direction = 'forward';
	      } else if (Angle >= 15 && Angle < 60) {
	        switch (generalDir) {
	          case 'left':
	            direction = 'leftForward';
	            break;
	          case 'right':
	            direction = 'rightForward';
	            break;
	          default:
	            throw new Error('WalkingMate#mate: Invalid direction');
	        }
	      } else if (Angle >= 60 && Angle < 120) {
	        switch (generalDir) {
	          case 'left':
	            direction = 'left';
	            break;
	          case 'right':
	            direction = 'right';
	            break;
	          default:
	            throw new Error('WalkingMate#mate: Invalid direction');
	        }
	      } else if (Angle >= 120 && Angle < 165) {
	        switch (generalDir) {
	          case 'left':
	            direction = 'leftBackward';
	            break;
	          case 'right':
	            direction = 'rightBackward';
	            break;
	          default:
	            throw new Error('WalkingMate#mate: Invalid direction');
	        }
	      } else if (Angle >= 165 && Angle <= 180) {
	        direction = 'backward';
	      }
	
	      return direction;
	    }
	  }]);
	
	  return WalkingMate;
	}(_StateMate3.default);
	
	var mates = {
	  defaultMate: new _StateMate3.default(),
	  walkingMate: new WalkingMate()
	};
	
	var WalkingState = function (_State) {
	  _inherits(WalkingState, _State);
	
	  function WalkingState() {
	    _classCallCheck(this, WalkingState);
	
	    // this.stateMate = new MergeMate(mates.walkingMate, () => {
	
	    // }, () => {
	
	    // });
	    var _this2 = _possibleConstructorReturn(this, (WalkingState.__proto__ || Object.getPrototypeOf(WalkingState)).call(this));
	
	    _this2.stateMate = new _MergeMate2.default(mates.walkingMate);
	    // this.stateMate = mates.walkingMate;
	    return _this2;
	  }
	
	  _createClass(WalkingState, [{
	    key: 'nextMove',
	    get: function get() {
	      return this._nextMove;
	    },
	    set: function set(nextMove) {
	      this._nextMove = nextMove;
	    }
	  }, {
	    key: 'distanceToEnd',
	    get: function get() {
	      return this._distanceToEnd;
	    },
	    set: function set(distanceToEnd) {
	      this._distanceToEnd = distanceToEnd;
	    }
	  }, {
	    key: 'distance',
	    get: function get() {
	      return this._distance;
	    },
	    set: function set(distance) {
	      this._distance = distance;
	    }
	  }, {
	    key: 'direction',
	    get: function get() {
	      return this._direction;
	    },
	    set: function set(direction) {
	      this._direction = direction;
	    }
	  }, {
	    key: 'orientation',
	    get: function get() {
	      return this._orientation;
	    },
	    set: function set(orientation) {
	      this._orientation = orientation;
	    }
	  }, {
	    key: 'orientationAngle',
	    get: function get() {
	      return this._orientationAngle;
	    },
	    set: function set(orientationAngle) {
	      this._orientationAngle = orientationAngle;
	    }
	  }, {
	    key: 'targetFloor',
	    get: function get() {
	      return this._targetFloor;
	    },
	    set: function set(targetFloor) {
	      this._targetFloor = targetFloor;
	    }
	  }, {
	    key: 'isUp',
	    get: function get() {
	      return this._isUp;
	    },
	    set: function set(isUp) {
	      this._isUp = isUp;
	    }
	  }, {
	    key: 'isEndSegment',
	    get: function get() {
	      return this._isEndSegment;
	    },
	    set: function set(isEndSegment) {
	      this._isEndSegment = isEndSegment;
	    }
	  }]);
	
	  return WalkingState;
	}(_State3.default);
	
	var states = [new WalkingState()];
	
	var DefaultSegmentProvider = function (_SegmentProvider) {
	  _inherits(DefaultSegmentProvider, _SegmentProvider);
	
	  function DefaultSegmentProvider() {
	    _classCallCheck(this, DefaultSegmentProvider);
	
	    return _possibleConstructorReturn(this, (DefaultSegmentProvider.__proto__ || Object.getPrototypeOf(DefaultSegmentProvider)).call(this, states));
	  }
	
	  return DefaultSegmentProvider;
	}(_SegmetProvider2.default);
	
	exports.default = DefaultSegmentProvider;

/***/ }),
/* 181 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _NGRObject2 = __webpack_require__(7);
	
	var _NGRObject3 = _interopRequireDefault(_NGRObject2);
	
	var _GeometryFactory = __webpack_require__(35);
	
	var _GeometryFactory2 = _interopRequireDefault(_GeometryFactory);
	
	var _jsts = __webpack_require__(5);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var DynamicNavigationRule = function (_NGRObject) {
	  _inherits(DynamicNavigationRule, _NGRObject);
	
	  function DynamicNavigationRule() {
	    _classCallCheck(this, DynamicNavigationRule);
	
	    var _this = _possibleConstructorReturn(this, (DynamicNavigationRule.__proto__ || Object.getPrototypeOf(DynamicNavigationRule)).call(this));
	
	    _this.reset();
	    return _this;
	  }
	
	  _createClass(DynamicNavigationRule, [{
	    key: 'start',
	    value: function start(x, y) {
	      for (var index = this._segments.length - 1; index >= 0; index--) {
	        var segment = this._segments[index];
	
	        if (this._isOnSegment(x, y, segment)) {
	          if (this._currentIndex !== index) {
	            this._changeSegment(segment);
	          }
	          this._currentIndex = index;
	
	          return true;
	        }
	        // this._segments.pop();
	      }
	
	      return false;
	    }
	  }, {
	    key: 'returnNearestSegment',
	    value: function returnNearestSegment(x, y, planargraphId) {
	      var ret = {
	        index: -1,
	        segment: null
	      };
	
	      for (var index = 0; index < this._segments.length; ++index) {
	        var segment = this._segments[index];
	
	        if (segment.spot.property['planar_graph'] === planargraphId && this._isOnSegment(x, y, segment)) {
	          ret.index = index;
	          ret.segment = segment;
	          break;
	        }
	      }
	
	      return ret;
	    }
	  }, {
	    key: 'findNearestSegment',
	    value: function findNearestSegment(x, y, planargraphId, autoPullToEnd, pullThreshold) {
	      var _returnNearestSegment = this.returnNearestSegment(x, y, planargraphId),
	          index = _returnNearestSegment.index,
	          segment = _returnNearestSegment.segment;
	
	      if (!segment) {
	        return false;
	      }
	
	      // this._center = new geom.Coordinate(x, y);
	
	      if (this._currentIndex !== null) {
	        if (this._currentIndex < index) {
	          this._currentIndex = index;
	          this._center = new _jsts.geom.Coordinate(x, y);
	          // 判断是否将定位点拉至线段终点
	          var nextSegment = this._segments[this._currentIndex + 1];
	          var useNextSeg = !segment.state.isEndSegment && !segment.state.targetFloor;
	          var segmentEnd = useNextSeg ? nextSegment.spot.lineString.getCoordinate() : segment.spot.lineString.points.coordinates[1];
	          if (autoPullToEnd && segmentEnd.distance(new _jsts.geom.Coordinate(x, y)) <= pullThreshold && this.currentIndex !== 0) {
	            this._center = segmentEnd;
	            this.emit('onArriveSegEnd');
	          }
	          this._changeSegment(segment, this._center);
	        } else {
	          var segmentStart = segment.spot.lineString.getCoordinate();
	          if (segmentStart.distance(new _jsts.geom.Coordinate(x, y)) > segmentStart.distance(this._center)) {
	            this._center = new _jsts.geom.Coordinate(x, y);
	            // 判断是否将定位点拉至线段终点
	            var _nextSegment = this._segments[this._currentIndex + 1];
	            var _useNextSeg = !segment.state.isEndSegment && !segment.state.targetFloor;
	            var _segmentEnd = _useNextSeg ? _nextSegment.spot.lineString.getCoordinate() : segment.spot.lineString.points.coordinates[1];
	            if (autoPullToEnd && _segmentEnd.distance(new _jsts.geom.Coordinate(x, y)) <= pullThreshold && this.currentIndex !== 0) {
	              this._center = _segmentEnd;
	              this.emit('onArriveSegEnd');
	            }
	            this._changeLocation(this._center);
	          }
	        }
	      } else {
	        this._currentIndex = index;
	        this._center = new _jsts.geom.Coordinate(x, y);
	        this._changeSegment(segment, this._center);
	      }
	
	      return true;
	    }
	  }, {
	    key: 'clearCurSt',
	    value: function clearCurSt() {
	      this._currentIndex = 0;
	      this._center = null;
	    }
	  }, {
	    key: 'reset',
	    value: function reset() {
	      var _this2 = this;
	
	      this._currentIndex = 0;
	      this._center = null;
	      this._segments = [];
	      this.clearCurSt();
	      if (!this._trigger) {
	
	        return;
	      }
	      this._trigger.forEach(function (segment) {
	        _this2._segments.push(segment);
	      });
	      // this._segments.reverse();
	    }
	  }, {
	    key: '_isOnSegment',
	    value: function _isOnSegment(x, y, segment) {
	      var point = _GeometryFactory2.default.createPoint([x, y]);
	      var spot = segment.spot;
	
	      while (spot) {
	        var lineString = spot.lineString;
	
	        if (lineString.buffer(0.1).contains(point)) {
	          return true;
	        }
	        spot = spot.nextLineSpot;
	        if (spot && spot.isValid) {
	          break;
	        }
	      }
	
	      return false;
	    }
	  }, {
	    key: '_changeSegment',
	    value: function _changeSegment(segment, location) {
	      this.emit('onSegmentChange', segment);
	      this.emit('onLocationChange', location);
	    }
	  }, {
	    key: '_changeLocation',
	    value: function _changeLocation(location) {
	      this.emit('onLocationChange', location);
	    }
	  }, {
	    key: 'currentIndex',
	    get: function get() {
	      return this._currentIndex;
	    }
	  }, {
	    key: 'center',
	    get: function get() {
	      return this._center;
	    }
	  }, {
	    key: 'trigger',
	    set: function set(trigger) {
	      this._trigger = trigger;
	      this.reset();
	    }
	  }]);
	
	  return DynamicNavigationRule;
	}(_NGRObject3.default);
	
	exports.default = DynamicNavigationRule;

/***/ }),
/* 182 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _Spot = __webpack_require__(186);
	
	var _GeometryFactory = __webpack_require__(35);
	
	var _GeometryFactory2 = _interopRequireDefault(_GeometryFactory);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var IteratorFS = function () {
	  function IteratorFS(fs) {
	    _classCallCheck(this, IteratorFS);
	
	    this._spots = [];
	
	    for (var _iterator = fs.features, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
	      var _ref;
	
	      if (_isArray) {
	        if (_i >= _iterator.length) break;
	        _ref = _iterator[_i++];
	      } else {
	        _i = _iterator.next();
	        if (_i.done) break;
	        _ref = _i.value;
	      }
	
	      var feature = _ref;
	
	      var properties = feature.properties;
	      var geometry = feature.geometry;
	      var coordinates = geometry.coordinates;
	      var coords = [];
	      for (var _iterator2 = coordinates, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator]();;) {
	        var _ref2;
	
	        if (_isArray2) {
	          if (_i2 >= _iterator2.length) break;
	          _ref2 = _iterator2[_i2++];
	        } else {
	          _i2 = _iterator2.next();
	          if (_i2.done) break;
	          _ref2 = _i2.value;
	        }
	
	        var coord = _ref2;
	
	        coords.push(coord);
	        if (coords.length === 2 && !this.needToThrow(coords)) {
	          var currentSpot = new _Spot.LineSpot(properties, _GeometryFactory2.default.createLineString(coords));
	          var lastSpot = this._spots[this._spots.length - 1];
	          if (lastSpot) {
	            lastSpot.nextLineSpot = currentSpot;
	          }
	          currentSpot.lastLineSpot = lastSpot;
	          this._spots.push(currentSpot);
	        }
	        if (coords.length === 2) {
	          coords.shift();
	        }
	      }
	    }
	  }
	
	  _createClass(IteratorFS, [{
	    key: 'next',
	    value: function next() {
	      return this._spots.shift();
	    }
	  }, {
	    key: 'has',
	    value: function has() {
	      return this._spots.length !== 0;
	    }
	  }, {
	    key: 'needToThrow',
	    value: function needToThrow(coords) {
	      if (Math.sqrt(Math.pow(coords[0][0] - coords[1][0], 2) + Math.pow(coords[0][1] - coords[1][1], 2)) < 0.01) {
	        return true;
	      }
	      return false;
	    }
	  }]);
	
	  return IteratorFS;
	}();
	
	exports.default = IteratorFS;

/***/ }),
/* 183 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _StateMate2 = __webpack_require__(75);
	
	var _StateMate3 = _interopRequireDefault(_StateMate2);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var MergeMate = function (_StateMate) {
	  _inherits(MergeMate, _StateMate);
	
	  function MergeMate(mate, map, reduce) {
	    _classCallCheck(this, MergeMate);
	
	    var _this = _possibleConstructorReturn(this, (MergeMate.__proto__ || Object.getPrototypeOf(MergeMate)).call(this));
	
	    _this._mate = mate;
	    _this._map = map;
	    _this._reduce = reduce;
	    _this._spots = [];
	    return _this;
	  }
	
	  // mate(spot) {
	  //   const result = this._mate.mate(spot);
	  //   if (this._map) {
	  //     const isFilter = this._map(spot, result);
	  //     if (isFilter) {
	  //       this._spots[this._spots.length] = { spot, result };
	  //       return null;
	  //     } else if (this._reduce) {
	  //       this._spots[this._spots.length] = { spot, result };
	  //       const nResult = this._reduce(this._spots);
	  //       this._spots = [];
	  //       return nResult;
	  //     }
	  //   }
	  //   return null;
	  // }
	
	  _createClass(MergeMate, [{
	    key: 'mate',
	    value: function mate(spot) {
	      if (!spot.isValid) {
	        return null;
	      }
	      var result = this._mate.mate(spot);
	      result.distanceToEnd = result.distance;
	      if (!spot.nextLineSpot) {
	        return result;
	      }
	      var nextSpot = spot.nextLineSpot;
	      var nextResult = this._mate.mate(nextSpot);
	      while (nextSpot && (nextResult.direction && nextResult.direction === 'forward' || !nextResult.direction) && !nextResult.orientation) {
	        result.distance += nextResult.distance;
	        nextSpot.isValid = false;
	        if (nextResult.isEndSegment) {
	          result.isEndSegment = true;
	          break;
	        }
	        if (nextResult.targetFloor) {
	          result.targetFloor = nextResult.targetFloor;
	          result.isUp = nextResult.isUp;
	          break;
	        }
	        nextSpot = nextSpot.nextLineSpot;
	        nextResult = this._mate.mate(nextSpot);
	      }
	
	      nextSpot = spot.nextLineSpot;
	      while (nextSpot) {
	        nextResult = this._mate.mate(nextSpot);
	        result.distanceToEnd += nextResult.distance;
	        nextSpot = nextSpot.nextLineSpot;
	      }
	
	      var crtSpot = spot;
	      var crtResult = void 0;
	      var distanceToConnection = 0;
	      var connectionFound = false;
	      while (crtSpot) {
	        crtResult = this._mate.mate(crtSpot);
	        distanceToConnection += crtResult.distance;
	        crtSpot = crtSpot.nextLineSpot;
	        if (!connectionFound && crtResult.targetFloor) {
	          result.distanceToConnection = distanceToConnection;
	          connectionFound = true;
	        }
	      }
	
	      return result;
	    }
	  }]);
	
	  return MergeMate;
	}(_StateMate3.default);
	
	exports.default = MergeMate;

/***/ }),
/* 184 */
/***/ (function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var Segment = function () {
	  function Segment(spot, state, audioProvider) {
	    _classCallCheck(this, Segment);
	
	    this._spot = spot;
	    this._state = state;
	    this._lastSegment = this._nextSegment = null;
	    this._audioProvider = audioProvider;
	  }
	
	  _createClass(Segment, [{
	    key: 'getMessageInNavi',
	    value: function getMessageInNavi(passDist) {
	      var muted = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
	
	      var message = null;
	      var messageEnd = null;
	      if (this._nextSegment && this._nextSegment.state.direction) {
	        messageEnd = this._parseDirectionInNavi(this._nextSegment.state.direction);
	      }
	
	      if (this.state.isEndSegment) {
	        messageEnd = '到达目的地附近';
	      }
	
	      if (this.state.targetFloor) {
	        messageEnd = this.state.isUp ? '\u4E58\u7535\u68AF\u4E0A\u884C\u81F3' + this.state.targetFloor + '\u5C42' : '\u4E58\u7535\u68AF\u4E0B\u884C\u81F3' + this.state.targetFloor + '\u5C42';
	      }
	
	      if (!passDist) {
	        message = '\u76F4\u884C' + parseFloat(this.state.distance).toFixed(1) + '\u7C73\u540E' + messageEnd;
	      } else {
	        message = '\u76F4\u884C' + parseFloat(this.state.distance - passDist).toFixed(1) + '\u7C73\u540E' + messageEnd;
	      }
	
	      // if (this.state.orientation) {
	      //   message = `${this._parseOrientationInNavi(this.state.orientation)}${message}`;
	      // }
	
	      if (parseFloat(this.state.distance - passDist).toFixed(1) <= 0) {
	        message = '' + messageEnd;
	      }
	
	      if (!muted) {
	        if (!this._audioProvider) {
	          console.log('Audio not provided when initializing DynamicNavigation');
	        } else {
	          this._audioProvider.playMessage(message);
	        }
	      }
	      return message;
	    }
	  }, {
	    key: '_parseDirectionInNavi',
	    value: function _parseDirectionInNavi(direction) {
	      var message = null;
	      switch (direction) {
	        case 'leftForward':
	          message = '左前方直行';
	          break;
	        case 'leftBackward':
	          message = '左后方直行';
	          break;
	        case 'left':
	          message = '向左转';
	          break;
	        case 'rightForward':
	          message = '右前方直行';
	          break;
	        case 'rightBackward':
	          message = '右后方直行';
	          break;
	        case 'right':
	          message = '向右转';
	          break;
	        case 'backward':
	          message = '向后转';
	          break;
	        default:
	          throw new Error('WalkingMate#message: Invalid direction or orientation');
	      }
	      return message;
	    }
	  }, {
	    key: '_parseOrientationInNavi',
	    value: function _parseOrientationInNavi(orientation) {
	      var message = null;
	      switch (orientation) {
	        case 'east':
	          message = '向东';
	          break;
	        case 'west':
	          message = '向西';
	          break;
	        case 'south':
	          message = '向南';
	          break;
	        case 'north':
	          message = '向北';
	          break;
	        case 'northeast':
	          message = '向东北';
	          break;
	        case 'northwest':
	          message = '向西北';
	          break;
	        case 'southeast':
	          message = '向东南';
	          break;
	        case 'southwest':
	          message = '向西南';
	          break;
	        default:
	          throw new Error('WalkingMate#message: Invalid direction or orientation');
	      }
	      return message;
	    }
	  }, {
	    key: 'getMessageInList',
	    value: function getMessageInList() {
	      var message = null;
	      if (this.state.direction) {
	        message = this._parseDirection(this.state.direction);
	      } else if (this.state.orientation) {
	        message = this._parseOrientation(this.state.orientation);
	      }
	
	      if (this.state.isEndSegment) {
	        return message + '\u540E\u5230\u8FBE\u76EE\u7684\u5730';
	      }
	
	      if (this.state.targetFloor) {
	        var eleMessage = this.state.isUp ? '\u540E\u4E0A\u884C\u81F3' + this.state.targetFloor + '\u5C42' : '\u540E\u4E0B\u884C\u81F3' + this.state.targetFloor + '\u5C42';
	        return '' + message + eleMessage;
	      }
	
	      return message;
	    }
	  }, {
	    key: '_parseDirection',
	    value: function _parseDirection(direction) {
	      var message = null;
	      switch (direction) {
	        case 'forward':
	          message = '\u76F4\u884C' + parseFloat(this.state.distance).toFixed(1) + '\u7C73';
	          break;
	        case 'leftForward':
	          message = '\u5DE6\u524D\u65B9\u76F4\u884C' + parseFloat(this.state.distance).toFixed(1) + '\u7C73';
	          break;
	        case 'leftBackward':
	          message = '\u5DE6\u540E\u65B9\u76F4\u884C' + parseFloat(this.state.distance).toFixed(1) + '\u7C73';
	          break;
	        case 'left':
	          message = '\u5411\u5DE6\u76F4\u884C' + parseFloat(this.state.distance).toFixed(1) + '\u7C73';
	          break;
	        case 'rightForward':
	          message = '\u53F3\u524D\u65B9\u76F4\u884C' + parseFloat(this.state.distance).toFixed(1) + '\u7C73';
	          break;
	        case 'rightBackward':
	          message = '\u53F3\u540E\u65B9\u76F4\u884C' + parseFloat(this.state.distance).toFixed(1) + '\u7C73';
	          break;
	        case 'right':
	          message = '\u5411\u53F3\u76F4\u884C' + parseFloat(this.state.distance).toFixed(1) + '\u7C73';
	          break;
	        case 'backward':
	          message = '\u5411\u540E\u76F4\u884C' + parseFloat(this.state.distance).toFixed(1) + '\u7C73';
	          break;
	        default:
	          throw new Error('WalkingMate#message: Invalid direction or orientation');
	      }
	      return message;
	    }
	  }, {
	    key: '_parseOrientation',
	    value: function _parseOrientation(orientation) {
	      var message = null;
	      switch (orientation) {
	        case 'east':
	          message = '\u5411\u4E1C\u76F4\u884C' + parseFloat(this.state.distance).toFixed(1) + '\u7C73';
	          break;
	        case 'west':
	          message = '\u5411\u897F\u76F4\u884C' + parseFloat(this.state.distance).toFixed(1) + '\u7C73';
	          break;
	        case 'south':
	          message = '\u5411\u5357\u76F4\u884C' + parseFloat(this.state.distance).toFixed(1) + '\u7C73';
	          break;
	        case 'north':
	          message = '\u5411\u5317\u76F4\u884C' + parseFloat(this.state.distance).toFixed(1) + '\u7C73';
	          break;
	        case 'northeast':
	          message = '\u5411\u4E1C\u5317\u76F4\u884C' + parseFloat(this.state.distance).toFixed(1) + '\u7C73';
	          break;
	        case 'northwest':
	          message = '\u5411\u897F\u5317\u76F4\u884C' + parseFloat(this.state.distance).toFixed(1) + '\u7C73';
	          break;
	        case 'southeast':
	          message = '\u5411\u4E1C\u5357\u76F4\u884C' + parseFloat(this.state.distance).toFixed(1) + '\u7C73';
	          break;
	        case 'southwest':
	          message = '\u5411\u897F\u5357\u76F4\u884C' + parseFloat(this.state.distance).toFixed(1) + '\u7C73';
	          break;
	        default:
	          throw new Error('WalkingMate#message: Invalid direction or orientation');
	      }
	      return message;
	    }
	  }, {
	    key: 'spot',
	    get: function get() {
	      return this._spot;
	    }
	  }, {
	    key: 'state',
	    get: function get() {
	      return this._state;
	    }
	  }, {
	    key: 'lastSegment',
	    set: function set(lastSegment) {
	      this._lastSegment = lastSegment;
	    },
	    get: function get() {
	      return this._lastSegment;
	    }
	  }, {
	    key: 'nextSegment',
	    set: function set(nextSegment) {
	      this._nextSegment = nextSegment;
	    },
	    get: function get() {
	      return this._nextSegment;
	    }
	  }]);
	
	  return Segment;
	}();
	
	exports.default = Segment;

/***/ }),
/* 185 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _Segment = __webpack_require__(184);
	
	var _Segment2 = _interopRequireDefault(_Segment);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var SegmentProvider = function () {
	  function SegmentProvider(states) {
	    _classCallCheck(this, SegmentProvider);
	
	    this.states = states;
	  }
	
	  _createClass(SegmentProvider, [{
	    key: 'provider',
	    value: function provider(spot, state, audioProvider) {
	      return new _Segment2.default(spot, state, audioProvider);
	    }
	  }, {
	    key: 'states',
	    get: function get() {
	      return this._states;
	    },
	    set: function set(states) {
	      this._states = states;
	    }
	  }]);
	
	  return SegmentProvider;
	}();
	
	exports.default = SegmentProvider;

/***/ }),
/* 186 */
/***/ (function(module, exports) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var Spot = function () {
	  function Spot(property) {
	    _classCallCheck(this, Spot);
	
	    this.property = property || {};
	  }
	
	  _createClass(Spot, [{
	    key: "property",
	    get: function get() {
	      return this._property;
	    },
	    set: function set(property) {
	      this._property = property;
	    }
	  }]);
	
	  return Spot;
	}();
	
	var PointSpot = function (_Spot) {
	  _inherits(PointSpot, _Spot);
	
	  function PointSpot(property, coordinate) {
	    _classCallCheck(this, PointSpot);
	
	    var _this = _possibleConstructorReturn(this, (PointSpot.__proto__ || Object.getPrototypeOf(PointSpot)).call(this, property));
	
	    _this._coordinate = coordinate;
	    return _this;
	  }
	
	  _createClass(PointSpot, [{
	    key: "coordinate",
	    get: function get() {
	      return this._coordinate;
	    }
	  }]);
	
	  return PointSpot;
	}(Spot);
	
	var LineSpot = function (_Spot2) {
	  _inherits(LineSpot, _Spot2);
	
	  function LineSpot(property, lineString) {
	    _classCallCheck(this, LineSpot);
	
	    var _this2 = _possibleConstructorReturn(this, (LineSpot.__proto__ || Object.getPrototypeOf(LineSpot)).call(this, property));
	
	    _this2._lineString = lineString;
	    _this2._lastLineSpot = _this2._nextLineSpot = null;
	    _this2._isValid = true;
	    return _this2;
	  }
	
	  _createClass(LineSpot, [{
	    key: "lineString",
	    get: function get() {
	      return this._lineString;
	    }
	  }, {
	    key: "lastLineSpot",
	    get: function get() {
	      return this._lastLineSpot;
	    },
	    set: function set(lastLineSpot) {
	      this._lastLineSpot = lastLineSpot;
	    }
	  }, {
	    key: "nextLineSpot",
	    get: function get() {
	      return this._nextLineSpot;
	    },
	    set: function set(nextLineSpot) {
	      this._nextLineSpot = nextLineSpot;
	    }
	  }, {
	    key: "isValid",
	    get: function get() {
	      return this._isValid;
	    },
	    set: function set(isValid) {
	      this._isValid = isValid;
	    }
	  }]);
	
	  return LineSpot;
	}(Spot);
	
	exports.Spot = Spot;
	exports.PointSpot = PointSpot;
	exports.LineSpot = LineSpot;

/***/ }),
/* 187 */
/***/ (function(module, exports) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var State = function () {
	  function State() {
	    _classCallCheck(this, State);
	  }
	
	  _createClass(State, [{
	    key: "message",
	    get: function get() {
	      return this._message;
	    },
	    set: function set(message) {
	      this._message = message;
	    }
	  }, {
	    key: "stateMate",
	    get: function get() {
	      return this._stateMate;
	    },
	    set: function set(stateMate) {
	      this._stateMate = stateMate;
	    }
	  }]);
	
	  return State;
	}();
	
	exports.default = State;

/***/ }),
/* 188 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _IteratorFS = __webpack_require__(182);
	
	var _IteratorFS2 = _interopRequireDefault(_IteratorFS);
	
	var _AudioProvider = __webpack_require__(179);
	
	var _AudioProvider2 = _interopRequireDefault(_AudioProvider);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var Trigger = function () {
	  function Trigger(segmentProvider) {
	    var needAudio = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
	
	    _classCallCheck(this, Trigger);
	
	    this._provider = segmentProvider;
	    this._audioProvider = needAudio ? new _AudioProvider2.default() : null;
	    this._segments = [];
	  }
	
	  _createClass(Trigger, [{
	    key: 'addSegment',
	    value: function addSegment(segment) {
	      if (this._segments.length !== 0) {
	        this._segments[this._segments.length - 1].nextSegment = segment;
	        segment.lastSegment = this._segments[this._segments.length - 1];
	      }
	      this._segments.push(segment);
	      return this;
	    }
	  }, {
	    key: 'removeSegment',
	    value: function removeSegment(index) {
	      this._segments.splice(index, 1);
	      return this;
	    }
	  }, {
	    key: 'getSegment',
	    value: function getSegment(index) {
	      return this._segments[index];
	    }
	  }, {
	    key: 'size',
	    value: function size() {
	      return this._segments.length;
	    }
	  }, {
	    key: 'forEach',
	    value: function forEach(callBack) {
	      [].forEach.call(this._segments, callBack);
	    }
	  }, {
	    key: 'trigger',
	    value: function trigger(featureCollection) {
	      var itfs = new _IteratorFS2.default(featureCollection);
	      var states = this.provider.states;
	
	      this._segments = [];
	      while (itfs.has()) {
	        var spot = itfs.next();
	        for (var _iterator = states, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
	          var _ref;
	
	          if (_isArray) {
	            if (_i >= _iterator.length) break;
	            _ref = _iterator[_i++];
	          } else {
	            _i = _iterator.next();
	            if (_i.done) break;
	            _ref = _i.value;
	          }
	
	          var state = _ref;
	
	          var mate = state.stateMate.mate(spot);
	          if (mate) {
	            var temp = Object.create(Object.getPrototypeOf(state));
	            for (var key in mate) {
	              temp[key] = mate[key];
	            }
	            var segment = this._provider.provider(spot, temp, this._audioProvider);
	            this.addSegment(segment);
	          }
	        }
	      }
	    }
	  }, {
	    key: 'provider',
	    get: function get() {
	      return this._provider;
	    },
	    set: function set(provider) {
	      this._provider = provider;
	    }
	  }]);
	
	  return Trigger;
	}();
	
	exports.default = Trigger;

/***/ }),
/* 189 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.CustomG = exports.DynamicNavigation = exports.naviFilter = exports.NaviUtils = exports.PathService = exports.NavigateManager = undefined;
	
	var _NavigateManager = __webpack_require__(45);
	
	var _NavigateManager2 = _interopRequireDefault(_NavigateManager);
	
	var _PathService = __webpack_require__(72);
	
	var _PathService2 = _interopRequireDefault(_PathService);
	
	var _NaviUtils = __webpack_require__(177);
	
	var _DynamicNavigation = __webpack_require__(74);
	
	var _DynamicNavigation2 = _interopRequireDefault(_DynamicNavigation);
	
	var _CustomG = __webpack_require__(174);
	
	var _CustomG2 = _interopRequireDefault(_CustomG);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	// import Segment from './dynamic/Segment';
	exports.NavigateManager = _NavigateManager2.default;
	exports.PathService = _PathService2.default;
	exports.NaviUtils = _NaviUtils.NaviUtils;
	exports.naviFilter = _NaviUtils.naviFilter;
	exports.DynamicNavigation = _DynamicNavigation2.default;
	exports.CustomG = _CustomG2.default;

/***/ }),
/* 190 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _assign = __webpack_require__(1);
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _Overlay2 = __webpack_require__(76);
	
	var _Overlay3 = _interopRequireDefault(_Overlay2);
	
	var _jsts = __webpack_require__(5);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var initOptions = {
	  /*
	  url: (String) (required)
	  size: (Object) (optional, should have x and y properties and cam be set through CSS)
	  anchor: (Object) (opional, should have x and y properties, centered by default and can be set in CSS with negative margins)
	  className: (String) (optional, image element className)
	   */
	  anchor: [0, 0],
	  className: '',
	  crossOrigin: false,
	  interactive: true
	};
	
	/**
	 * 创建图片覆盖物。在地图上可作为图片标注显示。
	 * @extends {NGR.overlay.Overlay}
	 * @memberOf NGR.overlay
	 */
	
	var IconOverlay = function (_Overlay) {
	  _inherits(IconOverlay, _Overlay);
	
	  /**
	   * 构造方法。
	   * @param {Object}   options                 覆盖物选项，如图片、文字、图片大小、url信息。
	   * @param {String}   options.url             图片url。
	   * @param {Number[]} [options.size]          图片大小。
	   * @param {Number[]} [options.anchor=[0, 0]] 锚点，用于确定图片旋转的中心点。
	   * @param {String}   [options.className='']  img类名。
	   */
	  function IconOverlay(options) {
	    _classCallCheck(this, IconOverlay);
	
	    var opts = _assign({}, initOptions, options);
	
	    var _this = _possibleConstructorReturn(this, (IconOverlay.__proto__ || Object.getPrototypeOf(IconOverlay)).call(this, null, opts));
	
	    _this._dom = _this._createIcon();
	    return _this;
	  }
	
	  /**
	   * Create Icon by url.
	   * @private
	   * @return {HTMLImageElement} Icon dom.
	   */
	
	
	  _createClass(IconOverlay, [{
	    key: '_createIcon',
	    value: function _createIcon() {
	      var _this2 = this;
	
	      var _options = this._options,
	          url = _options.url,
	          interactive = _options.interactive;
	
	
	      if (!url) {
	        throw new Error('url not set in IconOverlay options.');
	      }
	
	      var img = this._createImg(url);
	
	      img.addEventListener('load', function (event) {
	        _this2.emit('load', _this2, event);
	      }, false);
	
	      img.addEventListener('error', function (event) {
	        _this2.emit('error', _this2, event);
	      }, false);
	
	      img.addEventListener('click', function (event) {
	        if (interactive) {
	          _this2.emit('click', _this2, event);
	        }
	      }, false);
	
	      this._setStyles(img);
	
	      return img;
	    }
	
	    /**
	     * Create image dom.
	     * @private
	     * @param  {String}           url Source of image.
	     * @param  {HTMLImageElement} el  Specified image element.
	     * @return {HTMLImageElement}     Image dom.
	     */
	
	  }, {
	    key: '_createImg',
	    value: function _createImg(url) {
	      var _options2 = this._options,
	          crossOrigin = _options2.crossOrigin,
	          alt = _options2.alt;
	
	      var img = document.createElement('img');
	
	      img.src = url;
	
	      if (crossOrigin) {
	        img.crossOrigin = '';
	      }
	
	      if (alt) {
	        img.alt = alt;
	      }
	
	      return img;
	    }
	
	    /**
	     * 设置图片属性。
	     * @param {Obeject} options          图片覆盖物选项，如图片大小、url信息等，详见构造函数。
	     * @return {NGR.overlay.IconOverlay} this。
	     */
	
	  }, {
	    key: 'setStyles',
	    value: function setStyles(options) {
	      _assign({}, this._options, options);
	      this._setStyles(this._dom);
	
	      return this;
	    }
	  }, {
	    key: '_setStyles',
	
	
	    /**
	     * Set styles of icon depending on options.
	     * @private
	     * @param {HTMLImageElement} img     Image element.
	     * @return {NGR.overlay.IconOverlay} this.
	     */
	    value: function _setStyles(img) {
	      var className = this._options.className;
	
	
	      if (className) {
	        img.className = 'ngr-iconOverlay ' + className;
	      }
	
	      var _options3 = this._options,
	          anchor = _options3.anchor,
	          size = _options3.size;
	
	
	      anchor = this._translate2Coord(anchor);
	      size = this._translate2Coord(size);
	
	      if (anchor) {
	        img.style.marginLeft = -anchor.x + 'px';
	        img.style.marginTop = -anchor.y + 'px';
	      }
	
	      if (size) {
	        img.style.width = size.x + 'px';
	        img.style.height = size.y + 'px';
	      }
	
	      return this;
	    }
	
	    /**
	     * Translate an Object or Array to a Coordinate.
	     * @private
	     * @param  {Object|Array} p      Point to be translate.
	     * @return {NGR.geom.Coordinate} Coordinate.
	     */
	
	  }, {
	    key: '_translate2Coord',
	    value: function _translate2Coord(p) {
	      if (!p) {
	        return null;
	      }
	
	      var x = void 0,
	          y = void 0;
	
	      if (Array.isArray(p)) {
	        x = p[0] ? p[0] : 0;
	        y = p[1] ? p[1] : 0;
	      } else {
	        x = p.x ? p.x : 0;
	        y = p.y ? p.y : 0;
	      }
	
	      return new _jsts.geom.Coordinate(x, y);
	    }
	  }, {
	    key: 'url',
	    set: function set(url) {
	      if (url === this._options.url) {
	        return;
	      }
	
	      this._dom.src = url;
	    }
	  }]);
	
	  return IconOverlay;
	}(_Overlay3.default);
	
	exports.default = IconOverlay;

/***/ }),
/* 191 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _NGRObject2 = __webpack_require__(7);
	
	var _NGRObject3 = _interopRequireDefault(_NGRObject2);
	
	var _jsts = __webpack_require__(5);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var Particle = function (_NGRObject) {
	  _inherits(Particle, _NGRObject);
	
	  function Particle() {
	    _classCallCheck(this, Particle);
	
	    var _this = _possibleConstructorReturn(this, (Particle.__proto__ || Object.getPrototypeOf(Particle)).call(this));
	
	    _this.particleCount = 10;
	    _this.colors = [[0.5, 0.5, 0.5], [1, 0, 0]];
	    _this.position = new _jsts.geom.Coordinate(0, 0, 0);
	    return _this;
	  }
	
	  _createClass(Particle, [{
	    key: 'parent',
	    get: function get() {
	      return this._parent;
	    },
	    set: function set(parent) {
	      this._parent = parent;
	    }
	  }, {
	    key: 'particleCount',
	    get: function get() {
	      return this._particleCount;
	    },
	    set: function set(particleCount) {
	      this._particleCount = particleCount;
	      this.emit('valueChange', this, 'particleCount', particleCount);
	    }
	  }, {
	    key: 'position',
	    get: function get() {
	      return this._position;
	    },
	    set: function set(position) {
	      this._position = position;
	      this.emit('valueChange', this, 'position', position);
	    }
	  }, {
	    key: 'colors',
	    get: function get() {
	      return this._colors;
	    },
	    set: function set(colors) {
	      this._colors = colors;
	      this.emit('valueChange', this, 'colors', colors);
	    }
	  }]);
	
	  return Particle;
	}(_NGRObject3.default);
	
	exports.default = Particle;

/***/ }),
/* 192 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _assign = __webpack_require__(1);
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _NGRObject2 = __webpack_require__(7);
	
	var _NGRObject3 = _interopRequireDefault(_NGRObject2);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var ParticleGroup = function (_NGRObject) {
	  _inherits(ParticleGroup, _NGRObject);
	
	  function ParticleGroup(options) {
	    _classCallCheck(this, ParticleGroup);
	
	    var _this = _possibleConstructorReturn(this, (ParticleGroup.__proto__ || Object.getPrototypeOf(ParticleGroup)).call(this));
	
	    _this._particlesIndex = [];
	    _this._particles = {};
	    _assign(_this, options || {});
	    return _this;
	  }
	
	  _createClass(ParticleGroup, [{
	    key: 'addParticle',
	    value: function addParticle(particle) {
	      if (particle && this.has(particle)) {
	        return;
	      }
	      this._particles[particle.id] = particle;
	      this._particlesIndex[this._particlesIndex.length] = particle.id;
	      this.emit('addParticle', this, particle);
	      particle.parent = this;
	    }
	  }, {
	    key: 'removeParticle',
	    value: function removeParticle(particle) {
	      if (particle && this.has(particle)) {
	        delete this._particles[particle.id];
	        var indexOf = this._particlesIndex.indexOf(particle.id);
	        if (indexOf !== -1) {
	          this._particlesIndex.splice(indexOf, 1);
	        }
	        this.emit('removeParticle', this, particle);
	        particle.parent = null;
	      }
	    }
	  }, {
	    key: 'forEach',
	    value: function forEach(callback) {
	      var _this2 = this;
	
	      this._particlesIndex.forEach(function (id, index) {
	        callback(_this2._particles[id], index);
	      });
	    }
	  }, {
	    key: 'getIndex',
	    value: function getIndex(particle) {
	      return this._particlesIndex.indexOf(particle);
	    }
	  }, {
	    key: 'has',
	    value: function has(particle) {
	      return !!particle && particle.id in this._particlesIndex;
	    }
	  }, {
	    key: 'texture',
	    get: function get() {
	      return this._texture;
	    },
	    set: function set(texture) {
	      this._texture = texture;
	    }
	  }]);
	
	  return ParticleGroup;
	}(_NGRObject3.default);
	
	exports.default = ParticleGroup;

/***/ }),
/* 193 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.ParticleEngine = exports.ParticleGroup = exports.Particle = undefined;
	
	var _Particle = __webpack_require__(191);
	
	var _Particle2 = _interopRequireDefault(_Particle);
	
	var _ParticleGroup = __webpack_require__(192);
	
	var _ParticleGroup2 = _interopRequireDefault(_ParticleGroup);
	
	var _ParticleEngine = __webpack_require__(78);
	
	var _ParticleEngine2 = _interopRequireDefault(_ParticleEngine);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.Particle = _Particle2.default;
	exports.ParticleGroup = _ParticleGroup2.default;
	exports.ParticleEngine = _ParticleEngine2.default;

/***/ }),
/* 194 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _Renderer2 = __webpack_require__(79);
	
	var _Renderer3 = _interopRequireDefault(_Renderer2);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var SimpleRenderer = function (_Renderer) {
	  _inherits(SimpleRenderer, _Renderer);
	
	  function SimpleRenderer() {
	    _classCallCheck(this, SimpleRenderer);
	
	    return _possibleConstructorReturn(this, (SimpleRenderer.__proto__ || Object.getPrototypeOf(SimpleRenderer)).apply(this, arguments));
	  }
	
	  _createClass(SimpleRenderer, [{
	    key: 'getStyle',
	    value: function getStyle(feature) {
	      // eslint-disable-line no-unused-vars
	      return this.style;
	    }
	  }, {
	    key: 'style',
	    set: function set(style) {
	      this._style = style;
	    },
	    get: function get() {
	      return this._style;
	    }
	  }]);
	
	  return SimpleRenderer;
	}(_Renderer3.default);
	
	exports.default = SimpleRenderer;

/***/ }),
/* 195 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _Renderer2 = __webpack_require__(79);
	
	var _Renderer3 = _interopRequireDefault(_Renderer2);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var globalRegexp = new RegExp();
	
	var UniqueRenderer = function (_Renderer) {
	  _inherits(UniqueRenderer, _Renderer);
	
	  function UniqueRenderer() {
	    _classCallCheck(this, UniqueRenderer);
	
	    var _this = _possibleConstructorReturn(this, (UniqueRenderer.__proto__ || Object.getPrototypeOf(UniqueRenderer)).call(this));
	
	    _this._keys = [];
	    _this._styles = {};
	    return _this;
	  }
	
	  _createClass(UniqueRenderer, [{
	    key: 'addKey',
	    value: function addKey() {
	      var _this2 = this;
	
	      for (var _len = arguments.length, keys = Array(_len), _key = 0; _key < _len; _key++) {
	        keys[_key] = arguments[_key];
	      }
	
	      keys.forEach(function (key) {
	        _this2._keys.push(key);
	      });
	    }
	  }, {
	    key: 'addStyle',
	    value: function addStyle(value, style) {
	      this._styles[value] = style;
	    }
	  }, {
	    key: 'getStyle',
	    value: function getStyle(feature) {
	      for (var index in this._keys) {
	        var key = this._keys[index];
	        if (key in feature.properties) {
	          for (var name in this._styles) {
	            globalRegexp.compile(name, 'g');
	            if (globalRegexp.test(feature.properties[key])) {
	              return this._styles[name];
	            }
	            // const style = this._styles[];
	            // if (style) {
	            //   return style;
	            // }
	          }
	        }
	      }
	      return this.defaultStyle;
	    }
	  }, {
	    key: 'defaultStyle',
	    get: function get() {
	      return this._defaultStyle;
	    },
	    set: function set(defaultStyle) {
	      this._defaultStyle = defaultStyle;
	    }
	  }]);
	
	  return UniqueRenderer;
	}(_Renderer3.default);
	
	exports.default = UniqueRenderer;

/***/ }),
/* 196 */
/***/ (function(module, exports) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	/**
	 * Merge node. For inheritance.
	 * @ignore
	 */
	var MergeNode = function () {
	  function MergeNode() {
	    _classCallCheck(this, MergeNode);
	  }
	
	  _createClass(MergeNode, [{
	    key: "merge",
	
	    /**
	     * Merge. For override.
	     * @param  {String}         id     id.
	     * @param  {THREE.Object3D} scene  Scene.
	     * @param  {THREE.Object3D} parent Parent of above scene.
	     * @return {MergeNode}      this.
	     */
	    value: function merge(id, scene, parent) {
	      // eslint-disable-line no-unused-vars
	      return this;
	    }
	
	    /**
	     * Check whether this node has the passed id or not. For override. For override.
	     * @param  {String}  id Id.
	     * @return {Boolean}    Check result.
	     */
	
	  }, {
	    key: "has",
	    value: function has(id) {
	      // eslint-disable-line no-unused-vars
	      return false;
	    }
	  }, {
	    key: "destroy",
	    value: function destroy() {}
	  }]);
	
	  return MergeNode;
	}();
	
	exports.default = MergeNode;

/***/ }),
/* 197 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _assign = __webpack_require__(1);
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _three = __webpack_require__(2);
	
	var THREE = _interopRequireWildcard(_three);
	
	var _Octree = __webpack_require__(128);
	
	var _lang = __webpack_require__(4);
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	/**
	 * Initial octree options.
	 * @ignore
	 * @type {Object}
	 */
	var initOptions = {
	  undeferred: false,
	  depthMax: Infinity,
	  objectsThreshold: 8,
	  overlap: 0.15
	};
	
	/**
	 * Octree manager.
	 * @private
	 */
	
	var OctreeManager = function () {
	  function OctreeManager(options) {
	    _classCallCheck(this, OctreeManager);
	
	    this.options = _assign({}, initOptions, options);
	    this._octree = new _Octree.Octree(_assign({}, this.options));
	    // layerId : featureIds Number[] : uuids String[]
	    this.featureMapping = {};
	    // sceneGroupId Number : layerGroupId Number
	    this.groupMapping = {};
	    // layerGroupId Number : virtualGroup THREE.Group
	    this.virtualGroups = {};
	  }
	
	  _createClass(OctreeManager, [{
	    key: 'update',
	    value: function update() {
	      this._octree.update();
	    }
	  }, {
	    key: '_add',
	    value: function _add(object, featureMapping, virtualGroup) {
	      if (object instanceof THREE.Group) {
	        var meshes = object.children;
	
	        for (var _iterator = meshes, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
	          var _ref;
	
	          if (_isArray) {
	            if (_i >= _iterator.length) break;
	            _ref = _iterator[_i++];
	          } else {
	            _i = _iterator.next();
	            if (_i.done) break;
	            _ref = _i.value;
	          }
	
	          var mesh = _ref;
	
	          this._add(mesh, featureMapping, virtualGroup);
	        }
	        return;
	      }
	
	      // object._virtualGroupUuid = virtualGroup.uuid;
	      featureMapping.push(object.uuid);
	      this._octree.add(object);
	    }
	  }, {
	    key: 'add',
	    value: function add(object, layerId, featureId) {
	      var mergeOptions = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
	
	      if ((0, _lang.isBlank)(object) || (0, _lang.isBlank)(layerId) || (0, _lang.isBlank)(featureId)) {
	        return;
	      }
	
	      if ((0, _lang.isBlank)(this.featureMapping[layerId])) {
	        this.featureMapping[layerId] = {};
	      }
	      if ((0, _lang.isBlank)(this.featureMapping[layerId][featureId])) {
	        this.featureMapping[layerId][featureId] = [];
	      }
	
	      var fm = this.featureMapping[layerId][featureId];
	      var layerGroupId = mergeOptions.layerGroupId,
	          sceneGroupId = mergeOptions.sceneGroupId;
	
	      var vGroup = null;
	
	      if (layerGroupId && sceneGroupId) {
	
	        if (!this.groupMapping[sceneGroupId]) {
	          this.groupMapping[sceneGroupId] = layerGroupId;
	        } else if (layerGroupId !== this.groupMapping[sceneGroupId]) {
	          throw new Error('OctreeManager: Unmatch in groupMapping');
	        }
	
	        if (!this.virtualGroups[layerGroupId]) {
	          this.virtualGroups[layerGroupId] = new THREE.Group();
	        }
	
	        vGroup = this.virtualGroups[layerGroupId];
	        vGroup.add(object);
	        object._virtual = true;
	      }
	
	      this._add(object, fm, vGroup);
	    }
	  }, {
	    key: 'remove',
	    value: function remove(object) {
	      var needDispose = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
	
	      if (object._virtual) {
	        object.parent.remove(object);
	      }
	
	      if (object instanceof THREE.Group) {
	        var meshes = object.children;
	
	        for (var _iterator2 = meshes, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator]();;) {
	          var _ref2;
	
	          if (_isArray2) {
	            if (_i2 >= _iterator2.length) break;
	            _ref2 = _iterator2[_i2++];
	          } else {
	            _i2 = _iterator2.next();
	            if (_i2.done) break;
	            _ref2 = _i2.value;
	          }
	
	          var mesh = _ref2;
	
	          this.remove(mesh, needDispose);
	        }
	        return;
	      }
	
	      this._octree.remove(object);
	
	      if (needDispose) {
	        object.geometry.dispose();
	      }
	    }
	  }, {
	    key: 'removeByLayerAndFeature',
	    value: function removeByLayerAndFeature(layerId, featureId) {
	      if (!this.featureMapping[layerId] || !this.featureMapping[layerId][featureId]) {
	        return;
	      }
	
	      var uuids = this.featureMapping[layerId][featureId];
	
	      if (uuids && uuids.length > 0) {
	        for (var _iterator3 = uuids, _isArray3 = Array.isArray(_iterator3), _i3 = 0, _iterator3 = _isArray3 ? _iterator3 : _iterator3[Symbol.iterator]();;) {
	          var _ref3;
	
	          if (_isArray3) {
	            if (_i3 >= _iterator3.length) break;
	            _ref3 = _iterator3[_i3++];
	          } else {
	            _i3 = _iterator3.next();
	            if (_i3.done) break;
	            _ref3 = _i3.value;
	          }
	
	          var uuid = _ref3;
	
	          var object = this._octree.objectsMap[uuid];
	
	          if (object) {
	            this.remove(object);
	          }
	        }
	      }
	
	      delete this.featureMapping[layerId][featureId];
	    }
	  }, {
	    key: 'has',
	    value: function has(layerId, featureId) {
	      var fm = this.featureMapping;
	
	      return fm[layerId] && fm[layerId][featureId] && fm[layerId][featureId].length > 0;
	    }
	
	    // TODO
	    // updateObject(object) {
	    // }
	
	  }, {
	    key: 'rebuild',
	    value: function rebuild() {
	      // const startTimestamp = new Date().getTime();
	
	      this._octree.rebuild();
	
	      // const endTimestamp = new Date().getTime();
	
	      // console.log(endTimestamp - startTimestamp);
	    }
	  }, {
	    key: 'clearOctree',
	    value: function clearOctree() {
	      var needDispose = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
	
	      var objects = this._octree.objects;
	      var len = objects.length;
	
	      // renew octree
	      this._octree = new _Octree.Octree(_assign({}, this.options));
	      this.featureMapping = {};
	      this.groupMapping = {};
	      this.virtualGroups = {};
	
	      if (needDispose) {
	        // dispose geometry
	        for (var i = len - 1; i >= 0; --i) {
	          var object = objects[i];
	
	          objects.splice(i, 1);
	          object.geometry.dispose();
	        }
	      }
	    }
	  }, {
	    key: 'searchByClientPoint',
	    value: function searchByClientPoint(x, y, camera) {
	      var raycaster = new THREE.Raycaster();
	      var ret = [];
	
	      raycaster.setFromCamera(new THREE.Vector2(x, y), camera);
	
	      var octreeObjects = this._octree.search(raycaster.ray.origin, raycaster.far, true, raycaster.ray.direction);
	      var intersections = _Octree.RaycasterUtils.intersectOctreeObjects(raycaster, octreeObjects);
	
	      // check visible
	      for (var _iterator4 = intersections, _isArray4 = Array.isArray(_iterator4), _i4 = 0, _iterator4 = _isArray4 ? _iterator4 : _iterator4[Symbol.iterator]();;) {
	        var _ref4;
	
	        if (_isArray4) {
	          if (_i4 >= _iterator4.length) break;
	          _ref4 = _iterator4[_i4++];
	        } else {
	          _i4 = _iterator4.next();
	          if (_i4.done) break;
	          _ref4 = _i4.value;
	        }
	
	        var intersection = _ref4;
	
	        var parent = intersection.object;
	        var visible = parent.visible;
	
	        while (parent) {
	          visible = parent.visible;
	          if (!visible) {
	            break;
	          }
	          parent = parent.parent;
	        }
	
	        if (visible) {
	          ret.push(intersection);
	        }
	      }
	
	      return ret;
	    }
	  }]);
	
	  return OctreeManager;
	}();
	
	exports.default = OctreeManager;

/***/ }),
/* 198 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.OverlayNodeId = exports.OverlayNode = undefined;
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };
	
	var _three = __webpack_require__(2);
	
	var THREE = _interopRequireWildcard(_three);
	
	var _SceneNode2 = __webpack_require__(24);
	
	var _SceneNode3 = _interopRequireDefault(_SceneNode2);
	
	var _ThreeCamera = __webpack_require__(32);
	
	var _ThreeCamera2 = _interopRequireDefault(_ThreeCamera);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var OverlayNodeId = -2;
	
	var OverlayNode = function (_SceneNode) {
	  _inherits(OverlayNode, _SceneNode);
	
	  function OverlayNode(sceneId) {
	    _classCallCheck(this, OverlayNode);
	
	    var _this = _possibleConstructorReturn(this, (OverlayNode.__proto__ || Object.getPrototypeOf(OverlayNode)).call(this, sceneId));
	
	    _this._layerOverlay = {};
	    _this._overlays = {};
	    _this._domMapping = {};
	    _this._domScene = new THREE.Scene();
	
	    _this._addOverlay = _this._addOverlay.bind(_this);
	    _this._removeOverlay = _this._removeOverlay.bind(_this);
	    _this._reAttachOverlay = _this._reAttachOverlay.bind(_this);
	    _this._removeLayer = _this._removeLayer.bind(_this);
	    _this._onSceneChange = _this._onSceneChange.bind(_this);
	    _this._overlayValueChange = _this._overlayValueChange.bind(_this);
	    return _this;
	  }
	
	  _createClass(OverlayNode, [{
	    key: '_removeOverlay',
	    value: function _removeOverlay(mapView, layer, overlay) {
	      this.removeOverlay(layer, overlay);
	    }
	  }, {
	    key: '_reAttachOverlay',
	    value: function _reAttachOverlay(mapView, layer, overlay) {
	      this.reAttachOverlay(layer, overlay);
	    }
	  }, {
	    key: '_removeLayer',
	    value: function _removeLayer(mapView, layer) {
	      var overlays = this._layerOverlay[layer.id];
	
	      if (overlays) {
	        for (var _iterator = overlays, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
	          var _ref;
	
	          if (_isArray) {
	            if (_i >= _iterator.length) break;
	            _ref = _iterator[_i++];
	          } else {
	            _i = _iterator.next();
	            if (_i.done) break;
	            _ref = _i.value;
	          }
	
	          var id = _ref;
	
	          var overlay = this._overlays[id];
	
	          if (overlay) {
	            this.removeOverlay(layer, overlay);
	          }
	        }
	      }
	      delete this._layerOverlay[layer.id];
	    }
	  }, {
	    key: '_onSceneChange',
	    value: function _onSceneChange(type, layer, features) {
	      var overlays = this._layerOverlay[layer.id];
	
	      if (!overlays || features !== null) {
	        return;
	      }
	
	      switch (type) {
	        case 'visible':
	          {
	            for (var _iterator2 = overlays, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator]();;) {
	              var _ref2;
	
	              if (_isArray2) {
	                if (_i2 >= _iterator2.length) break;
	                _ref2 = _iterator2[_i2++];
	              } else {
	                _i2 = _iterator2.next();
	                if (_i2.done) break;
	                _ref2 = _i2.value;
	              }
	
	              var id = _ref2;
	
	              var overlay = this._overlays[id];
	              var visible = arguments.length <= 3 ? undefined : arguments[3];
	
	              if (overlay) {
	                if (visible === true) {
	                  overlay.targetDom.style.display = overlay._options.defaultDisplay;
	                } else if (visible === false) {
	                  overlay.targetDom.style.display = 'none';
	                }
	              }
	            }
	            break;
	          }
	        case 'position':
	          {
	            for (var _iterator3 = overlays, _isArray3 = Array.isArray(_iterator3), _i3 = 0, _iterator3 = _isArray3 ? _iterator3 : _iterator3[Symbol.iterator]();;) {
	              var _ref3;
	
	              if (_isArray3) {
	                if (_i3 >= _iterator3.length) break;
	                _ref3 = _iterator3[_i3++];
	              } else {
	                _i3 = _iterator3.next();
	                if (_i3.done) break;
	                _ref3 = _i3.value;
	              }
	
	              var _id = _ref3;
	
	              var css2dObj = this._domMapping[_id];
	
	              if (css2dObj) {
	                // console.log(css2dObj, value);
	                var position = arguments.length <= 3 ? undefined : arguments[3];
	
	                css2dObj.position.setZ(position[2]);
	              }
	            }
	            break;
	          }
	        default:
	          break;
	      }
	    }
	  }, {
	    key: '_overlayValueChange',
	    value: function _overlayValueChange(overlay, func, value) {
	      var obj = this._domMapping[overlay.id];
	
	      if (func === 'position') {
	        obj.position.setX(value.x);
	        obj.position.setY(value.y);
	        obj.position.setZ(value.z || obj.position.z);
	      }
	    }
	  }, {
	    key: '_addOverlay',
	    value: function _addOverlay(mapView, layer, overlay) {
	      if (overlay.id in this._domMapping) {
	        // add again
	        this.removeOverlay(overlay.layer, overlay);
	      }
	
	      var css2dObject = new THREE.CSS2DObject(overlay.targetDom);
	      var overlays = this._layerOverlay[layer.id];
	
	      if (!overlays) {
	        overlays = [];
	        this._layerOverlay[layer.id] = overlays;
	      }
	      overlays.push(overlay.id);
	      this._overlays[overlay.id] = overlay;
	      this._domMapping[overlay.id] = css2dObject;
	      this._domScene.add(css2dObject);
	      overlay.attach(layer);
	      overlay.on('valueChange', this._overlayValueChange);
	      if (overlay.position) {
	        this._overlayValueChange(overlay, 'position', overlay.position);
	      }
	    }
	  }, {
	    key: 'add',
	    value: function add(scene) {
	      if (scene instanceof _SceneNode3.default) {
	        _get(OverlayNode.prototype.__proto__ || Object.getPrototypeOf(OverlayNode.prototype), 'add', this).call(this, scene);
	      }
	      if (scene instanceof _ThreeCamera2.default) {
	        this._camera = scene.camera;
	      }
	    }
	  }, {
	    key: 'removeOverlay',
	    value: function removeOverlay(layer, overlay) {
	      if (overlay.id in this._domMapping) {
	        var css2dObject = this._domMapping[overlay.id];
	        var overlays = this._layerOverlay[layer.id];
	
	        this._domScene.remove(css2dObject);
	        delete this._domMapping[overlay.id];
	        delete this._overlays[overlay.id];
	        overlay.detach(layer);
	        if (overlays) {
	          var indexof = overlays.indexOf(overlay.id);
	
	          if (indexof !== -1) {
	            overlays.splice(indexof, 1);
	          }
	          if (overlays.length === 0) {
	            delete this._layerOverlay[layer.id];
	          }
	        }
	        overlay.off('valueChange', this._overlayValueChange);
	        // write back default display value
	        overlay.targetDom.style.display = overlay._options.defaultDisplay;
	      }
	    }
	  }, {
	    key: 'reAttachOverlay',
	    value: function reAttachOverlay(layer, overlay) {
	      if (!layer || !overlay) {
	        throw new Error('reAttachOverlay: Invalid parameter');
	      }
	
	      var lastLayer = overlay.layer;
	      var overlays = this._layerOverlay[lastLayer.id];
	
	      if (overlays) {
	        var index = overlays.indexOf(overlay.id);
	
	        if (index !== -1) {
	          var newOverlays = this._layerOverlay[layer.id];
	
	          if (!newOverlays) {
	            newOverlays = [];
	            this._layerOverlay[layer.id] = newOverlays;
	          }
	          overlays.splice(index, 1);
	          newOverlays.push(overlay.id);
	          overlay.detach(lastLayer);
	          overlay.attach(layer);
	        }
	      }
	    }
	  }, {
	    key: 'onAdd',
	    value: function onAdd(sceneManager) {
	      _get(OverlayNode.prototype.__proto__ || Object.getPrototypeOf(OverlayNode.prototype), 'onAdd', this).call(this, sceneManager);
	
	      this._domRenderer = sceneManager.mapView.engine.getDomRenderer(sceneManager.mapView);
	
	      this._sceneManager.mapView.on('addOverlay', this._addOverlay);
	      this._sceneManager.mapView.on('removeOverlay', this._removeOverlay);
	      this._sceneManager.mapView.on('reAttachOverlay', this._reAttachOverlay);
	      this._sceneManager.mapView.on('removeLayer', this._removeLayer);
	      this._sceneManager.on('onSceneChange', this._onSceneChange);
	    }
	  }, {
	    key: 'onRemove',
	    value: function onRemove(sceneManager) {
	      this._sceneManager.mapView.off('addOverlay', this._addOverlay);
	      this._sceneManager.mapView.off('removeOverlay', this._removeOverlay);
	      this._sceneManager.mapView.off('reAttachOverlay', this._reAttachOverlay);
	      this._sceneManager.mapView.off('removeLayer', this._removeLayer);
	      this._sceneManager.off('onSceneChange', this._onSceneChange);
	
	      _get(OverlayNode.prototype.__proto__ || Object.getPrototypeOf(OverlayNode.prototype), 'onRemove', this).call(this, sceneManager);
	    }
	  }, {
	    key: 'render',
	    value: function render() {
	      _get(OverlayNode.prototype.__proto__ || Object.getPrototypeOf(OverlayNode.prototype), 'render', this).call(this);
	      if (this._domRenderer && this._camera) {
	        this._domRenderer.render(this._domScene, this._camera);
	      }
	    }
	  }]);
	
	  return OverlayNode;
	}(_SceneNode3.default);
	
	exports.OverlayNode = OverlayNode;
	exports.OverlayNodeId = OverlayNodeId;

/***/ }),
/* 199 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.ParticleNodeId = exports.ParticleNode = undefined;
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };
	
	var _three = __webpack_require__(2);
	
	var THREE = _interopRequireWildcard(_three);
	
	var _SPE = __webpack_require__(108);
	
	var _SPE2 = _interopRequireDefault(_SPE);
	
	var _SceneNode2 = __webpack_require__(24);
	
	var _SceneNode3 = _interopRequireDefault(_SceneNode2);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var ParticleNodeId = -3;
	
	var ParticleNode = function (_SceneNode) {
	  _inherits(ParticleNode, _SceneNode);
	
	  function ParticleNode(sceneId) {
	    _classCallCheck(this, ParticleNode);
	
	    var _this = _possibleConstructorReturn(this, (ParticleNode.__proto__ || Object.getPrototypeOf(ParticleNode)).call(this, sceneId));
	
	    _this._particleGroup = new THREE.Group();
	    _this._group_group = {};
	    _this._clock = new THREE.Clock();
	
	    _this._valueChange = _this._valueChange.bind(_this);
	    _this._addParticle = _this._addParticle.bind(_this);
	    _this._removeParticle = _this._removeParticle.bind(_this);
	    _this._addParticleGroup = _this._addParticleGroup.bind(_this);
	    _this._removeParticleGroup = _this._removeParticleGroup.bind(_this);
	    return _this;
	  }
	
	  _createClass(ParticleNode, [{
	    key: '_valueChange',
	    value: function _valueChange(particle, type) {
	      var parent = particle.parent;
	      if (parent) {
	        var speGroup = self._group_group[parent.id];
	        if (!speGroup) {
	          return;
	        }
	        var indexOf = parent.getIndex(particle);
	        if (indexOf === -1) {
	          return;
	        }
	        var emitter = speGroup.emitters[indexOf];
	        if (!emitter) {
	          return;
	        }
	
	        for (var _len = arguments.length, value = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
	          value[_key - 2] = arguments[_key];
	        }
	
	        switch (type) {
	          case 'position':
	            {
	              emitter.position.value = emitter.position.value.set(value[0], value[1], value[2]);
	              break;
	            }
	          case 'particleCount':
	            {
	              emitter.particleCount = value[0];
	              break;
	            }
	          case 'colors':
	            {
	              var colors = [];
	              for (var _iterator = value, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
	                var _ref;
	
	                if (_isArray) {
	                  if (_i >= _iterator.length) break;
	                  _ref = _iterator[_i++];
	                } else {
	                  _i = _iterator.next();
	                  if (_i.done) break;
	                  _ref = _i.value;
	                }
	
	                var color = _ref;
	
	                colors[colors.length] = new THREE.Color(color[0], color[1], color[2]);
	              }
	              emitter.color.value = colors;
	              break;
	            }
	          default:
	            {
	              break;
	            }
	        }
	      }
	    }
	  }, {
	    key: '_addParticle',
	    value: function _addParticle(particleGroup, particle) {
	      var speGroup = this._group_group[particleGroup.id];
	
	      if (speGroup) {
	        this.addEmitterByParticle(particleGroup, speGroup, particle);
	      }
	    }
	  }, {
	    key: '_removeParticle',
	    value: function _removeParticle(particleGroup, particle) {
	      var speGroup = this._group_group[particleGroup.id];
	
	      if (speGroup) {
	        this.removeEmitterByParticle(particleGroup, speGroup, particle);
	      }
	    }
	  }, {
	    key: '_addParticleGroup',
	    value: function _addParticleGroup(particleGroup) {
	      var speGroup = self._group_group[particleGroup.id];
	
	      if (!speGroup) {
	        speGroup = new _SPE2.default.Group({
	          texture: {
	            value: THREE.ImageUtils.loadTexture(particleGroup.texture)
	          }
	        });
	        self._group_group[particleGroup.id] = speGroup;
	        particleGroup.forEach(function (particle) {
	          self.addEmitterByParticle(particleGroup, speGroup, particle);
	        });
	        particleGroup.on('addParticle', self._addParticle);
	        particleGroup.on('removeParticle', self._addParticle);
	        self._particleGroup.add(speGroup.mesh);
	      }
	    }
	  }, {
	    key: '_removeParticleGroup',
	    value: function _removeParticleGroup(particleGroup) {
	      var _this2 = this;
	
	      var speGroup = this._group_group[particleGroup.id];
	
	      if (speGroup) {
	        particleGroup.forEach(function (particle) {
	          _this2.removeEmitterByParticle(particleGroup, speGroup, particle);
	        });
	        this._particleGroup.remove(speGroup.mesh);
	        delete this._group_group[particleGroup.id];
	        particleGroup.off('addParticle', this._addParticle);
	        particleGroup.off('removeParticle', this._addParticle);
	      }
	    }
	  }, {
	    key: 'addEmitterByParticle',
	    value: function addEmitterByParticle(particleGroup, speGroup, particle) {
	      var colors = [];
	
	      for (var _iterator2 = particle.colors, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator]();;) {
	        var _ref2;
	
	        if (_isArray2) {
	          if (_i2 >= _iterator2.length) break;
	          _ref2 = _iterator2[_i2++];
	        } else {
	          _i2 = _iterator2.next();
	          if (_i2.done) break;
	          _ref2 = _i2.value;
	        }
	
	        var color = _ref2;
	
	        colors[colors.length] = new THREE.Color(color[0], color[1], color[2]);
	      }
	
	      var emitter = new _SPE2.default.Emitter({
	        type: 1,
	        maxAge: {
	          value: 1
	        },
	        size: {
	          value: 1
	        },
	        velocity: {
	          value: new THREE.Vector3(3, 3, 3),
	          distribution: _SPE2.default.distributions.DISC
	        },
	        position: {
	          value: new THREE.Vector3(particle.position.x, particle.position.y, particle.position.z || 0),
	          radius: 5,
	          spread: new THREE.Vector3(3, 3, 3)
	        },
	        color: {
	          value: colors
	        },
	        particleCount: particle.particleCount
	      });
	
	      speGroup.addEmitter(emitter);
	      particle.on('valueChange', this._valueChange);
	    }
	  }, {
	    key: 'removeEmitterByParticle',
	    value: function removeEmitterByParticle(particleGroup, speGroup, particle) {
	      var indexOf = particleGroup.getIndex(particle);
	
	      if (indexOf !== -1) {
	        speGroup.removeEmitter(speGroup.emitters[indexOf]);
	        particle.off('valueChange', this._valueChange);
	      }
	    }
	  }, {
	    key: 'onAdd',
	    value: function onAdd(sceneManager) {
	      _get(ParticleNode.prototype.__proto__ || Object.getPrototypeOf(ParticleNode.prototype), 'onAdd', this).call(this, sceneManager);
	
	      var threeNode = sceneManager.get(-1);
	
	      threeNode.renderScene.add(this._particleGroup);
	      if (sceneManager.mapView && sceneManager.mapView.particleEngine) {
	        sceneManager.mapView.particleEngine.on('addParticleGroup', this._addParticleGroup);
	      }
	    }
	  }, {
	    key: 'onRemove',
	    value: function onRemove(sceneManager) {
	      if (sceneManager.mapView && sceneManager.mapView.particleEngine) {
	        sceneManager.mapView.particleEngine.off('addParticleGroup', this._addParticleGroup);
	      }
	
	      var threeNode = sceneManager.get(-1);
	
	      threeNode.renderScene.remove(this._particleGroup);
	      _get(ParticleNode.prototype.__proto__ || Object.getPrototypeOf(ParticleNode.prototype), 'onRemove', this).call(this, sceneManager);
	    }
	  }, {
	    key: 'render',
	    value: function render() {
	      _get(ParticleNode.prototype.__proto__ || Object.getPrototypeOf(ParticleNode.prototype), 'render', this).call(this);
	      if (this._group_group) {
	        for (var id in this._group_group) {
	          this._group_group[id].tick(this._clock.getDelta());
	        }
	      }
	    }
	  }, {
	    key: 'particleGroup',
	    get: function get() {
	      return this._particleGroup;
	    }
	  }]);
	
	  return ParticleNode;
	}(_SceneNode3.default);
	
	exports.ParticleNode = ParticleNode;
	exports.ParticleNodeId = ParticleNodeId;

/***/ }),
/* 200 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.SceneAnimationManager = undefined;
	
	var _assign = __webpack_require__(1);
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _AnimatorFactory = __webpack_require__(9);
	
	var _AnimatorFactory2 = _interopRequireDefault(_AnimatorFactory);
	
	var _three = __webpack_require__(2);
	
	var THREE = _interopRequireWildcard(_three);
	
	var _lang = __webpack_require__(4);
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function isNumber(number) {
	  return !isNaN(number) && isFinite(number);
	}
	
	function isValidNumber(number) {
	  return isNumber(number) && number >= 0;
	}
	
	var SceneAnimation = function () {
	  function SceneAnimation() {
	    _classCallCheck(this, SceneAnimation);
	
	    this._animator = null;
	  }
	
	  _createClass(SceneAnimation, [{
	    key: 'hasAnimation',
	    value: function hasAnimation(scene) {
	      // eslint-disable-line no-unused-vars
	      return false;
	    }
	  }, {
	    key: 'isValidParams',
	    value: function isValidParams(params) {
	      // eslint-disable-line no-unused-vars
	      return false;
	    }
	  }, {
	    key: 'setParams',
	    value: function setParams(scene, params) {
	      // eslint-disable-line no-unused-vars
	      return null;
	    }
	  }, {
	    key: 'getParams',
	    value: function getParams(scene) {
	      // eslint-disable-line no-unused-vars
	      return null;
	    }
	  }, {
	    key: 'parseParams',
	    value: function parseParams(params) {
	      return params;
	    }
	  }, {
	    key: 'start',
	    value: function start(scene, destParam) {
	      var blink = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
	
	      var _this = this;
	
	      var duration = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 300;
	      var repeat = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;
	
	      var startParam = this.getParams(scene);
	      var _startParam = _assign({}, startParam);
	      var _destParam = this.parseParams(destParam);
	      var _duration = isValidNumber(duration) ? duration : 300;
	      var _repeat = isValidNumber(repeat) ? repeat : 0;
	
	      if (!this.hasAnimation(scene) || !this.isValidParams(startParam) || !this.isValidParams(_destParam)) {
	        console.warn('SceneAnimation: Invalid parameter.');
	        return null;
	      }
	
	      var onUpdate = function onUpdate(animator, target) {
	        _this.setParams(scene, target);
	      };
	
	      this.stop();
	
	      this.animator = _AnimatorFactory2.default.getInstance().ofObject(_startParam, _destParam, _duration).on('update', onUpdate).on('complete', function (animator) {
	        // animator.stop();
	        if (blink) {
	          _AnimatorFactory2.default.getInstance().ofObject(_destParam, startParam, _duration).on('update', onUpdate).on('complete', function (animator) {
	            animator.stop();
	          }).start();
	        } else {
	          animator.stop();
	        }
	      }).repeat(_repeat).start();
	
	      return this;
	    }
	  }, {
	    key: 'stop',
	    value: function stop() {
	      if (this.animator && this.animator.stop) {
	        this.animator.stop();
	      }
	    }
	  }]);
	
	  return SceneAnimation;
	}();
	
	var OpacityAnimation = function (_SceneAnimation) {
	  _inherits(OpacityAnimation, _SceneAnimation);
	
	  function OpacityAnimation() {
	    _classCallCheck(this, OpacityAnimation);
	
	    return _possibleConstructorReturn(this, (OpacityAnimation.__proto__ || Object.getPrototypeOf(OpacityAnimation)).apply(this, arguments));
	  }
	
	  _createClass(OpacityAnimation, [{
	    key: 'hasAnimation',
	    value: function hasAnimation(scene) {
	      return scene && scene.material && (0, _lang.isPresent)(scene.material.opacity);
	    }
	  }, {
	    key: 'isValidParams',
	    value: function isValidParams(params) {
	      return params && params.num && isValidNumber(params.num) && params.num <= 1;
	    }
	  }, {
	    key: 'setParams',
	    value: function setParams(scene, params) {
	      if (this.hasAnimation(scene) && this.isValidParams(params)) {
	        scene.material.opacity = params.num;
	        if (params.num >= 1) {
	          scene.material.transparent = false;
	        }
	        return true;
	      }
	      return false;
	    }
	  }, {
	    key: 'getParams',
	    value: function getParams(scene) {
	      if (this.hasAnimation(scene)) {
	        return { num: scene.material.opacity };
	      }
	      return null;
	    }
	  }, {
	    key: 'parseParams',
	    value: function parseParams(params) {
	      return params && params.num ? params : { num: params };
	    }
	  }]);
	
	  return OpacityAnimation;
	}(SceneAnimation);
	
	var ColorAnimation = function (_SceneAnimation2) {
	  _inherits(ColorAnimation, _SceneAnimation2);
	
	  function ColorAnimation() {
	    _classCallCheck(this, ColorAnimation);
	
	    return _possibleConstructorReturn(this, (ColorAnimation.__proto__ || Object.getPrototypeOf(ColorAnimation)).apply(this, arguments));
	  }
	
	  _createClass(ColorAnimation, [{
	    key: 'hasAnimation',
	    value: function hasAnimation(scene) {
	      return scene && scene.material && (0, _lang.isPresent)(scene.material.color);
	    }
	  }, {
	    key: '_isValidColorCom',
	    value: function _isValidColorCom(com) {
	      return isValidNumber(com) && com <= 1;
	    }
	  }, {
	    key: 'isValidParams',
	    value: function isValidParams(params) {
	      return params && this._isValidColorCom(params.r) && this._isValidColorCom(params.g) && this._isValidColorCom(params.b);
	    }
	  }, {
	    key: 'setParams',
	    value: function setParams(scene, params) {
	      if (this.hasAnimation(scene) && this.isValidParams(params)) {
	        scene.material.color.setRGB(params.r, params.g, params.b);
	        return true;
	      }
	      return false;
	    }
	  }, {
	    key: 'getParams',
	    value: function getParams(scene) {
	      if (this.hasAnimation(scene)) {
	        var color = scene.material.color;
	
	        return {
	          r: color.r,
	          g: color.g,
	          b: color.b
	        };
	      }
	      return null;
	    }
	  }, {
	    key: 'parseParams',
	    value: function parseParams(params) {
	      if (params && params.r && params.g && params.b) {
	        return params;
	      }
	      var color = new THREE.Color().set(params);
	
	      return {
	        r: color.r,
	        g: color.g,
	        b: color.b
	      };
	    }
	  }]);
	
	  return ColorAnimation;
	}(SceneAnimation);
	
	var PositionAnimation = function (_SceneAnimation3) {
	  _inherits(PositionAnimation, _SceneAnimation3);
	
	  function PositionAnimation() {
	    _classCallCheck(this, PositionAnimation);
	
	    return _possibleConstructorReturn(this, (PositionAnimation.__proto__ || Object.getPrototypeOf(PositionAnimation)).apply(this, arguments));
	  }
	
	  _createClass(PositionAnimation, [{
	    key: 'hasAnimation',
	    value: function hasAnimation(scene) {
	      return scene && scene.position;
	    }
	  }, {
	    key: 'isValidParams',
	    value: function isValidParams(params) {
	      return params && isNumber(params.x) && isNumber(params.y) && isNumber(params.z);
	    }
	  }, {
	    key: 'setParams',
	    value: function setParams(scene, params) {
	      if (this.hasAnimation(scene) && this.isValidParams(params)) {
	        scene.position.set(params.x, params.y, params.z);
	        return true;
	      }
	      return false;
	    }
	  }, {
	    key: 'getParams',
	    value: function getParams(scene) {
	      if (this.hasAnimation(scene)) {
	        var position = scene.position;
	
	        return {
	          x: position.x,
	          y: position.y,
	          z: position.z
	        };
	      }
	      return null;
	    }
	  }]);
	
	  return PositionAnimation;
	}(SceneAnimation);
	
	var SceneAnimationManager = function () {
	  function SceneAnimationManager() {
	    _classCallCheck(this, SceneAnimationManager);
	
	    this._animationList = {
	      opacity: new OpacityAnimation(),
	      color: new ColorAnimation(),
	      position: new PositionAnimation()
	    };
	  }
	
	  _createClass(SceneAnimationManager, [{
	    key: 'setAnimation',
	    value: function setAnimation(key, animation) {
	      if (key && animation instanceof SceneAnimation) {
	        this._animationList[key] = animation;
	        return true;
	      }
	      return false;
	    }
	  }, {
	    key: 'getAnimation',
	    value: function getAnimation(key) {
	      return this._animationList[key];
	    }
	  }, {
	    key: 'removeAnimation',
	    value: function removeAnimation(key) {
	      if (this._animationList[key]) {
	        delete this._animationList[key];
	        return true;
	      }
	      return false;
	    }
	  }]);
	
	  return SceneAnimationManager;
	}();
	
	exports.SceneAnimationManager = SceneAnimationManager;

/***/ }),
/* 201 */
/***/ (function(module, exports) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var SceneGenerator = function () {
	  function SceneGenerator() {
	    _classCallCheck(this, SceneGenerator);
	  }
	
	  _createClass(SceneGenerator, [{
	    key: "generator",
	    value: function generator(layer, mapView) {
	      // eslint-disable-line no-unused-vars
	      return null;
	    }
	  }, {
	    key: "find",
	    value: function find(layer) {
	      // eslint-disable-line no-unused-vars
	      return null;
	    }
	  }]);
	
	  return SceneGenerator;
	}();
	
	exports.default = SceneGenerator;

/***/ }),
/* 202 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };
	
	var _SceneNode2 = __webpack_require__(24);
	
	var _SceneNode3 = _interopRequireDefault(_SceneNode2);
	
	var _OctreeManager = __webpack_require__(197);
	
	var _OctreeManager2 = _interopRequireDefault(_OctreeManager);
	
	var _lang = __webpack_require__(4);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	function toArray(target) {
	  return [].concat((0, _lang.isNumber)(target) || (0, _lang.isArray)(target) ? target : []);
	}
	
	/**
	 * 一个渲染场景节点管理类，可用于增减渲染场景，查找渲染场景，调整渲染场景的显示效果等。
	 * @extends {SceneNode}
	 */
	
	var SceneManager = function (_SceneNode) {
	  _inherits(SceneManager, _SceneNode);
	
	  /**
	   * 创造一个渲染场景节点管理类，需要提供一个应用该管理类的MapView进行绑定。
	   * @param  {NGR.view.MapView} mapView 绑定的MapView对象。
	   */
	  function SceneManager(mapView) {
	    _classCallCheck(this, SceneManager);
	
	    var _this = _possibleConstructorReturn(this, (SceneManager.__proto__ || Object.getPrototypeOf(SceneManager)).call(this, 0));
	
	    _this.onAdd(_this);
	    _this._mapView = mapView;
	    _this._allScene = {};
	    _this._octreeManager = new _OctreeManager2.default();
	    return _this;
	  }
	
	  /**
	   * 获取绑定的{@link MapView}
	   * @ignore
	   * @type {NGR.view.MapView}
	   * @return {NGR.view.MapView} MapView.
	   */
	
	
	  _createClass(SceneManager, [{
	    key: 'clearOctree',
	
	
	    /**
	     * 清空八叉树。
	     * @ignore
	     * @return {undefined}
	     */
	    value: function clearOctree() {
	      this._octreeManager.clearOctree();
	    }
	
	    /**
	     * Search objects in octree by client coordinate.
	     * @private
	     * @param {Number} x   X.
	     * @param {Number} y   Y.
	     * @return {Object[]}  Search result.
	     */
	
	  }, {
	    key: '_searchObjectsInOctree',
	    value: function _searchObjectsInOctree(x, y) {
	      var camera = this._mapView.activeCamera.camera;
	
	      return this._octreeManager.searchByClientPoint(x, y, camera);
	    }
	
	    /**
	     * Render scene nodes of this manager and update octree.
	     * @ignore
	     * @override
	     * @return {undefined}
	     */
	
	  }, {
	    key: 'render',
	    value: function render() {
	      _get(SceneManager.prototype.__proto__ || Object.getPrototypeOf(SceneManager.prototype), 'render', this).call(this);
	      this._octreeManager.update();
	    }
	
	    /**
	     * 添加一个渲染场景节点到场景节点管理器中。
	     * @param  {Scene} scene  需要添加的渲染场景节点。
	     * @return {SceneManager} this。
	     */
	
	  }, {
	    key: 'addScene',
	    value: function addScene(scene) {
	      if (scene.id && !this.hasScene(scene)) {
	        this._allScene[scene.id] = scene;
	        scene.onAdd(this);
	      }
	
	      return this;
	    }
	
	    /**
	     * 根据指定的参数查找符合条件的渲染场景集合，并且修改它们缩放的大小。
	     * @param  {Layer}  layer 需要修改数据的图层。
	     * @param  {String} key   查找条件的字段。
	     * @param  {Object} value 字段的值。
	     * @param  {Number} x     缩放的方向，x轴坐标。
	     * @param  {Number} y     缩放的方向，y轴坐标。
	     * @param  {Number} z     缩放的方向，z轴坐标。
	     * @return {SceneManager} this。
	     */
	
	  }, {
	    key: 'setScale',
	    value: function setScale(layer, key, value, x, y, z) {
	      var features = this._search(layer, key, value);
	
	      this.emit('onSceneChange', 'scale', layer, features, [x, y, z]);
	
	      return this;
	    }
	
	    /**
	     * 根据指定的参数查找符合条件的渲染场景集合，并且修改它们的位置。
	     * @param  {Layer}   layer  需要修改数据的图层。
	     * @param  {String}  key   查找条件的字段。
	     * @param  {Object}  value 字段的值。
	     * @param  {Number}  x      x轴坐标值。
	     * @param  {Number}  y      y轴坐标值。
	     * @param  {Number}  z      z轴坐标值。
	     * @return {SceneManager}   this。
	     */
	
	  }, {
	    key: 'setPosition',
	    value: function setPosition(layer, key, value, x, y, z) {
	      var features = this._search(layer, key, value);
	      var tempX = x;
	      var tempY = y;
	
	      if (layer.coordinateSystem) {
	        var offset = layer.coordinateSystem.getOffset();
	
	        tempX = x + offset[0];
	        tempY = y + offset[1];
	      }
	      this.emit('onSceneChange', 'position', layer, features, [tempX, tempY, z]);
	
	      return this;
	    }
	
	    /**
	     * 根据指定的参数查找符合条件的渲染场景集合，并且修改它们的位置。此方法不
	     * 会更新八叉树，适用于上层动画。
	     * @ignore
	     * @param  {Layer}   layer  需要修改数据的图层。
	     * @param  {String}  key    匹配的键。
	     * @param  {Object}  value  匹配的值。
	     * @param  {Number}  x      x。
	     * @param  {Number}  y      y。
	     * @param  {Number}  z      z。
	     * @return {SceneManager}   this。
	     */
	
	  }, {
	    key: 'quickSetPosition',
	    value: function quickSetPosition(layer, key, value, x, y, z) {
	      var features = this._search(layer, key, value);
	      var tempX = x;
	      var tempY = y;
	
	      if (layer.coordinateSystem) {
	        var offset = layer.coordinateSystem.offset(x, y);
	
	        tempX = offset[0];
	        tempY = offset[1];
	      }
	      this.emit('onSceneChange', 'quickPosition', layer, features, [tempX, tempY, z]);
	
	      return this;
	    }
	
	    /**
	     * 根据指定的参数查找符合条件的渲染场景集合，并且修改它们的角度。
	     * @param  {Layer}  layer 需要修改数据的图层。
	     * @param  {String} key   查找条件的字段。
	     * @param  {Object} value 字段的值。
	     * @param  {Number} x     x轴坐标值。
	     * @param  {Number} y     y轴坐标值。
	     * @param  {Number} z     z轴坐标值。
	     * @return {SceneManager} this。
	     */
	
	  }, {
	    key: 'setRotation',
	    value: function setRotation(layer, key, value, x, y, z) {
	      var features = this._search(layer, key, value);
	
	      this.emit('onSceneChange', 'rotation', layer, features, [x, y, z]);
	
	      return this;
	    }
	
	    /**
	     * 根据指定的参数查找符合条件的渲染场景场景集合，并且设置它们是否可见。
	     * @param  {Layer}   layer   需要修改数据的图层。
	     * @param  {String}  key   查找条件的字段。
	     * @param  {Object}  value 字段的值。
	     * @param  {Boolean} visible 是否显示，true为可见，false为不可见。
	     * @return {SceneManager}    this。
	     */
	
	  }, {
	    key: 'setVisible',
	    value: function setVisible(layer, key, value, visible) {
	      var features = this._search(layer, key, value);
	
	      this.emit('onSceneChange', 'visible', layer, features, visible);
	
	      return this;
	    }
	
	    /**
	     * 根据指定的参数查找符合条件的渲染场景集合，并且修改它们的高亮颜色。
	     * @param  {Layer|String}  layer   需要修改数据的图层。
	     * @param  {String}          key   查找条件的字段。
	     * @param  {Object}          value 字段的值。
	     * @param  {Number|String} scalar  高亮颜色(16进制码的字符串)。
	     * @return {SceneManager}          this。
	     */
	
	  }, {
	    key: 'highlight',
	    value: function highlight(layer, key, value) {
	      var scalar = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1.414;
	
	      var features = this._search(layer, key, value);
	
	      this.emit('onSceneChange', 'highlight', layer, features, scalar);
	
	      return this;
	    }
	
	    /**
	     * 根据指定的参数查找符合条件的渲染场景集合，并且修改它们的颜色。
	     * @param  {Layer|String}  layer      需要修改数据的图层。
	     * @param  {String}        key   查找条件的字段。
	     * @param  {Object}        value 字段的值。
	     * @param  {Number|String} color      颜色。
	     * @param  {Object}        [aOptions] 动画参数，如持续时间（单位毫秒）、是否重复等。
	     * @return {SceneManager}             this。
	     */
	
	  }, {
	    key: 'setColor',
	    value: function setColor(layer, key, value, color, aOptions) {
	      var features = this._search(layer, key, value);
	
	      this.emit('onSceneChange', 'color', layer, features, color, aOptions);
	
	      return this;
	    }
	
	    /**
	     * 重设管理器中符合条件的渲染场景的样式。
	     * @param  {Layer|String}    layer    需要修改数据的图层。
	     * @param  {String}          key   查找条件的字段。
	     * @param  {Object}          value 字段的值。
	     * @param  {NGR.style.Style} newStyle 新的样式。
	     * @return {SceneManager}             this。
	     */
	
	  }, {
	    key: 'resetStyle',
	    value: function resetStyle(layer, key, value, newStyle) {
	      var features = this._search(layer, key, value);
	
	      this.emit('onSceneChange', 'styleResetting', layer, features, newStyle);
	
	      return this;
	    }
	
	    /**
	     * 批量设置Feature。
	     * @ignore
	     * @param {string}                              method   修改方法
	     * @param {Layer|String}                        layer    修改哪个层中的数据。
	     * @param {NGR.data.Feature|NGR.data.Feature[]} features 待修改的Feature。
	     * @param {...Object}                           values   修改值。
	     * @return {SceneManager}                                this。
	     */
	
	  }, {
	    key: 'setValueChangeByFeatures',
	    value: function setValueChangeByFeatures(method, layer, features) {
	      for (var _len = arguments.length, values = Array(_len > 3 ? _len - 3 : 0), _key = 3; _key < _len; _key++) {
	        values[_key - 3] = arguments[_key];
	      }
	
	      this.emit.apply(this, ['onSceneChange', method, layer, features].concat(values));
	
	      return this;
	    }
	
	    /**
	     * 根据指定的参数查找符合条件的渲染场景集合，并且重置颜色。
	     * @param  {Layer|String} layer 需要修改数据的图层。
	     * @param  {String}       key   查找条件的字段。
	     * @param  {Object}       value 字段的值。
	     * @return {SceneManager}       this。
	     */
	
	  }, {
	    key: 'resetColor',
	    value: function resetColor(layer, key, value) {
	      var features = this._search(layer, key, value);
	
	      this.emit('onSceneChange', 'colorResetting', layer, features);
	
	      return this;
	    }
	
	    /**
	     * 根据指定的参数查找符合条件的渲染场景集合，并且修改它们的透明度。
	     * @param  {Layer|String}  layer      需要修改数据的图层。
	     * @param  {String}        key   查找条件的字段。
	     * @param  {Object}        value 字段的值。
	     * @param  {Number|String} opacity    透明度。
	     * @param  {Object}        [aOptions] 动画参数，如持续时间（单位毫秒）、是否重复等。
	     * @return {SceneManager}             this。
	     */
	
	  }, {
	    key: 'setOpacity',
	    value: function setOpacity(layer, key, value, opacity, aOptions) {
	      var features = this._search(layer, key, value);
	
	      this.emit('onSceneChange', 'opacity', layer, features, opacity, aOptions);
	
	      return this;
	    }
	  }, {
	    key: 'setDepthTest',
	    value: function setDepthTest(layer, key, value, depthTest) {
	      if (!(0, _lang.isBoolean)(depthTest)) {
	        throw new Error('Unsupported depthTest type');
	      }
	
	      var features = this._search(layer, key, value);
	
	      this.emit('onSceneChange', 'depthTest', layer, features, depthTest);
	    }
	  }, {
	    key: 'getAABB',
	    value: function getAABB(layer, key, value, outBox) {
	      if ((0, _lang.isArray)(outBox)) {
	        throw new Error('SceneManager#getAABB: Invalid outBox');
	      }
	
	      var features = this._search(layer, key, value);
	      var feature = void 0;
	
	      if ((0, _lang.isArray)(features)) {
	        feature = features[0];
	        console.warn('SceneManager#getAABB: Get the first feature of several features');
	      } else {
	        feature = features;
	      }
	
	      if (!feature) {
	        throw new Error('SceneManager#getAABB: Feature not found');
	      }
	
	      outBox.length = 0;
	
	      this.emit('onGetAABB', layer, feature, outBox);
	
	      return this;
	    }
	
	    /**
	     * 从场景管理器中删除一个渲染场景节点。
	     * @param  {Scene} scene  需要删除的场景节点。
	     * @return {SceneManager} this。
	     */
	
	  }, {
	    key: 'removeScene',
	    value: function removeScene(scene) {
	      if (scene.id && this.hasScene(scene)) {
	        delete this._allScene[scene.id];
	        scene.onRemove(this);
	      }
	
	      return this;
	    }
	
	    /**
	     * 判断一个渲染场景节点是否在场景管理器中。
	     * @param  {Scene}  scene 需要判断的场景节点。
	     * @return {Boolean}      存在返回true，否则返回false。
	     */
	
	  }, {
	    key: 'hasScene',
	    value: function hasScene(scene) {
	      return !!scene && (scene in this._allScene || scene.id in this._allScene);
	    }
	
	    /**
	     * 销毁一个场景管理器。
	     * @return {undefined}
	     */
	
	  }, {
	    key: 'destroy',
	    value: function destroy() {
	      for (var sceneId in this._allScene) {
	        this.removeScene(this._allScene[sceneId]);
	      }
	      this._mapView = null;
	    }
	
	    /**
	     * Search feature by layer, key and value.
	     * @private
	     * @param  {Layer}  layer Layer.
	     * @param  {String}           key   Key.
	     * @param  {Object}           value Value.
	     * @return {Array}                  Features array.
	     */
	
	  }, {
	    key: '_search',
	    value: function _search(layer, key, value) {
	      if (!key && !value) {
	        return null;
	      }
	
	      var valueList = toArray(value);
	      var features = [];
	      var tempLayer = layer;
	
	      if (typeof layer === 'string') {
	        tempLayer = this._mapView.getLayer(layer);
	      }
	      if (tempLayer) {
	        if (key === 'id') {
	          for (var _iterator = valueList, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
	            var _ref;
	
	            if (_isArray) {
	              if (_i >= _iterator.length) break;
	              _ref = _iterator[_i++];
	            } else {
	              _i = _iterator.next();
	              if (_i.done) break;
	              _ref = _i.value;
	            }
	
	            var _value = _ref;
	
	            features.push(tempLayer.searchById(_value));
	          }
	          // for compability
	          if (features.length === 1) {
	            features = features.pop();
	          }
	        } else {
	          for (var _iterator2 = valueList, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator]();;) {
	            var _ref2;
	
	            if (_isArray2) {
	              if (_i2 >= _iterator2.length) break;
	              _ref2 = _iterator2[_i2++];
	            } else {
	              _i2 = _iterator2.next();
	              if (_i2.done) break;
	              _ref2 = _i2.value;
	            }
	
	            var _value2 = _ref2;
	
	            features = features.concat(tempLayer.search(key, _value2));
	          }
	        }
	      }
	      return features;
	    }
	  }, {
	    key: 'mapView',
	    get: function get() {
	      return this._mapView;
	    }
	  }]);
	
	  return SceneManager;
	}(_SceneNode3.default);
	
	exports.default = SceneManager;

/***/ }),
/* 203 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _MergeNode2 = __webpack_require__(196);
	
	var _MergeNode3 = _interopRequireDefault(_MergeNode2);
	
	var _three = __webpack_require__(2);
	
	var THREE = _interopRequireWildcard(_three);
	
	var _Style = __webpack_require__(14);
	
	var _Style2 = _interopRequireDefault(_Style);
	
	var _StyleUtil = __webpack_require__(19);
	
	var _StyleUtil2 = _interopRequireDefault(_StyleUtil);
	
	var _lang = __webpack_require__(4);
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var MergeLeaf = function () {
	  function MergeLeaf(container) {
	    _classCallCheck(this, MergeLeaf);
	
	    this._container = container;
	  }
	
	  _createClass(MergeLeaf, [{
	    key: 'reset',
	    value: function reset() {
	      this._range = {};
	      this._rangeIndex = [];
	      this._rangeLength = 0;
	    }
	  }, {
	    key: 'merge',
	    value: function merge(id, scene) {// eslint-disable-line no-unused-vars
	    }
	  }, {
	    key: 'update',
	    value: function update() {}
	  }, {
	    key: 'remove',
	    value: function remove(id) {// eslint-disable-line no-unused-vars
	    }
	  }, {
	    key: 'has',
	    value: function has(id) {
	      return id in this._range;
	    }
	  }, {
	    key: 'type',
	    value: function type() {
	      return null;
	    }
	  }, {
	    key: 'clear',
	    value: function clear() {
	      this.reset();
	    }
	  }]);
	
	  return MergeLeaf;
	}();
	
	var MergeLeafLine = function (_MergeLeaf) {
	  _inherits(MergeLeafLine, _MergeLeaf);
	
	  function MergeLeafLine() {
	    _classCallCheck(this, MergeLeafLine);
	
	    return _possibleConstructorReturn(this, (MergeLeafLine.__proto__ || Object.getPrototypeOf(MergeLeafLine)).apply(this, arguments));
	  }
	
	  _createClass(MergeLeafLine, [{
	    key: 'reset',
	    value: function reset() {
	      _get(MergeLeafLine.prototype.__proto__ || Object.getPrototypeOf(MergeLeafLine.prototype), 'reset', this).call(this);
	      if (this._lineGeoBuffer) {
	        this._lineGeoBuffer.dispose();
	      }
	      this._lineGeoBuffer = new THREE.BufferGeometry();
	      this._lineIndex = [];
	      // this._lineList = {};
	      this._linePosition = [];
	      this._lineColor = [];
	      this._lineMesh = new THREE.LineSegments(this._lineGeoBuffer, new THREE.LineBasicMaterial({ vertexColors: THREE.VertexColors }));
	      this._lineMesh.material.transparent = true;
	      if (this.blending) {
	        this._lineMesh.material.blending = THREE.CustomBlending;
	        this._lineMesh.material.blendEquation = THREE.MinEquation;
	      }
	      // this._lineMesh.material.blendEquationAlpha = 0.5;
	      // this._lineMesh.material.blendSrc = THREE.SrcAlphaFactor;
	      // this._lineMesh.material.blendSrcAlpha = 0.5;
	      // this._lineMesh.material.blendDst = THREE.SrcColorFactor;
	      // this._lineMesh.material.blendDstAlpha = 0.5;
	    }
	  }, {
	    key: 'clear',
	    value: function clear() {
	      this._container.remove(this._lineMesh);
	      _get(MergeLeafLine.prototype.__proto__ || Object.getPrototypeOf(MergeLeafLine.prototype), 'clear', this).call(this);
	    }
	  }, {
	    key: 'setValue',
	    value: function setValue(id, method) {
	      switch (method) {
	        case 'color':
	          {
	            break;
	          }
	        case 'opacity':
	          {
	            if (id === 0) {
	              this._lineMesh.material.opacity = arguments.length <= 2 ? undefined : arguments[2];
	              this._lineMesh.material.blending = THREE.NormalBlending;
	              if ((arguments.length <= 2 ? undefined : arguments[2]) === 1) {
	                this._lineMesh.material.transparent = true;
	                if (this.blending) {
	                  this._lineMesh.material.blending = THREE.CustomBlending;
	                  this._lineMesh.material.blendEquation = THREE.MinEquation;
	                }
	              }
	              break;
	            }
	            break;
	          }
	        case 'colorResetting':
	          {
	            break;
	          }
	        default:
	          break;
	      }
	    }
	  }, {
	    key: 'merge',
	    value: function merge(id, scene) {
	      var color = scene.material.color;
	      var vertices = scene.geometry.vertices;
	
	      if (vertices.length === 0) {
	        return null;
	      }
	
	      var lineRange = this._range[id];
	
	      if (lineRange) {
	        this.remove(id);
	      }
	      lineRange = [];
	      this._range[id] = lineRange;
	      this._rangeIndex.push(id);
	      lineRange.push(this._linePosition.length);
	      lineRange.push(this._lineIndex.length);
	
	      for (var index in vertices) {
	        if (index > 0) {
	          this._lineIndex.push(this._rangeLength - 1, this._rangeLength);
	          // const tempPrev = vertices[index - 1];
	          // const precision = 4;
	          // const lineId = tempPrev.x.toFixed(precision).toString() + ' ' + tempPrev.y.toFixed(precision).toString() + ' ' + tempPrev.z.toFixed(precision).toString() + ' ' + temp.x.toFixed(precision).toString() + ' ' + temp.y.toFixed(precision).toString() + ' ' + temp.z.toFixed(precision).toString();
	          // const lineId2 = temp.x.toFixed(precision).toString() + ' ' + temp.y.toFixed(precision).toString() + ' ' + temp.z.toFixed(precision).toString() + ' ' + tempPrev.x.toFixed(precision).toString() + ' ' + tempPrev.y.toFixed(precision).toString() + ' ' + tempPrev.z.toFixed(precision).toString();
	          // if ((this._lineList[lineId] === undefined) && (this._lineList[lineId2] === undefined)) {
	          //   this._lineList[lineId] = 1;
	          //   this._lineList[lineId2] = 1;
	          //   this._lineIndex.push(this._rangeLength - 1, this._rangeLength);
	          // } else {
	          //   console.log('tmd');
	          // }
	        }
	
	        var temp = vertices[index];
	
	        this._linePosition[this._rangeLength * 3] = temp.x;
	        this._linePosition[this._rangeLength * 3 + 1] = temp.y;
	        this._linePosition[this._rangeLength * 3 + 2] = temp.z;
	
	        this._lineColor[this._rangeLength * 3] = color.r;
	        this._lineColor[this._rangeLength * 3 + 1] = color.g;
	        this._lineColor[this._rangeLength * 3 + 2] = color.b;
	
	        this._rangeLength++;
	      }
	      lineRange.push(this._linePosition.length);
	      lineRange.push(this._lineIndex.length);
	
	      scene.geometry.dispose();
	      return this._lineMesh;
	    }
	  }, {
	    key: 'update',
	    value: function update() {
	      this._resetLineBuffer();
	    }
	  }, {
	    key: 'remove',
	    value: function remove(id) {
	      var lineRange = this._range[id];
	
	      if (lineRange) {
	        return;
	      }
	
	      var pMin = lineRange[0];
	      var pMax = lineRange[2];
	      var iMin = lineRange[1];
	      var iMax = lineRange[3];
	      var indexCount = iMax - iMin;
	      var positionCount = pMax - pMin;
	      var count = positionCount / 3;
	
	      this._rangeLength -= count;
	      this._linePosition.splice(pMin, pMax - pMin);
	      this._lineColor.splice(pMin, pMax - pMin);
	      this._lineIndex.splice(iMin, iMax - iMin);
	
	      for (var i = iMin; i < this._lineIndex.length; i++) {
	        this._lineIndex[i] -= count;
	      }
	
	      var indexOf = this._rangeIndex.indexOf(id);
	
	      if (indexOf !== -1) {
	        for (var _i = indexOf + 1; _i < this._rangeIndex.length; _i++) {
	          var range = this._range[this._rangeIndex[_i]];
	
	          if (range) {
	            range[0] -= positionCount;
	            range[2] -= positionCount;
	            range[1] -= indexCount;
	            range[3] -= indexCount;
	          }
	        }
	        this._rangeIndex.splice(indexOf, 1);
	      }
	
	      // this._resetLineBuffer();
	      delete this._range[id];
	    }
	  }, {
	    key: 'type',
	    value: function type() {
	      return 'line';
	    }
	  }, {
	    key: '_resetLineBuffer',
	    value: function _resetLineBuffer() {
	      this._lineGeoBuffer.setIndex(new THREE.BufferAttribute(new Uint16Array(this._lineIndex), 1));
	      this._lineGeoBuffer.addAttribute('position', new THREE.BufferAttribute(new Float32Array(this._linePosition), 3));
	      this._lineGeoBuffer.addAttribute('color', new THREE.BufferAttribute(new Float32Array(this._lineColor), 3));
	      this._lineGeoBuffer.computeBoundingSphere();
	
	      this._container.add(this._lineMesh);
	    }
	  }, {
	    key: 'blending',
	    get: function get() {
	      return this._blending;
	    },
	    set: function set(blending) {
	      this._blending = blending;
	    }
	  }]);
	
	  return MergeLeafLine;
	}(MergeLeaf);
	
	var MergeLeafPolygon = function (_MergeLeaf2) {
	  _inherits(MergeLeafPolygon, _MergeLeaf2);
	
	  function MergeLeafPolygon() {
	    _classCallCheck(this, MergeLeafPolygon);
	
	    return _possibleConstructorReturn(this, (MergeLeafPolygon.__proto__ || Object.getPrototypeOf(MergeLeafPolygon)).apply(this, arguments));
	  }
	
	  _createClass(MergeLeafPolygon, [{
	    key: 'reset',
	    value: function reset() {
	      _get(MergeLeafPolygon.prototype.__proto__ || Object.getPrototypeOf(MergeLeafPolygon.prototype), 'reset', this).call(this);
	      this._polygonPosition = [];
	      this._polygonId = [];
	      this._polygonColor = [];
	      this._polygonNormals = [];
	      this._range = {};
	      this._rangeIndex = [];
	      if (this._polygonBuffer) {
	        this._polygonBuffer.dispose();
	      }
	      this._polygonBuffer = new THREE.BufferGeometry();
	      /*
	      this._polygonMesh = new THREE.Mesh(this._polygonBuffer, new THREE.MeshBasicMaterial({
	        vertexColors: THREE.VertexColors,
	      }));
	      */
	      this._polygonMesh = new THREE.Mesh(this._polygonBuffer, new THREE.ShaderMaterial({
	        uniforms: {
	          coloredPOI: { value: -1 },
	          pickedColor: { value: new THREE.Vector3(1, 0, 0) },
	          transparentPOI: { value: -1 },
	          opacity: { value: 1.0 },
	          universalOpacity: { value: 1.0 }
	        },
	        vertexShader: ['attribute float polygonId;', 'attribute vec3 color;', 'varying vec3 vColor;', 'varying float vAlpha;', 'uniform float coloredPOI;', 'uniform vec3 pickedColor;', 'uniform float transparentPOI;', 'uniform float opacity;', 'uniform float universalOpacity;', 'void main() {', 'gl_Position = projectionMatrix * modelViewMatrix * vec4(position,1.0);', 'vColor = color;', 'vAlpha = universalOpacity;', 'if (polygonId == coloredPOI) vColor =  pickedColor;', 'if (polygonId == transparentPOI) vAlpha =  opacity;', '}'].join('\n'),
	        fragmentShader: ['varying vec3 vColor;', 'varying float vAlpha;', 'void main() {', 'gl_FragColor = vec4(vColor, vAlpha);', '}'].join('\n'),
	        transparent: true
	      }));
	      this._rangeLength = 0;
	    }
	  }, {
	    key: 'clear',
	    value: function clear() {
	      this._container.remove(this._polygonMesh);
	      _get(MergeLeafPolygon.prototype.__proto__ || Object.getPrototypeOf(MergeLeafPolygon.prototype), 'clear', this).call(this);
	    }
	  }, {
	    key: 'setValue',
	    value: function setValue(id, method) {
	      // if (!value || value.length === 0) {
	      //   return;
	      // }
	      // if (!params) {
	      //   return;
	      // }
	      // for (const method in params) {
	      //   const value = params[method];
	      //   if (!value) {
	      //     continue;
	      //   }
	      //   switch (method) {
	      //     case 'color': {
	      //       this._polygonMesh.material.uniforms.coloredPOI = id;
	      //       this._polygonMesh.material.uniforms.pickedColor = value;
	      //       break;
	      //     }
	      //     case 'opacity': {
	      //       this._polygonMesh.material.uniforms.transparentPOI = id;
	      //       this._polygonMesh.material.uniforms.opacity = value;
	      //       break;
	      //     }
	      //     default:
	      //       break;
	      //   }
	      // }
	      switch (method) {
	        case 'color':
	          {
	            var parseColor = _StyleUtil2.default.parseColor(arguments.length <= 2 ? undefined : arguments[2]);
	            var color = new THREE.Color(parseColor);
	
	            this._polygonMesh.material.uniforms.coloredPOI.value = id;
	            this._polygonMesh.material.uniforms.pickedColor.value = new THREE.Vector3(color.r, color.g, color.b);
	            break;
	          }
	        case 'opacity':
	          {
	            if ((arguments.length <= 2 ? undefined : arguments[2]) !== 1) {
	              this._polygonMesh.material.transparent = true;
	            } else {
	              this._polygonMesh.material.transparent = false;
	            }
	
	            if (id === 0) {
	              this._polygonMesh.material.uniforms.transparentPOI.value = -1;
	              this._polygonMesh.material.uniforms.universalOpacity.value = arguments.length <= 2 ? undefined : arguments[2];
	              break;
	            }
	            this._polygonMesh.material.uniforms.transparentPOI.value = id;
	            this._polygonMesh.material.uniforms.opacity.value = arguments.length <= 2 ? undefined : arguments[2];
	            break;
	          }
	        case 'colorResetting':
	          {
	            this._polygonMesh.material.uniforms.coloredPOI.value = -1;
	            break;
	          }
	        default:
	          break;
	      }
	    }
	  }, {
	    key: 'merge',
	    value: function merge(id, scene) {
	      var _this3 = this;
	
	      var geometry = scene.geometry,
	          position = scene.position,
	          color = scene.material.color;
	
	
	      if (!geometry) {
	        return null;
	      }
	      if (geometry.faces.length > 0) {
	        // const id = scene._sceneId;
	        var material = scene.material;
	
	        if (!(this._polygonMesh.material instanceof THREE.MeshPhongMaterial) && material instanceof THREE.MeshPhongMaterial) {
	          // this._polygonMesh.material = new THREE.MeshPhongMaterial({ vertexColors: THREE.VertexColors });
	          // this._polygonMesh.material.shading = THREE.SmoothShading;
	          this._polygonMesh.material = new THREE.ShaderMaterial({
	            uniforms: {
	              coloredPOI: { value: -1 },
	              pickedColor: { value: new THREE.Vector3(1, 0, 0) },
	              transparentPOI: { value: -1 },
	              opacity: { value: 1.0 },
	              universalOpacity: { value: 1.0 },
	              directionalLights: { value: [] },
	              ambientLightColor: { value: [] },
	              spotLights: { value: [] },
	              pointLights: { value: [] },
	              hemisphereLights: { value: [] },
	              directionalShadowMap: { value: [] },
	              directionalShadowMatrix: { value: [] },
	              spotShadowMap: { value: [] },
	              spotShadowMatrix: { value: [] },
	              pointShadowMap: { value: [] },
	              pointShadowMatrix: { value: [] }
	            },
	            vertexShader: ['attribute float polygonId;', 'attribute vec3 color;', 'varying vec3 vColor;', 'varying float vAlpha;', 'uniform float coloredPOI;', 'uniform vec3 pickedColor;', 'uniform float transparentPOI;', 'uniform float opacity;', 'uniform float universalOpacity;', 'void main() {', 'gl_Position = projectionMatrix * modelViewMatrix * vec4(position,1.0);', '// vec3 transformedNormal = normalMatrix * normal;', 'float nDotL = max(dot(vec3(0.57735,0.57735,-0.57735), normal), 0.0);', '// vec3 pointLight = vec3(10,10,100);', '// float nDotL = dot(normalize( pointLight-position), normal);', 'vColor = color - color.xyz * nDotL * 0.5;', '// vColor = color.xyz * nDotL * 0.5 + color;', 'vAlpha = universalOpacity;', 'if (polygonId == coloredPOI) vColor =  pickedColor;', 'if (polygonId == transparentPOI) vAlpha =  opacity;', '}'].join('\n'),
	            fragmentShader: ['varying vec3 vColor;', 'varying float vAlpha;', 'void main() {', 'gl_FragColor = vec4(vColor, vAlpha);', '}'].join('\n'),
	            transparent: true,
	            lights: false
	          });
	        }
	
	        var stride = 9;
	        var faceKeys = ['a', 'b', 'c'];
	        var vecKeys = ['x', 'y', 'z'];
	        var colorKeys = ['r', 'g', 'b'];
	        var polygonRange = this._range[id];
	
	        if (polygonRange) {
	          this.remove(id, parent);
	        }
	        polygonRange = [];
	        this._range[id] = polygonRange;
	        this._rangeIndex.push(id);
	        polygonRange.push(this._polygonPosition.length);
	        geometry.faces.forEach(function (face) {
	          var faceColor = color ? color : face.color;
	
	          for (var index = 0; index < stride; index++) {
	            var bufferIndex = _this3._rangeLength * stride + index;
	            var faceKey = faceKeys[Math.floor(index / 3)];
	            var vecKey = vecKeys[index % 3];
	            var colorKey = colorKeys[index % 3];
	
	            _this3._polygonPosition[bufferIndex] = geometry.vertices[face[faceKey]][vecKey] + position[vecKey];
	            _this3._polygonNormals[bufferIndex] = face.normal[vecKey];
	            _this3._polygonColor[bufferIndex] = faceColor[colorKey];
	          }
	          // this._polygonPosition[this._rangeLength * 9 + 0] = geometry.vertices[face.a].x + position.x;
	          // this._polygonPosition[this._rangeLength * 9 + 1] = geometry.vertices[face.a].y + position.y;
	          // this._polygonPosition[this._rangeLength * 9 + 2] = geometry.vertices[face.a].z + position.z;
	          // this._polygonPosition[this._rangeLength * 9 + 3] = geometry.vertices[face.b].x + position.x;
	          // this._polygonPosition[this._rangeLength * 9 + 4] = geometry.vertices[face.b].y + position.y;
	          // this._polygonPosition[this._rangeLength * 9 + 5] = geometry.vertices[face.b].z + position.z;
	          // this._polygonPosition[this._rangeLength * 9 + 6] = geometry.vertices[face.c].x + position.x;
	          // this._polygonPosition[this._rangeLength * 9 + 7] = geometry.vertices[face.c].y + position.y;
	          // this._polygonPosition[this._rangeLength * 9 + 8] = geometry.vertices[face.c].z + position.z;
	
	          // this._polygonNormals[this._rangeLength * 9 + 0] = face.normal.x;
	          // this._polygonNormals[this._rangeLength * 9 + 1] = face.normal.y;
	          // this._polygonNormals[this._rangeLength * 9 + 2] = face.normal.z;
	          // this._polygonNormals[this._rangeLength * 9 + 3] = face.normal.x;
	          // this._polygonNormals[this._rangeLength * 9 + 4] = face.normal.y;
	          // this._polygonNormals[this._rangeLength * 9 + 5] = face.normal.z;
	          // this._polygonNormals[this._rangeLength * 9 + 6] = face.normal.x;
	          // this._polygonNormals[this._rangeLength * 9 + 7] = face.normal.y;
	          // this._polygonNormals[this._rangeLength * 9 + 8] = face.normal.z;
	
	          // this._polygonColor[this._rangeLength * 9 + 0] = faceColor.r;
	          // this._polygonColor[this._rangeLength * 9 + 1] = faceColor.g;
	          // this._polygonColor[this._rangeLength * 9 + 2] = faceColor.b;
	          // this._polygonColor[this._rangeLength * 9 + 3] = faceColor.r;
	          // this._polygonColor[this._rangeLength * 9 + 4] = faceColor.g;
	          // this._polygonColor[this._rangeLength * 9 + 5] = faceColor.b;
	          // this._polygonColor[this._rangeLength * 9 + 6] = faceColor.r;
	          // this._polygonColor[this._rangeLength * 9 + 7] = faceColor.g;
	          // this._polygonColor[this._rangeLength * 9 + 8] = faceColor.b;
	
	          _this3._polygonId[_this3._rangeLength * 3 + 0] = id;
	          _this3._polygonId[_this3._rangeLength * 3 + 1] = id;
	          _this3._polygonId[_this3._rangeLength * 3 + 2] = id;
	          _this3._rangeLength++;
	        });
	        polygonRange.push(this._polygonPosition.length);
	        geometry.dispose();
	      }
	      return this._polygonMesh;
	    }
	  }, {
	    key: 'update',
	    value: function update() {
	      this._resetPolygonBuffer();
	    }
	  }, {
	    key: 'remove',
	    value: function remove(id) {
	      var polygonRange = this._range[id];
	
	      if (!polygonRange) {
	        return;
	      }
	
	      var pMin = polygonRange[0];
	      var pMax = polygonRange[1];
	      var positionCount = pMax - pMin;
	      var count = positionCount / 9;
	      var indexOf = this._rangeIndex.indexOf(id);
	
	      this._rangeLength -= count;
	      this._polygonPosition.splice(pMin, positionCount);
	      this._polygonNormals.splice(pMin, positionCount);
	      this._polygonColor.splice(pMin, positionCount);
	      this._polygonId.splice(pMin / 3, positionCount / 3);
	
	      if (indexOf !== -1) {
	        for (var i = indexOf + 1; i < this._rangeIndex.length; i++) {
	          var range = this._range[this._rangeIndex[i]];
	
	          if (range) {
	            range[0] -= positionCount;
	            range[1] -= positionCount;
	          }
	        }
	        this._rangeIndex.splice(indexOf, 1);
	      }
	      // this._resetPolygonBuffer();
	      delete this._range[id];
	    }
	  }, {
	    key: 'type',
	    value: function type() {
	      return 'polygon';
	    }
	  }, {
	    key: '_resetPolygonBuffer',
	    value: function _resetPolygonBuffer() {
	      this._polygonBuffer.addAttribute('position', new THREE.BufferAttribute(new Float32Array(this._polygonPosition), 3));
	      this._polygonBuffer.addAttribute('normal', new THREE.BufferAttribute(new Float32Array(this._polygonNormals), 3));
	      this._polygonBuffer.addAttribute('color', new THREE.BufferAttribute(new Float32Array(this._polygonColor), 3));
	      this._polygonBuffer.addAttribute('polygonId', new THREE.BufferAttribute(new Float32Array(this._polygonId), 1));
	      // this._polygonBuffer.colorsNeedUpdate = true;
	      this._polygonBuffer.computeBoundingSphere();
	
	      this._container.add(this._polygonMesh);
	    }
	  }]);
	
	  return MergeLeafPolygon;
	}(MergeLeaf);
	
	var ThreeMergeNode = function (_MergeNode) {
	  _inherits(ThreeMergeNode, _MergeNode);
	
	  function ThreeMergeNode(sceneManager) {
	    _classCallCheck(this, ThreeMergeNode);
	
	    // this.resetPolygon();
	    // this.resetLine();
	    var _this4 = _possibleConstructorReturn(this, (ThreeMergeNode.__proto__ || Object.getPrototypeOf(ThreeMergeNode)).call(this));
	
	    _this4._sceneManager = sceneManager;
	    _this4._lastLeaf = {};
	    _this4.lastLayerId = 0;
	    _this4._featuresMapping = {};
	    _this4._mergeLeafs = {};
	
	    _this4._onSceneChange = _this4._onSceneChange.bind(_this4);
	
	    _this4._sceneManager.on('onSceneChange', _this4._onSceneChange);
	    return _this4;
	  }
	
	  _createClass(ThreeMergeNode, [{
	    key: '_onSceneChange',
	    value: function _onSceneChange(type, layer, features) {
	      if (type !== 'color' && type !== 'opacity' && type !== 'colorResetting') {
	        return;
	      }
	
	      for (var _len = arguments.length, value = Array(_len > 3 ? _len - 3 : 0), _key = 3; _key < _len; _key++) {
	        value[_key - 3] = arguments[_key];
	      }
	
	      if (!features) {
	        this.setValue.apply(this, [layer, null, type].concat(value));
	      } else if (!(0, _lang.isArray)(features) && this.has(features)) {
	        if (this.lastLayerId !== layer.id) {
	          for (var name in this._lastLeaf) {
	            var leaf = this._lastLeaf[name];
	
	            leaf.setValue.apply(leaf, [-1, name].concat(value));
	          }
	          this.lastLayerId = layer.id;
	        }
	        this.setValue.apply(this, [layer, features, type].concat(value));
	      }
	    }
	  }, {
	    key: 'has',
	    value: function has(feature, mesh) {
	      // return !!id && id in this._range || id in this._range;
	      var id = feature.id;
	      var mapping = this._featuresMapping[id];
	
	      if (!mapping) {
	        return false;
	      }
	      return !mesh || mesh.id in mapping;
	    }
	  }, {
	    key: 'hasLayer',
	    value: function hasLayer(parentId) {
	      return parentId in this._mergeLeafs;
	    }
	  }, {
	    key: 'merge',
	    value: function merge(feature, style, scene, parentId, parent) {
	      var mergeType = 0;
	
	      if (!style && !style instanceof _Style2.default) {
	        return mergeType;
	      }
	
	      var type = style.type();
	
	      if (type === 'Polygon') {
	        var polygonMerge = style.polygonMerge;
	        var outlineMerge = style.outlineMerge;
	
	        if (!polygonMerge && !outlineMerge) {
	          return mergeType;
	        }
	
	        if (scene instanceof THREE.Group) {
	          for (var _iterator = scene.children, _isArray = Array.isArray(_iterator), _i2 = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
	            var _ref;
	
	            if (_isArray) {
	              if (_i2 >= _iterator.length) break;
	              _ref = _iterator[_i2++];
	            } else {
	              _i2 = _iterator.next();
	              if (_i2.done) break;
	              _ref = _i2.value;
	            }
	
	            var ch = _ref;
	
	            mergeType = this.merge(feature, style, ch, parentId, parent);
	            if (mergeType === 2) {
	              scene.remove(ch);
	            }
	          }
	          if (scene.children.length === 0) {
	            return 2;
	          }
	          return mergeType;
	        }
	
	        var featureMapping = this._featuresMapping[feature.id];
	
	        if (!featureMapping) {
	          featureMapping = [];
	          this._featuresMapping[feature.id] = featureMapping;
	        }
	
	        var mergeleafs = this._mergeLeafs[parentId];
	
	        if (!mergeleafs) {
	          mergeleafs = {};
	          this._mergeLeafs[parentId] = mergeleafs;
	        }
	
	        if (outlineMerge && scene.children.length > 0) {
	          var lineMesh = scene.children[0];
	
	          scene.remove(lineMesh);
	          var lineLeaf = mergeleafs['line'];
	          if (!lineLeaf) {
	            lineLeaf = new MergeLeafLine(parent);
	            lineLeaf.blending = style.outlineBlending;
	            lineLeaf.reset();
	            mergeleafs['line'] = lineLeaf;
	          }
	          lineLeaf.merge(lineMesh.id, lineMesh);
	          featureMapping.push(lineMesh.id);
	          mergeType = 1;
	        }
	
	        if (polygonMerge) {
	          var polygonLeaf = mergeleafs['polygon'];
	
	          if (!polygonLeaf) {
	            polygonLeaf = new MergeLeafPolygon(parent);
	            polygonLeaf.reset();
	            mergeleafs['polygon'] = polygonLeaf;
	          }
	          polygonLeaf.merge(scene.id, scene);
	          featureMapping.push(scene.id);
	          mergeType = mergeType === 1 ? 2 : 1;
	        }
	      }
	      return mergeType;
	    }
	  }, {
	    key: 'update',
	    value: function update(parentId) {
	      var leafs = this._mergeLeafs[parentId];
	
	      if (leafs) {
	        for (var name in leafs) {
	          var leaf = leafs[name];
	          leaf.update();
	        }
	      }
	    }
	  }, {
	    key: 'setValue',
	    value: function setValue(layer, feature, method) {
	      var groupId = layer.id;
	      var leafs = this._mergeLeafs[groupId];
	
	      for (var _len2 = arguments.length, value = Array(_len2 > 3 ? _len2 - 3 : 0), _key2 = 3; _key2 < _len2; _key2++) {
	        value[_key2 - 3] = arguments[_key2];
	      }
	
	      if (!feature && leafs) {
	        this._setValue.apply(this, [leafs, null, method].concat(value));
	      } else if (feature) {
	        var mapping = this._featuresMapping[feature.id];
	
	        if (!mapping) {
	          return;
	        }
	        for (var parentId in this._mergeLeafs) {
	          leafs = this._mergeLeafs[parentId];
	          this._setValue.apply(this, [leafs, mapping, method].concat(value));
	        }
	      }
	    }
	  }, {
	    key: '_setValue',
	    value: function _setValue(leafs, mapping, method) {
	      for (var _len3 = arguments.length, value = Array(_len3 > 3 ? _len3 - 3 : 0), _key3 = 3; _key3 < _len3; _key3++) {
	        value[_key3 - 3] = arguments[_key3];
	      }
	
	      if (leafs['line']) {
	        if (!mapping) {
	          var _leafs$line;
	
	          (_leafs$line = leafs['line']).setValue.apply(_leafs$line, [0, method].concat(value));
	        }
	      }
	
	      var leaf = leafs['polygon'];
	
	      if (!leaf) {
	        return;
	      }
	      if (mapping) {
	        // target single poi
	        for (var _iterator2 = mapping, _isArray2 = Array.isArray(_iterator2), _i3 = 0, _iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator]();;) {
	          var _ref2;
	
	          if (_isArray2) {
	            if (_i3 >= _iterator2.length) break;
	            _ref2 = _iterator2[_i3++];
	          } else {
	            _i3 = _iterator2.next();
	            if (_i3.done) break;
	            _ref2 = _i3.value;
	          }
	
	          var meshId = _ref2;
	
	          if (leaf.has(meshId)) {
	            leaf.setValue.apply(leaf, [meshId, method].concat(value));
	            this._lastLeaf[method] = leaf;
	          }
	        }
	      } else {
	        // target group
	        leaf.setValue.apply(leaf, [0, method].concat(value));
	      }
	    }
	  }, {
	    key: 'remove',
	    value: function remove(feature) {
	      var id = feature.id;
	      var featuresMapping = this._featuresMapping[id];
	
	      if (featuresMapping) {
	        for (var _iterator3 = featuresMapping, _isArray3 = Array.isArray(_iterator3), _i4 = 0, _iterator3 = _isArray3 ? _iterator3 : _iterator3[Symbol.iterator]();;) {
	          var _ref3;
	
	          if (_isArray3) {
	            if (_i4 >= _iterator3.length) break;
	            _ref3 = _iterator3[_i4++];
	          } else {
	            _i4 = _iterator3.next();
	            if (_i4.done) break;
	            _ref3 = _i4.value;
	          }
	
	          var sceneId = _ref3;
	
	          for (var parentId in this._mergeLeafs) {
	            var mergeLeafs = this._mergeLeafs[parentId];
	
	            if (!mergeLeafs) {
	              continue;
	            }
	            for (var type in mergeLeafs) {
	              var leaf = mergeLeafs[type];
	
	              leaf.remove(sceneId);
	            }
	          }
	        }
	        delete this._featuresMapping[id];
	      }
	    }
	  }, {
	    key: 'removeByLayer',
	    value: function removeByLayer(layer, parentId) {
	      var _this5 = this;
	
	      layer.visit(function (feature) {
	        var featuresMapping = _this5._featuresMapping[feature.id];
	
	        if (featuresMapping) {
	          delete _this5._featuresMapping[feature.id];
	        }
	      });
	      var leafs = this._mergeLeafs[parentId];
	
	      if (leafs) {
	        for (var name in leafs) {
	          var leaf = leafs[name];
	
	          leaf.clear();
	        }
	        delete this._mergeLeafs[parentId];
	      }
	    }
	  }, {
	    key: 'destroy',
	    value: function destroy() {
	      this._sceneManager.off('onSceneChange', this._onSceneChange);
	      this._lastLeaf = [];
	      this._featuresMapping = [];
	      for (var parentId in this._mergeLeafs) {
	        var leafs = this._mergeLeafs[parentId];
	
	        for (var name in leafs) {
	          var leaf = leafs[name];
	
	          leaf.clear();
	        }
	      }
	      this._mergeLeafs = [];
	    }
	  }]);
	
	  return ThreeMergeNode;
	}(_MergeNode3.default);
	
	exports.default = ThreeMergeNode;

/***/ }),
/* 204 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _assign = __webpack_require__(1);
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	// import PlaneLineGroup from '../../lib/three-ext/planeLine/PlaneLineGroup';
	
	// import BasicShader from '../../lib/three-line-2d/basic';
	
	// attach methods to THREE
	/* eslint-disable no-unused-vars */
	
	
	var _three = __webpack_require__(2);
	
	var THREE = _interopRequireWildcard(_three);
	
	var _LoaderCache = __webpack_require__(162);
	
	var _LoaderCache2 = _interopRequireDefault(_LoaderCache);
	
	var _PolygonIterator = __webpack_require__(158);
	
	var _PolygonIterator2 = _interopRequireDefault(_PolygonIterator);
	
	var _MeshProxy = __webpack_require__(125);
	
	var _MeshProxy2 = _interopRequireDefault(_MeshProxy);
	
	var _SpriteText2D = __webpack_require__(119);
	
	var _SpriteText2D2 = _interopRequireDefault(_SpriteText2D);
	
	var _textAlign = __webpack_require__(59);
	
	var _textAlign2 = _interopRequireDefault(_textAlign);
	
	var _SpriteIcon = __webpack_require__(130);
	
	var _SpriteIcon2 = _interopRequireDefault(_SpriteIcon);
	
	var _ShapeUtils = __webpack_require__(129);
	
	var _ShapeUtils2 = _interopRequireDefault(_ShapeUtils);
	
	var _JTSUtils = __webpack_require__(12);
	
	var _JTSUtils2 = _interopRequireDefault(_JTSUtils);
	
	var _Math = __webpack_require__(38);
	
	var _Math2 = _interopRequireDefault(_Math);
	
	var _lang = __webpack_require__(4);
	
	var _threeLine2d = __webpack_require__(280);
	
	var _threeLine2d2 = _interopRequireDefault(_threeLine2d);
	
	var _shaderDash = __webpack_require__(135);
	
	var _shaderDash2 = _interopRequireDefault(_shaderDash);
	
	var _OBJLoader = __webpack_require__(127);
	
	var _OBJLoader2 = _interopRequireDefault(_OBJLoader);
	
	var _ColladaLoader = __webpack_require__(121);
	
	var _ColladaLoader2 = _interopRequireDefault(_ColladaLoader);
	
	var _MTLLoader = __webpack_require__(124);
	
	var _MTLLoader2 = _interopRequireDefault(_MTLLoader);
	
	var _FBXLoader = __webpack_require__(123);
	
	var _FBXLoader2 = _interopRequireDefault(_FBXLoader);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	/* eslint-enable no-unused-vars */
	
	// const ColorKeywords = [0xF0F8FF, 0x00FFFF, 0x000000, 0x00FFFF, 0x2F4F4F, 0xADFF2F, 0xFFA07A, 0xFFE4E1, 0xDB7093, 0x2E8B57, 0x708090, 0xFF6347, 0xFFFF00, 0x9ACD32];
	
	// const textureLoader = new THREE.TextureLoader();
	var tubeTextureLoader = new THREE.TextureLoader();
	var textureLoader = new _LoaderCache2.default(new THREE.TextureLoader());
	var layerFeatureMapping = {};
	var THREE2DLine = (0, _threeLine2d2.default)(THREE);
	var THREE2DDashShader = (0, _shaderDash2.default)(THREE);
	var styleMapping = {
	  Annotation: {
	    outlineColor: 'strokeStyle',
	    outlineWidth: 'lineWidth',
	    shadowColor: 'shadowColor',
	    shadowBlur: 'shadowBlur',
	    color: 'fillStyle'
	  }
	};
	// let layerFeatureCount = 0;
	// let layerFeatureIndex = 0;
	
	function groupGetAABB(camera) {
	  var margin = this.margin || 0;
	  var minX = Number.MAX_VALUE;
	  var maxX = Number.MIN_VALUE;
	  var minY = minX;
	  var maxY = maxX;
	
	  for (var _iterator = this.children, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
	    var _ref;
	
	    if (_isArray) {
	      if (_i >= _iterator.length) break;
	      _ref = _iterator[_i++];
	    } else {
	      _i = _iterator.next();
	      if (_i.done) break;
	      _ref = _i.value;
	    }
	
	    var mesh = _ref;
	
	    if (mesh.getAABB) {
	      var temp = mesh.getAABB(camera);
	
	      if (minX > temp[0]) {
	        minX = temp[0];
	      }
	      if (minY > temp[1]) {
	        minY = temp[1];
	      }
	      if (maxX < temp[3]) {
	        maxX = temp[3];
	      }
	      if (maxY < temp[4]) {
	        maxY = temp[4];
	      }
	    }
	  }
	
	  return [minX - margin, minY - margin, 0, maxX + margin, maxY + margin, 0];
	}
	
	function groupMakeCollision(collision) {
	  var needAnimation = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
	
	  for (var _iterator2 = this.children, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator]();;) {
	    var _ref2;
	
	    if (_isArray2) {
	      if (_i2 >= _iterator2.length) break;
	      _ref2 = _iterator2[_i2++];
	    } else {
	      _i2 = _iterator2.next();
	      if (_i2.done) break;
	      _ref2 = _i2.value;
	    }
	
	    var mesh = _ref2;
	
	    if (mesh.makeCollision) {
	      mesh.makeCollision(collision, needAnimation);
	    }
	  }
	  this.visible = !collision;
	}
	
	var ThreeMeshGenerator = function () {
	  function ThreeMeshGenerator() {
	    _classCallCheck(this, ThreeMeshGenerator);
	  }
	
	  _createClass(ThreeMeshGenerator, null, [{
	    key: 'generator',
	    value: function generator(sceneManager, layer, feature, style) {
	      var engine = sceneManager.mapView.engine;
	      var type = style.type();
	      var mesh = null;
	
	      switch (type) {
	        case 'Polygon':
	          mesh = ThreeMeshGenerator.polygon(sceneManager, engine, feature, style);
	          break;
	        case 'Annotation':
	          mesh = ThreeMeshGenerator.annotation(sceneManager, layer, engine, feature, style);
	          break;
	        case 'Icon':
	          mesh = ThreeMeshGenerator.icon(sceneManager, layer, engine, feature, style);
	          break;
	        case 'LineString':
	          mesh = ThreeMeshGenerator.lineString(sceneManager, engine, feature, style);
	          break;
	        case 'Light':
	          mesh = ThreeMeshGenerator.light(sceneManager, engine, feature, style);
	          break;
	        case 'Model':
	          mesh = ThreeMeshGenerator.model(sceneManager, layer, engine, feature, style);
	          break;
	        case 'Sphere':
	          mesh = ThreeMeshGenerator.sphere(sceneManager, layer, engine, feature, style);
	          break;
	        default:
	          console.warn('Invalid style type');
	      }
	
	      if (mesh) {
	        mesh.originStyle = style;
	        if (feature.properties.id) {
	          mesh._sceneId = feature.properties.id;
	          mesh._layerId = layer.id;
	          if (mesh instanceof THREE.Group) {
	            for (var _iterator3 = mesh.children, _isArray3 = Array.isArray(_iterator3), _i3 = 0, _iterator3 = _isArray3 ? _iterator3 : _iterator3[Symbol.iterator]();;) {
	              var _ref3;
	
	              if (_isArray3) {
	                if (_i3 >= _iterator3.length) break;
	                _ref3 = _iterator3[_i3++];
	              } else {
	                _i3 = _iterator3.next();
	                if (_i3.done) break;
	                _ref3 = _i3.value;
	              }
	
	              var node = _ref3;
	
	              node._sceneId = feature.properties.id;
	              node._layerId = layer.id;
	            }
	          }
	        }
	        if (style.collision) {
	          sceneManager.mapView.collisionSceneManager.add(feature, mesh);
	        }
	        if (style.alwaysVisible) {
	          sceneManager.mapView.collisionSceneManager.add(feature, mesh, true);
	          if (mesh.type === 'PlaneLineGroup') {
	            var _loop = function _loop() {
	              if (_isArray4) {
	                if (_i4 >= _iterator4.length) return 'break';
	                _ref4 = _iterator4[_i4++];
	              } else {
	                _i4 = _iterator4.next();
	                if (_i4.done) return 'break';
	                _ref4 = _i4.value;
	              }
	
	              var planeGroup = _ref4;
	
	              planeGroup.on('loaded', function () {
	                return sceneManager.mapView.collisionSceneManager.add(feature, planeGroup, true);
	              });
	            };
	
	            for (var _iterator4 = mesh.children, _isArray4 = Array.isArray(_iterator4), _i4 = 0, _iterator4 = _isArray4 ? _iterator4 : _iterator4[Symbol.iterator]();;) {
	              var _ref4;
	
	              var _ret = _loop();
	
	              if (_ret === 'break') break;
	            }
	          }
	        }
	      }
	      return mesh;
	    }
	  }, {
	    key: 'annotation',
	    value: function annotation(sceneManager, layer, engine, feature, style) {
	      var geometry = feature.geometry;
	      var type = geometry.getGeometryType();
	      var mesh = null;
	
	      if (type === 'Point') {
	        var field = style.field;
	        var params = ThreeMeshGenerator.parseParams(feature, style, ['font', 'color', 'outlineColor', 'outlineWidth', 'shadowColor', 'shadowBlur', 'depthTest', 'optTextRect']);
	
	        params.antialias = false;
	        params.align = _textAlign2.default.center;
	        if (field && feature.properties[field]) {
	          // TODO(jian.feng)
	          var mapView = sceneManager.mapView;
	          var webGlRenderer = engine.getRenderer(mapView);
	          var dpr = webGlRenderer.getPixelRatio() === window.devicePixelRatio ? 1 : window.devicePixelRatio;
	          var anchorStyle = style.anchorStyle,
	              _style$z = style.z,
	              z = _style$z === undefined ? 0 : _style$z,
	              margin = style.margin,
	              anchor = style.anchor,
	              anchorAuto = style.anchorAuto;
	
	          var anchorMesh = null;
	
	          mesh = new _SpriteText2D2.default(feature.properties[field], params);
	          mesh.position.set(geometry.getX(), geometry.getY(), (geometry.getCoordinate().z || 0) + z);
	          mesh.sprite.scale.x = mesh.canvas.textWidth / 2 * dpr;
	          mesh.sprite.scale.y = mesh.canvas.textHeight / 2 * dpr;
	          mesh.sprite.material.materialScale = true;
	          mesh.margin = margin;
	          mesh.sprite.material.anchor = anchor.slice();
	          mesh.sprite.material.transparent = true;
	          if (anchorStyle) {
	            var anchorStyleType = anchorStyle.type();
	
	            if (anchorStyleType === 'Icon') {
	              anchorMesh = ThreeMeshGenerator.icon(sceneManager, layer, engine, feature, style.anchorStyle);
	            }
	          }
	          if (anchorMesh) {
	            var annotationGroup = new THREE.Group();
	
	            if (anchorAuto && anchorStyle.width) {
	              mesh.sprite.material.anchor[0] = -anchorStyle.width / 2 / mesh.sprite.scale.x;
	            }
	            annotationGroup.add(mesh);
	            annotationGroup.add(anchorMesh);
	            mesh = annotationGroup;
	            annotationGroup.margin = margin;
	            annotationGroup.getAABB = groupGetAABB;
	            annotationGroup.makeCollision = groupMakeCollision;
	          }
	        }
	      }
	      return mesh;
	    }
	  }, {
	    key: 'icon',
	    value: function icon(sceneManager, layer, engine, feature, style) {
	      var geometry = feature.geometry;
	      var type = geometry.getGeometryType();
	      var mesh = null;
	
	      if (type === 'Point') {
	        var params = ThreeMeshGenerator.parseParams(feature, style, ['texture', 'serverUrl']);
	        var _style$depthTest = style.depthTest,
	            depthTest = _style$depthTest === undefined ? true : _style$depthTest,
	            plane = style.plane,
	            anchor = style.anchor,
	            margin = style.margin,
	            _style$z2 = style.z,
	            z = _style$z2 === undefined ? 0 : _style$z2;
	
	
	        params.fog = true;
	        params.depthTest = !!depthTest;
	        params.transparent = true;
	        params.alphaTest = 0.01;
	        if (plane) {
	          var planeGeometry = ThreeMeshGenerator._generateTexturePlane(1, 1);
	          var planeMaterial = new THREE.MeshBasicMaterial(params);
	
	          mesh = new THREE.Mesh(planeGeometry, planeMaterial);
	          mesh.renderOrder = 1;
	          ThreeMeshGenerator.parseTexture(sceneManager, layer, mesh, style, params);
	          // textureLoader.load(params.map, (texture) => {
	          //   texture.magFilter = THREE.LinearFilter;
	          //   texture.minFilter = THREE.LinearFilter;
	          //   texture.anisotropy = 8;
	          //   params.map = texture;
	          //   // mesh.add(planeMesh);
	          // });
	        } else {
	          mesh = new _SpriteIcon2.default(new THREE.SpriteMaterial(params));
	          // mesh.scale.set(4, 4, 4);
	          // mesh.material.materialScale = true;
	          mesh.margin = margin;
	          mesh.material.anchor = anchor.slice();
	          ThreeMeshGenerator.parseTexture(sceneManager, layer, mesh, style, params);
	        }
	        mesh.position.set(geometry.getX(), geometry.getY(), (geometry.getCoordinate().z || 0) + z);
	      }
	      return mesh;
	    }
	  }, {
	    key: 'lineString',
	    value: function lineString(sceneManager, engine, feature, style) {
	      var geometry = feature.geometry;
	      var type = geometry.getGeometryType();
	      var mesh = void 0;
	
	      if (type === 'LineString') {
	        var coordinates = geometry.getCoordinates();
	
	        if (coordinates.length !== 0) {
	          var params = ThreeMeshGenerator.parseParams(feature, style, ['color', 'depthTest']);
	
	          params.depthTest = (0, _lang.isBoolean)(style.depthTest) ? style.depthTest : true;
	          /* if (style.dynamic) {
	            mesh = new THREE.Group();
	            mesh.type = 'PlaneLineGroup';
	            if (style.bottomTexture) {
	              const bottomParams = Object.assign({}, params);
	              const topLine = new PlaneLineGroup(coordinates, style.width, params, true);
	              const bottomLine = new PlaneLineGroup(coordinates, style.width, bottomParams, true);
	               // depth depends on image loading order
	              textureLoader.load(style.bottomTexture, (texture) => {
	                bottomLine._materialParams.map = texture;
	                bottomLine._materialParams.needsUpdate = true;
	                bottomLine._addMeshes();
	                textureLoader.load(style.texture, (subTexture) => {
	                  topLine._materialParams.map = subTexture;
	                  topLine._materialParams.needsUpdate = true;
	                  topLine._addMeshes();
	                  subTexture.dispose();
	                });
	              });
	               mesh.add(bottomLine);
	              mesh.add(topLine);
	            } else {
	              const line = new PlaneLineGroup(coordinates, style.width, params, true);
	               textureLoader.load(style.texture, (texture) => {
	                line._materialParams.map = texture;
	                line._materialParams.needsUpdate = true;
	                line._addMeshes();
	                texture.dispose();
	              });
	              mesh.add(line);
	            }
	            mesh.visible = false;
	          } else */if (style['2d']) {
	            var width = style.width,
	                opacity = style.opacity,
	                _style$dashSteps = style.dashSteps,
	                dashSteps = _style$dashSteps === undefined ? 12 : _style$dashSteps,
	                _style$dashDistance = style.dashDistance,
	                dashDistance = _style$dashDistance === undefined ? 0.2 : _style$dashDistance,
	                _style$dashSmooth = style.dashSmooth,
	                dashSmooth = _style$dashSmooth === undefined ? 0.01 : _style$dashSmooth;
	
	            var coords = coordinates.map(function (_ref5) {
	              var x = _ref5.x,
	                  y = _ref5.y,
	                  _ref5$z = _ref5.z,
	                  z = _ref5$z === undefined ? 0 : _ref5$z;
	              return [x, y, z];
	            });
	            var _geometry = THREE2DLine(coords /* , { distances: true }*/);
	            var material = new THREE.ShaderMaterial(THREE2DDashShader({
	              side: THREE.DoubleSide,
	              diffuse: params.color,
	              thickness: width,
	              opacity: opacity,
	              depthTest: params.depthTest
	            }));
	
	            material.uniforms.dashSteps.value = dashSteps;
	            material.uniforms.dashDistance.value = dashDistance;
	            material.uniforms.dashSmooth.value = dashSmooth;
	            mesh = new THREE.Mesh(_geometry, material);
	            mesh.position.z += 0.1;
	            // mesh.scale.multiplyScalar(0.5);
	          } else {
	            var tension = style.tension,
	                textureUrl = style.texture,
	                density = style.density,
	                _style$width = style.width,
	                _width = _style$width === undefined ? 1 : _style$width;
	
	            var _coords = coordinates.map(function (_ref6) {
	              var x = _ref6.x,
	                  y = _ref6.y,
	                  _ref6$z = _ref6.z,
	                  z = _ref6$z === undefined ? 0 : _ref6$z;
	              return new THREE.Vector3(x, y, z);
	            });
	            var pipeSpline = new THREE.CatmullRomCurve3(_coords);
	            // const pipeSpline = new THREE.SplineCurve3(coords);
	
	            pipeSpline.type = 'catmullrom';
	            pipeSpline.tension = tension >= 0 && tension <= 1 ? tension : 0;
	
	            var tube = new THREE.TubeGeometry(pipeSpline, Math.ceil(pipeSpline.getLength() * (density > 0 ? density : 1)), _width / 2, 8, false);
	
	            if (textureUrl) {
	              // Tube texture must be immutable, and texture.clone didn't work, so don't use cache
	              tubeTextureLoader.load(textureUrl, function (texture) {
	                var ratio = texture.image.width / texture.image.height;
	                var len = tube.parameters.path.getLength();
	                var width = tube.parameters.radius * 2;
	
	                mesh.material.needsUpdate = true;
	                mesh.material.map = texture;
	                mesh.material.map.wrapS = THREE.RepeatWrapping;
	                mesh.material.map.repeat.setX(len / width / ratio);
	                // texture.dispose();
	              });
	              params.transparent = true;
	            }
	            // params.wireframe = true;
	            mesh = new THREE.Mesh(tube, new THREE.MeshBasicMaterial(params));
	          }
	        }
	      }
	      return mesh;
	    }
	  }, {
	    key: 'polygon',
	    value: function polygon(sceneManager, engine, feature, style) {
	      var geometry = feature.geometry;
	      var params = ThreeMeshGenerator.parseParams(feature, style, ['color', 'opacity', 'texture']);
	      var type = geometry.getGeometryType();
	      var mesh = null;
	
	      if (type === 'Polygon') {
	        mesh = ThreeMeshGenerator._polygon(sceneManager, engine, geometry, style, params, geometry.zIndex, feature.id);
	      } else if (type === 'MultiPolygon') {
	        mesh = new THREE.Group();
	        for (var index = 0; index < geometry.getNumGeometries(); index++) {
	          var _mesh = ThreeMeshGenerator._polygon(sceneManager, engine, geometry.getGeometryN(index), style, params, geometry.zIndex, feature.id);
	
	          mesh.add(_mesh);
	        }
	      }
	      return mesh;
	    }
	
	    /**
	     * Generate polygon mesh.
	     * @static
	     * @private
	     * @param  {SceneManager} sceneManager SceneManager.
	     * @param  {Engine}       engine       Engine.
	     * @param  {Geometry}     geometry     JSTS geometry.
	     * @param  {Style}        style        Style.
	     * @param  {Object}       params       Material parameters.
	     * @param  {Number}       zIndex       zIndex Offset Z.
	     * @param  {Number}       fId          feature ID corresponding to the feature of geometry.
	     * @return {THREE.Mesh}                Polygon mesh.
	     */
	
	  }, {
	    key: '_polygon',
	    value: function _polygon(sceneManager, engine, geometry, style, params, zIndex, fId) {
	      var height = style.height,
	          bevelEnabled = style.bevelEnabled,
	          bevelThickness = style.bevelThickness,
	          bevelSize = style.bevelSize,
	          bevelSegments = style.bevelSegments,
	          light = style.light,
	          z = style.z,
	          outlineColor = style.outlineColor,
	          lineHeight = style.lineHeight;
	
	      var shape = new THREE.Shape();
	      var polygonIterator = new _PolygonIterator2.default(geometry);
	      var options = {
	        amount: Math.abs(height),
	        bevelEnabled: false
	      };
	      var textureParams = params.map;
	      var mesh = null;
	      var shapeGeometry = void 0;
	      var points = null;
	
	      polygonIterator.shellCreator(function () {
	        return shape;
	      });
	      polygonIterator.shell(function (shell, _ref7, index) {
	        var x = _ref7.x,
	            y = _ref7.y;
	
	        if (index === 0) {
	          shell.moveTo(x, y);
	        } else {
	          shell.lineTo(x, y);
	        }
	      });
	      polygonIterator.holeCreator(function () {
	        var path = new THREE.Path();
	
	        shape.holes.push(path);
	        return path;
	      });
	      polygonIterator.holes(function (hole, _ref8, index) {
	        var x = _ref8.x,
	            y = _ref8.y;
	
	        if (index === 0) {
	          hole.moveTo(x, y);
	        } else {
	          hole.lineTo(x, y);
	        }
	      });
	      if (sceneManager.mapView._goemMap && sceneManager.mapView._goemMap[fId]) {
	        shapeGeometry = sceneManager.mapView._goemMap[fId].geometry;
	      } else if ((0, _lang.isNumber)(height) && height !== 0) {
	        if (bevelEnabled) {
	          options.bevelEnabled = true;
	          options.bevelThickness = (0, _lang.isNumber)(bevelThickness) ? bevelThickness : 0;
	          options.bevelSize = (0, _lang.isNumber)(bevelSize) && bevelSize > 0 ? bevelSize : 1;
	          options.bevelSegments = (0, _lang.isNumber)(bevelSegments) ? bevelSegments : 1;
	        }
	        shapeGeometry = new THREE.ExtrudeGeometry(shape, options);
	      } else {
	        shapeGeometry = new THREE.ShapeGeometry(shape);
	      }
	      if (textureParams) {
	        // delete params.color;
	        // params.map.dispose();
	        delete params.map;
	      }
	      if ((0, _lang.isNumber)(params.opacity)) {
	        params.transparent = true;
	      }
	      mesh = new THREE.Mesh(shapeGeometry, light ? new THREE.MeshPhongMaterial(params) : new THREE.MeshBasicMaterial(params));
	      if (z) {
	        mesh.position.setZ(z);
	      }
	      if (height < 0) {
	        mesh.position.setZ(mesh.position.z + height);
	      }
	      // mesh.position.set(-center.x, -center.y, -center.z + geometry.zIndex);
	      // mesh.scale.set(0.9998, 0.9998, 0.9998);
	      // ThreeMeshGenerator.parseTexture(sceneManager, mesh, style, params);
	
	      // line
	      if (options.bevelEnabled) {
	        points = _ShapeUtils2.default.createExpandedPointsGeometry(shape, options.bevelSize);
	      } else {
	        shape.autoClose = true;
	        points = shape.createPointsGeometry();
	      }
	      if ((0, _lang.isPresent)(outlineColor)) {
	        var finallineHeight = lineHeight ? lineHeight : (height || 0) + 0.03;
	
	        points.translate(0, 0, finallineHeight + zIndex);
	
	        var line = new THREE.Line(points, new THREE.LineBasicMaterial({ color: outlineColor }));
	
	        mesh.add(line);
	      }
	
	      // texture
	      if (textureParams) {
	        var _textureParams$depthT = textureParams.depthTest,
	            depthTest = _textureParams$depthT === undefined ? true : _textureParams$depthT,
	            _textureParams$alphaT = textureParams.alphaTest,
	            alphaTest = _textureParams$alphaT === undefined ? 0.01 : _textureParams$alphaT,
	            _textureParams$size = textureParams.size,
	            size = _textureParams$size === undefined ? [1, 1] : _textureParams$size,
	            _textureParams$offset = textureParams.offset,
	            offset = _textureParams$offset === undefined ? [0, 0] : _textureParams$offset,
	            url = textureParams.url,
	            rotation = textureParams.rotation;
	
	
	        textureLoader.load(url, function (texture) {
	          var planeGeometry = ThreeMeshGenerator._generateTexturePlane(size[0] || 1, size[1] || 1);
	
	          texture.magFilter = THREE.LinearFilter;
	          texture.minFilter = THREE.LinearFilter;
	          texture.anisotropy = 8;
	
	          var planeMaterial = new THREE.MeshBasicMaterial({
	            map: texture,
	            transparent: true,
	            depthTest: !!depthTest,
	            alphaTest: alphaTest
	          });
	          var planeMesh = new THREE.Mesh(planeGeometry, planeMaterial);
	          var center = geometry.getCentroid();
	
	          mesh.add(planeMesh);
	          planeMesh.position.set(center.getX() + (offset[0] || 0), center.getY() + (offset[1] || 0), height + 0.1);
	          if ((0, _lang.isNumber)(rotation)) {
	            var rad = Math.PI * rotation / 180;
	
	            planeMesh.rotateZ(rad);
	            texture.dispose();
	          }
	        });
	      }
	      return mesh;
	    }
	  }, {
	    key: 'light',
	    value: function light(sceneManager, engine, feature, _ref9) {
	      var lightType = _ref9.lightType,
	          _ref9$intensity = _ref9.intensity,
	          intensity = _ref9$intensity === undefined ? 1 : _ref9$intensity,
	          _ref9$color = _ref9.color,
	          color = _ref9$color === undefined ? 0xFFFFFF : _ref9$color,
	          _ref9$options = _ref9.options,
	          options = _ref9$options === undefined ? {} : _ref9$options;
	
	      var geometry = feature.geometry;
	      var type = geometry.getGeometryType();
	      var mesh = null;
	
	      if (type === 'Point') {
	        switch (lightType) {
	          case 'PointLight':
	            mesh = new THREE[lightType]();
	            break;
	          case 'SpotLight':
	            mesh = new THREE[lightType]();
	            break;
	          case 'DirectionalLight':
	            mesh = new THREE[lightType]();
	            break;
	          case 'HemisphereLight':
	            {
	              var groudColor = options.groudColorc || 0xFFFFFF;
	
	              mesh = new THREE[lightType](color, groudColor, intensity);
	              break;
	            }
	          case 'AmbientLight':
	            mesh = new THREE[lightType]();
	            break;
	          default:
	        }
	        if (mesh) {
	          var coordinate = geometry.getCoordinate();
	
	          mesh.position.set(coordinate.x, coordinate.y, coordinate.z);
	          if (mesh.shadow) {
	            var d = 20;
	
	            mesh.castShadow = true;
	            mesh.shadow.mapSize.width = 1024;
	            mesh.shadow.mapSize.height = 1024;
	            mesh.shadow.camera.left = -d;
	            mesh.shadow.camera.right = d;
	            mesh.shadow.camera.top = d;
	            mesh.shadow.camera.bottom = -d;
	            mesh.shadow.camera.far = 1000;
	          }
	        }
	      }
	      return mesh;
	    }
	  }, {
	    key: '_postProcessOctreeForModel',
	    value: function _postProcessOctreeForModel(sceneManager, layer, object, feature) {
	      if (object instanceof THREE.Group) {
	        for (var _iterator5 = object.children, _isArray5 = Array.isArray(_iterator5), _i5 = 0, _iterator5 = _isArray5 ? _iterator5 : _iterator5[Symbol.iterator]();;) {
	          var _ref10;
	
	          if (_isArray5) {
	            if (_i5 >= _iterator5.length) break;
	            _ref10 = _iterator5[_i5++];
	          } else {
	            _i5 = _iterator5.next();
	            if (_i5.done) break;
	            _ref10 = _i5.value;
	          }
	
	          var node = _ref10;
	
	          node._sceneId = feature.id;
	          node._layerId = layer.id;
	        }
	      } else {
	        object._sceneId = feature.id;
	        object._layerId = layer.id;
	      }
	      sceneManager._octreeManager.add(object, layer.id, feature.id);
	    }
	  }, {
	    key: 'model',
	    value: function model(sceneManager, layer, engine, feature, style) {
	      var path = style.path,
	          fileType = style.fileType,
	          autoAttach = style.autoAttach,
	          position = style.position,
	          scale = style.scale,
	          rotate = style.rotate,
	          clickable = style.clickable,
	          _style$params = style.params,
	          params = _style$params === undefined ? {} : _style$params;
	
	
	      if (!path || !fileType) {
	        return null;
	      }
	
	      var mesh = new _MeshProxy2.default();
	      var geometry = feature.geometry;
	      var type = geometry.getGeometryType();
	      var attachParam = _assign({}, { position: position, scale: scale, rotate: rotate });
	
	      switch (type) {
	        case 'Point':
	          {
	            var _geometry$getCoordina = geometry.getCoordinate(),
	                x = _geometry$getCoordina.x,
	                y = _geometry$getCoordina.y,
	                z = _geometry$getCoordina.z;
	
	            _assign(attachParam, { position: [x, y, z || 0] });
	            break;
	          }
	        case 'Polygon':
	          {
	            var envelope = geometry.getEnvelope();
	            var centroid = envelope.getCentroid();
	
	            var _centroid$getCoordina = centroid.getCoordinate(),
	                _x2 = _centroid$getCoordina.x,
	                _y = _centroid$getCoordina.y,
	                _z = _centroid$getCoordina.z;
	
	            _assign(attachParam, { position: [_x2, _y, _z || 0] });
	            if (autoAttach) {
	              var longEdge = _JTSUtils2.default.getLongEdge(geometry);
	              var subVector = _Math2.default.subVector(longEdge.p1, longEdge.p0);
	              var angle = _Math2.default.getAngle(subVector, { x: 0, y: 1, z: 0 });
	
	              _assign(attachParam, { rotate: [0, 0, angle] });
	            }
	            break;
	          }
	        default:
	      }
	
	      switch (fileType) {
	        case 'obj':
	          {
	            var loader = new THREE.OBJLoader();
	
	            if (params.mtl) {
	              var mtlLoader = new THREE.MTLLoader();
	
	              if (params.texturePath) {
	                mtlLoader.setTexturePath(params.texturePath);
	              }
	              mtlLoader.load(params.mtl, function (materials) {
	                materials.preload();
	                loader.setMaterials(materials);
	                loader.load(path, function (object) {
	                  ThreeMeshGenerator._setModelParam(object, attachParam);
	                  mesh.addProxy(object);
	                  if (clickable) {
	                    ThreeMeshGenerator._postProcessOctreeForModel(sceneManager, layer, object, feature);
	                  }
	                });
	                if (feature.onload) {
	                  feature.onload();
	                }
	              });
	            } else {
	              loader.load(path, function (object) {
	                var texture = null;
	
	                if (params.texture) {
	                  var _loader = new THREE.ImageLoader();
	
	                  texture = new THREE.Texture();
	                  _loader.load(params.texture, function (image) {
	                    texture.image = image;
	                  });
	                }
	                object.traverse(function (child) {
	                  if (child instanceof THREE.Mesh && texture) {
	                    child.material.map = texture;
	                  }
	                });
	                ThreeMeshGenerator._setModelParam(object, attachParam);
	                mesh.addProxy(object);
	                if (clickable) {
	                  ThreeMeshGenerator._postProcessOctreeForModel(sceneManager, layer, object, feature);
	                }
	                if (feature.onload) {
	                  feature.onload();
	                }
	              });
	            }
	            break;
	          }
	        case 'dae':
	          {
	            var _loader2 = new THREE.ColladaLoader();
	
	            _loader2.options.convertUpAxis = true;
	            _loader2.load(path, function (collada) {
	              var dae = collada.scene;
	
	              // dae.traverse(function (child) {
	              //   if (child instanceof THREE.SkinnedMesh) {
	              //   }
	              // });
	              dae.updateMatrix();
	              ThreeMeshGenerator._setModelParam(dae, attachParam);
	              mesh.addProxy(dae);
	              if (clickable) {
	                ThreeMeshGenerator._postProcessOctreeForModel(sceneManager, layer, dae, feature);
	              }
	            });
	            break;
	          }
	        case 'fbx':
	          {
	            var _loader3 = new THREE.FBXLoader();
	
	            _loader3.load(path, function (object) {
	              mesh.addProxy(object);
	              if (clickable) {
	                ThreeMeshGenerator._postProcessOctreeForModel(sceneManager, layer, object, feature);
	              }
	            });
	            break;
	          }
	        case 'js':
	          {
	            var _loader4 = new THREE.JSONLoader();
	
	            _loader4.load(path, function (geometry, materials) {
	              var zmesh = new THREE.Mesh(geometry, new THREE.MultiMaterial(materials));
	
	              mesh.addProxy(zmesh);
	              ThreeMeshGenerator._setModelParam(zmesh, style);
	              if (clickable) {
	                ThreeMeshGenerator._postProcessOctreeForModel(sceneManager, layer, zmesh, feature);
	              }
	            });
	            break;
	          }
	        default:
	          break;
	      }
	      return mesh;
	    }
	  }, {
	    key: 'sphere',
	    value: function sphere(sceneManager, layer, engine, feature, style) {
	      var geometry = feature.geometry;
	
	      var type = geometry.getGeometryType();
	      var mesh = null;
	
	      if (type === 'Point') {
	        var radius = style.radius,
	            widthSegments = style.widthSegments,
	            heightSegments = style.heightSegments,
	            light = style.light;
	
	        var sphereGeometry = new THREE.SphereGeometry(radius, widthSegments, heightSegments);
	        var MTLParams = ThreeMeshGenerator.parseParams(feature, style, ['color', 'opacity']);
	
	        var _geometry$getCoordina2 = geometry.getCoordinate(),
	            x = _geometry$getCoordina2.x,
	            y = _geometry$getCoordina2.y,
	            z = _geometry$getCoordina2.z;
	
	        if ((0, _lang.isNumber)(MTLParams.opacity)) {
	          MTLParams.transparent = true;
	        }
	        mesh = new THREE.Mesh(sphereGeometry, light ? new THREE.MeshPhongMaterial(MTLParams) : new THREE.MeshBasicMaterial(MTLParams));
	        mesh.position.set(x, y, z || 0);
	      }
	
	      return mesh;
	    }
	  }, {
	    key: 'parseParams',
	    value: function parseParams(feature, style, params) {
	      var temp = {};
	      var mapping = styleMapping[style.type()];
	
	      for (var _iterator6 = params, _isArray6 = Array.isArray(_iterator6), _i6 = 0, _iterator6 = _isArray6 ? _iterator6 : _iterator6[Symbol.iterator]();;) {
	        var _ref11;
	
	        if (_isArray6) {
	          if (_i6 >= _iterator6.length) break;
	          _ref11 = _iterator6[_i6++];
	        } else {
	          _i6 = _iterator6.next();
	          if (_i6.done) break;
	          _ref11 = _i6.value;
	        }
	
	        var param = _ref11;
	
	        // params.forEach((param) => {
	        var value = style[param];
	
	        if ((0, _lang.isPresent)(value)) {
	          if (param === 'texture' || param === 'serverUrl') {
	            if (feature.properties[style.field]) {
	              value += feature.properties[style.field];
	            }
	            if (style.suffix) {
	              value += style.suffix;
	            }
	            temp['map'] = value;
	            // temp['map'] = textureLoader.load(value, (texture) => {
	            //   texture
	            // });
	
	            continue;
	          }
	          if (mapping && mapping[param]) {
	            temp[mapping[param]] = value;
	          } else {
	            temp[param] = value;
	          }
	        }
	      }
	      return temp;
	    }
	  }, {
	    key: 'beginLayerCount',
	    value: function beginLayerCount(layer) {
	      layerFeatureMapping[layer.id] = {
	        layerFeatureCount: layer.features.getFeatureCount(),
	        layerFeatureIndex: 0
	      };
	    }
	  }, {
	    key: 'resetLayer',
	    value: function resetLayer(layer) {
	      var featureMapping = layerFeatureMapping[layer.id];
	
	      if (!featureMapping.async) {
	        delete layerFeatureMapping[layer.id];
	      }
	    }
	  }, {
	    key: 'removeLayerCount',
	    value: function removeLayerCount(layer) {
	      delete layerFeatureMapping[layer.id];
	    }
	  }, {
	    key: 'parseTexture',
	    value: function parseTexture(sceneManager, layer, mesh, _ref12, param) {
	      var width = _ref12.width,
	          height = _ref12.height;
	
	      if (param['map']) {
	        var featureMapping = layerFeatureMapping[layer.id];
	
	        if (!featureMapping) {
	          ThreeMeshGenerator.beginLayerCount(layer);
	          featureMapping = layerFeatureMapping[layer.id];
	        }
	
	        featureMapping.async = true;
	        mesh.material.map = null;
	        textureLoader.load(param['map'], function (texture) {
	          if (sceneManager.mapView && sceneManager.mapView.activeCamera) {
	            texture.minFilter = THREE.LinearFilter;
	            texture.magFilter = THREE.LinearFilter;
	            mesh.material.map = texture;
	            mesh.material.needsUpdate = true;
	            mesh.scale.set(width || texture.image.width, height || texture.image.height, 1);
	            // mesh.scale.x = width;
	            // mesh.scale.y = height;
	            mesh.material.materialScale = true;
	            mesh.material.map.dispose();
	            if (!featureMapping) {
	              sceneManager.mapView.collisionSceneManager.updateCollision();
	
	              return;
	            }
	            ThreeMeshGenerator._allComplete(layer, sceneManager);
	          } else {
	            mesh.scale.set(4, 4, 0);
	          }
	        }, function () {}, function () {
	          ThreeMeshGenerator._allComplete(layer, sceneManager);
	        });
	      }
	    }
	  }, {
	    key: '_allComplete',
	    value: function _allComplete(layer, sceneManager) {
	      var featureMapping = layerFeatureMapping[layer.id];
	
	      if (!featureMapping) {
	        return;
	      }
	      featureMapping.layerFeatureIndex++;
	      if (layer.features.getFeatureCount() === featureMapping.layerFeatureIndex) {
	        sceneManager.mapView.collisionSceneManager.updateCollision();
	      }
	    }
	  }, {
	    key: '_setModelParam',
	    value: function _setModelParam(mesh) {
	      var style = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
	      var scale = style.scale,
	          rotate = style.rotate,
	          position = style.position;
	
	
	      if (scale) {
	        mesh.scale.set(scale[0], scale[1], scale[2]);
	      }
	      if (rotate) {
	        mesh.rotation.set(rotate[0], rotate[1], rotate[2]);
	      }
	      if (position) {
	        mesh.position.set(position[0], position[1], position[2]);
	      }
	    }
	
	    /**
	     * Generate a plane geometry for texture. Left bottom is [0, 0].
	     * @static
	     * @private
	     * @param  {Number} x X length.
	     * @param  {Number} y Y length.
	     * @return {THREE.Geometry}   Plane
	     */
	
	  }, {
	    key: '_generateTexturePlane',
	    value: function _generateTexturePlane(x, y) {
	      var halfWidth = (0, _lang.isNumber)(x) ? x / 2 : 0.5;
	      var halfHeight = (0, _lang.isNumber)(y) ? y / 2 : 0.5;
	      var plane = new THREE.Shape();
	
	      // CCW
	      plane.moveTo(-halfWidth, -halfHeight);
	      plane.lineTo(halfWidth, -halfHeight);
	      plane.lineTo(halfWidth, halfHeight);
	      plane.lineTo(-halfWidth, halfHeight);
	      plane.lineTo(-halfWidth, -halfHeight);
	
	      var geometry = new THREE.ShapeGeometry(plane);
	
	      geometry.faceVertexUvs[0] = [[new THREE.Vector2(0, 0), new THREE.Vector2(1, 0), new THREE.Vector2(1, 1)], [new THREE.Vector2(1, 1), new THREE.Vector2(0, 1), new THREE.Vector2(0, 0)]];
	
	      return geometry;
	    }
	  }]);
	
	  return ThreeMeshGenerator;
	}();
	
	exports.default = ThreeMeshGenerator;

/***/ }),
/* 205 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.ThreeNodeId = exports.ThreeNode = undefined;
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };
	
	var _config = __webpack_require__(18);
	
	var _lang = __webpack_require__(4);
	
	var _SceneNode2 = __webpack_require__(24);
	
	var _SceneNode3 = _interopRequireDefault(_SceneNode2);
	
	var _ThreeCamera = __webpack_require__(32);
	
	var _ThreeCamera2 = _interopRequireDefault(_ThreeCamera);
	
	var _ThreeMeshGenerator = __webpack_require__(204);
	
	var _ThreeMeshGenerator2 = _interopRequireDefault(_ThreeMeshGenerator);
	
	var _ThreeMergeNode = __webpack_require__(203);
	
	var _ThreeMergeNode2 = _interopRequireDefault(_ThreeMergeNode);
	
	var _LayerGroup = __webpack_require__(43);
	
	var _LayerGroup2 = _interopRequireDefault(_LayerGroup);
	
	var _StyleUtil = __webpack_require__(19);
	
	var _StyleUtil2 = _interopRequireDefault(_StyleUtil);
	
	var _three = __webpack_require__(2);
	
	var THREE = _interopRequireWildcard(_three);
	
	var _stats = __webpack_require__(131);
	
	var _stats2 = _interopRequireDefault(_stats);
	
	var _dom = __webpack_require__(11);
	
	var _SceneAnimation = __webpack_require__(200);
	
	var _jsts = __webpack_require__(5);
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	// import MergeManager from './merge/MergeManager';
	
	// import ThreeMergeDataProvider from './merge/ThreeMergeDataProvider';
	// import { PolygonMateRule, PolygonLightMateRule, PolygonLineMateRule, MultiMateRule } from './merge/MergeMateRule';
	
	
	/**
	 * Default id of ThreeNode.
	 * @ignore
	 * @type {Number}
	 */
	var ThreeNodeId = -1;
	
	/**
	 * A ThreeNode is a specified SceneNode with threejs scene.
	 * @ignore
	 * @extends {SceneNode}
	 */
	
	var ThreeNode = function (_SceneNode) {
	  _inherits(ThreeNode, _SceneNode);
	
	  /**
	   * Constructor.
	   * @param  {Number} sceneId Scene id.
	   */
	  function ThreeNode(sceneId) {
	    _classCallCheck(this, ThreeNode);
	
	    var _this = _possibleConstructorReturn(this, (ThreeNode.__proto__ || Object.getPrototypeOf(ThreeNode)).call(this, sceneId));
	
	    _this._scene = new THREE.Scene();
	    _this._groupLayers = {};
	    _this._groups = {};
	    _this._meshMapping = {};
	    _this._sceneAnimationManager = new _SceneAnimation.SceneAnimationManager();
	
	    // const polygonMateRule = new PolygonMateRule();
	    // const polygonLightMateRule = new PolygonLightMateRule();
	    // const polygonLineMateRule = new PolygonLineMateRule();
	    // const multiMateRule = new MultiMateRule([polygonMateRule, polygonLightMateRule, polygonLineMateRule]);
	    // this._mergeManger = new MergeManager();
	    // this._mergeManger.addMateRule(multiMateRule);
	
	    _this._addLayerToGroup = _this._preAddToGroup.bind(_this);
	    _this._removeLayerToGroup = _this._preRemoveToGroup.bind(_this);
	    _this._addLayer = _this._addLayer.bind(_this);
	    _this._removeLayer = _this._removeLayer.bind(_this);
	    _this._addFeature = _this._addSceneByFeature.bind(_this);
	    _this._updateFeature = _this._updateSceneByFeature.bind(_this);
	    _this._removeFeature = _this._removeSceneByFeature.bind(_this);
	    _this._onSceneChange = _this._parseSceneChange.bind(_this);
	    _this._onGetAABB = _this._onGetAABB.bind(_this);
	    return _this;
	  }
	
	  _createClass(ThreeNode, [{
	    key: '_addLayer',
	    value: function _addLayer(mapView, layer) {
	      var _this2 = this;
	
	      if (layer instanceof _LayerGroup2.default) {
	        layer.on('addToGroup', this._addLayerToGroup);
	        layer.on('removeToGroup', this._removeLayerToGroup);
	        layer.foreach(function (name, l) {
	          _this2._preAddToGroup(layer, l);
	        });
	
	        return;
	      }
	      this.addLayer(layer);
	    }
	  }, {
	    key: '_removeLayer',
	    value: function _removeLayer(mapView, layer) {
	      var _this3 = this;
	
	      if (layer instanceof _LayerGroup2.default) {
	        layer.off('addToGroup', this._addLayerToGroup);
	        layer.off('removeToGroup', this._removeLayerToGroup);
	        layer.foreach(function (name, l) {
	          _this3._preRemoveToGroup(layer, l);
	        });
	
	        return;
	      }
	      this.removeLayer(layer);
	    }
	  }, {
	    key: '_onGetAABB',
	    value: function _onGetAABB(layer, feature, outBox) {
	      var mesh = this._findMesh(layer, feature);
	
	      if (!mesh) {
	        throw new Error('ThreeNode#_onGetAABB: Mesh not found');
	      }
	
	      var _setFromObject = new THREE.Box3().setFromObject(mesh),
	          min = _setFromObject.min,
	          max = _setFromObject.max;
	
	      outBox.push(new _jsts.geom.Coordinate(min.x, min.y, min.z), new _jsts.geom.Coordinate(max.x, max.y, max.z));
	    }
	
	    /**
	     * This function will be called when being added to a sceneManager.
	     * @ignore
	     * @override
	     * @param  {SceneManager} sceneManager SceneManager.
	     * @return {undefined}
	     */
	
	  }, {
	    key: 'onAdd',
	    value: function onAdd(sceneManager) {
	      var engine = sceneManager.mapView.engine;
	
	      _get(ThreeNode.prototype.__proto__ || Object.getPrototypeOf(ThreeNode.prototype), 'onAdd', this).call(this, sceneManager);
	      this._mergeNode = new _ThreeMergeNode2.default(sceneManager);
	      this._targetRenderer = engine.getRenderer(sceneManager.mapView);
	      this._sceneManager.mapView.on('addLayer', this._addLayer);
	      this._sceneManager.mapView.on('removeLayer', this._removeLayer);
	      this._sceneManager.on('onSceneChange', this._onSceneChange);
	      this._sceneManager.on('onGetAABB', this._onGetAABB);
	
	      if (_config.isDev) {
	        var container = sceneManager.mapView.container;
	
	        this._stats = new _stats2.default();
	        _dom.DOMUtils.addClass(this._stats.dom, 'ngr-stats');
	        container.appendChild(this._stats.dom);
	      }
	    }
	
	    /**
	     * This function will be called when being removed from a sceneManager.
	     * @ignore
	     * @override
	     * @param  {SceneManager} sceneManager SceneManager.
	     * @return {undefined}
	     */
	
	  }, {
	    key: 'onRemove',
	    value: function onRemove(sceneManager) {
	      this._mergeNode.destroy();
	      this._mergeNode = null;
	      this._sceneManager.mapView.off('addLayer', this._addLayer);
	      this._sceneManager.mapView.off('removeLayer', this._removeLayer);
	      this._sceneManager.off('onSceneChange', this._onSceneChange);
	      this._sceneManager.off('onGetAABB', this._onGetAABB);
	
	      _get(ThreeNode.prototype.__proto__ || Object.getPrototypeOf(ThreeNode.prototype), 'onRemove', this).call(this, sceneManager);
	    }
	
	    /**
	     * Add a scene to this node.
	     * @override
	     * @param {SceneNode|THREE.Object3D} scene SceneNode.
	     * @return {undefined}
	     */
	
	  }, {
	    key: 'add',
	    value: function add(scene) {
	      if (scene instanceof _SceneNode3.default) {
	        _get(ThreeNode.prototype.__proto__ || Object.getPrototypeOf(ThreeNode.prototype), 'add', this).call(this, scene);
	      }
	      if (scene instanceof _ThreeCamera2.default) {
	        this._camera = scene.camera;
	        this._scene.children.unshift(this._camera);
	      } /* else {
	         this._scene.add(scene);
	        }*/
	    }
	
	    /**
	     * Traverse the features of the passed layer and add scenes to this node by above features.
	     * @param {FeatureLayer} layer Layer.
	     * @return {ThreeNode}         this.
	     */
	
	  }, {
	    key: 'addLayer',
	    value: function addLayer(layer) {
	      var _this4 = this;
	
	      if (!this.hasLayer(layer)) {
	        // if (layer instanceof LayerGroup) {
	        //   layer.foreach((name, l) => {
	        //     this._preAddToGroup(layer, l);
	        //     this.addLayer(l);
	        //   });
	        // } else {
	        layer.on('addFeature', this._addFeature);
	        layer.on('updateFeature', this._updateFeature);
	        layer.on('removeFeature', this._removeFeature);
	        _ThreeMeshGenerator2.default.beginLayerCount(layer);
	        layer.visit(function (feature, style) {
	          _this4._addSceneByFeature(layer, feature, style, false);
	        });
	        _ThreeMeshGenerator2.default.resetLayer(layer);
	        if (this._mergeNode) {
	          // const pGroupId = this._getPgroupByLayer(layer);
	          this._mergeNode.update(layer.id);
	        }
	        // }
	      }
	      return this;
	    }
	  }, {
	    key: '_preAddToGroup',
	    value: function _preAddToGroup(gLayer, layer) {
	      var gGroup = this._groups[gLayer.id];
	      var groupLayers = this._groupLayers[gLayer.id];
	
	      if (!gGroup) {
	        gGroup = new THREE.Group();
	        this._groups[gLayer.id] = gGroup;
	        if (gLayer.height) {
	          gGroup.position.setZ(gLayer.height);
	        }
	        this._scene.add(gGroup);
	      }
	      if (!groupLayers) {
	        groupLayers = [];
	        this._groupLayers[gLayer.id] = groupLayers;
	      }
	      groupLayers.push(layer.id);
	      this.addLayer(layer);
	    }
	  }, {
	    key: '_preRemoveToGroup',
	    value: function _preRemoveToGroup(gLayer, layer) {
	      var gGroup = this._groups[gLayer.id];
	
	      if (gGroup) {
	        var groupLayers = this._groupLayers[gLayer.id];
	        var index = groupLayers.indexOf(layer.id);
	
	        if (index !== -1) {
	          groupLayers.splice(index, 1);
	        }
	        if (groupLayers.length === 0) {
	          this._scene.remove(gGroup);
	          delete this._groups[gLayer.id];
	          delete this._groupLayers[gLayer.id];
	        }
	        this.removeLayer(layer);
	      }
	    }
	
	    /**
	     * Traverse the features of the passed layer and remove scenes from this node by above features.
	     * @param {FeatureLayer} layer Layer.
	     * @return {ThreeNode}         this.
	     */
	
	  }, {
	    key: 'removeLayer',
	    value: function removeLayer(layer) {
	      var _this5 = this;
	
	      if (this.hasLayer(layer)) {
	        var group = this._groups[layer.id];
	
	        layer.off('addFeature', this._addFeature);
	        layer.off('updateFeature', this._updateFeature);
	        layer.off('removeFeature', this._removeFeature);
	        _ThreeMeshGenerator2.default.removeLayerCount(layer);
	        if (group && group.parent) {
	          group.parent.remove(group);
	        }
	        if (this._mergeNode && this._mergeNode.hasLayer(layer.id)) {
	          this._mergeNode.removeByLayer(layer, layer.id);
	        }
	        layer.visit(function (feature) {
	          _this5._removeSceneByFeature(layer, feature, false);
	        });
	        if (this._mergeManger) {
	          this._mergeManger.updateAll();
	        }
	        delete this._groups[layer.id];
	      }
	      return this;
	    }
	
	    /**
	     * Check whether this node has the passed layer or not.
	     * @param  {Layer}  layer Layer.
	     * @return {Boolean}      Check result.
	     */
	
	  }, {
	    key: 'hasLayer',
	    value: function hasLayer(layer) {
	      return !!layer && (layer in this._groups || layer.id in this._groups);
	    }
	
	    /**
	     * Render this node.
	     * @ignore
	     * @override
	     * @return {undefined}
	     */
	
	  }, {
	    key: 'render',
	    value: function render() {
	      _get(ThreeNode.prototype.__proto__ || Object.getPrototypeOf(ThreeNode.prototype), 'render', this).call(this);
	      if (this._targetRenderer && this._camera) {
	        if (!this._targetRenderer.autoClear) {
	          this._targetRenderer.clear();
	        }
	        this._targetRenderer.render(this._scene, this._camera);
	
	        if (_config.isDev) {
	          this._stats.update();
	        }
	      }
	    }
	
	    /**
	     * Add scene by feature.
	     * @param {Layer}   layer          Layer.
	     * @param {Feature} feature        Feature.
	     * @param {Style}   style          Style.
	     * @param {Boolean} isMergeUpdate  Boolean.
	     * @return {undefined}
	     */
	
	  }, {
	    key: '_addSceneByFeature',
	    value: function _addSceneByFeature(layer, feature, style) {
	      var isMergeUpdate = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
	
	      var id = feature.id;
	      var layerMapping = this._meshMapping[id];
	      var group = this._groups[layer.id];
	      var pGroupId = null;
	      var node = null;
	
	      if ((0, _lang.isBlank)(id)) {
	        console.warn('error feature\'s id');
	
	        return;
	      }
	      if (layerMapping && layerMapping[layer.id]) {
	        return;
	      }
	
	      pGroupId = this._getPgroupByLayer(layer);
	      if (!group) {
	        group = new THREE.Group();
	        this._groups[layer.id] = group;
	        if (layer.height) {
	          group.position.setZ(layer.height);
	        }
	        if (pGroupId !== -1) {
	          this._groups[pGroupId].add(group);
	        } else {
	          this._scene.add(group);
	        }
	      }
	
	      node = _ThreeMeshGenerator2.default.generator(this._sceneManager, layer, feature, style);
	      if (node) {
	        // const provider = new ThreeMergeDataProvider(node);
	        // const mergeResult = this._mergeManger.merge(feature, style, provider);
	        // if (mergeResult.merged.length > 0) {
	        //   for (const mergeNode of mergeResult.merged) {
	        //     group.add(mergeNode);
	        //   }
	        // }
	        // if (mergeResult.mergeType === 2) {
	        //   group.add(node);
	        //   if (!layerMapping) {
	        //     layerMapping = {};
	        //     layerMapping.size = 0;
	        //     this._meshMapping[id] = layerMapping;
	        //   }
	        //   this._meshMapping[id][layer.name] = node.id;
	        //   layerMapping.size++;
	        // }
	        var mergeNode = this._mergeNode.merge(feature, style, node, layer.id, this._groups[layer.id] || this._scene);
	        // if (mergeNode) {
	        //   group.add(mergeNode);
	        // } else {
	        //   group.add(node);
	        // }
	        // if (mergeNode === node) {
	        if (mergeNode !== 0 && isMergeUpdate) {
	          this._mergeNode.update(layer.id);
	        }
	        if (mergeNode !== 2) {
	          group.add(node);
	          if (!layerMapping) {
	            layerMapping = {};
	            layerMapping.size = 0;
	            this._meshMapping[id] = layerMapping;
	          }
	          this._meshMapping[id][layer.id] = node.id;
	          layerMapping.size++;
	        }
	
	        if (style.type() === 'Polygon' && style.clickable) {
	          if (mergeNode === 2) {
	            // polygon was merged
	            this._sceneManager._octreeManager.add(node, layer.id, id, { layerGroupId: layer.parent.id, sceneGroupId: group.parent.id });
	          } else {
	            this._sceneManager._octreeManager.add(node, layer.id, id);
	          }
	        }
	      }
	    }
	  }, {
	    key: '_getPgroupByLayer',
	    value: function _getPgroupByLayer(layer) {
	      for (var key in this._groupLayers) {
	        var pGroup = this._groupLayers[key];
	
	        if (pGroup.indexOf(layer.id) !== -1) {
	          return key;
	        }
	      }
	
	      return -1;
	    }
	
	    /**
	     * Update scene by feature.
	     * @param {Layer}   layer   Layer.
	     * @param {Feature} feature Feature.
	     * @param {Style}   style   Style.
	     * @return {undefined}
	     */
	
	  }, {
	    key: '_updateSceneByFeature',
	    value: function _updateSceneByFeature(layer, feature, style) {
	      var id = feature.id;
	
	      if (id) {
	        var group = this._groups[layer.id];
	        var layerMapping = this._meshMapping[id];
	
	        if (group && layerMapping) {
	          var meshId = layerMapping[layer.id];
	          var mesh = group.getObjectById(meshId);
	          var geometry = feature.geometry;
	
	          if (style.type() === 'Icon') {
	            mesh.position.set(geometry.getCoordinates()[0], geometry.getCoordinates()[1], 0);
	          }
	        }
	      }
	    }
	
	    /**
	     * Remove scene by feature.
	     * @param {Layer}   layer          Layer.
	     * @param {Feature} feature        Feature.
	     * @param {Boolean} isClear        isClear.
	     * @param {Boolean} isMergeUpdate  Boolean.
	     * @return {undefined}
	     */
	
	  }, {
	    key: '_removeSceneByFeature',
	    value: function _removeSceneByFeature(layer, feature, isClear) {
	      var isMergeUpdate = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
	
	      var id = feature.id;
	      var group = this._groups[layer.id];
	      var layerMapping = this._meshMapping[id];
	      var mesh = null;
	
	      if ((0, _lang.isBlank)(id)) {
	        return;
	      }
	
	      if (group && layerMapping) {
	        var meshId = layerMapping[layer.id];
	
	        mesh = group.getObjectById(meshId);
	        if (mesh) {
	          group.remove(mesh);
	          if (mesh.proxy) {
	            delete mesh.proxy;
	          }
	          if (mesh && mesh.geometry) {
	            mesh.geometry.dispose();
	          }
	          this._sceneManager.mapView.collisionSceneManager.remove(feature);
	          delete layerMapping[layer.id];
	          layerMapping.size--;
	          if (layerMapping.size === 0) {
	            delete this._meshMapping[id];
	          }
	        }
	      }
	      // to optimize
	      this._sceneManager._octreeManager.removeByLayerAndFeature(layer.id, id);
	      if (this._mergeNode && this._mergeNode.has(id, mesh)) {
	        this._mergeNode.remove(id, mesh);
	        if (isMergeUpdate) {
	          // const pGroupId = this._getPgroupByLayer(layer);
	          this._mergeNode.update(layer.id);
	        }
	      }
	      if (this._mergeManger) {
	        this._mergeManger.remove(feature, isClear);
	      }
	    }
	
	    /**
	     * Find mesh through layer and feature.
	     * @private
	     * @param  {Layer|String} layer   A layer object or just a layer name.
	     * @param  {Feature}      feature Feature.
	     * @return {THREE.Mesh}           Found mesh.
	     */
	
	  }, {
	    key: '_findMesh',
	    value: function _findMesh(layer, feature) {
	      var layerName = (0, _lang.isString)(layer) ? layer : layer.id;
	      var group = this._groups[layerName];
	      var mesh = void 0;
	
	      if ((0, _lang.isBlank)(feature) || (0, _lang.isArray)(feature)) {
	        return group;
	      }
	
	      if ((0, _lang.isNumber)(feature.id)) {
	        var layerMapping = this._meshMapping[feature.id];
	
	        if (layerMapping) {
	          var meshId = layerMapping[layerName];
	
	          if (group && meshId) {
	            mesh = group.getObjectById(meshId);
	          }
	        }
	      }
	
	      return mesh;
	    }
	
	    /**
	     * Handler of onSceneChange event of SceneManager.
	     * @private
	     * @param  {String}        type     Subhandler type.
	     * @param  {Layer|String}  layer    Layer.
	     * @param  {Feature|Array} features A feature or an features array.
	     * @param  {Obejct}        value    Subhandler parameter.
	     * @return {ThreeNode}              this.
	     */
	
	  }, {
	    key: '_parseSceneChange',
	    value: function _parseSceneChange(type, layer, features) {
	      var callMethod = void 0;
	
	      for (var _len = arguments.length, value = Array(_len > 3 ? _len - 3 : 0), _key = 3; _key < _len; _key++) {
	        value[_key - 3] = arguments[_key];
	      }
	
	      switch (type) {
	        case 'scale':
	          callMethod = this._setMeshScale;
	          break;
	        case 'quickPosition':
	          callMethod = this._quickSetMeshPosition;
	          break;
	        case 'position':
	          callMethod = this._setMeshPosition;
	          break;
	        case 'rotation':
	          callMethod = this._setMeshRotation;
	          break;
	        case 'visible':
	          callMethod = this._setMeshVisible;
	          break;
	        case 'color':
	          callMethod = this._setMeshColor;
	          break;
	        case 'colorResetting':
	          callMethod = this._setMeshColor;
	          break;
	        case 'highlight':
	          callMethod = this._hightlight;
	          break;
	        case 'opacity':
	          callMethod = this._setOpacity;
	          break;
	        case 'depthTest':
	          callMethod = this._setDepthTest;
	          break;
	        case 'styleResetting':
	          this._resetStyle.apply(this, [layer, features].concat(value));
	          return this;
	        default:
	          break;
	      }
	      if ((0, _lang.isArray)(features)) {
	        for (var _iterator = features, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
	          var _ref;
	
	          if (_isArray) {
	            if (_i >= _iterator.length) break;
	            _ref = _iterator[_i++];
	          } else {
	            _i = _iterator.next();
	            if (_i.done) break;
	            _ref = _i.value;
	          }
	
	          var feature = _ref;
	
	          this._callMeshValue.apply(this, [type, layer, feature, callMethod].concat(value));
	        }
	      } else {
	        this._callMeshValue.apply(this, [type, layer, features, callMethod].concat(value));
	      }
	
	      return this;
	    }
	  }, {
	    key: '_callMeshValue',
	    value: function _callMeshValue(type, layer, feature, callMethod) {
	      var mesh = this._findMesh(layer, feature);
	
	      for (var _len2 = arguments.length, value = Array(_len2 > 4 ? _len2 - 4 : 0), _key2 = 4; _key2 < _len2; _key2++) {
	        value[_key2 - 4] = arguments[_key2];
	      }
	
	      if (type === 'colorResetting') {
	        value[0] = this._getColorByFeature(layer, feature);
	      }
	      if (mesh) {
	        callMethod.call.apply(callMethod, [this, mesh].concat(value));
	      }
	      // if (feature && this._mergeNode && this._mergeNode.has(feature, mesh)) {
	      //   this._mergeNode.setValue(feature.id, type, ...value);
	      // }
	    }
	  }, {
	    key: '_resetStyle',
	    value: function _resetStyle(layer, features, style) {
	      var _this6 = this;
	
	      if (!layer || !style) {
	        return;
	      }
	
	      if ((0, _lang.isEmpty)(features)) {
	        layer.visit(function (feature) {
	          _this6._removeSceneByFeature(layer, feature, false);
	          _this6._addSceneByFeature(layer, feature, style);
	        });
	      } else if (features.length) {
	        for (var _iterator2 = features, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator]();;) {
	          var _ref2;
	
	          if (_isArray2) {
	            if (_i2 >= _iterator2.length) break;
	            _ref2 = _iterator2[_i2++];
	          } else {
	            _i2 = _iterator2.next();
	            if (_i2.done) break;
	            _ref2 = _i2.value;
	          }
	
	          var feature = _ref2;
	
	          this._removeSceneByFeature(layer, feature, false);
	          this._addSceneByFeature(layer, feature, style);
	        }
	      } else {
	        this._removeSceneByFeature(layer, features, false);
	        this._addSceneByFeature(layer, features, style);
	      }
	    }
	
	    /**
	     * Set mesh position.
	     * @private
	     * @param {THREE.Mesh}  mesh   Mesh.
	     * @param {Array}       value  Positoin.
	     * @return {THREE.Vector3}     Positoin.
	     */
	
	  }, {
	    key: '_quickSetMeshPosition',
	    value: function _quickSetMeshPosition(mesh, value) {
	      var destPosition = new THREE.Vector3(value[0], value[1], value[2]);
	
	      if (mesh.type === 'MeshProxy') {
	        mesh.proxyPosition.copy(destPosition);
	      } else {
	        mesh.position.copy(destPosition);
	      }
	
	      return destPosition;
	    }
	
	    /**
	     * Set mesh position and update octree.
	     * @private
	     * @param {THREE.Mesh}  mesh   Mesh.
	     * @param {Array}       value  Positoin.
	     * @return {undefined}
	     */
	
	  }, {
	    key: '_setMeshPosition',
	    value: function _setMeshPosition(mesh, value) {
	      var octreeManager = this._sceneManager._octreeManager;
	      var rebuildFlag = false;
	
	      this._quickSetMeshPosition(mesh, value);
	      if (mesh instanceof THREE.Group) {
	        var vGroup = octreeManager.virtualGroups[octreeManager.groupMapping[mesh.id]];
	
	        if (vGroup) {
	          var x = value[0];
	          var y = value[1];
	          var z = value[2];
	
	          rebuildFlag = true;
	          if (vGroup.type === 'MeshProxy') {
	            vGroup.proxyPosition.set(x, y, z);
	          } else {
	            vGroup.position.set(x, y, z);
	          }
	          // vGroup.matrixWorldNeedsUpdate = true;
	          vGroup.updateMatrixWorld();
	        }
	      } else if (octreeManager.has(mesh._layerId, mesh._sceneId)) {
	        rebuildFlag = true;
	      }
	
	      if (rebuildFlag) {
	        octreeManager.rebuild();
	      }
	    }
	
	    /**
	     * Set mesh scale.
	     * @private
	     * @param {THREE.Mesh}  mesh   Mesh.
	     * @param {Array}       value  Scale.
	     * @return {undefined}
	     */
	
	  }, {
	    key: '_setMeshScale',
	    value: function _setMeshScale(mesh, value) {
	      if (mesh.type === 'MeshProxy') {
	        mesh.proxyScale.set(value[0], value[1], value[2]);
	      } else {
	        mesh.scale.set(value[0], value[1], value[2]);
	      }
	    }
	
	    /**
	     * Set mesh rotation.
	     * @private
	     * @param {THREE.Mesh}  mesh   Mesh.
	     * @param {Array}       value  rotation.
	     * @return {undefined}
	     */
	
	  }, {
	    key: '_setMeshRotation',
	    value: function _setMeshRotation(mesh, value) {
	      if (mesh.type === 'MeshProxy') {
	        mesh.proxyRotation.set(value[0], value[1], value[2]);
	      } else {
	        mesh.rotation.set(value[0], value[1], value[2]);
	      }
	    }
	
	    /**
	     * Set mesh visibility.
	     * @private
	     * @param {THREE.Mesh}  mesh   Mesh.
	     * @param {Boolean}     value  visible.
	     * @return {undefined}
	     */
	
	  }, {
	    key: '_setMeshVisible',
	    value: function _setMeshVisible(mesh, value) {
	      mesh.visible = value;
	      if (mesh instanceof THREE.Group) {
	        var octreeManager = this._sceneManager._octreeManager;
	        var vGroup = octreeManager.virtualGroups[octreeManager.groupMapping[mesh.id]];
	
	        if (vGroup) {
	          vGroup.visible = value;
	        }
	      }
	    }
	
	    /**
	     * Get mesh color by feature style.
	     * @private
	     * @param  {Layer|String} layer   A layer object or just a layer name.
	     * @param  {Feature}      feature Feature.
	     * @return {NUmber}               Color
	     */
	
	  }, {
	    key: '_getColorByFeature',
	    value: function _getColorByFeature(layer, feature) {
	      if (!feature) {
	        return null;
	      }
	
	      var tempLayer = (0, _lang.isString)(layer) ? this._sceneManager.mapView.getLayer(layer) : layer;
	      var style = tempLayer.renderer.getStyle(feature);
	
	      return style.color;
	    }
	
	    /**
	     * Set mesh color.
	     * @private
	     * @param {THREE.Mesh}  mesh     Mesh.
	     * @param {Number}      value    Color.
	     * @param {Boolean}     aOptions Animation options.
	     * @return {ThreeNode}           this.
	     */
	
	  }, {
	    key: '_setMeshColor',
	    value: function _setMeshColor(mesh, value, aOptions) {
	      if (mesh instanceof THREE.Group) {
	        return this;
	      }
	
	      var parseColor = _StyleUtil2.default.parseColor(value);
	
	      mesh.material.needsUpdate = true;
	      if (aOptions) {
	        this._sceneAnimationManager.getAnimation('color').start(mesh, parseColor, aOptions.blink, aOptions.duration, aOptions.repeat);
	      } else {
	        this._sceneAnimationManager.getAnimation('color').stop();
	        mesh.material.color = new THREE.Color().set(parseColor);
	      }
	
	      return this;
	    }
	
	    /**
	     * Hightlight mesh.
	     * @private
	     * @param  {THREE.Mesh} mesh  Mesh.
	     * @param  {Number}     value Hightlight scalar.
	     * @return {ThreeNode}        this.
	     */
	
	  }, {
	    key: '_hightlight',
	    value: function _hightlight(mesh, value) {
	      if (mesh instanceof THREE.Group) {
	        return this;
	      }
	
	      var scalar = (0, _lang.isNumber)(value) ? value : 1.414;
	      var originColor = mesh.material.color;
	      var r = originColor.r * scalar > 1 ? 1 : originColor.r * scalar;
	      var g = originColor.g * scalar > 1 ? 1 : originColor.g * scalar;
	      var b = originColor.b * scalar > 1 ? 1 : originColor.b * scalar;
	      var color = new THREE.Color(r, g, b);
	
	      mesh.material.color = color;
	      mesh.material.needsUpdate = true;
	
	      return this;
	    }
	
	    /**
	     * Set mesh opacity.
	     * @private
	     * @param {Three.Mesh} mesh     Mesh.
	     * @param {Number}     value    Opacity.
	     * @param {Object}     aOptions Animation options.
	     * @return {ThreeNode}          this.
	     */
	
	  }, {
	    key: '_setOpacity',
	    value: function _setOpacity(mesh, value, aOptions) {
	      var _this7 = this;
	
	      if (mesh instanceof THREE.Group) {
	        // for (const m of mesh.children) {
	        //   this._setOpacity(m, value, aOptions);
	        // }
	        // mesh.traverse((node) => {
	        //   if (node.material) {
	        //     this._setOpacity(node, value, aOptions);
	        //   }
	        // });
	        mesh.children.forEach(function (node) {
	          _this7._setOpacity(node, value, aOptions);
	        }, this);
	
	        return this;
	      }
	      if (mesh && mesh.material && (0, _lang.isNumber)(value) && value >= 0 && value <= 1) {
	        mesh.material.transparent = true;
	        mesh.destOpacity = value;
	        if (aOptions) {
	          this._sceneAnimationManager.getAnimation('opacity').start(mesh, value, aOptions.blink, aOptions.duration, aOptions.repeat);
	        } else {
	          mesh.material.opacity = value;
	          if (value === 1) {
	            mesh.material.transparent = false;
	          }
	        }
	      }
	
	      return this;
	    }
	  }, {
	    key: '_setDepthTest',
	    value: function _setDepthTest(mesh, depthTest) {
	      var _this8 = this;
	
	      if (mesh instanceof THREE.Group) {
	        // mesh.traverse(node => {
	        //   this._setDepthTest(node, depthTest);
	        // });
	        mesh.children.forEach(function (node) {
	          _this8._setDepthTest(node, depthTest);
	        }, this);
	
	        return this;
	      }
	
	      if (mesh && mesh.material && (0, _lang.isBoolean)(depthTest)) {
	        mesh.material.depthTest = depthTest;
	      }
	
	      return this;
	    }
	  }, {
	    key: 'renderScene',
	    get: function get() {
	      return this._scene;
	    }
	  }]);
	
	  return ThreeNode;
	}(_SceneNode3.default);
	
	exports.ThreeNode = ThreeNode;
	exports.ThreeNodeId = ThreeNodeId;

/***/ }),
/* 206 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _SceneGenerator2 = __webpack_require__(201);
	
	var _SceneGenerator3 = _interopRequireDefault(_SceneGenerator2);
	
	var _ThreeNode = __webpack_require__(205);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var ThreeSceneGenerator = function (_SceneGenerator) {
	  _inherits(ThreeSceneGenerator, _SceneGenerator);
	
	  function ThreeSceneGenerator() {
	    _classCallCheck(this, ThreeSceneGenerator);
	
	    var _this = _possibleConstructorReturn(this, (ThreeSceneGenerator.__proto__ || Object.getPrototypeOf(ThreeSceneGenerator)).call(this));
	
	    _this._threeNode = new _ThreeNode.ThreeNode(_ThreeNode.ThreeNodeId);
	    return _this;
	  }
	
	  _createClass(ThreeSceneGenerator, [{
	    key: 'generator',
	    value: function generator(layer, mapView) {
	      if (!this._threeNode._sceneManager) {
	        this._threeNode._sceneManager = mapView.sceneManager;
	      }
	      // this._threeNode.addLayer(layer);
	      return this._threeNode;
	    }
	  }, {
	    key: 'find',
	    value: function find(layer) {
	      // eslint-disable-line no-unused-vars
	      return null;
	    }
	  }]);
	
	  return ThreeSceneGenerator;
	}(_SceneGenerator3.default);
	
	exports.default = ThreeSceneGenerator;

/***/ }),
/* 207 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _three = __webpack_require__(2);
	
	var THREE = _interopRequireWildcard(_three);
	
	var _rbush = __webpack_require__(250);
	
	var _rbush2 = _interopRequireDefault(_rbush);
	
	var _priorityqueuejs = __webpack_require__(89);
	
	var _priorityqueuejs2 = _interopRequireDefault(_priorityqueuejs);
	
	var _CollisionAnimation = __webpack_require__(25);
	
	var _FeatureLayer = __webpack_require__(36);
	
	var _FeatureLayer2 = _interopRequireDefault(_FeatureLayer);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var priorityComparator = function priorityComparator(a, b) {
	  return b.priority - a.priority;
	};
	
	/**
	 * 用于管理渲染场景之间是否进行碰撞检测及碰撞检测效果的类。
	 */
	
	var CollisionSceneManager = function () {
	  function CollisionSceneManager() {
	    _classCallCheck(this, CollisionSceneManager);
	
	    this._rbush = null;
	    this._priorityQueue = null;
	    this._features = {};
	    this._collsionFeatures = {};
	    this._collisionDetectionScenes = {};
	    this._visibleScenes = {};
	    this._animators = {};
	    this._animation = _CollisionAnimation.CAType.Default;
	  }
	
	  /**
	   * activeCamera getter.
	   * @ignore
	   * @return {CameraNode} Current active camera.
	   */
	
	
	  _createClass(CollisionSceneManager, [{
	    key: 'add',
	
	
	    /**
	     * 添加需要进行碰撞检测的渲染场景。
	     * @ignore
	     * @param {NGR.data.Feature} feature         Feature对象。
	     * @param {SceneNode}        scene           场景ID。
	     * @param {Boolean}          isAlwaysVisible 如果渲染场景需要一直显示，请设置true。
	     * @param {Bollean}          needUpdate      是否需要在添加渲染场景之后做一次碰撞检测。
	     * @return {CollisionSceneManager}           this。
	     */
	    value: function add(feature, scene) {
	      var isAlwaysVisible = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
	      var needUpdate = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
	
	      if (scene instanceof THREE.Group && !scene.getAABB) {
	        for (var _iterator = scene.children, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
	          var _ref;
	
	          if (_isArray) {
	            if (_i >= _iterator.length) break;
	            _ref = _iterator[_i++];
	          } else {
	            _i = _iterator.next();
	            if (_i.done) break;
	            _ref = _i.value;
	          }
	
	          var child = _ref;
	
	          this.add(feature, child, isAlwaysVisible);
	        }
	        if (needUpdate) {
	          this.updateCollision();
	        }
	        return this;
	      }
	
	      var scenes = this._collisionDetectionScenes[feature.id];
	      if (!scenes) {
	        scenes = [];
	        this._collisionDetectionScenes[feature.id] = scenes;
	      }
	      this._features[feature.id] = feature;
	      this._collsionFeatures[feature.id] = feature;
	      scenes.push(scene);
	      // scene.visible = false;
	
	      if (needUpdate) {
	        this.updateCollision();
	      }
	      return this;
	    }
	
	    /**
	     * 隐藏feature对应的scene。
	     * @ignore
	     * @param  {NGR.data.Feature|NGR.data.FeatureCollection} feature    Feature对象。
	     * @param  {Boolean}                                     needRemove 如果在隐藏的同时需要删除渲染场景，设置为true。
	     * @return {CollisionSceneManager}                                  this.
	     */
	
	  }, {
	    key: 'hide',
	    value: function hide(feature) {
	      var needRemove = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
	
	      if (!feature) {
	        return this;
	      }
	
	      if (feature.features) {
	        for (var _iterator2 = feature.features, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator]();;) {
	          var _ref2;
	
	          if (_isArray2) {
	            if (_i2 >= _iterator2.length) break;
	            _ref2 = _iterator2[_i2++];
	          } else {
	            _i2 = _iterator2.next();
	            if (_i2.done) break;
	            _ref2 = _i2.value;
	          }
	
	          var tempFeature = _ref2;
	
	          this.hide(tempFeature, needRemove);
	        }
	        return this;
	      }
	
	      var hiddenScenes = this._collisionDetectionScenes[feature.id];
	      if (hiddenScenes) {
	        for (var _iterator3 = hiddenScenes, _isArray3 = Array.isArray(_iterator3), _i3 = 0, _iterator3 = _isArray3 ? _iterator3 : _iterator3[Symbol.iterator]();;) {
	          var _ref3;
	
	          if (_isArray3) {
	            if (_i3 >= _iterator3.length) break;
	            _ref3 = _iterator3[_i3++];
	          } else {
	            _i3 = _iterator3.next();
	            if (_i3.done) break;
	            _ref3 = _i3.value;
	          }
	
	          var hiddenScene = _ref3;
	
	          if (hiddenScene) {
	            hiddenScene.makeCollision(true);
	            if (needRemove) {
	              this.remove(feature);
	            }
	          }
	        }
	      }
	      return this;
	    }
	
	    /**
	     * 将一个参与碰撞检测的渲染场景从类中删除。
	     * @ignore
	     * @param  {NGR.data.Feature} feature Feature对象。
	     * @return {CollisionSceneManager}    this。
	     */
	
	  }, {
	    key: 'remove',
	    value: function remove(feature) {
	      if (this.hasCollision(feature)) {
	        delete this._collisionDetectionScenes[feature.id];
	      }
	      if (this.hasVisible(feature)) {
	        delete this._visibleScenes[feature.id];
	      }
	      delete this._features[feature.id];
	      delete this._collsionFeatures[feature.id];
	      return this;
	    }
	
	    /**
	     * Set the enable of a feature.
	     * @ignore
	     * @param  {NGR.data.Feature} feature            Feature.
	     * @param  {Boolean}          [enable=true]      Enable or disable.
	     * @param  {Boolean}          [needUpdate=false] Whether need to update.
	     * @return {CollisionSceneManager}               this.
	     */
	
	  }, {
	    key: 'setEnable',
	    value: function setEnable(feature) {
	      var enable = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
	      var needUpdate = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
	
	      if (this.hasCollision(feature)) {
	        if (enable) {
	          this._collsionFeatures[feature.id] = this._features[feature.id];
	        } else {
	          delete this._collsionFeatures[feature.id];
	        }
	        if (needUpdate) {
	          this.updateCollision();
	        }
	      }
	
	      return this;
	    }
	
	    /**
	     * handle a featureLayer.
	     * @private
	     * @param  {NGR.data.FeatureLayer} featureLayer       Feature layer.
	     * @param  {Boolean}               [enable=true]      [description]
	     * @param  {Boolean}               [needUpdate=false] Whether need to update.
	     * @return {CollisionSceneManager}                    this.
	     */
	
	  }, {
	    key: 'setFeatureLayerEnable',
	    value: function setFeatureLayerEnable(featureLayer) {
	      var _this = this;
	
	      var enable = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
	      var needUpdate = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
	
	      if (!(featureLayer instanceof _FeatureLayer2.default)) {
	        throw new Error('setFeatureLayerEnable: Invalid featureLayer');
	      }
	
	      featureLayer.visit(function (feature, style) {
	        if (style.collision) {
	          _this.setEnable(feature, enable);
	        }
	      });
	
	      if (needUpdate) {
	        this.updateCollision();
	      }
	
	      return this;
	    }
	
	    /**
	     * 判断一个渲染场景是否存在。
	     * @ignore
	     * @param  {NGR.data.Feature} feature Feature对象。
	     * @return {Boolean}                  存在返回true,否则返回false。
	     */
	
	  }, {
	    key: 'hasCollision',
	    value: function hasCollision(feature) {
	      return !!feature && feature.id in this._collisionDetectionScenes;
	    }
	
	    /**
	     * 判断scene是否存在在并未被碰撞检测列表中。
	     * @ignore
	     * @param  {NGR.data.Feature} feature Feature对象。
	     * @return {Boolean}                  存在返回true,否则返回false。
	     */
	
	  }, {
	    key: 'hasVisible',
	    value: function hasVisible(feature) {
	      return !!feature && feature.id in this._visibleScenes;
	    }
	
	    /**
	     * Check if a feature is enabled or not.
	     * @ignore
	     * @param  {NGR.data.Feature} feature Feature.
	     * @return {Boolean}                  Check result.
	     */
	
	  }, {
	    key: 'isEnabled',
	    value: function isEnabled(feature) {
	      return !!feature && feature.id in this._collsionFeatures;
	    }
	
	    /**
	     * Return a box object which can be used in rbush according passed AABB.
	     * @private
	     * @param  {Array} AABB AABB.
	     * @return {Object}     Box.
	     */
	
	  }, {
	    key: '_AABB2RbushBox',
	    value: function _AABB2RbushBox(AABB) {
	      if (!(AABB instanceof Array && AABB.length === 6)) {
	        console.warn('Invalid AABB');
	        return null;
	      }
	
	      var box = {
	        minX: AABB[0],
	        minY: AABB[1],
	        maxX: AABB[3],
	        maxY: AABB[4]
	      };
	      return box;
	    }
	
	    /**
	     * 在执行碰撞检测结果时是否增加动画。
	     * @param {NGR.scene.CAType} animation 动画类型，有Default(默认)、Opacity(透明度)两种。默认效果为不使用动画，透明度效果为碰撞对象渐变消失。
	     * @return {CollisionSceneManager}     this。
	     */
	
	  }, {
	    key: 'animation',
	    value: function animation(_animation) {
	      this._animation = _animation;
	      return this;
	    }
	
	    /**
	     * 进行一次碰撞检测。
	     * @return {CollisionSceneManager} this。
	     */
	
	  }, {
	    key: 'updateCollision',
	    value: function updateCollision() {
	      var camera = this._activeCamera;
	      if (camera) {
	        var scenes = void 0,
	            box = void 0;
	
	        this._clearAnimation();
	
	        camera.camera.updateMatrix();
	        camera.camera.updateMatrixWorld();
	        this._visibleScenes = {};
	        this._rbush = (0, _rbush2.default)();
	        this._priorityQueue = new _priorityqueuejs2.default(priorityComparator);
	        for (var featureId in this._collsionFeatures) {
	          this._priorityQueue.enq(this._collsionFeatures[featureId]);
	        }
	        while (this._priorityQueue.size()) {
	          var feature = this._priorityQueue.deq();
	          scenes = this._collisionDetectionScenes[feature.id];
	          for (var _iterator4 = scenes, _isArray4 = Array.isArray(_iterator4), _i4 = 0, _iterator4 = _isArray4 ? _iterator4 : _iterator4[Symbol.iterator]();;) {
	            var _ref4;
	
	            if (_isArray4) {
	              if (_i4 >= _iterator4.length) break;
	              _ref4 = _iterator4[_i4++];
	            } else {
	              _i4 = _iterator4.next();
	              if (_i4.done) break;
	              _ref4 = _i4.value;
	            }
	
	            var scene = _ref4;
	
	            box = this._AABB2RbushBox(scene.getAABB(camera));
	            if (!box) {
	              continue;
	            }
	            var collision = this._rbush.search(box);
	            var isCollision = false;
	            if (collision.length > 0) {
	              isCollision = true;
	            } else {
	              this._visibleScenes[scene._sceneId] = scene;
	              this._rbush.insert(box);
	              isCollision = false;
	            }
	            var isAnimation = this._animation.hasAnimation(scene);
	            if (isAnimation) {
	              var animator = this._animation.makeCollision(scene, isCollision);
	
	              this._postProcessAnimator(scene, animator);
	            } else {
	              scene.makeCollision(isCollision, isAnimation);
	            }
	          }
	        }
	        this._animation.reset(this);
	        // for (const sceneId in this._collisionDetectionScenes) {
	        //   scene = this._collisionDetectionScenes[sceneId];
	        //   box = this._AABB2RbushBox(scene.getAABB(camera));
	        //   if (box) {
	        //     const collision = this._rbush.search(box);
	        //     if (collision.length > 0) {
	        //       scene.makeCollision(true);
	        //     } else {
	        //       this._visibleScenes[scene._sceneId] = scene;
	        //       this._rbush.insert(box);
	        //       scene.makeCollision(false);
	        //     }
	        //   }
	        // }
	      }
	      return this;
	    }
	  }, {
	    key: '_postProcessAnimator',
	    value: function _postProcessAnimator(scene, animator) {
	      var _this2 = this;
	
	      if (!animator) {
	        return;
	      }
	
	      this._animators[scene.uuid] = animator;
	
	      animator.on('complete', function () {
	        delete _this2._animators[scene.uuid];
	      }).on('stop', function () {
	        delete _this2._animators[scene.uuid];
	      });
	    }
	  }, {
	    key: '_clearAnimation',
	    value: function _clearAnimation() {
	      for (var key in this._animators) {
	        var animator = this._animators[key];
	
	        animator.stop();
	      }
	
	      this._animators = {};
	    }
	
	    /**
	     * 清理所有渲染场景。
	     * @ignore
	     * @return {CollisionSceneManager} this。
	     */
	
	  }, {
	    key: 'clear',
	    value: function clear() {
	      this._rbush = null;
	      this._priorityQueue = null;
	      this._features = {};
	      this._collsionFeatures = {};
	      this._collisionDetectionScenes = {};
	      this._visibleScenes = {};
	
	      this._clearAnimation();
	
	      return this;
	    }
	  }, {
	    key: 'activeCamera',
	    get: function get() {
	      return this._activeCamera;
	    }
	
	    /**
	     * activeCamera setter.
	     * @ignore
	     * @param  {CameraNode} camera Camera node.
	     */
	    ,
	    set: function set(camera) {
	      this._activeCamera = camera;
	    }
	  }]);
	
	  return CollisionSceneManager;
	}();
	
	exports.default = CollisionSceneManager;

/***/ }),
/* 208 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.CAType = undefined;
	
	var _CollisionAnimation = __webpack_require__(25);
	
	exports.CAType = _CollisionAnimation.CAType; // import SceneManager from './SceneManager';
	// import SceneNode from './SceneNode';
	// import ThreeNode from './ThreeNode';
	// import CollisionSceneManager from './collision/CollisionSceneManager';

/***/ }),
/* 209 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _NGRObject = __webpack_require__(7);
	
	var _NGRObject2 = _interopRequireDefault(_NGRObject);
	
	var _fulltilt = __webpack_require__(105);
	
	var _fulltilt2 = _interopRequireDefault(_fulltilt);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	// eslint-disable-line no-unused-vars
	
	var manager = new _NGRObject2.default();
	
	var sensorType = {
	  compass: 'compass'
	};
	
	var compassListener = function compassListener() {
	  if (manager.orientationControl) {
	    var screenAdjustedEvent = manager.orientationControl.getScreenAdjustedEuler();
	    var alpha = screenAdjustedEvent.alpha;
	    if (alpha) {
	      manager.emit(sensorType.compass, {
	        type: sensorType.compass,
	        alpha: alpha
	      });
	    }
	  }
	};
	
	var registerListener = function registerListener(callback, type) {
	  var listeners = manager.listeners(type);
	  switch (type) {
	    case sensorType.compass:
	      {
	        if (window.FULLTILT && window.FULLTILT.getDeviceOrientation && listeners.length === 0) {
	          var options = {
	            type: 'world'
	          };
	          window.FULLTILT.getDeviceOrientation(options).then(function (orientationControl) {
	            manager.orientationControl = orientationControl;
	            manager.orientationControl.listen(compassListener);
	          });
	        }
	        break;
	      }
	    default:
	      throw new Error(type + ' is a invalid value!');
	  }
	  manager.on(type, callback);
	};
	
	var unregisterListener = function unregisterListener(callback, type) {
	  var listeners = manager.listeners(type);
	  manager.off(type, callback);
	  switch (type) {
	    case sensorType.compass:
	      {
	        if (listeners.length === 0 && window.FULLTILT && window.FULLTILT.getDeviceOrientation && manager.orientationControl) {
	          manager.orientationControl.stop();
	          delete manager.orientationControl;
	        }
	        break;
	      }
	    default:
	      throw new Error(type + ' is a invalid value!');
	  }
	};
	
	exports.default = {
	  sensorType: sensorType,
	  registerListener: registerListener,
	  unregisterListener: unregisterListener
	};

/***/ }),
/* 210 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.SensorManager = undefined;
	
	var _SensorManager = __webpack_require__(209);
	
	var _SensorManager2 = _interopRequireDefault(_SensorManager);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.SensorManager = _SensorManager2.default;

/***/ }),
/* 211 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _assign = __webpack_require__(1);
	
	var _Style = __webpack_require__(14);
	
	var _Style2 = _interopRequireDefault(_Style);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var defaultProps = {
	  clickable: true,
	  /**
	   * 模型的缩放，用一个向量表示模型需要显示的范围。模型可以防止在地图上表示行进的人、停止的车辆等。
	   * @type {Number[]}
	   * @memberof NGR.style.Model.prototype
	   */
	  scale: null,
	  /**
	   * 模型的旋转，用一个三维向量表示模型需要旋转的弧度。
	   * @type {Number[]}
	   * @memberof NGR.style.Model.prototype
	   */
	  rotate: null,
	  params: null,
	  autoAttach: null,
	  /**
	   * 模型的格式，目前支持.obj、.dae、.fbx。
	   * @type {String}
	   * @memberof NGR.style.Model.prototype
	   */
	  fileType: null,
	  /**
	   * 返回样式类型。
	   * @memberof NGR.style.Model.prototype
	   * @override
	   * @return {String} 样式类型。
	   */
	  type: function type() {
	    return 'Model';
	  }
	};
	
	/**
	 * 设置模型的显示样式。
	 * @memberOf NGR.style
	 * @class Model
	 * @extends {NGR.style.Style}
	 */
	function Model() {
	  _assign(this, new _Style2.default(), defaultProps);
	}
	
	/**
	 * 模型文件存放的，支持URL或本地路径。
	 * @type {String}
	 * @name NGR.style.Model#path
	 */
	Object.defineProperty(Model.prototype, 'path', {
	  get: function get() {
	    return this._path;
	  },
	  set: function set(path) {
	    var fileType = Model.getFileType(path);
	    if (fileType && fileType.length !== 0) {
	      this.fileType = fileType[0];
	    }
	    this._path = path;
	  }
	});
	
	Model.getFileType = function (path) {
	  return (/[.]/.exec(path) ? /[^.]+$/.exec(path) : null
	  );
	};
	
	exports.default = Model;

/***/ }),
/* 212 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _assign = __webpack_require__(1);
	
	var _Style = __webpack_require__(14);
	
	var _Style2 = _interopRequireDefault(_Style);
	
	var _StyleUtil = __webpack_require__(19);
	
	var _StyleUtil2 = _interopRequireDefault(_StyleUtil);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var defaultProps = {
	  radius: 1,
	  widthSegments: 8,
	  heightSegments: 6,
	  type: function type() {
	    return 'Sphere';
	  }
	};
	
	function Shpere() {
	  _assign(this, new _Style2.default(), defaultProps);
	}
	
	Object.defineProperty(Shpere.prototype, 'color', {
	  get: function get() {
	    return this._color;
	  },
	  set: function set(color) {
	    this._color = _StyleUtil2.default.parseColor(color);
	  }
	});
	
	exports.default = Shpere;

/***/ }),
/* 213 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.Polygon = exports.LineString = exports.Light = exports.JSONStyleGenerator = exports.Icon = exports.Annotation = exports.Style = undefined;
	
	var _Style = __webpack_require__(14);
	
	var _Style2 = _interopRequireDefault(_Style);
	
	var _Annotation = __webpack_require__(80);
	
	var _Annotation2 = _interopRequireDefault(_Annotation);
	
	var _Icon = __webpack_require__(81);
	
	var _Icon2 = _interopRequireDefault(_Icon);
	
	var _JSONStyleGenerator = __webpack_require__(82);
	
	var _JSONStyleGenerator2 = _interopRequireDefault(_JSONStyleGenerator);
	
	var _Light = __webpack_require__(83);
	
	var _Light2 = _interopRequireDefault(_Light);
	
	var _LineString = __webpack_require__(84);
	
	var _LineString2 = _interopRequireDefault(_LineString);
	
	var _Polygon = __webpack_require__(85);
	
	var _Polygon2 = _interopRequireDefault(_Polygon);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.Style = _Style2.default;
	exports.Annotation = _Annotation2.default;
	exports.Icon = _Icon2.default;
	exports.JSONStyleGenerator = _JSONStyleGenerator2.default;
	exports.Light = _Light2.default;
	exports.LineString = _LineString2.default;
	exports.Polygon = _Polygon2.default;

/***/ }),
/* 214 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _fetch = __webpack_require__(13);
	
	var _fetch2 = _interopRequireDefault(_fetch);
	
	var _three = __webpack_require__(2);
	
	var THREE = _interopRequireWildcard(_three);
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var GeometryTransporter = function () {
	  function GeometryTransporter() {
	    _classCallCheck(this, GeometryTransporter);
	  }
	
	  _createClass(GeometryTransporter, null, [{
	    key: 'export',
	    value: function _export(mapView, featureCollection, category) {
	      var res = [];
	      var layer = mapView.getLayer(featureCollection.features[0].properties.planar_graph).getLayer('Area');
	      featureCollection.features.forEach(function (feature) {
	        if (!category) {
	          var threeNode = mapView.sceneManager.get(-1);
	          var mesh = threeNode._findMesh(layer, feature);
	          delete mesh.geometry.parameters;
	          res.push({ fId: feature.id, gData: mesh.geometry.toJSON() });
	        } else if (feature.properties.category === category) {
	          var _threeNode = mapView.sceneManager.get(-1);
	          var _mesh = _threeNode._findMesh(layer, feature);
	          delete _mesh.geometry.parameters;
	          res.push({ fId: feature.id, gData: _mesh.geometry.toJSON() });
	        }
	      });
	      return res;
	    }
	  }, {
	    key: 'load',
	    value: function load(url) {
	      var geomMap = {};
	      var loader = new THREE.JSONLoader();
	      return (0, _fetch2.default)(url, {}).then(function (response) {
	        // const time1 = new Date();
	        var rawMaps = JSON.parse(response._bodyText);
	        rawMaps.forEach(function (rawMap) {
	          geomMap[rawMap.fId] = loader.parse(rawMap.gData.data);
	        });
	        // const time2 = new Date();
	        // console.log(`Total loading time is ${time2.getTime() - time1.getTime()} ms`);
	        return geomMap;
	      });
	    }
	  }]);
	
	  return GeometryTransporter;
	}();
	
	exports.default = GeometryTransporter;

/***/ }),
/* 215 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _NGRObject2 = __webpack_require__(7);
	
	var _NGRObject3 = _interopRequireDefault(_NGRObject2);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var SwitchType = {
	  low: 2,
	  high: 3
	};
	
	/**
	 * 俯仰角度触发类，当俯仰角度到达阈值时触发预先设置的事件。
	 * @extends {NGRObject}
	 * @memberOf NGR.view
	 */
	
	var SwitchDispatcher = function (_NGRObject) {
	  _inherits(SwitchDispatcher, _NGRObject);
	
	  /**
	   * 构造方法。
	   * @param  {NGR.view.MapView} mapView         地图。
	   * @param  {Number}           switchThreshold 俯仰角度阈值。
	   */
	  function SwitchDispatcher(mapView) {
	    var switchThreshold = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 5;
	
	    _classCallCheck(this, SwitchDispatcher);
	
	    var _this = _possibleConstructorReturn(this, (SwitchDispatcher.__proto__ || Object.getPrototypeOf(SwitchDispatcher)).call(this));
	
	    _this._mapView = mapView;
	    _this.callType = SwitchType.high;
	    _this.callOne = false;
	    _this.switchThreshold = switchThreshold;
	
	    _this._switchType = _this._switchType.bind(_this);
	
	    if (mapView) {
	      mapView.gestureManager.on('skewEnd', _this._switchType);
	      mapView.on('changePlanarGraph', _this._switchType);
	    }
	    return _this;
	  }
	
	  _createClass(SwitchDispatcher, [{
	    key: '_switchType',
	    value: function _switchType() {
	      if (this._mapView.activeControl) {
	        var skew = this._mapView.activeControl.getSkew();
	
	        if (this.callType === SwitchType.high && skew < this.switchThreshold) {
	          this.callType = SwitchType.low;
	          this.callOne = true;
	        } else if (this.callType === SwitchType.low && skew > this.switchThreshold) {
	          this.callType = SwitchType.high;
	          this.callOne = true;
	        }
	
	        if (this.callOne) {
	          this.callOne = false;
	          switch (this.callType) {
	            case SwitchType.low:
	              {
	                this.emit('switch', {
	                  mode: SwitchType.low
	                });
	                break;
	              }
	            case SwitchType.high:
	              {
	                this.emit('switch', {
	                  mode: SwitchType.high
	                });
	                break;
	              }
	            default:
	              {
	                break;
	              }
	          }
	        }
	      }
	    }
	  }, {
	    key: 'destroy',
	
	
	    /**
	     * 销毁对象。
	     * @return {undefined}
	     */
	    value: function destroy() {
	      if (this._mapView) {
	        this._mapView.gestureManager.off('skewEnd', this._switchType);
	        this._mapView.off('changePlanarGraph', this._switchType);
	      }
	    }
	  }, {
	    key: 'switchThreshold',
	    get: function get() {
	      return this._switchThreshold;
	    },
	    set: function set(switchThreshold) {
	      this._switchThreshold = switchThreshold;
	    }
	  }]);
	
	  return SwitchDispatcher;
	}(_NGRObject3.default);
	
	exports.default = SwitchDispatcher;

/***/ }),
/* 216 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _NGRObject2 = __webpack_require__(7);
	
	var _NGRObject3 = _interopRequireDefault(_NGRObject2);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var GestureManager = function (_NGRObject) {
	  _inherits(GestureManager, _NGRObject);
	
	  function GestureManager() {
	    _classCallCheck(this, GestureManager);
	
	    var _this = _possibleConstructorReturn(this, (GestureManager.__proto__ || Object.getPrototypeOf(GestureManager)).call(this));
	
	    _this._gestures = {};
	    _this._events = {};
	    return _this;
	  }
	
	  _createClass(GestureManager, [{
	    key: 'init',
	    value: function init(mapView) {
	      this._mapView = mapView;
	    }
	  }, {
	    key: 'addGesture',
	    value: function addGesture(gesture) {
	      var type = gesture.type();
	      if (!this.hasGesture(gesture)) {
	        this._gestures[type] = gesture;
	        var providerEvent = gesture.providerEvent();
	        if (providerEvent) {
	          this._events[type] = providerEvent;
	        }
	        gesture.onAdd(this);
	      }
	    }
	  }, {
	    key: 'removeGesture',
	    value: function removeGesture(gesture) {
	      var type = gesture.type();
	      if (this.hasGesture(gesture)) {
	        delete this._gestures[type];
	        var providerEvent = this._events[type];
	        for (var _iterator = providerEvent, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
	          var _ref;
	
	          if (_isArray) {
	            if (_i >= _iterator.length) break;
	            _ref = _iterator[_i++];
	          } else {
	            _i = _iterator.next();
	            if (_i.done) break;
	            _ref = _i.value;
	          }
	
	          var event = _ref;
	
	          var listeners = this.listeners(event);
	          for (var _iterator2 = listeners, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator]();;) {
	            var _ref2;
	
	            if (_isArray2) {
	              if (_i2 >= _iterator2.length) break;
	              _ref2 = _iterator2[_i2++];
	            } else {
	              _i2 = _iterator2.next();
	              if (_i2.done) break;
	              _ref2 = _i2.value;
	            }
	
	            var listener = _ref2;
	
	            this.off(event, listener);
	          }
	        }
	        if (providerEvent) {
	          delete this._events[type];
	        }
	        gesture.onRemove(this);
	      }
	    }
	  }, {
	    key: 'hasGesture',
	    value: function hasGesture(gesture) {
	      return !!gesture && gesture.type() in this._gestures;
	    }
	  }, {
	    key: 'destroy',
	    value: function destroy() {
	      for (var gesture in this._gestures) {
	        this.removeGesture(this._gestures[gesture]);
	      }
	      this._gesture = [];
	      this._events = [];
	    }
	  }, {
	    key: 'mapView',
	    get: function get() {
	      return this._mapView;
	    }
	  }]);
	
	  return GestureManager;
	}(_NGRObject3.default);
	
	exports.default = GestureManager;

/***/ }),
/* 217 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };
	
	var _Gesture2 = __webpack_require__(88);
	
	var _Gesture3 = _interopRequireDefault(_Gesture2);
	
	var _HammerEvent = __webpack_require__(220);
	
	var _HammerEvent2 = _interopRequireDefault(_HammerEvent);
	
	var _hammerjs = __webpack_require__(240);
	
	var _hammerjs2 = _interopRequireDefault(_hammerjs);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var HammerGesture = function (_Gesture) {
	  _inherits(HammerGesture, _Gesture);
	
	  function HammerGesture() {
	    _classCallCheck(this, HammerGesture);
	
	    return _possibleConstructorReturn(this, (HammerGesture.__proto__ || Object.getPrototypeOf(HammerGesture)).apply(this, arguments));
	  }
	
	  _createClass(HammerGesture, [{
	    key: 'onAdd',
	    value: function onAdd(gestureManager) {
	      _get(HammerGesture.prototype.__proto__ || Object.getPrototypeOf(HammerGesture.prototype), 'onAdd', this).call(this, gestureManager);
	      this._eventManager = new _hammerjs2.default.Manager(gestureManager.mapView.targetDom);
	
	      this._eventManager.add(new _hammerjs2.default.Tap({ event: 'doubletap', taps: 2 }));
	      this._eventManager.add(new _hammerjs2.default.Tap({ event: 'singletap' }));
	      this._eventManager.get('doubletap').recognizeWith('singletap');
	      this._eventManager.get('singletap').requireFailure('doubletap');
	      this._eventManager.on('singletap', function (event) {
	        var touchEvent = new _HammerEvent2.default();
	        touchEvent.cast(event);
	        touchEvent.type = 'singleTap';
	        gestureManager.emit('singleTap', touchEvent);
	        gestureManager.emit('tap', touchEvent);
	      });
	      this._eventManager.on('doubletap', function (event) {
	        var touchEvent = new _HammerEvent2.default();
	        touchEvent.cast(event);
	        touchEvent.type = 'doubleTap';
	        gestureManager.emit('doubleTap', touchEvent);
	      });
	
	      this._eventManager.add(new _hammerjs2.default.Press({ event: 'press' }));
	      this._eventManager.on('press', function (event) {
	        var touchEvent = new _HammerEvent2.default();
	        touchEvent.cast(event);
	        touchEvent.type = 'longTap';
	        gestureManager.emit('longTap', touchEvent);
	      });
	
	      var moveEvent = new _HammerEvent2.default();
	      this._eventManager.add(new _hammerjs2.default.Pan());
	      this._eventManager.on('panstart panmove panend pinchin pinchout', function (event) {
	        moveEvent.cast(event);
	        switch (event.type) {
	          case 'panstart':
	            moveEvent.type = 'moveStart';
	            gestureManager.emit('moveStart', moveEvent);
	            break;
	          case 'panend':
	            moveEvent.type = 'moveEnd';
	            gestureManager.emit('moveEnd', moveEvent);
	            break;
	          case 'panmove':
	            moveEvent.type = 'move';
	            gestureManager.emit('move', moveEvent);
	            break;
	          default:
	            break;
	        }
	      });
	
	      var eventType = 0;
	      var skewCount = 0;
	      var skewEvent = new _HammerEvent2.default();
	      this._eventManager.add(new _hammerjs2.default.Pan({ event: 'skew', pointers: 2, direction: _hammerjs2.default.DIRECTION_ALL }));
	      this._eventManager.on('skewstart skewup skewdown skewend', function (event) {
	        skewEvent.cast(event);
	        switch (event.type) {
	          case 'skewstart':
	            skewEvent.type = 'skewStart';
	            gestureManager.emit('skewStart', skewEvent);
	            break;
	          case 'skewend':
	            eventType = 0;
	            skewEvent.type = 'skewEnd';
	            gestureManager.emit('skewEnd', skewEvent);
	            break;
	          case 'skewup':
	            // if (eventType === 2) {
	            // }
	            skewEvent.type = 'skewUp';
	            gestureManager.emit('skewUp', skewEvent);
	            break;
	          case 'skewdown':
	            // if (eventType === 2) {
	            // }
	            skewEvent.type = 'skewDown';
	            gestureManager.emit('skewDown', skewEvent);
	            break;
	          default:
	            break;
	        }
	      });
	      this._eventManager.get('pan').recognizeWith(this._eventManager.get('skew'));
	      this._eventManager.get('skew').requireFailure(this._eventManager.get('pan'));
	
	      var zoom = new _hammerjs2.default.Pinch({ threshold: 0 });
	      var hasRotateZoom = function hasRotateZoom(event, DeltaRotation) {
	        return Math.abs(DeltaRotation) > 8 && Math.abs(DeltaRotation) < 352 || event.scale > 1.15 || event.scale < 0.85;
	      };
	
	      var rotateEvent = new _HammerEvent2.default();
	      var skewAngleStart = 0;
	      var skewAve = 0;
	      this._eventManager.add(zoom);
	      // const getTwoTouchs = (event) => {
	      //   const touches = HammerGesture.getTouchEvent(event);
	      //   let cx0 = touches[0].clientX;
	      //   let cy0 = touches[0].clientY;
	      //   let cx1 = touches[1].clientX;
	      //   let cy1 = touches[1].clientY;
	      //   if (cx0 > cx1) {
	      //     cx1 = [cx0, cx0 = cx1][0];
	      //     cy1 = [cy0, cy0 = cy1][0];
	      //   }
	      //   const v1 = new THREE.Vector2(cx0, cy0);
	      //   const v2 = new THREE.Vector2(cx1, cy1);
	      //   const angle = v2.sub(v1).angle();
	      //   return angle * 180 / Math.PI;
	      // };
	      this._eventManager.on('pinchstart pinchmove pinchend', function (event) {
	        rotateEvent.cast(event);
	        switch (event.type) {
	          case 'pinchstart':
	            skewAngleStart = event.rotation;
	            skewAve = 0;
	            break;
	          case 'pinchend':
	            rotateEvent.type = 'zoomEnd';
	            gestureManager.emit('zoomEnd', rotateEvent);
	            rotateEvent.type = 'rotateEnd';
	            gestureManager.emit('rotateEnd', rotateEvent);
	            eventType = 0;
	            skewCount = 0;
	            break;
	          case 'pinchmove':
	            {
	              var angle = Math.abs(event.rotation - skewAngleStart);
	              if (skewCount++ < 5) {
	                skewAve += angle;
	              } else {
	                if (skewCount === 6) {
	                  // eslint-disable-line
	                  skewCount++;
	                  rotateEvent.type = 'zoomStart';
	                  gestureManager.emit('zoomStart', rotateEvent);
	                  rotateEvent.type = 'rotateStart';
	                  gestureManager.emit('rotateStart', rotateEvent);
	                  skewAve /= skewCount;
	                  // console.log(skewAve, event.scale);
	                  if (eventType === 0 && hasRotateZoom(event, skewAve)) {
	                    eventType = 1;
	                  } else {
	                    eventType = 2;
	                  }
	                } else {
	                  rotateEvent.type = 'zoom';
	                  gestureManager.emit('zoom', rotateEvent);
	                  rotateEvent.type = 'rotate';
	                  gestureManager.emit('rotate', rotateEvent);
	                }
	                // if (eventType === 1) {
	                // }
	              }
	              break;
	            }
	          default:
	            break;
	        }
	      });
	      this._eventManager.get('pinch').recognizeWith(this._eventManager.get('skew'));
	    }
	  }, {
	    key: 'onRemove',
	    value: function onRemove(gestureManager) {
	      _get(HammerGesture.prototype.__proto__ || Object.getPrototypeOf(HammerGesture.prototype), 'onRemove', this).call(this, gestureManager);
	      this._eventManager.destroy();
	    }
	  }, {
	    key: 'providerEvent',
	    value: function providerEvent() {
	      return ['singleTap', 'doubleTap', 'longTap', 'moveStart', 'moveEnd', 'move', 'skewStart', 'skewEnd', 'skewUp', 'skewDown', 'zoomStart', 'zoomEnd', 'zoom', 'rotateStart', 'rotateEnd', 'rotate'];
	    }
	  }, {
	    key: 'type',
	    value: function type() {
	      return 'hammer';
	    }
	  }], [{
	    key: 'getTouchEvent',
	    value: function getTouchEvent(event) {
	      var touches = void 0;
	      if (event.pointers.length === 2) {
	        touches = event.pointers;
	      }
	      if (event.changedPointers.length === 2) {
	        touches = event.changedPointers;
	      }
	      return touches;
	    }
	  }]);
	
	  return HammerGesture;
	}(_Gesture3.default);
	
	exports.default = HammerGesture;

/***/ }),
/* 218 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };
	
	var _Gesture2 = __webpack_require__(88);
	
	var _Gesture3 = _interopRequireDefault(_Gesture2);
	
	var _WheelEvent = __webpack_require__(221);
	
	var _WheelEvent2 = _interopRequireDefault(_WheelEvent);
	
	var _TouchEvent = __webpack_require__(48);
	
	var _TouchEvent2 = _interopRequireDefault(_TouchEvent);
	
	var _Touch = __webpack_require__(47);
	
	var _Touch2 = _interopRequireDefault(_Touch);
	
	var _config = __webpack_require__(18);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var MouseGesture = function (_Gesture) {
	  _inherits(MouseGesture, _Gesture);
	
	  function MouseGesture() {
	    _classCallCheck(this, MouseGesture);
	
	    return _possibleConstructorReturn(this, (MouseGesture.__proto__ || Object.getPrototypeOf(MouseGesture)).apply(this, arguments));
	  }
	
	  _createClass(MouseGesture, [{
	    key: 'onAdd',
	    value: function onAdd(gestureManager) {
	      var _this2 = this;
	
	      _get(MouseGesture.prototype.__proto__ || Object.getPrototypeOf(MouseGesture.prototype), 'onAdd', this).call(this, gestureManager);
	
	      if (!_config.touchEmulator) {
	        var targetDom = gestureManager.mapView.targetDom;
	
	        this._contextMenu = function (event) {
	          event.preventDefault();
	        };
	        targetDom.addEventListener('contextmenu', this._contextMenu, false);
	
	        var wheelEvent = new _WheelEvent2.default();
	        var wheeling = void 0;
	        this._mouseWheel = function (event) {
	          event.preventDefault();
	          event.stopPropagation();
	          wheelEvent.cast(event);
	          if (!wheeling) {
	            wheelEvent.scale = 1;
	            wheelEvent.type = 'zoomStart';
	            gestureManager.emit('zoomStart', wheelEvent);
	          }
	
	          clearTimeout(wheeling);
	          wheeling = setTimeout(function () {
	            wheeling = null;
	            wheelEvent.type = 'zoomEnd';
	            gestureManager.emit('zoomEnd', wheelEvent);
	          }, 250);
	
	          if (wheeling) {
	            wheelEvent.type = 'zoom';
	            gestureManager.emit('zoom', wheelEvent);
	          }
	        };
	        targetDom.addEventListener('mousewheel', this._mouseWheel, false);
	        targetDom.addEventListener('MozMousePixelScroll', this._mouseWheel, false);
	
	        var dx = 0;
	        var dy = 0;
	        var mouseSkewRotate = new _TouchEvent2.default();
	        // const switchRotate = new TouchEvent();
	        // const switchSkew = new TouchEvent();
	        var preTouch = {
	          clientX: 0,
	          clientY: 0
	        };
	        var cast = function cast(mouseSkewRotate, event) {
	          var touches = [];
	          var touch = new _Touch2.default();
	          touch.clientX = event.clientX;
	          touch.clientY = event.clientY;
	          touch.pageX = event.pageX;
	          touch.pageY = event.pageY;
	          touch.screenX = event.screenX;
	          touch.screenY = event.screenY;
	          touch.detail = event.detail;
	          touches.push(touch);
	          mouseSkewRotate.touches = touches;
	
	          mouseSkewRotate.target = event.target;
	
	          var dx = event.clientX - preTouch.clientX;
	          // const dy = event.clientY - preTouch.clientY;
	          if (dx > 0) {
	            mouseSkewRotate.rotate -= dx;
	            mouseSkewRotate.scale = 0;
	          } else {
	            mouseSkewRotate.rotate -= dx;
	            mouseSkewRotate.scale = 0;
	          }
	          preTouch.clientX = event.clientX;
	          preTouch.clientY = event.clientY;
	        };
	        this._mouseDown = function (event) {
	          if (event.button === 2) {
	            event.preventDefault();
	            mouseSkewRotate.rotate = 0;
	            mouseSkewRotate.scale = 1;
	            preTouch.clientX = event.clientX;
	            preTouch.clientY = event.clientY;
	            cast(mouseSkewRotate, event);
	            targetDom.addEventListener('mousemove', _this2._mouseMove, false);
	            targetDom.addEventListener('mouseup', _this2._mouseUp, false);
	            mouseSkewRotate.type = 'rotateStart';
	            gestureManager.emit('rotateStart', mouseSkewRotate);
	            mouseSkewRotate.type = 'skewStart';
	            gestureManager.emit('skewStart', mouseSkewRotate);
	            dx = event.clientX;
	            dy = event.clientY;
	          }
	        };
	        this._mouseMove = function (event) {
	          cast(mouseSkewRotate, event);
	          dx = event.clientX - dx;
	          dy = event.clientY - dy;
	          // if (dy === 0) {
	          mouseSkewRotate.type = 'rotate';
	          gestureManager.emit('rotate', mouseSkewRotate);
	          // } else if (dx === 0) {
	          if (dy > 0) {
	            mouseSkewRotate.type = 'skewDown';
	            gestureManager.emit('skewDown', mouseSkewRotate);
	          } else {
	            mouseSkewRotate.type = 'skewUp';
	            gestureManager.emit('skewUp', mouseSkewRotate);
	          }
	          // }
	          dx = event.clientX;
	          dy = event.clientY;
	        };
	        this._mouseUp = function (event) {
	          cast(mouseSkewRotate, event);
	          targetDom.removeEventListener('mousemove', _this2._mouseMove, false);
	          targetDom.removeEventListener('mouseup', _this2._mouseUp, false);
	          mouseSkewRotate.type = 'rotateEnd';
	          gestureManager.emit('rotateEnd', mouseSkewRotate);
	          mouseSkewRotate.type = 'skewEnd';
	          gestureManager.emit('skewEnd', mouseSkewRotate);
	        };
	        targetDom.addEventListener('mousedown', this._mouseDown, false);
	      }
	    }
	  }, {
	    key: 'onRemove',
	    value: function onRemove(gestureManager) {
	      _get(MouseGesture.prototype.__proto__ || Object.getPrototypeOf(MouseGesture.prototype), 'onRemove', this).call(this, gestureManager);
	      if (!_config.touchEmulator) {
	        var targetDom = gestureManager.mapView.targetDom;
	        targetDom.removeEventListener('contextmenu', this._contextMenu, false);
	        targetDom.removeEventListener('mousewheel', this._mouseWheel, false);
	        targetDom.removeEventListener('MozMousePixelScroll', this._mouseWheel, false);
	
	        targetDom.removeEventListener('mousedown', this._mouseDown, false);
	      }
	    }
	  }, {
	    key: 'providerEvent',
	    value: function providerEvent() {
	      return ['skewStart', 'skewEnd', 'skewUp', 'skewDown', 'zoomStart', 'zoomEnd', 'zoom', 'rotateStart', 'rotateEnd', 'rotate'];
	    }
	  }, {
	    key: 'type',
	    value: function type() {
	      return 'mouse';
	    }
	  }]);
	
	  return MouseGesture;
	}(_Gesture3.default);
	
	exports.default = MouseGesture;

/***/ }),
/* 219 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.GeometryTransporter = exports.SwitchDispatcher = exports.CoordinateSystem = exports.MapView = undefined;
	
	var _MapView = __webpack_require__(26);
	
	var _MapView2 = _interopRequireDefault(_MapView);
	
	var _CoordinateSystem = __webpack_require__(86);
	
	var _CoordinateSystem2 = _interopRequireDefault(_CoordinateSystem);
	
	var _SwitchDispatcher = __webpack_require__(215);
	
	var _SwitchDispatcher2 = _interopRequireDefault(_SwitchDispatcher);
	
	var _GeometryTransporter = __webpack_require__(214);
	
	var _GeometryTransporter2 = _interopRequireDefault(_GeometryTransporter);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.MapView = _MapView2.default;
	exports.CoordinateSystem = _CoordinateSystem2.default;
	exports.SwitchDispatcher = _SwitchDispatcher2.default;
	exports.GeometryTransporter = _GeometryTransporter2.default;

/***/ }),
/* 220 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _Touch = __webpack_require__(47);
	
	var _Touch2 = _interopRequireDefault(_Touch);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var HammerEvent = function () {
	  function HammerEvent() {
	    _classCallCheck(this, HammerEvent);
	  }
	
	  _createClass(HammerEvent, [{
	    key: 'cast',
	    value: function cast(event) {
	      if (event) {
	        var touches = [];
	        var pointers = event.pointers.length > 0 ? event.pointers : event.changedPointers;
	        for (var _iterator = pointers, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
	          var _ref;
	
	          if (_isArray) {
	            if (_i >= _iterator.length) break;
	            _ref = _iterator[_i++];
	          } else {
	            _i = _iterator.next();
	            if (_i.done) break;
	            _ref = _i.value;
	          }
	
	          var pointer = _ref;
	
	          var touch = new _Touch2.default();
	          touch.clientX = pointer.clientX;
	          touch.clientY = pointer.clientY;
	          touch.pageX = pointer.pageX;
	          touch.pageY = pointer.pageY;
	          touch.screenX = pointer.screenX;
	          touch.screenY = pointer.screenY;
	          touch.detail = pointer.detail;
	          touches.push(touch);
	        }
	        this.touches = touches;
	
	        this.target = event.target;
	        this.rotate = event.rotation;
	        this.scale = event.scale;
	      }
	    }
	  }]);
	
	  return HammerEvent;
	}();
	
	exports.default = HammerEvent;

/***/ }),
/* 221 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _TouchEvent2 = __webpack_require__(48);
	
	var _TouchEvent3 = _interopRequireDefault(_TouchEvent2);
	
	var _Touch = __webpack_require__(47);
	
	var _Touch2 = _interopRequireDefault(_Touch);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var WheelEvent = function (_TouchEvent) {
	  _inherits(WheelEvent, _TouchEvent);
	
	  function WheelEvent() {
	    _classCallCheck(this, WheelEvent);
	
	    var _this = _possibleConstructorReturn(this, (WheelEvent.__proto__ || Object.getPrototypeOf(WheelEvent)).call(this));
	
	    _this.scale = 1;
	    return _this;
	  }
	
	  _createClass(WheelEvent, [{
	    key: 'cast',
	    value: function cast(event) {
	      var touches = [];
	      var touch = new _Touch2.default();
	      touch.clientX = event.clientX;
	      touch.clientY = event.clientY;
	      touch.pageX = event.pageX;
	      touch.pageY = event.pageY;
	      touch.screenX = event.screenX;
	      touch.screenY = event.screenY;
	      touches.push(touch);
	      this.touches = touches;
	
	      this.rotate = 0;
	      this.target = event.target;
	
	      if (typeof event.wheelDelta !== 'undefined') {
	        this.delta = event.wheelDelta;
	      } else if (typeof event.detail !== 'undefined') {
	        this.delta = -event.detail;
	      }
	
	      this.scale += this.delta > 0 ? 0.1 : -0.1;
	    }
	  }, {
	    key: 'delta',
	    get: function get() {
	      return this._delta;
	    },
	    set: function set(delta) {
	      this._delta = delta;
	    }
	  }]);
	
	  return WheelEvent;
	}(_TouchEvent3.default);
	
	exports.default = WheelEvent;

/***/ }),
/* 222 */
/***/ (function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var Protocal = function () {
	  function Protocal() {
	    _classCallCheck(this, Protocal);
	
	    this._messageChannel = new MessageChannel();
	  }
	
	  _createClass(Protocal, [{
	    key: 'name',
	    value: function name() {
	      return 'null';
	    }
	  }, {
	    key: 'params',
	    value: function params() {
	      return null;
	    }
	  }, {
	    key: 'action',
	    value: function action(promise, resolve, reject, params) {
	      if (params) {
	        if (params.type === 'error') {
	          this.error(promise, reject, params);
	          return;
	        }
	        this.success(promise, resolve, params);
	      }
	    }
	  }, {
	    key: 'success',
	    value: function success(promise, resolve, params) {// eslint-disable-line no-unused-vars
	    }
	  }, {
	    key: 'error',
	    value: function error(promise, reject, params) {
	      reject(params.result.message);
	    }
	  }, {
	    key: 'channel',
	    get: function get() {
	      return this._messageChannel;
	    }
	  }]);
	
	  return Protocal;
	}();
	
	exports.default = Protocal;

/***/ }),
/* 223 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var _Promise = typeof Promise === 'undefined' ? __webpack_require__(20).Promise : Promise;
	
	var WorkerExecutor = function () {
	  function WorkerExecutor(worker) {
	    _classCallCheck(this, WorkerExecutor);
	
	    this._worker = worker;
	  }
	
	  _createClass(WorkerExecutor, [{
	    key: 'exec',
	    value: function exec(protocal) {
	      var promise = new _Promise(function (resolve, reject) {
	        if (!protocal) {
	          reject('protocal is null');
	          return;
	        }
	        protocal.channel.port1.onmessage = function (e) {
	          protocal.action(promise, resolve, reject, e.data);
	        };
	      });
	      if (!protocal) {
	        return promise;
	      }
	      this._worker.postMessage({
	        type: protocal.name(),
	        params: protocal.params()
	      }, [protocal.channel.port2]);
	      return promise;
	    }
	  }, {
	    key: 'destroy',
	    value: function destroy() {
	      this._worker.terminate();
	    }
	  }]);
	
	  return WorkerExecutor;
	}();
	
	exports.default = WorkerExecutor;

/***/ }),
/* 224 */
/***/ (function(module, exports, __webpack_require__) {

	
	/**
	 * This is the common logic for both the Node.js and web browser
	 * implementations of `debug()`.
	 *
	 * Expose `debug()` as the module.
	 */
	
	exports = module.exports = createDebug.debug = createDebug['default'] = createDebug;
	exports.coerce = coerce;
	exports.disable = disable;
	exports.enable = enable;
	exports.enabled = enabled;
	exports.humanize = __webpack_require__(241);
	
	/**
	 * The currently active debug mode names, and names to skip.
	 */
	
	exports.names = [];
	exports.skips = [];
	
	/**
	 * Map of special "%n" handling functions, for the debug "format" argument.
	 *
	 * Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
	 */
	
	exports.formatters = {};
	
	/**
	 * Previous log timestamp.
	 */
	
	var prevTime;
	
	/**
	 * Select a color.
	 * @param {String} namespace
	 * @return {Number}
	 * @api private
	 */
	
	function selectColor(namespace) {
	  var hash = 0, i;
	
	  for (i in namespace) {
	    hash  = ((hash << 5) - hash) + namespace.charCodeAt(i);
	    hash |= 0; // Convert to 32bit integer
	  }
	
	  return exports.colors[Math.abs(hash) % exports.colors.length];
	}
	
	/**
	 * Create a debugger with the given `namespace`.
	 *
	 * @param {String} namespace
	 * @return {Function}
	 * @api public
	 */
	
	function createDebug(namespace) {
	
	  function debug() {
	    // disabled?
	    if (!debug.enabled) return;
	
	    var self = debug;
	
	    // set `diff` timestamp
	    var curr = +new Date();
	    var ms = curr - (prevTime || curr);
	    self.diff = ms;
	    self.prev = prevTime;
	    self.curr = curr;
	    prevTime = curr;
	
	    // turn the `arguments` into a proper Array
	    var args = new Array(arguments.length);
	    for (var i = 0; i < args.length; i++) {
	      args[i] = arguments[i];
	    }
	
	    args[0] = exports.coerce(args[0]);
	
	    if ('string' !== typeof args[0]) {
	      // anything else let's inspect with %O
	      args.unshift('%O');
	    }
	
	    // apply any `formatters` transformations
	    var index = 0;
	    args[0] = args[0].replace(/%([a-zA-Z%])/g, function(match, format) {
	      // if we encounter an escaped % then don't increase the array index
	      if (match === '%%') return match;
	      index++;
	      var formatter = exports.formatters[format];
	      if ('function' === typeof formatter) {
	        var val = args[index];
	        match = formatter.call(self, val);
	
	        // now we need to remove `args[index]` since it's inlined in the `format`
	        args.splice(index, 1);
	        index--;
	      }
	      return match;
	    });
	
	    // apply env-specific formatting (colors, etc.)
	    exports.formatArgs.call(self, args);
	
	    var logFn = debug.log || exports.log || console.log.bind(console);
	    logFn.apply(self, args);
	  }
	
	  debug.namespace = namespace;
	  debug.enabled = exports.enabled(namespace);
	  debug.useColors = exports.useColors();
	  debug.color = selectColor(namespace);
	
	  // env-specific initialization logic for debug instances
	  if ('function' === typeof exports.init) {
	    exports.init(debug);
	  }
	
	  return debug;
	}
	
	/**
	 * Enables a debug mode by namespaces. This can include modes
	 * separated by a colon and wildcards.
	 *
	 * @param {String} namespaces
	 * @api public
	 */
	
	function enable(namespaces) {
	  exports.save(namespaces);
	
	  exports.names = [];
	  exports.skips = [];
	
	  var split = (typeof namespaces === 'string' ? namespaces : '').split(/[\s,]+/);
	  var len = split.length;
	
	  for (var i = 0; i < len; i++) {
	    if (!split[i]) continue; // ignore empty strings
	    namespaces = split[i].replace(/\*/g, '.*?');
	    if (namespaces[0] === '-') {
	      exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
	    } else {
	      exports.names.push(new RegExp('^' + namespaces + '$'));
	    }
	  }
	}
	
	/**
	 * Disable debug output.
	 *
	 * @api public
	 */
	
	function disable() {
	  exports.enable('');
	}
	
	/**
	 * Returns true if the given mode name is enabled, false otherwise.
	 *
	 * @param {String} name
	 * @return {Boolean}
	 * @api public
	 */
	
	function enabled(name) {
	  var i, len;
	  for (i = 0, len = exports.skips.length; i < len; i++) {
	    if (exports.skips[i].test(name)) {
	      return false;
	    }
	  }
	  for (i = 0, len = exports.names.length; i < len; i++) {
	    if (exports.names[i].test(name)) {
	      return true;
	    }
	  }
	  return false;
	}
	
	/**
	 * Coerce `val`.
	 *
	 * @param {Mixed} val
	 * @return {Mixed}
	 * @api private
	 */
	
	function coerce(val) {
	  if (val instanceof Error) return val.stack || val.message;
	  return val;
	}


/***/ }),
/* 225 */
/***/ (function(module, exports) {

	// removed by extract-text-webpack-plugin

/***/ }),
/* 226 */
225,
/* 227 */
225,
/* 228 */
225,
/* 229 */
225,
/* 230 */
225,
/* 231 */
225,
/* 232 */
225,
/* 233 */
225,
/* 234 */
225,
/* 235 */
/***/ (function(module, exports) {

	module.exports = add
	
	/**
	 * Adds two vec2's
	 *
	 * @param {vec2} out the receiving vector
	 * @param {vec2} a the first operand
	 * @param {vec2} b the second operand
	 * @returns {vec2} out
	 */
	function add(out, a, b) {
	    out[0] = a[0] + b[0]
	    out[1] = a[1] + b[1]
	    return out
	}

/***/ }),
/* 236 */
/***/ (function(module, exports) {

	module.exports = dot
	
	/**
	 * Calculates the dot product of two vec2's
	 *
	 * @param {vec2} a the first operand
	 * @param {vec2} b the second operand
	 * @returns {Number} dot product of a and b
	 */
	function dot(a, b) {
	    return a[0] * b[0] + a[1] * b[1]
	}

/***/ }),
/* 237 */
/***/ (function(module, exports) {

	module.exports = normalize
	
	/**
	 * Normalize a vec2
	 *
	 * @param {vec2} out the receiving vector
	 * @param {vec2} a vector to normalize
	 * @returns {vec2} out
	 */
	function normalize(out, a) {
	    var x = a[0],
	        y = a[1]
	    var len = x*x + y*y
	    if (len > 0) {
	        //TODO: evaluate use of glm_invsqrt here?
	        len = 1 / Math.sqrt(len)
	        out[0] = a[0] * len
	        out[1] = a[1] * len
	    }
	    return out
	}

/***/ }),
/* 238 */
/***/ (function(module, exports) {

	module.exports = set
	
	/**
	 * Set the components of a vec2 to the given values
	 *
	 * @param {vec2} out the receiving vector
	 * @param {Number} x X component
	 * @param {Number} y Y component
	 * @returns {vec2} out
	 */
	function set(out, x, y) {
	    out[0] = x
	    out[1] = y
	    return out
	}

/***/ }),
/* 239 */
/***/ (function(module, exports) {

	module.exports = subtract
	
	/**
	 * Subtracts vector b from vector a
	 *
	 * @param {vec2} out the receiving vector
	 * @param {vec2} a the first operand
	 * @param {vec2} b the second operand
	 * @returns {vec2} out
	 */
	function subtract(out, a, b) {
	    out[0] = a[0] - b[0]
	    out[1] = a[1] - b[1]
	    return out
	}

/***/ }),
/* 240 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*! Hammer.JS - v2.0.7 - 2016-04-22
	 * http://hammerjs.github.io/
	 *
	 * Copyright (c) 2016 Jorik Tangelder;
	 * Licensed under the MIT license */
	(function(window, document, exportName, undefined) {
	  'use strict';
	
	var VENDOR_PREFIXES = ['', 'webkit', 'Moz', 'MS', 'ms', 'o'];
	var TEST_ELEMENT = document.createElement('div');
	
	var TYPE_FUNCTION = 'function';
	
	var round = Math.round;
	var abs = Math.abs;
	var now = Date.now;
	
	/**
	 * set a timeout with a given scope
	 * @param {Function} fn
	 * @param {Number} timeout
	 * @param {Object} context
	 * @returns {number}
	 */
	function setTimeoutContext(fn, timeout, context) {
	    return setTimeout(bindFn(fn, context), timeout);
	}
	
	/**
	 * if the argument is an array, we want to execute the fn on each entry
	 * if it aint an array we don't want to do a thing.
	 * this is used by all the methods that accept a single and array argument.
	 * @param {*|Array} arg
	 * @param {String} fn
	 * @param {Object} [context]
	 * @returns {Boolean}
	 */
	function invokeArrayArg(arg, fn, context) {
	    if (Array.isArray(arg)) {
	        each(arg, context[fn], context);
	        return true;
	    }
	    return false;
	}
	
	/**
	 * walk objects and arrays
	 * @param {Object} obj
	 * @param {Function} iterator
	 * @param {Object} context
	 */
	function each(obj, iterator, context) {
	    var i;
	
	    if (!obj) {
	        return;
	    }
	
	    if (obj.forEach) {
	        obj.forEach(iterator, context);
	    } else if (obj.length !== undefined) {
	        i = 0;
	        while (i < obj.length) {
	            iterator.call(context, obj[i], i, obj);
	            i++;
	        }
	    } else {
	        for (i in obj) {
	            obj.hasOwnProperty(i) && iterator.call(context, obj[i], i, obj);
	        }
	    }
	}
	
	/**
	 * wrap a method with a deprecation warning and stack trace
	 * @param {Function} method
	 * @param {String} name
	 * @param {String} message
	 * @returns {Function} A new function wrapping the supplied method.
	 */
	function deprecate(method, name, message) {
	    var deprecationMessage = 'DEPRECATED METHOD: ' + name + '\n' + message + ' AT \n';
	    return function() {
	        var e = new Error('get-stack-trace');
	        var stack = e && e.stack ? e.stack.replace(/^[^\(]+?[\n$]/gm, '')
	            .replace(/^\s+at\s+/gm, '')
	            .replace(/^Object.<anonymous>\s*\(/gm, '{anonymous}()@') : 'Unknown Stack Trace';
	
	        var log = window.console && (window.console.warn || window.console.log);
	        if (log) {
	            log.call(window.console, deprecationMessage, stack);
	        }
	        return method.apply(this, arguments);
	    };
	}
	
	/**
	 * extend object.
	 * means that properties in dest will be overwritten by the ones in src.
	 * @param {Object} target
	 * @param {...Object} objects_to_assign
	 * @returns {Object} target
	 */
	var assign;
	if (typeof Object.assign !== 'function') {
	    assign = function assign(target) {
	        if (target === undefined || target === null) {
	            throw new TypeError('Cannot convert undefined or null to object');
	        }
	
	        var output = Object(target);
	        for (var index = 1; index < arguments.length; index++) {
	            var source = arguments[index];
	            if (source !== undefined && source !== null) {
	                for (var nextKey in source) {
	                    if (source.hasOwnProperty(nextKey)) {
	                        output[nextKey] = source[nextKey];
	                    }
	                }
	            }
	        }
	        return output;
	    };
	} else {
	    assign = Object.assign;
	}
	
	/**
	 * extend object.
	 * means that properties in dest will be overwritten by the ones in src.
	 * @param {Object} dest
	 * @param {Object} src
	 * @param {Boolean} [merge=false]
	 * @returns {Object} dest
	 */
	var extend = deprecate(function extend(dest, src, merge) {
	    var keys = Object.keys(src);
	    var i = 0;
	    while (i < keys.length) {
	        if (!merge || (merge && dest[keys[i]] === undefined)) {
	            dest[keys[i]] = src[keys[i]];
	        }
	        i++;
	    }
	    return dest;
	}, 'extend', 'Use `assign`.');
	
	/**
	 * merge the values from src in the dest.
	 * means that properties that exist in dest will not be overwritten by src
	 * @param {Object} dest
	 * @param {Object} src
	 * @returns {Object} dest
	 */
	var merge = deprecate(function merge(dest, src) {
	    return extend(dest, src, true);
	}, 'merge', 'Use `assign`.');
	
	/**
	 * simple class inheritance
	 * @param {Function} child
	 * @param {Function} base
	 * @param {Object} [properties]
	 */
	function inherit(child, base, properties) {
	    var baseP = base.prototype,
	        childP;
	
	    childP = child.prototype = Object.create(baseP);
	    childP.constructor = child;
	    childP._super = baseP;
	
	    if (properties) {
	        assign(childP, properties);
	    }
	}
	
	/**
	 * simple function bind
	 * @param {Function} fn
	 * @param {Object} context
	 * @returns {Function}
	 */
	function bindFn(fn, context) {
	    return function boundFn() {
	        return fn.apply(context, arguments);
	    };
	}
	
	/**
	 * let a boolean value also be a function that must return a boolean
	 * this first item in args will be used as the context
	 * @param {Boolean|Function} val
	 * @param {Array} [args]
	 * @returns {Boolean}
	 */
	function boolOrFn(val, args) {
	    if (typeof val == TYPE_FUNCTION) {
	        return val.apply(args ? args[0] || undefined : undefined, args);
	    }
	    return val;
	}
	
	/**
	 * use the val2 when val1 is undefined
	 * @param {*} val1
	 * @param {*} val2
	 * @returns {*}
	 */
	function ifUndefined(val1, val2) {
	    return (val1 === undefined) ? val2 : val1;
	}
	
	/**
	 * addEventListener with multiple events at once
	 * @param {EventTarget} target
	 * @param {String} types
	 * @param {Function} handler
	 */
	function addEventListeners(target, types, handler) {
	    each(splitStr(types), function(type) {
	        target.addEventListener(type, handler, false);
	    });
	}
	
	/**
	 * removeEventListener with multiple events at once
	 * @param {EventTarget} target
	 * @param {String} types
	 * @param {Function} handler
	 */
	function removeEventListeners(target, types, handler) {
	    each(splitStr(types), function(type) {
	        target.removeEventListener(type, handler, false);
	    });
	}
	
	/**
	 * find if a node is in the given parent
	 * @method hasParent
	 * @param {HTMLElement} node
	 * @param {HTMLElement} parent
	 * @return {Boolean} found
	 */
	function hasParent(node, parent) {
	    while (node) {
	        if (node == parent) {
	            return true;
	        }
	        node = node.parentNode;
	    }
	    return false;
	}
	
	/**
	 * small indexOf wrapper
	 * @param {String} str
	 * @param {String} find
	 * @returns {Boolean} found
	 */
	function inStr(str, find) {
	    return str.indexOf(find) > -1;
	}
	
	/**
	 * split string on whitespace
	 * @param {String} str
	 * @returns {Array} words
	 */
	function splitStr(str) {
	    return str.trim().split(/\s+/g);
	}
	
	/**
	 * find if a array contains the object using indexOf or a simple polyFill
	 * @param {Array} src
	 * @param {String} find
	 * @param {String} [findByKey]
	 * @return {Boolean|Number} false when not found, or the index
	 */
	function inArray(src, find, findByKey) {
	    if (src.indexOf && !findByKey) {
	        return src.indexOf(find);
	    } else {
	        var i = 0;
	        while (i < src.length) {
	            if ((findByKey && src[i][findByKey] == find) || (!findByKey && src[i] === find)) {
	                return i;
	            }
	            i++;
	        }
	        return -1;
	    }
	}
	
	/**
	 * convert array-like objects to real arrays
	 * @param {Object} obj
	 * @returns {Array}
	 */
	function toArray(obj) {
	    return Array.prototype.slice.call(obj, 0);
	}
	
	/**
	 * unique array with objects based on a key (like 'id') or just by the array's value
	 * @param {Array} src [{id:1},{id:2},{id:1}]
	 * @param {String} [key]
	 * @param {Boolean} [sort=False]
	 * @returns {Array} [{id:1},{id:2}]
	 */
	function uniqueArray(src, key, sort) {
	    var results = [];
	    var values = [];
	    var i = 0;
	
	    while (i < src.length) {
	        var val = key ? src[i][key] : src[i];
	        if (inArray(values, val) < 0) {
	            results.push(src[i]);
	        }
	        values[i] = val;
	        i++;
	    }
	
	    if (sort) {
	        if (!key) {
	            results = results.sort();
	        } else {
	            results = results.sort(function sortUniqueArray(a, b) {
	                return a[key] > b[key];
	            });
	        }
	    }
	
	    return results;
	}
	
	/**
	 * get the prefixed property
	 * @param {Object} obj
	 * @param {String} property
	 * @returns {String|Undefined} prefixed
	 */
	function prefixed(obj, property) {
	    var prefix, prop;
	    var camelProp = property[0].toUpperCase() + property.slice(1);
	
	    var i = 0;
	    while (i < VENDOR_PREFIXES.length) {
	        prefix = VENDOR_PREFIXES[i];
	        prop = (prefix) ? prefix + camelProp : property;
	
	        if (prop in obj) {
	            return prop;
	        }
	        i++;
	    }
	    return undefined;
	}
	
	/**
	 * get a unique id
	 * @returns {number} uniqueId
	 */
	var _uniqueId = 1;
	function uniqueId() {
	    return _uniqueId++;
	}
	
	/**
	 * get the window object of an element
	 * @param {HTMLElement} element
	 * @returns {DocumentView|Window}
	 */
	function getWindowForElement(element) {
	    var doc = element.ownerDocument || element;
	    return (doc.defaultView || doc.parentWindow || window);
	}
	
	var MOBILE_REGEX = /mobile|tablet|ip(ad|hone|od)|android/i;
	
	var SUPPORT_TOUCH = ('ontouchstart' in window);
	var SUPPORT_POINTER_EVENTS = prefixed(window, 'PointerEvent') !== undefined;
	var SUPPORT_ONLY_TOUCH = SUPPORT_TOUCH && MOBILE_REGEX.test(navigator.userAgent);
	
	var INPUT_TYPE_TOUCH = 'touch';
	var INPUT_TYPE_PEN = 'pen';
	var INPUT_TYPE_MOUSE = 'mouse';
	var INPUT_TYPE_KINECT = 'kinect';
	
	var COMPUTE_INTERVAL = 25;
	
	var INPUT_START = 1;
	var INPUT_MOVE = 2;
	var INPUT_END = 4;
	var INPUT_CANCEL = 8;
	
	var DIRECTION_NONE = 1;
	var DIRECTION_LEFT = 2;
	var DIRECTION_RIGHT = 4;
	var DIRECTION_UP = 8;
	var DIRECTION_DOWN = 16;
	
	var DIRECTION_HORIZONTAL = DIRECTION_LEFT | DIRECTION_RIGHT;
	var DIRECTION_VERTICAL = DIRECTION_UP | DIRECTION_DOWN;
	var DIRECTION_ALL = DIRECTION_HORIZONTAL | DIRECTION_VERTICAL;
	
	var PROPS_XY = ['x', 'y'];
	var PROPS_CLIENT_XY = ['clientX', 'clientY'];
	
	/**
	 * create new input type manager
	 * @param {Manager} manager
	 * @param {Function} callback
	 * @returns {Input}
	 * @constructor
	 */
	function Input(manager, callback) {
	    var self = this;
	    this.manager = manager;
	    this.callback = callback;
	    this.element = manager.element;
	    this.target = manager.options.inputTarget;
	
	    // smaller wrapper around the handler, for the scope and the enabled state of the manager,
	    // so when disabled the input events are completely bypassed.
	    this.domHandler = function(ev) {
	        if (boolOrFn(manager.options.enable, [manager])) {
	            self.handler(ev);
	        }
	    };
	
	    this.init();
	
	}
	
	Input.prototype = {
	    /**
	     * should handle the inputEvent data and trigger the callback
	     * @virtual
	     */
	    handler: function() { },
	
	    /**
	     * bind the events
	     */
	    init: function() {
	        this.evEl && addEventListeners(this.element, this.evEl, this.domHandler);
	        this.evTarget && addEventListeners(this.target, this.evTarget, this.domHandler);
	        this.evWin && addEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);
	    },
	
	    /**
	     * unbind the events
	     */
	    destroy: function() {
	        this.evEl && removeEventListeners(this.element, this.evEl, this.domHandler);
	        this.evTarget && removeEventListeners(this.target, this.evTarget, this.domHandler);
	        this.evWin && removeEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);
	    }
	};
	
	/**
	 * create new input type manager
	 * called by the Manager constructor
	 * @param {Hammer} manager
	 * @returns {Input}
	 */
	function createInputInstance(manager) {
	    var Type;
	    var inputClass = manager.options.inputClass;
	
	    if (inputClass) {
	        Type = inputClass;
	    } else if (SUPPORT_POINTER_EVENTS) {
	        Type = PointerEventInput;
	    } else if (SUPPORT_ONLY_TOUCH) {
	        Type = TouchInput;
	    } else if (!SUPPORT_TOUCH) {
	        Type = MouseInput;
	    } else {
	        Type = TouchMouseInput;
	    }
	    return new (Type)(manager, inputHandler);
	}
	
	/**
	 * handle input events
	 * @param {Manager} manager
	 * @param {String} eventType
	 * @param {Object} input
	 */
	function inputHandler(manager, eventType, input) {
	    var pointersLen = input.pointers.length;
	    var changedPointersLen = input.changedPointers.length;
	    var isFirst = (eventType & INPUT_START && (pointersLen - changedPointersLen === 0));
	    var isFinal = (eventType & (INPUT_END | INPUT_CANCEL) && (pointersLen - changedPointersLen === 0));
	
	    input.isFirst = !!isFirst;
	    input.isFinal = !!isFinal;
	
	    if (isFirst) {
	        manager.session = {};
	    }
	
	    // source event is the normalized value of the domEvents
	    // like 'touchstart, mouseup, pointerdown'
	    input.eventType = eventType;
	
	    // compute scale, rotation etc
	    computeInputData(manager, input);
	
	    // emit secret event
	    manager.emit('hammer.input', input);
	
	    manager.recognize(input);
	    manager.session.prevInput = input;
	}
	
	/**
	 * extend the data with some usable properties like scale, rotate, velocity etc
	 * @param {Object} manager
	 * @param {Object} input
	 */
	function computeInputData(manager, input) {
	    var session = manager.session;
	    var pointers = input.pointers;
	    var pointersLength = pointers.length;
	
	    // store the first input to calculate the distance and direction
	    if (!session.firstInput) {
	        session.firstInput = simpleCloneInputData(input);
	    }
	
	    // to compute scale and rotation we need to store the multiple touches
	    if (pointersLength > 1 && !session.firstMultiple) {
	        session.firstMultiple = simpleCloneInputData(input);
	    } else if (pointersLength === 1) {
	        session.firstMultiple = false;
	    }
	
	    var firstInput = session.firstInput;
	    var firstMultiple = session.firstMultiple;
	    var offsetCenter = firstMultiple ? firstMultiple.center : firstInput.center;
	
	    var center = input.center = getCenter(pointers);
	    input.timeStamp = now();
	    input.deltaTime = input.timeStamp - firstInput.timeStamp;
	
	    input.angle = getAngle(offsetCenter, center);
	    input.distance = getDistance(offsetCenter, center);
	
	    computeDeltaXY(session, input);
	    input.offsetDirection = getDirection(input.deltaX, input.deltaY);
	
	    var overallVelocity = getVelocity(input.deltaTime, input.deltaX, input.deltaY);
	    input.overallVelocityX = overallVelocity.x;
	    input.overallVelocityY = overallVelocity.y;
	    input.overallVelocity = (abs(overallVelocity.x) > abs(overallVelocity.y)) ? overallVelocity.x : overallVelocity.y;
	
	    input.scale = firstMultiple ? getScale(firstMultiple.pointers, pointers) : 1;
	    input.rotation = firstMultiple ? getRotation(firstMultiple.pointers, pointers) : 0;
	
	    input.maxPointers = !session.prevInput ? input.pointers.length : ((input.pointers.length >
	        session.prevInput.maxPointers) ? input.pointers.length : session.prevInput.maxPointers);
	
	    computeIntervalInputData(session, input);
	
	    // find the correct target
	    var target = manager.element;
	    if (hasParent(input.srcEvent.target, target)) {
	        target = input.srcEvent.target;
	    }
	    input.target = target;
	}
	
	function computeDeltaXY(session, input) {
	    var center = input.center;
	    var offset = session.offsetDelta || {};
	    var prevDelta = session.prevDelta || {};
	    var prevInput = session.prevInput || {};
	
	    if (input.eventType === INPUT_START || prevInput.eventType === INPUT_END) {
	        prevDelta = session.prevDelta = {
	            x: prevInput.deltaX || 0,
	            y: prevInput.deltaY || 0
	        };
	
	        offset = session.offsetDelta = {
	            x: center.x,
	            y: center.y
	        };
	    }
	
	    input.deltaX = prevDelta.x + (center.x - offset.x);
	    input.deltaY = prevDelta.y + (center.y - offset.y);
	}
	
	/**
	 * velocity is calculated every x ms
	 * @param {Object} session
	 * @param {Object} input
	 */
	function computeIntervalInputData(session, input) {
	    var last = session.lastInterval || input,
	        deltaTime = input.timeStamp - last.timeStamp,
	        velocity, velocityX, velocityY, direction;
	
	    if (input.eventType != INPUT_CANCEL && (deltaTime > COMPUTE_INTERVAL || last.velocity === undefined)) {
	        var deltaX = input.deltaX - last.deltaX;
	        var deltaY = input.deltaY - last.deltaY;
	
	        var v = getVelocity(deltaTime, deltaX, deltaY);
	        velocityX = v.x;
	        velocityY = v.y;
	        velocity = (abs(v.x) > abs(v.y)) ? v.x : v.y;
	        direction = getDirection(deltaX, deltaY);
	
	        session.lastInterval = input;
	    } else {
	        // use latest velocity info if it doesn't overtake a minimum period
	        velocity = last.velocity;
	        velocityX = last.velocityX;
	        velocityY = last.velocityY;
	        direction = last.direction;
	    }
	
	    input.velocity = velocity;
	    input.velocityX = velocityX;
	    input.velocityY = velocityY;
	    input.direction = direction;
	}
	
	/**
	 * create a simple clone from the input used for storage of firstInput and firstMultiple
	 * @param {Object} input
	 * @returns {Object} clonedInputData
	 */
	function simpleCloneInputData(input) {
	    // make a simple copy of the pointers because we will get a reference if we don't
	    // we only need clientXY for the calculations
	    var pointers = [];
	    var i = 0;
	    while (i < input.pointers.length) {
	        pointers[i] = {
	            clientX: round(input.pointers[i].clientX),
	            clientY: round(input.pointers[i].clientY)
	        };
	        i++;
	    }
	
	    return {
	        timeStamp: now(),
	        pointers: pointers,
	        center: getCenter(pointers),
	        deltaX: input.deltaX,
	        deltaY: input.deltaY
	    };
	}
	
	/**
	 * get the center of all the pointers
	 * @param {Array} pointers
	 * @return {Object} center contains `x` and `y` properties
	 */
	function getCenter(pointers) {
	    var pointersLength = pointers.length;
	
	    // no need to loop when only one touch
	    if (pointersLength === 1) {
	        return {
	            x: round(pointers[0].clientX),
	            y: round(pointers[0].clientY)
	        };
	    }
	
	    var x = 0, y = 0, i = 0;
	    while (i < pointersLength) {
	        x += pointers[i].clientX;
	        y += pointers[i].clientY;
	        i++;
	    }
	
	    return {
	        x: round(x / pointersLength),
	        y: round(y / pointersLength)
	    };
	}
	
	/**
	 * calculate the velocity between two points. unit is in px per ms.
	 * @param {Number} deltaTime
	 * @param {Number} x
	 * @param {Number} y
	 * @return {Object} velocity `x` and `y`
	 */
	function getVelocity(deltaTime, x, y) {
	    return {
	        x: x / deltaTime || 0,
	        y: y / deltaTime || 0
	    };
	}
	
	/**
	 * get the direction between two points
	 * @param {Number} x
	 * @param {Number} y
	 * @return {Number} direction
	 */
	function getDirection(x, y) {
	    if (x === y) {
	        return DIRECTION_NONE;
	    }
	
	    if (abs(x) >= abs(y)) {
	        return x < 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;
	    }
	    return y < 0 ? DIRECTION_UP : DIRECTION_DOWN;
	}
	
	/**
	 * calculate the absolute distance between two points
	 * @param {Object} p1 {x, y}
	 * @param {Object} p2 {x, y}
	 * @param {Array} [props] containing x and y keys
	 * @return {Number} distance
	 */
	function getDistance(p1, p2, props) {
	    if (!props) {
	        props = PROPS_XY;
	    }
	    var x = p2[props[0]] - p1[props[0]],
	        y = p2[props[1]] - p1[props[1]];
	
	    return Math.sqrt((x * x) + (y * y));
	}
	
	/**
	 * calculate the angle between two coordinates
	 * @param {Object} p1
	 * @param {Object} p2
	 * @param {Array} [props] containing x and y keys
	 * @return {Number} angle
	 */
	function getAngle(p1, p2, props) {
	    if (!props) {
	        props = PROPS_XY;
	    }
	    var x = p2[props[0]] - p1[props[0]],
	        y = p2[props[1]] - p1[props[1]];
	    return Math.atan2(y, x) * 180 / Math.PI;
	}
	
	/**
	 * calculate the rotation degrees between two pointersets
	 * @param {Array} start array of pointers
	 * @param {Array} end array of pointers
	 * @return {Number} rotation
	 */
	function getRotation(start, end) {
	    return getAngle(end[1], end[0], PROPS_CLIENT_XY) + getAngle(start[1], start[0], PROPS_CLIENT_XY);
	}
	
	/**
	 * calculate the scale factor between two pointersets
	 * no scale is 1, and goes down to 0 when pinched together, and bigger when pinched out
	 * @param {Array} start array of pointers
	 * @param {Array} end array of pointers
	 * @return {Number} scale
	 */
	function getScale(start, end) {
	    return getDistance(end[0], end[1], PROPS_CLIENT_XY) / getDistance(start[0], start[1], PROPS_CLIENT_XY);
	}
	
	var MOUSE_INPUT_MAP = {
	    mousedown: INPUT_START,
	    mousemove: INPUT_MOVE,
	    mouseup: INPUT_END
	};
	
	var MOUSE_ELEMENT_EVENTS = 'mousedown';
	var MOUSE_WINDOW_EVENTS = 'mousemove mouseup';
	
	/**
	 * Mouse events input
	 * @constructor
	 * @extends Input
	 */
	function MouseInput() {
	    this.evEl = MOUSE_ELEMENT_EVENTS;
	    this.evWin = MOUSE_WINDOW_EVENTS;
	
	    this.pressed = false; // mousedown state
	
	    Input.apply(this, arguments);
	}
	
	inherit(MouseInput, Input, {
	    /**
	     * handle mouse events
	     * @param {Object} ev
	     */
	    handler: function MEhandler(ev) {
	        var eventType = MOUSE_INPUT_MAP[ev.type];
	
	        // on start we want to have the left mouse button down
	        if (eventType & INPUT_START && ev.button === 0) {
	            this.pressed = true;
	        }
	
	        if (eventType & INPUT_MOVE && ev.which !== 1) {
	            eventType = INPUT_END;
	        }
	
	        // mouse must be down
	        if (!this.pressed) {
	            return;
	        }
	
	        if (eventType & INPUT_END) {
	            this.pressed = false;
	        }
	
	        this.callback(this.manager, eventType, {
	            pointers: [ev],
	            changedPointers: [ev],
	            pointerType: INPUT_TYPE_MOUSE,
	            srcEvent: ev
	        });
	    }
	});
	
	var POINTER_INPUT_MAP = {
	    pointerdown: INPUT_START,
	    pointermove: INPUT_MOVE,
	    pointerup: INPUT_END,
	    pointercancel: INPUT_CANCEL,
	    pointerout: INPUT_CANCEL
	};
	
	// in IE10 the pointer types is defined as an enum
	var IE10_POINTER_TYPE_ENUM = {
	    2: INPUT_TYPE_TOUCH,
	    3: INPUT_TYPE_PEN,
	    4: INPUT_TYPE_MOUSE,
	    5: INPUT_TYPE_KINECT // see https://twitter.com/jacobrossi/status/480596438489890816
	};
	
	var POINTER_ELEMENT_EVENTS = 'pointerdown';
	var POINTER_WINDOW_EVENTS = 'pointermove pointerup pointercancel';
	
	// IE10 has prefixed support, and case-sensitive
	if (window.MSPointerEvent && !window.PointerEvent) {
	    POINTER_ELEMENT_EVENTS = 'MSPointerDown';
	    POINTER_WINDOW_EVENTS = 'MSPointerMove MSPointerUp MSPointerCancel';
	}
	
	/**
	 * Pointer events input
	 * @constructor
	 * @extends Input
	 */
	function PointerEventInput() {
	    this.evEl = POINTER_ELEMENT_EVENTS;
	    this.evWin = POINTER_WINDOW_EVENTS;
	
	    Input.apply(this, arguments);
	
	    this.store = (this.manager.session.pointerEvents = []);
	}
	
	inherit(PointerEventInput, Input, {
	    /**
	     * handle mouse events
	     * @param {Object} ev
	     */
	    handler: function PEhandler(ev) {
	        var store = this.store;
	        var removePointer = false;
	
	        var eventTypeNormalized = ev.type.toLowerCase().replace('ms', '');
	        var eventType = POINTER_INPUT_MAP[eventTypeNormalized];
	        var pointerType = IE10_POINTER_TYPE_ENUM[ev.pointerType] || ev.pointerType;
	
	        var isTouch = (pointerType == INPUT_TYPE_TOUCH);
	
	        // get index of the event in the store
	        var storeIndex = inArray(store, ev.pointerId, 'pointerId');
	
	        // start and mouse must be down
	        if (eventType & INPUT_START && (ev.button === 0 || isTouch)) {
	            if (storeIndex < 0) {
	                store.push(ev);
	                storeIndex = store.length - 1;
	            }
	        } else if (eventType & (INPUT_END | INPUT_CANCEL)) {
	            removePointer = true;
	        }
	
	        // it not found, so the pointer hasn't been down (so it's probably a hover)
	        if (storeIndex < 0) {
	            return;
	        }
	
	        // update the event in the store
	        store[storeIndex] = ev;
	
	        this.callback(this.manager, eventType, {
	            pointers: store,
	            changedPointers: [ev],
	            pointerType: pointerType,
	            srcEvent: ev
	        });
	
	        if (removePointer) {
	            // remove from the store
	            store.splice(storeIndex, 1);
	        }
	    }
	});
	
	var SINGLE_TOUCH_INPUT_MAP = {
	    touchstart: INPUT_START,
	    touchmove: INPUT_MOVE,
	    touchend: INPUT_END,
	    touchcancel: INPUT_CANCEL
	};
	
	var SINGLE_TOUCH_TARGET_EVENTS = 'touchstart';
	var SINGLE_TOUCH_WINDOW_EVENTS = 'touchstart touchmove touchend touchcancel';
	
	/**
	 * Touch events input
	 * @constructor
	 * @extends Input
	 */
	function SingleTouchInput() {
	    this.evTarget = SINGLE_TOUCH_TARGET_EVENTS;
	    this.evWin = SINGLE_TOUCH_WINDOW_EVENTS;
	    this.started = false;
	
	    Input.apply(this, arguments);
	}
	
	inherit(SingleTouchInput, Input, {
	    handler: function TEhandler(ev) {
	        var type = SINGLE_TOUCH_INPUT_MAP[ev.type];
	
	        // should we handle the touch events?
	        if (type === INPUT_START) {
	            this.started = true;
	        }
	
	        if (!this.started) {
	            return;
	        }
	
	        var touches = normalizeSingleTouches.call(this, ev, type);
	
	        // when done, reset the started state
	        if (type & (INPUT_END | INPUT_CANCEL) && touches[0].length - touches[1].length === 0) {
	            this.started = false;
	        }
	
	        this.callback(this.manager, type, {
	            pointers: touches[0],
	            changedPointers: touches[1],
	            pointerType: INPUT_TYPE_TOUCH,
	            srcEvent: ev
	        });
	    }
	});
	
	/**
	 * @this {TouchInput}
	 * @param {Object} ev
	 * @param {Number} type flag
	 * @returns {undefined|Array} [all, changed]
	 */
	function normalizeSingleTouches(ev, type) {
	    var all = toArray(ev.touches);
	    var changed = toArray(ev.changedTouches);
	
	    if (type & (INPUT_END | INPUT_CANCEL)) {
	        all = uniqueArray(all.concat(changed), 'identifier', true);
	    }
	
	    return [all, changed];
	}
	
	var TOUCH_INPUT_MAP = {
	    touchstart: INPUT_START,
	    touchmove: INPUT_MOVE,
	    touchend: INPUT_END,
	    touchcancel: INPUT_CANCEL
	};
	
	var TOUCH_TARGET_EVENTS = 'touchstart touchmove touchend touchcancel';
	
	/**
	 * Multi-user touch events input
	 * @constructor
	 * @extends Input
	 */
	function TouchInput() {
	    this.evTarget = TOUCH_TARGET_EVENTS;
	    this.targetIds = {};
	
	    Input.apply(this, arguments);
	}
	
	inherit(TouchInput, Input, {
	    handler: function MTEhandler(ev) {
	        var type = TOUCH_INPUT_MAP[ev.type];
	        var touches = getTouches.call(this, ev, type);
	        if (!touches) {
	            return;
	        }
	
	        this.callback(this.manager, type, {
	            pointers: touches[0],
	            changedPointers: touches[1],
	            pointerType: INPUT_TYPE_TOUCH,
	            srcEvent: ev
	        });
	    }
	});
	
	/**
	 * @this {TouchInput}
	 * @param {Object} ev
	 * @param {Number} type flag
	 * @returns {undefined|Array} [all, changed]
	 */
	function getTouches(ev, type) {
	    var allTouches = toArray(ev.touches);
	    var targetIds = this.targetIds;
	
	    // when there is only one touch, the process can be simplified
	    if (type & (INPUT_START | INPUT_MOVE) && allTouches.length === 1) {
	        targetIds[allTouches[0].identifier] = true;
	        return [allTouches, allTouches];
	    }
	
	    var i,
	        targetTouches,
	        changedTouches = toArray(ev.changedTouches),
	        changedTargetTouches = [],
	        target = this.target;
	
	    // get target touches from touches
	    targetTouches = allTouches.filter(function(touch) {
	        return hasParent(touch.target, target);
	    });
	
	    // collect touches
	    if (type === INPUT_START) {
	        i = 0;
	        while (i < targetTouches.length) {
	            targetIds[targetTouches[i].identifier] = true;
	            i++;
	        }
	    }
	
	    // filter changed touches to only contain touches that exist in the collected target ids
	    i = 0;
	    while (i < changedTouches.length) {
	        if (targetIds[changedTouches[i].identifier]) {
	            changedTargetTouches.push(changedTouches[i]);
	        }
	
	        // cleanup removed touches
	        if (type & (INPUT_END | INPUT_CANCEL)) {
	            delete targetIds[changedTouches[i].identifier];
	        }
	        i++;
	    }
	
	    if (!changedTargetTouches.length) {
	        return;
	    }
	
	    return [
	        // merge targetTouches with changedTargetTouches so it contains ALL touches, including 'end' and 'cancel'
	        uniqueArray(targetTouches.concat(changedTargetTouches), 'identifier', true),
	        changedTargetTouches
	    ];
	}
	
	/**
	 * Combined touch and mouse input
	 *
	 * Touch has a higher priority then mouse, and while touching no mouse events are allowed.
	 * This because touch devices also emit mouse events while doing a touch.
	 *
	 * @constructor
	 * @extends Input
	 */
	
	var DEDUP_TIMEOUT = 2500;
	var DEDUP_DISTANCE = 25;
	
	function TouchMouseInput() {
	    Input.apply(this, arguments);
	
	    var handler = bindFn(this.handler, this);
	    this.touch = new TouchInput(this.manager, handler);
	    this.mouse = new MouseInput(this.manager, handler);
	
	    this.primaryTouch = null;
	    this.lastTouches = [];
	}
	
	inherit(TouchMouseInput, Input, {
	    /**
	     * handle mouse and touch events
	     * @param {Hammer} manager
	     * @param {String} inputEvent
	     * @param {Object} inputData
	     */
	    handler: function TMEhandler(manager, inputEvent, inputData) {
	        var isTouch = (inputData.pointerType == INPUT_TYPE_TOUCH),
	            isMouse = (inputData.pointerType == INPUT_TYPE_MOUSE);
	
	        if (isMouse && inputData.sourceCapabilities && inputData.sourceCapabilities.firesTouchEvents) {
	            return;
	        }
	
	        // when we're in a touch event, record touches to  de-dupe synthetic mouse event
	        if (isTouch) {
	            recordTouches.call(this, inputEvent, inputData);
	        } else if (isMouse && isSyntheticEvent.call(this, inputData)) {
	            return;
	        }
	
	        this.callback(manager, inputEvent, inputData);
	    },
	
	    /**
	     * remove the event listeners
	     */
	    destroy: function destroy() {
	        this.touch.destroy();
	        this.mouse.destroy();
	    }
	});
	
	function recordTouches(eventType, eventData) {
	    if (eventType & INPUT_START) {
	        this.primaryTouch = eventData.changedPointers[0].identifier;
	        setLastTouch.call(this, eventData);
	    } else if (eventType & (INPUT_END | INPUT_CANCEL)) {
	        setLastTouch.call(this, eventData);
	    }
	}
	
	function setLastTouch(eventData) {
	    var touch = eventData.changedPointers[0];
	
	    if (touch.identifier === this.primaryTouch) {
	        var lastTouch = {x: touch.clientX, y: touch.clientY};
	        this.lastTouches.push(lastTouch);
	        var lts = this.lastTouches;
	        var removeLastTouch = function() {
	            var i = lts.indexOf(lastTouch);
	            if (i > -1) {
	                lts.splice(i, 1);
	            }
	        };
	        setTimeout(removeLastTouch, DEDUP_TIMEOUT);
	    }
	}
	
	function isSyntheticEvent(eventData) {
	    var x = eventData.srcEvent.clientX, y = eventData.srcEvent.clientY;
	    for (var i = 0; i < this.lastTouches.length; i++) {
	        var t = this.lastTouches[i];
	        var dx = Math.abs(x - t.x), dy = Math.abs(y - t.y);
	        if (dx <= DEDUP_DISTANCE && dy <= DEDUP_DISTANCE) {
	            return true;
	        }
	    }
	    return false;
	}
	
	var PREFIXED_TOUCH_ACTION = prefixed(TEST_ELEMENT.style, 'touchAction');
	var NATIVE_TOUCH_ACTION = PREFIXED_TOUCH_ACTION !== undefined;
	
	// magical touchAction value
	var TOUCH_ACTION_COMPUTE = 'compute';
	var TOUCH_ACTION_AUTO = 'auto';
	var TOUCH_ACTION_MANIPULATION = 'manipulation'; // not implemented
	var TOUCH_ACTION_NONE = 'none';
	var TOUCH_ACTION_PAN_X = 'pan-x';
	var TOUCH_ACTION_PAN_Y = 'pan-y';
	var TOUCH_ACTION_MAP = getTouchActionProps();
	
	/**
	 * Touch Action
	 * sets the touchAction property or uses the js alternative
	 * @param {Manager} manager
	 * @param {String} value
	 * @constructor
	 */
	function TouchAction(manager, value) {
	    this.manager = manager;
	    this.set(value);
	}
	
	TouchAction.prototype = {
	    /**
	     * set the touchAction value on the element or enable the polyfill
	     * @param {String} value
	     */
	    set: function(value) {
	        // find out the touch-action by the event handlers
	        if (value == TOUCH_ACTION_COMPUTE) {
	            value = this.compute();
	        }
	
	        if (NATIVE_TOUCH_ACTION && this.manager.element.style && TOUCH_ACTION_MAP[value]) {
	            this.manager.element.style[PREFIXED_TOUCH_ACTION] = value;
	        }
	        this.actions = value.toLowerCase().trim();
	    },
	
	    /**
	     * just re-set the touchAction value
	     */
	    update: function() {
	        this.set(this.manager.options.touchAction);
	    },
	
	    /**
	     * compute the value for the touchAction property based on the recognizer's settings
	     * @returns {String} value
	     */
	    compute: function() {
	        var actions = [];
	        each(this.manager.recognizers, function(recognizer) {
	            if (boolOrFn(recognizer.options.enable, [recognizer])) {
	                actions = actions.concat(recognizer.getTouchAction());
	            }
	        });
	        return cleanTouchActions(actions.join(' '));
	    },
	
	    /**
	     * this method is called on each input cycle and provides the preventing of the browser behavior
	     * @param {Object} input
	     */
	    preventDefaults: function(input) {
	        var srcEvent = input.srcEvent;
	        var direction = input.offsetDirection;
	
	        // if the touch action did prevented once this session
	        if (this.manager.session.prevented) {
	            srcEvent.preventDefault();
	            return;
	        }
	
	        var actions = this.actions;
	        var hasNone = inStr(actions, TOUCH_ACTION_NONE) && !TOUCH_ACTION_MAP[TOUCH_ACTION_NONE];
	        var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y) && !TOUCH_ACTION_MAP[TOUCH_ACTION_PAN_Y];
	        var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X) && !TOUCH_ACTION_MAP[TOUCH_ACTION_PAN_X];
	
	        if (hasNone) {
	            //do not prevent defaults if this is a tap gesture
	
	            var isTapPointer = input.pointers.length === 1;
	            var isTapMovement = input.distance < 2;
	            var isTapTouchTime = input.deltaTime < 250;
	
	            if (isTapPointer && isTapMovement && isTapTouchTime) {
	                return;
	            }
	        }
	
	        if (hasPanX && hasPanY) {
	            // `pan-x pan-y` means browser handles all scrolling/panning, do not prevent
	            return;
	        }
	
	        if (hasNone ||
	            (hasPanY && direction & DIRECTION_HORIZONTAL) ||
	            (hasPanX && direction & DIRECTION_VERTICAL)) {
	            return this.preventSrc(srcEvent);
	        }
	    },
	
	    /**
	     * call preventDefault to prevent the browser's default behavior (scrolling in most cases)
	     * @param {Object} srcEvent
	     */
	    preventSrc: function(srcEvent) {
	        this.manager.session.prevented = true;
	        srcEvent.preventDefault();
	    }
	};
	
	/**
	 * when the touchActions are collected they are not a valid value, so we need to clean things up. *
	 * @param {String} actions
	 * @returns {*}
	 */
	function cleanTouchActions(actions) {
	    // none
	    if (inStr(actions, TOUCH_ACTION_NONE)) {
	        return TOUCH_ACTION_NONE;
	    }
	
	    var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X);
	    var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y);
	
	    // if both pan-x and pan-y are set (different recognizers
	    // for different directions, e.g. horizontal pan but vertical swipe?)
	    // we need none (as otherwise with pan-x pan-y combined none of these
	    // recognizers will work, since the browser would handle all panning
	    if (hasPanX && hasPanY) {
	        return TOUCH_ACTION_NONE;
	    }
	
	    // pan-x OR pan-y
	    if (hasPanX || hasPanY) {
	        return hasPanX ? TOUCH_ACTION_PAN_X : TOUCH_ACTION_PAN_Y;
	    }
	
	    // manipulation
	    if (inStr(actions, TOUCH_ACTION_MANIPULATION)) {
	        return TOUCH_ACTION_MANIPULATION;
	    }
	
	    return TOUCH_ACTION_AUTO;
	}
	
	function getTouchActionProps() {
	    if (!NATIVE_TOUCH_ACTION) {
	        return false;
	    }
	    var touchMap = {};
	    var cssSupports = window.CSS && window.CSS.supports;
	    ['auto', 'manipulation', 'pan-y', 'pan-x', 'pan-x pan-y', 'none'].forEach(function(val) {
	
	        // If css.supports is not supported but there is native touch-action assume it supports
	        // all values. This is the case for IE 10 and 11.
	        touchMap[val] = cssSupports ? window.CSS.supports('touch-action', val) : true;
	    });
	    return touchMap;
	}
	
	/**
	 * Recognizer flow explained; *
	 * All recognizers have the initial state of POSSIBLE when a input session starts.
	 * The definition of a input session is from the first input until the last input, with all it's movement in it. *
	 * Example session for mouse-input: mousedown -> mousemove -> mouseup
	 *
	 * On each recognizing cycle (see Manager.recognize) the .recognize() method is executed
	 * which determines with state it should be.
	 *
	 * If the recognizer has the state FAILED, CANCELLED or RECOGNIZED (equals ENDED), it is reset to
	 * POSSIBLE to give it another change on the next cycle.
	 *
	 *               Possible
	 *                  |
	 *            +-----+---------------+
	 *            |                     |
	 *      +-----+-----+               |
	 *      |           |               |
	 *   Failed      Cancelled          |
	 *                          +-------+------+
	 *                          |              |
	 *                      Recognized       Began
	 *                                         |
	 *                                      Changed
	 *                                         |
	 *                                  Ended/Recognized
	 */
	var STATE_POSSIBLE = 1;
	var STATE_BEGAN = 2;
	var STATE_CHANGED = 4;
	var STATE_ENDED = 8;
	var STATE_RECOGNIZED = STATE_ENDED;
	var STATE_CANCELLED = 16;
	var STATE_FAILED = 32;
	
	/**
	 * Recognizer
	 * Every recognizer needs to extend from this class.
	 * @constructor
	 * @param {Object} options
	 */
	function Recognizer(options) {
	    this.options = assign({}, this.defaults, options || {});
	
	    this.id = uniqueId();
	
	    this.manager = null;
	
	    // default is enable true
	    this.options.enable = ifUndefined(this.options.enable, true);
	
	    this.state = STATE_POSSIBLE;
	
	    this.simultaneous = {};
	    this.requireFail = [];
	}
	
	Recognizer.prototype = {
	    /**
	     * @virtual
	     * @type {Object}
	     */
	    defaults: {},
	
	    /**
	     * set options
	     * @param {Object} options
	     * @return {Recognizer}
	     */
	    set: function(options) {
	        assign(this.options, options);
	
	        // also update the touchAction, in case something changed about the directions/enabled state
	        this.manager && this.manager.touchAction.update();
	        return this;
	    },
	
	    /**
	     * recognize simultaneous with an other recognizer.
	     * @param {Recognizer} otherRecognizer
	     * @returns {Recognizer} this
	     */
	    recognizeWith: function(otherRecognizer) {
	        if (invokeArrayArg(otherRecognizer, 'recognizeWith', this)) {
	            return this;
	        }
	
	        var simultaneous = this.simultaneous;
	        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
	        if (!simultaneous[otherRecognizer.id]) {
	            simultaneous[otherRecognizer.id] = otherRecognizer;
	            otherRecognizer.recognizeWith(this);
	        }
	        return this;
	    },
	
	    /**
	     * drop the simultaneous link. it doesnt remove the link on the other recognizer.
	     * @param {Recognizer} otherRecognizer
	     * @returns {Recognizer} this
	     */
	    dropRecognizeWith: function(otherRecognizer) {
	        if (invokeArrayArg(otherRecognizer, 'dropRecognizeWith', this)) {
	            return this;
	        }
	
	        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
	        delete this.simultaneous[otherRecognizer.id];
	        return this;
	    },
	
	    /**
	     * recognizer can only run when an other is failing
	     * @param {Recognizer} otherRecognizer
	     * @returns {Recognizer} this
	     */
	    requireFailure: function(otherRecognizer) {
	        if (invokeArrayArg(otherRecognizer, 'requireFailure', this)) {
	            return this;
	        }
	
	        var requireFail = this.requireFail;
	        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
	        if (inArray(requireFail, otherRecognizer) === -1) {
	            requireFail.push(otherRecognizer);
	            otherRecognizer.requireFailure(this);
	        }
	        return this;
	    },
	
	    /**
	     * drop the requireFailure link. it does not remove the link on the other recognizer.
	     * @param {Recognizer} otherRecognizer
	     * @returns {Recognizer} this
	     */
	    dropRequireFailure: function(otherRecognizer) {
	        if (invokeArrayArg(otherRecognizer, 'dropRequireFailure', this)) {
	            return this;
	        }
	
	        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
	        var index = inArray(this.requireFail, otherRecognizer);
	        if (index > -1) {
	            this.requireFail.splice(index, 1);
	        }
	        return this;
	    },
	
	    /**
	     * has require failures boolean
	     * @returns {boolean}
	     */
	    hasRequireFailures: function() {
	        return this.requireFail.length > 0;
	    },
	
	    /**
	     * if the recognizer can recognize simultaneous with an other recognizer
	     * @param {Recognizer} otherRecognizer
	     * @returns {Boolean}
	     */
	    canRecognizeWith: function(otherRecognizer) {
	        return !!this.simultaneous[otherRecognizer.id];
	    },
	
	    /**
	     * You should use `tryEmit` instead of `emit` directly to check
	     * that all the needed recognizers has failed before emitting.
	     * @param {Object} input
	     */
	    emit: function(input) {
	        var self = this;
	        var state = this.state;
	
	        function emit(event) {
	            self.manager.emit(event, input);
	        }
	
	        // 'panstart' and 'panmove'
	        if (state < STATE_ENDED) {
	            emit(self.options.event + stateStr(state));
	        }
	
	        emit(self.options.event); // simple 'eventName' events
	
	        if (input.additionalEvent) { // additional event(panleft, panright, pinchin, pinchout...)
	            emit(input.additionalEvent);
	        }
	
	        // panend and pancancel
	        if (state >= STATE_ENDED) {
	            emit(self.options.event + stateStr(state));
	        }
	    },
	
	    /**
	     * Check that all the require failure recognizers has failed,
	     * if true, it emits a gesture event,
	     * otherwise, setup the state to FAILED.
	     * @param {Object} input
	     */
	    tryEmit: function(input) {
	        if (this.canEmit()) {
	            return this.emit(input);
	        }
	        // it's failing anyway
	        this.state = STATE_FAILED;
	    },
	
	    /**
	     * can we emit?
	     * @returns {boolean}
	     */
	    canEmit: function() {
	        var i = 0;
	        while (i < this.requireFail.length) {
	            if (!(this.requireFail[i].state & (STATE_FAILED | STATE_POSSIBLE))) {
	                return false;
	            }
	            i++;
	        }
	        return true;
	    },
	
	    /**
	     * update the recognizer
	     * @param {Object} inputData
	     */
	    recognize: function(inputData) {
	        // make a new copy of the inputData
	        // so we can change the inputData without messing up the other recognizers
	        var inputDataClone = assign({}, inputData);
	
	        // is is enabled and allow recognizing?
	        if (!boolOrFn(this.options.enable, [this, inputDataClone])) {
	            this.reset();
	            this.state = STATE_FAILED;
	            return;
	        }
	
	        // reset when we've reached the end
	        if (this.state & (STATE_RECOGNIZED | STATE_CANCELLED | STATE_FAILED)) {
	            this.state = STATE_POSSIBLE;
	        }
	
	        this.state = this.process(inputDataClone);
	
	        // the recognizer has recognized a gesture
	        // so trigger an event
	        if (this.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED | STATE_CANCELLED)) {
	            this.tryEmit(inputDataClone);
	        }
	    },
	
	    /**
	     * return the state of the recognizer
	     * the actual recognizing happens in this method
	     * @virtual
	     * @param {Object} inputData
	     * @returns {Const} STATE
	     */
	    process: function(inputData) { }, // jshint ignore:line
	
	    /**
	     * return the preferred touch-action
	     * @virtual
	     * @returns {Array}
	     */
	    getTouchAction: function() { },
	
	    /**
	     * called when the gesture isn't allowed to recognize
	     * like when another is being recognized or it is disabled
	     * @virtual
	     */
	    reset: function() { }
	};
	
	/**
	 * get a usable string, used as event postfix
	 * @param {Const} state
	 * @returns {String} state
	 */
	function stateStr(state) {
	    if (state & STATE_CANCELLED) {
	        return 'cancel';
	    } else if (state & STATE_ENDED) {
	        return 'end';
	    } else if (state & STATE_CHANGED) {
	        return 'move';
	    } else if (state & STATE_BEGAN) {
	        return 'start';
	    }
	    return '';
	}
	
	/**
	 * direction cons to string
	 * @param {Const} direction
	 * @returns {String}
	 */
	function directionStr(direction) {
	    if (direction == DIRECTION_DOWN) {
	        return 'down';
	    } else if (direction == DIRECTION_UP) {
	        return 'up';
	    } else if (direction == DIRECTION_LEFT) {
	        return 'left';
	    } else if (direction == DIRECTION_RIGHT) {
	        return 'right';
	    }
	    return '';
	}
	
	/**
	 * get a recognizer by name if it is bound to a manager
	 * @param {Recognizer|String} otherRecognizer
	 * @param {Recognizer} recognizer
	 * @returns {Recognizer}
	 */
	function getRecognizerByNameIfManager(otherRecognizer, recognizer) {
	    var manager = recognizer.manager;
	    if (manager) {
	        return manager.get(otherRecognizer);
	    }
	    return otherRecognizer;
	}
	
	/**
	 * This recognizer is just used as a base for the simple attribute recognizers.
	 * @constructor
	 * @extends Recognizer
	 */
	function AttrRecognizer() {
	    Recognizer.apply(this, arguments);
	}
	
	inherit(AttrRecognizer, Recognizer, {
	    /**
	     * @namespace
	     * @memberof AttrRecognizer
	     */
	    defaults: {
	        /**
	         * @type {Number}
	         * @default 1
	         */
	        pointers: 1
	    },
	
	    /**
	     * Used to check if it the recognizer receives valid input, like input.distance > 10.
	     * @memberof AttrRecognizer
	     * @param {Object} input
	     * @returns {Boolean} recognized
	     */
	    attrTest: function(input) {
	        var optionPointers = this.options.pointers;
	        return optionPointers === 0 || input.pointers.length === optionPointers;
	    },
	
	    /**
	     * Process the input and return the state for the recognizer
	     * @memberof AttrRecognizer
	     * @param {Object} input
	     * @returns {*} State
	     */
	    process: function(input) {
	        var state = this.state;
	        var eventType = input.eventType;
	
	        var isRecognized = state & (STATE_BEGAN | STATE_CHANGED);
	        var isValid = this.attrTest(input);
	
	        // on cancel input and we've recognized before, return STATE_CANCELLED
	        if (isRecognized && (eventType & INPUT_CANCEL || !isValid)) {
	            return state | STATE_CANCELLED;
	        } else if (isRecognized || isValid) {
	            if (eventType & INPUT_END) {
	                return state | STATE_ENDED;
	            } else if (!(state & STATE_BEGAN)) {
	                return STATE_BEGAN;
	            }
	            return state | STATE_CHANGED;
	        }
	        return STATE_FAILED;
	    }
	});
	
	/**
	 * Pan
	 * Recognized when the pointer is down and moved in the allowed direction.
	 * @constructor
	 * @extends AttrRecognizer
	 */
	function PanRecognizer() {
	    AttrRecognizer.apply(this, arguments);
	
	    this.pX = null;
	    this.pY = null;
	}
	
	inherit(PanRecognizer, AttrRecognizer, {
	    /**
	     * @namespace
	     * @memberof PanRecognizer
	     */
	    defaults: {
	        event: 'pan',
	        threshold: 10,
	        pointers: 1,
	        direction: DIRECTION_ALL
	    },
	
	    getTouchAction: function() {
	        var direction = this.options.direction;
	        var actions = [];
	        if (direction & DIRECTION_HORIZONTAL) {
	            actions.push(TOUCH_ACTION_PAN_Y);
	        }
	        if (direction & DIRECTION_VERTICAL) {
	            actions.push(TOUCH_ACTION_PAN_X);
	        }
	        return actions;
	    },
	
	    directionTest: function(input) {
	        var options = this.options;
	        var hasMoved = true;
	        var distance = input.distance;
	        var direction = input.direction;
	        var x = input.deltaX;
	        var y = input.deltaY;
	
	        // lock to axis?
	        if (!(direction & options.direction)) {
	            if (options.direction & DIRECTION_HORIZONTAL) {
	                direction = (x === 0) ? DIRECTION_NONE : (x < 0) ? DIRECTION_LEFT : DIRECTION_RIGHT;
	                hasMoved = x != this.pX;
	                distance = Math.abs(input.deltaX);
	            } else {
	                direction = (y === 0) ? DIRECTION_NONE : (y < 0) ? DIRECTION_UP : DIRECTION_DOWN;
	                hasMoved = y != this.pY;
	                distance = Math.abs(input.deltaY);
	            }
	        }
	        input.direction = direction;
	        return hasMoved && distance > options.threshold && direction & options.direction;
	    },
	
	    attrTest: function(input) {
	        return AttrRecognizer.prototype.attrTest.call(this, input) &&
	            (this.state & STATE_BEGAN || (!(this.state & STATE_BEGAN) && this.directionTest(input)));
	    },
	
	    emit: function(input) {
	
	        this.pX = input.deltaX;
	        this.pY = input.deltaY;
	
	        var direction = directionStr(input.direction);
	
	        if (direction) {
	            input.additionalEvent = this.options.event + direction;
	        }
	        this._super.emit.call(this, input);
	    }
	});
	
	/**
	 * Pinch
	 * Recognized when two or more pointers are moving toward (zoom-in) or away from each other (zoom-out).
	 * @constructor
	 * @extends AttrRecognizer
	 */
	function PinchRecognizer() {
	    AttrRecognizer.apply(this, arguments);
	}
	
	inherit(PinchRecognizer, AttrRecognizer, {
	    /**
	     * @namespace
	     * @memberof PinchRecognizer
	     */
	    defaults: {
	        event: 'pinch',
	        threshold: 0,
	        pointers: 2
	    },
	
	    getTouchAction: function() {
	        return [TOUCH_ACTION_NONE];
	    },
	
	    attrTest: function(input) {
	        return this._super.attrTest.call(this, input) &&
	            (Math.abs(input.scale - 1) > this.options.threshold || this.state & STATE_BEGAN);
	    },
	
	    emit: function(input) {
	        if (input.scale !== 1) {
	            var inOut = input.scale < 1 ? 'in' : 'out';
	            input.additionalEvent = this.options.event + inOut;
	        }
	        this._super.emit.call(this, input);
	    }
	});
	
	/**
	 * Press
	 * Recognized when the pointer is down for x ms without any movement.
	 * @constructor
	 * @extends Recognizer
	 */
	function PressRecognizer() {
	    Recognizer.apply(this, arguments);
	
	    this._timer = null;
	    this._input = null;
	}
	
	inherit(PressRecognizer, Recognizer, {
	    /**
	     * @namespace
	     * @memberof PressRecognizer
	     */
	    defaults: {
	        event: 'press',
	        pointers: 1,
	        time: 251, // minimal time of the pointer to be pressed
	        threshold: 9 // a minimal movement is ok, but keep it low
	    },
	
	    getTouchAction: function() {
	        return [TOUCH_ACTION_AUTO];
	    },
	
	    process: function(input) {
	        var options = this.options;
	        var validPointers = input.pointers.length === options.pointers;
	        var validMovement = input.distance < options.threshold;
	        var validTime = input.deltaTime > options.time;
	
	        this._input = input;
	
	        // we only allow little movement
	        // and we've reached an end event, so a tap is possible
	        if (!validMovement || !validPointers || (input.eventType & (INPUT_END | INPUT_CANCEL) && !validTime)) {
	            this.reset();
	        } else if (input.eventType & INPUT_START) {
	            this.reset();
	            this._timer = setTimeoutContext(function() {
	                this.state = STATE_RECOGNIZED;
	                this.tryEmit();
	            }, options.time, this);
	        } else if (input.eventType & INPUT_END) {
	            return STATE_RECOGNIZED;
	        }
	        return STATE_FAILED;
	    },
	
	    reset: function() {
	        clearTimeout(this._timer);
	    },
	
	    emit: function(input) {
	        if (this.state !== STATE_RECOGNIZED) {
	            return;
	        }
	
	        if (input && (input.eventType & INPUT_END)) {
	            this.manager.emit(this.options.event + 'up', input);
	        } else {
	            this._input.timeStamp = now();
	            this.manager.emit(this.options.event, this._input);
	        }
	    }
	});
	
	/**
	 * Rotate
	 * Recognized when two or more pointer are moving in a circular motion.
	 * @constructor
	 * @extends AttrRecognizer
	 */
	function RotateRecognizer() {
	    AttrRecognizer.apply(this, arguments);
	}
	
	inherit(RotateRecognizer, AttrRecognizer, {
	    /**
	     * @namespace
	     * @memberof RotateRecognizer
	     */
	    defaults: {
	        event: 'rotate',
	        threshold: 0,
	        pointers: 2
	    },
	
	    getTouchAction: function() {
	        return [TOUCH_ACTION_NONE];
	    },
	
	    attrTest: function(input) {
	        return this._super.attrTest.call(this, input) &&
	            (Math.abs(input.rotation) > this.options.threshold || this.state & STATE_BEGAN);
	    }
	});
	
	/**
	 * Swipe
	 * Recognized when the pointer is moving fast (velocity), with enough distance in the allowed direction.
	 * @constructor
	 * @extends AttrRecognizer
	 */
	function SwipeRecognizer() {
	    AttrRecognizer.apply(this, arguments);
	}
	
	inherit(SwipeRecognizer, AttrRecognizer, {
	    /**
	     * @namespace
	     * @memberof SwipeRecognizer
	     */
	    defaults: {
	        event: 'swipe',
	        threshold: 10,
	        velocity: 0.3,
	        direction: DIRECTION_HORIZONTAL | DIRECTION_VERTICAL,
	        pointers: 1
	    },
	
	    getTouchAction: function() {
	        return PanRecognizer.prototype.getTouchAction.call(this);
	    },
	
	    attrTest: function(input) {
	        var direction = this.options.direction;
	        var velocity;
	
	        if (direction & (DIRECTION_HORIZONTAL | DIRECTION_VERTICAL)) {
	            velocity = input.overallVelocity;
	        } else if (direction & DIRECTION_HORIZONTAL) {
	            velocity = input.overallVelocityX;
	        } else if (direction & DIRECTION_VERTICAL) {
	            velocity = input.overallVelocityY;
	        }
	
	        return this._super.attrTest.call(this, input) &&
	            direction & input.offsetDirection &&
	            input.distance > this.options.threshold &&
	            input.maxPointers == this.options.pointers &&
	            abs(velocity) > this.options.velocity && input.eventType & INPUT_END;
	    },
	
	    emit: function(input) {
	        var direction = directionStr(input.offsetDirection);
	        if (direction) {
	            this.manager.emit(this.options.event + direction, input);
	        }
	
	        this.manager.emit(this.options.event, input);
	    }
	});
	
	/**
	 * A tap is ecognized when the pointer is doing a small tap/click. Multiple taps are recognized if they occur
	 * between the given interval and position. The delay option can be used to recognize multi-taps without firing
	 * a single tap.
	 *
	 * The eventData from the emitted event contains the property `tapCount`, which contains the amount of
	 * multi-taps being recognized.
	 * @constructor
	 * @extends Recognizer
	 */
	function TapRecognizer() {
	    Recognizer.apply(this, arguments);
	
	    // previous time and center,
	    // used for tap counting
	    this.pTime = false;
	    this.pCenter = false;
	
	    this._timer = null;
	    this._input = null;
	    this.count = 0;
	}
	
	inherit(TapRecognizer, Recognizer, {
	    /**
	     * @namespace
	     * @memberof PinchRecognizer
	     */
	    defaults: {
	        event: 'tap',
	        pointers: 1,
	        taps: 1,
	        interval: 300, // max time between the multi-tap taps
	        time: 250, // max time of the pointer to be down (like finger on the screen)
	        threshold: 9, // a minimal movement is ok, but keep it low
	        posThreshold: 10 // a multi-tap can be a bit off the initial position
	    },
	
	    getTouchAction: function() {
	        return [TOUCH_ACTION_MANIPULATION];
	    },
	
	    process: function(input) {
	        var options = this.options;
	
	        var validPointers = input.pointers.length === options.pointers;
	        var validMovement = input.distance < options.threshold;
	        var validTouchTime = input.deltaTime < options.time;
	
	        this.reset();
	
	        if ((input.eventType & INPUT_START) && (this.count === 0)) {
	            return this.failTimeout();
	        }
	
	        // we only allow little movement
	        // and we've reached an end event, so a tap is possible
	        if (validMovement && validTouchTime && validPointers) {
	            if (input.eventType != INPUT_END) {
	                return this.failTimeout();
	            }
	
	            var validInterval = this.pTime ? (input.timeStamp - this.pTime < options.interval) : true;
	            var validMultiTap = !this.pCenter || getDistance(this.pCenter, input.center) < options.posThreshold;
	
	            this.pTime = input.timeStamp;
	            this.pCenter = input.center;
	
	            if (!validMultiTap || !validInterval) {
	                this.count = 1;
	            } else {
	                this.count += 1;
	            }
	
	            this._input = input;
	
	            // if tap count matches we have recognized it,
	            // else it has began recognizing...
	            var tapCount = this.count % options.taps;
	            if (tapCount === 0) {
	                // no failing requirements, immediately trigger the tap event
	                // or wait as long as the multitap interval to trigger
	                if (!this.hasRequireFailures()) {
	                    return STATE_RECOGNIZED;
	                } else {
	                    this._timer = setTimeoutContext(function() {
	                        this.state = STATE_RECOGNIZED;
	                        this.tryEmit();
	                    }, options.interval, this);
	                    return STATE_BEGAN;
	                }
	            }
	        }
	        return STATE_FAILED;
	    },
	
	    failTimeout: function() {
	        this._timer = setTimeoutContext(function() {
	            this.state = STATE_FAILED;
	        }, this.options.interval, this);
	        return STATE_FAILED;
	    },
	
	    reset: function() {
	        clearTimeout(this._timer);
	    },
	
	    emit: function() {
	        if (this.state == STATE_RECOGNIZED) {
	            this._input.tapCount = this.count;
	            this.manager.emit(this.options.event, this._input);
	        }
	    }
	});
	
	/**
	 * Simple way to create a manager with a default set of recognizers.
	 * @param {HTMLElement} element
	 * @param {Object} [options]
	 * @constructor
	 */
	function Hammer(element, options) {
	    options = options || {};
	    options.recognizers = ifUndefined(options.recognizers, Hammer.defaults.preset);
	    return new Manager(element, options);
	}
	
	/**
	 * @const {string}
	 */
	Hammer.VERSION = '2.0.7';
	
	/**
	 * default settings
	 * @namespace
	 */
	Hammer.defaults = {
	    /**
	     * set if DOM events are being triggered.
	     * But this is slower and unused by simple implementations, so disabled by default.
	     * @type {Boolean}
	     * @default false
	     */
	    domEvents: false,
	
	    /**
	     * The value for the touchAction property/fallback.
	     * When set to `compute` it will magically set the correct value based on the added recognizers.
	     * @type {String}
	     * @default compute
	     */
	    touchAction: TOUCH_ACTION_COMPUTE,
	
	    /**
	     * @type {Boolean}
	     * @default true
	     */
	    enable: true,
	
	    /**
	     * EXPERIMENTAL FEATURE -- can be removed/changed
	     * Change the parent input target element.
	     * If Null, then it is being set the to main element.
	     * @type {Null|EventTarget}
	     * @default null
	     */
	    inputTarget: null,
	
	    /**
	     * force an input class
	     * @type {Null|Function}
	     * @default null
	     */
	    inputClass: null,
	
	    /**
	     * Default recognizer setup when calling `Hammer()`
	     * When creating a new Manager these will be skipped.
	     * @type {Array}
	     */
	    preset: [
	        // RecognizerClass, options, [recognizeWith, ...], [requireFailure, ...]
	        [RotateRecognizer, {enable: false}],
	        [PinchRecognizer, {enable: false}, ['rotate']],
	        [SwipeRecognizer, {direction: DIRECTION_HORIZONTAL}],
	        [PanRecognizer, {direction: DIRECTION_HORIZONTAL}, ['swipe']],
	        [TapRecognizer],
	        [TapRecognizer, {event: 'doubletap', taps: 2}, ['tap']],
	        [PressRecognizer]
	    ],
	
	    /**
	     * Some CSS properties can be used to improve the working of Hammer.
	     * Add them to this method and they will be set when creating a new Manager.
	     * @namespace
	     */
	    cssProps: {
	        /**
	         * Disables text selection to improve the dragging gesture. Mainly for desktop browsers.
	         * @type {String}
	         * @default 'none'
	         */
	        userSelect: 'none',
	
	        /**
	         * Disable the Windows Phone grippers when pressing an element.
	         * @type {String}
	         * @default 'none'
	         */
	        touchSelect: 'none',
	
	        /**
	         * Disables the default callout shown when you touch and hold a touch target.
	         * On iOS, when you touch and hold a touch target such as a link, Safari displays
	         * a callout containing information about the link. This property allows you to disable that callout.
	         * @type {String}
	         * @default 'none'
	         */
	        touchCallout: 'none',
	
	        /**
	         * Specifies whether zooming is enabled. Used by IE10>
	         * @type {String}
	         * @default 'none'
	         */
	        contentZooming: 'none',
	
	        /**
	         * Specifies that an entire element should be draggable instead of its contents. Mainly for desktop browsers.
	         * @type {String}
	         * @default 'none'
	         */
	        userDrag: 'none',
	
	        /**
	         * Overrides the highlight color shown when the user taps a link or a JavaScript
	         * clickable element in iOS. This property obeys the alpha value, if specified.
	         * @type {String}
	         * @default 'rgba(0,0,0,0)'
	         */
	        tapHighlightColor: 'rgba(0,0,0,0)'
	    }
	};
	
	var STOP = 1;
	var FORCED_STOP = 2;
	
	/**
	 * Manager
	 * @param {HTMLElement} element
	 * @param {Object} [options]
	 * @constructor
	 */
	function Manager(element, options) {
	    this.options = assign({}, Hammer.defaults, options || {});
	
	    this.options.inputTarget = this.options.inputTarget || element;
	
	    this.handlers = {};
	    this.session = {};
	    this.recognizers = [];
	    this.oldCssProps = {};
	
	    this.element = element;
	    this.input = createInputInstance(this);
	    this.touchAction = new TouchAction(this, this.options.touchAction);
	
	    toggleCssProps(this, true);
	
	    each(this.options.recognizers, function(item) {
	        var recognizer = this.add(new (item[0])(item[1]));
	        item[2] && recognizer.recognizeWith(item[2]);
	        item[3] && recognizer.requireFailure(item[3]);
	    }, this);
	}
	
	Manager.prototype = {
	    /**
	     * set options
	     * @param {Object} options
	     * @returns {Manager}
	     */
	    set: function(options) {
	        assign(this.options, options);
	
	        // Options that need a little more setup
	        if (options.touchAction) {
	            this.touchAction.update();
	        }
	        if (options.inputTarget) {
	            // Clean up existing event listeners and reinitialize
	            this.input.destroy();
	            this.input.target = options.inputTarget;
	            this.input.init();
	        }
	        return this;
	    },
	
	    /**
	     * stop recognizing for this session.
	     * This session will be discarded, when a new [input]start event is fired.
	     * When forced, the recognizer cycle is stopped immediately.
	     * @param {Boolean} [force]
	     */
	    stop: function(force) {
	        this.session.stopped = force ? FORCED_STOP : STOP;
	    },
	
	    /**
	     * run the recognizers!
	     * called by the inputHandler function on every movement of the pointers (touches)
	     * it walks through all the recognizers and tries to detect the gesture that is being made
	     * @param {Object} inputData
	     */
	    recognize: function(inputData) {
	        var session = this.session;
	        if (session.stopped) {
	            return;
	        }
	
	        // run the touch-action polyfill
	        this.touchAction.preventDefaults(inputData);
	
	        var recognizer;
	        var recognizers = this.recognizers;
	
	        // this holds the recognizer that is being recognized.
	        // so the recognizer's state needs to be BEGAN, CHANGED, ENDED or RECOGNIZED
	        // if no recognizer is detecting a thing, it is set to `null`
	        var curRecognizer = session.curRecognizer;
	
	        // reset when the last recognizer is recognized
	        // or when we're in a new session
	        if (!curRecognizer || (curRecognizer && curRecognizer.state & STATE_RECOGNIZED)) {
	            curRecognizer = session.curRecognizer = null;
	        }
	
	        var i = 0;
	        while (i < recognizers.length) {
	            recognizer = recognizers[i];
	
	            // find out if we are allowed try to recognize the input for this one.
	            // 1.   allow if the session is NOT forced stopped (see the .stop() method)
	            // 2.   allow if we still haven't recognized a gesture in this session, or the this recognizer is the one
	            //      that is being recognized.
	            // 3.   allow if the recognizer is allowed to run simultaneous with the current recognized recognizer.
	            //      this can be setup with the `recognizeWith()` method on the recognizer.
	            if (session.stopped !== FORCED_STOP && ( // 1
	                    !curRecognizer || recognizer == curRecognizer || // 2
	                    recognizer.canRecognizeWith(curRecognizer))) { // 3
	                recognizer.recognize(inputData);
	            } else {
	                recognizer.reset();
	            }
	
	            // if the recognizer has been recognizing the input as a valid gesture, we want to store this one as the
	            // current active recognizer. but only if we don't already have an active recognizer
	            if (!curRecognizer && recognizer.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED)) {
	                curRecognizer = session.curRecognizer = recognizer;
	            }
	            i++;
	        }
	    },
	
	    /**
	     * get a recognizer by its event name.
	     * @param {Recognizer|String} recognizer
	     * @returns {Recognizer|Null}
	     */
	    get: function(recognizer) {
	        if (recognizer instanceof Recognizer) {
	            return recognizer;
	        }
	
	        var recognizers = this.recognizers;
	        for (var i = 0; i < recognizers.length; i++) {
	            if (recognizers[i].options.event == recognizer) {
	                return recognizers[i];
	            }
	        }
	        return null;
	    },
	
	    /**
	     * add a recognizer to the manager
	     * existing recognizers with the same event name will be removed
	     * @param {Recognizer} recognizer
	     * @returns {Recognizer|Manager}
	     */
	    add: function(recognizer) {
	        if (invokeArrayArg(recognizer, 'add', this)) {
	            return this;
	        }
	
	        // remove existing
	        var existing = this.get(recognizer.options.event);
	        if (existing) {
	            this.remove(existing);
	        }
	
	        this.recognizers.push(recognizer);
	        recognizer.manager = this;
	
	        this.touchAction.update();
	        return recognizer;
	    },
	
	    /**
	     * remove a recognizer by name or instance
	     * @param {Recognizer|String} recognizer
	     * @returns {Manager}
	     */
	    remove: function(recognizer) {
	        if (invokeArrayArg(recognizer, 'remove', this)) {
	            return this;
	        }
	
	        recognizer = this.get(recognizer);
	
	        // let's make sure this recognizer exists
	        if (recognizer) {
	            var recognizers = this.recognizers;
	            var index = inArray(recognizers, recognizer);
	
	            if (index !== -1) {
	                recognizers.splice(index, 1);
	                this.touchAction.update();
	            }
	        }
	
	        return this;
	    },
	
	    /**
	     * bind event
	     * @param {String} events
	     * @param {Function} handler
	     * @returns {EventEmitter} this
	     */
	    on: function(events, handler) {
	        if (events === undefined) {
	            return;
	        }
	        if (handler === undefined) {
	            return;
	        }
	
	        var handlers = this.handlers;
	        each(splitStr(events), function(event) {
	            handlers[event] = handlers[event] || [];
	            handlers[event].push(handler);
	        });
	        return this;
	    },
	
	    /**
	     * unbind event, leave emit blank to remove all handlers
	     * @param {String} events
	     * @param {Function} [handler]
	     * @returns {EventEmitter} this
	     */
	    off: function(events, handler) {
	        if (events === undefined) {
	            return;
	        }
	
	        var handlers = this.handlers;
	        each(splitStr(events), function(event) {
	            if (!handler) {
	                delete handlers[event];
	            } else {
	                handlers[event] && handlers[event].splice(inArray(handlers[event], handler), 1);
	            }
	        });
	        return this;
	    },
	
	    /**
	     * emit event to the listeners
	     * @param {String} event
	     * @param {Object} data
	     */
	    emit: function(event, data) {
	        // we also want to trigger dom events
	        if (this.options.domEvents) {
	            triggerDomEvent(event, data);
	        }
	
	        // no handlers, so skip it all
	        var handlers = this.handlers[event] && this.handlers[event].slice();
	        if (!handlers || !handlers.length) {
	            return;
	        }
	
	        data.type = event;
	        data.preventDefault = function() {
	            data.srcEvent.preventDefault();
	        };
	
	        var i = 0;
	        while (i < handlers.length) {
	            handlers[i](data);
	            i++;
	        }
	    },
	
	    /**
	     * destroy the manager and unbinds all events
	     * it doesn't unbind dom events, that is the user own responsibility
	     */
	    destroy: function() {
	        this.element && toggleCssProps(this, false);
	
	        this.handlers = {};
	        this.session = {};
	        this.input.destroy();
	        this.element = null;
	    }
	};
	
	/**
	 * add/remove the css properties as defined in manager.options.cssProps
	 * @param {Manager} manager
	 * @param {Boolean} add
	 */
	function toggleCssProps(manager, add) {
	    var element = manager.element;
	    if (!element.style) {
	        return;
	    }
	    var prop;
	    each(manager.options.cssProps, function(value, name) {
	        prop = prefixed(element.style, name);
	        if (add) {
	            manager.oldCssProps[prop] = element.style[prop];
	            element.style[prop] = value;
	        } else {
	            element.style[prop] = manager.oldCssProps[prop] || '';
	        }
	    });
	    if (!add) {
	        manager.oldCssProps = {};
	    }
	}
	
	/**
	 * trigger dom event
	 * @param {String} event
	 * @param {Object} data
	 */
	function triggerDomEvent(event, data) {
	    var gestureEvent = document.createEvent('Event');
	    gestureEvent.initEvent(event, true, true);
	    gestureEvent.gesture = data;
	    data.target.dispatchEvent(gestureEvent);
	}
	
	assign(Hammer, {
	    INPUT_START: INPUT_START,
	    INPUT_MOVE: INPUT_MOVE,
	    INPUT_END: INPUT_END,
	    INPUT_CANCEL: INPUT_CANCEL,
	
	    STATE_POSSIBLE: STATE_POSSIBLE,
	    STATE_BEGAN: STATE_BEGAN,
	    STATE_CHANGED: STATE_CHANGED,
	    STATE_ENDED: STATE_ENDED,
	    STATE_RECOGNIZED: STATE_RECOGNIZED,
	    STATE_CANCELLED: STATE_CANCELLED,
	    STATE_FAILED: STATE_FAILED,
	
	    DIRECTION_NONE: DIRECTION_NONE,
	    DIRECTION_LEFT: DIRECTION_LEFT,
	    DIRECTION_RIGHT: DIRECTION_RIGHT,
	    DIRECTION_UP: DIRECTION_UP,
	    DIRECTION_DOWN: DIRECTION_DOWN,
	    DIRECTION_HORIZONTAL: DIRECTION_HORIZONTAL,
	    DIRECTION_VERTICAL: DIRECTION_VERTICAL,
	    DIRECTION_ALL: DIRECTION_ALL,
	
	    Manager: Manager,
	    Input: Input,
	    TouchAction: TouchAction,
	
	    TouchInput: TouchInput,
	    MouseInput: MouseInput,
	    PointerEventInput: PointerEventInput,
	    TouchMouseInput: TouchMouseInput,
	    SingleTouchInput: SingleTouchInput,
	
	    Recognizer: Recognizer,
	    AttrRecognizer: AttrRecognizer,
	    Tap: TapRecognizer,
	    Pan: PanRecognizer,
	    Swipe: SwipeRecognizer,
	    Pinch: PinchRecognizer,
	    Rotate: RotateRecognizer,
	    Press: PressRecognizer,
	
	    on: addEventListeners,
	    off: removeEventListeners,
	    each: each,
	    merge: merge,
	    extend: extend,
	    assign: assign,
	    inherit: inherit,
	    bindFn: bindFn,
	    prefixed: prefixed
	});
	
	// this prevents errors when Hammer is loaded in the presence of an AMD
	//  style loader but by script tag, not by the loader.
	var freeGlobal = (typeof window !== 'undefined' ? window : (typeof self !== 'undefined' ? self : {})); // jshint ignore:line
	freeGlobal.Hammer = Hammer;
	
	if (true) {
	    !(__WEBPACK_AMD_DEFINE_RESULT__ = function() {
	        return Hammer;
	    }.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	} else if (typeof module != 'undefined' && module.exports) {
	    module.exports = Hammer;
	} else {
	    window[exportName] = Hammer;
	}
	
	})(window, document, 'Hammer');


/***/ }),
/* 241 */
/***/ (function(module, exports) {

	/**
	 * Helpers.
	 */
	
	var s = 1000
	var m = s * 60
	var h = m * 60
	var d = h * 24
	var y = d * 365.25
	
	/**
	 * Parse or format the given `val`.
	 *
	 * Options:
	 *
	 *  - `long` verbose formatting [false]
	 *
	 * @param {String|Number} val
	 * @param {Object} [options]
	 * @throws {Error} throw an error if val is not a non-empty string or a number
	 * @return {String|Number}
	 * @api public
	 */
	
	module.exports = function (val, options) {
	  options = options || {}
	  var type = typeof val
	  if (type === 'string' && val.length > 0) {
	    return parse(val)
	  } else if (type === 'number' && isNaN(val) === false) {
	    return options.long ?
				fmtLong(val) :
				fmtShort(val)
	  }
	  throw new Error('val is not a non-empty string or a valid number. val=' + JSON.stringify(val))
	}
	
	/**
	 * Parse the given `str` and return milliseconds.
	 *
	 * @param {String} str
	 * @return {Number}
	 * @api private
	 */
	
	function parse(str) {
	  str = String(str)
	  if (str.length > 10000) {
	    return
	  }
	  var match = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(str)
	  if (!match) {
	    return
	  }
	  var n = parseFloat(match[1])
	  var type = (match[2] || 'ms').toLowerCase()
	  switch (type) {
	    case 'years':
	    case 'year':
	    case 'yrs':
	    case 'yr':
	    case 'y':
	      return n * y
	    case 'days':
	    case 'day':
	    case 'd':
	      return n * d
	    case 'hours':
	    case 'hour':
	    case 'hrs':
	    case 'hr':
	    case 'h':
	      return n * h
	    case 'minutes':
	    case 'minute':
	    case 'mins':
	    case 'min':
	    case 'm':
	      return n * m
	    case 'seconds':
	    case 'second':
	    case 'secs':
	    case 'sec':
	    case 's':
	      return n * s
	    case 'milliseconds':
	    case 'millisecond':
	    case 'msecs':
	    case 'msec':
	    case 'ms':
	      return n
	    default:
	      return undefined
	  }
	}
	
	/**
	 * Short format for `ms`.
	 *
	 * @param {Number} ms
	 * @return {String}
	 * @api private
	 */
	
	function fmtShort(ms) {
	  if (ms >= d) {
	    return Math.round(ms / d) + 'd'
	  }
	  if (ms >= h) {
	    return Math.round(ms / h) + 'h'
	  }
	  if (ms >= m) {
	    return Math.round(ms / m) + 'm'
	  }
	  if (ms >= s) {
	    return Math.round(ms / s) + 's'
	  }
	  return ms + 'ms'
	}
	
	/**
	 * Long format for `ms`.
	 *
	 * @param {Number} ms
	 * @return {String}
	 * @api private
	 */
	
	function fmtLong(ms) {
	  return plural(ms, d, 'day') ||
	    plural(ms, h, 'hour') ||
	    plural(ms, m, 'minute') ||
	    plural(ms, s, 'second') ||
	    ms + ' ms'
	}
	
	/**
	 * Pluralization helper.
	 */
	
	function plural(ms, n, name) {
	  if (ms < n) {
	    return
	  }
	  if (ms < n * 1.5) {
	    return Math.floor(ms / n) + ' ' + name
	  }
	  return Math.ceil(ms / n) + ' ' + name + 's'
	}


/***/ }),
/* 242 */
/***/ (function(module, exports, __webpack_require__) {

	var add = __webpack_require__(235)
	var set = __webpack_require__(238)
	var normalize = __webpack_require__(237)
	var subtract = __webpack_require__(239)
	var dot = __webpack_require__(236)
	
	var tmp = [0, 0]
	
	module.exports.computeMiter = function computeMiter(tangent, miter, lineA, lineB, halfThick) {
	    //get tangent line
	    add(tangent, lineA, lineB)
	    normalize(tangent, tangent)
	
	    //get miter as a unit vector
	    set(miter, -tangent[1], tangent[0])
	    set(tmp, -lineA[1], lineA[0])
	
	    //get the necessary length of our miter
	    return halfThick / dot(miter, tmp)
	}
	
	module.exports.normal = function normal(out, dir) {
	    //get perpendicular
	    set(out, -dir[1], dir[0])
	    return out
	}
	
	module.exports.direction = function direction(out, a, b) {
	    //get unit dir of two lines
	    subtract(out, a, b)
	    normalize(out, out)
	    return out
	}

/***/ }),
/* 243 */
/***/ (function(module, exports, __webpack_require__) {

	var util = __webpack_require__(242)
	
	var lineA = [0, 0]
	var lineB = [0, 0]
	var tangent = [0, 0]
	var miter = [0, 0]
	
	module.exports = function(points, closed) {
	    var curNormal = null
	    var out = []
	    if (closed) {
	        points = points.slice()
	        points.push(points[0])
	    }
	
	    var total = points.length
	    for (var i=1; i<total; i++) {
	        var last = points[i-1]
	        var cur = points[i]
	        var next = i<points.length-1 ? points[i+1] : null
	
	        util.direction(lineA, cur, last)
	        if (!curNormal)  {
	            curNormal = [0, 0]
	            util.normal(curNormal, lineA)
	        }
	
	        if (i === 1) //add initial normals
	            addNext(out, curNormal, 1)
	
	        if (!next) { //no miter, simple segment
	            util.normal(curNormal, lineA) //reset normal
	            addNext(out, curNormal, 1)
	        } else { //miter with last
	            //get unit dir of next line
	            util.direction(lineB, next, cur)
	
	            //stores tangent & miter
	            var miterLen = util.computeMiter(tangent, miter, lineA, lineB, 1)
	            addNext(out, miter, miterLen)
	        }
	    }
	
	    //if the polyline is a closed loop, clean up the last normal
	    if (points.length > 2 && closed) {
	        var last2 = points[total-2]
	        var cur2 = points[0]
	        var next2 = points[1]
	
	        util.direction(lineA, cur2, last2)
	        util.direction(lineB, next2, cur2)
	        util.normal(curNormal, lineA)
	        
	        var miterLen2 = util.computeMiter(tangent, miter, lineA, lineB, 1)
	        out[0][0] = miter.slice()
	        out[total-1][0] = miter.slice()
	        out[0][1] = miterLen2
	        out[total-1][1] = miterLen2
	        out.pop()
	    }
	
	    return out
	}
	
	function addNext(out, normal, length) {
	    out.push([[normal[0], normal[1]], length])
	}

/***/ }),
/* 244 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/* WEBPACK VAR INJECTION */(function(module, global) {/*! https://mths.be/punycode v1.3.2 by @mathias */
	;(function(root) {
	
		/** Detect free variables */
		var freeExports = typeof exports == 'object' && exports &&
			!exports.nodeType && exports;
		var freeModule = typeof module == 'object' && module &&
			!module.nodeType && module;
		var freeGlobal = typeof global == 'object' && global;
		if (
			freeGlobal.global === freeGlobal ||
			freeGlobal.window === freeGlobal ||
			freeGlobal.self === freeGlobal
		) {
			root = freeGlobal;
		}
	
		/**
		 * The `punycode` object.
		 * @name punycode
		 * @type Object
		 */
		var punycode,
	
		/** Highest positive signed 32-bit float value */
		maxInt = 2147483647, // aka. 0x7FFFFFFF or 2^31-1
	
		/** Bootstring parameters */
		base = 36,
		tMin = 1,
		tMax = 26,
		skew = 38,
		damp = 700,
		initialBias = 72,
		initialN = 128, // 0x80
		delimiter = '-', // '\x2D'
	
		/** Regular expressions */
		regexPunycode = /^xn--/,
		regexNonASCII = /[^\x20-\x7E]/, // unprintable ASCII chars + non-ASCII chars
		regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g, // RFC 3490 separators
	
		/** Error messages */
		errors = {
			'overflow': 'Overflow: input needs wider integers to process',
			'not-basic': 'Illegal input >= 0x80 (not a basic code point)',
			'invalid-input': 'Invalid input'
		},
	
		/** Convenience shortcuts */
		baseMinusTMin = base - tMin,
		floor = Math.floor,
		stringFromCharCode = String.fromCharCode,
	
		/** Temporary variable */
		key;
	
		/*--------------------------------------------------------------------------*/
	
		/**
		 * A generic error utility function.
		 * @private
		 * @param {String} type The error type.
		 * @returns {Error} Throws a `RangeError` with the applicable error message.
		 */
		function error(type) {
			throw RangeError(errors[type]);
		}
	
		/**
		 * A generic `Array#map` utility function.
		 * @private
		 * @param {Array} array The array to iterate over.
		 * @param {Function} callback The function that gets called for every array
		 * item.
		 * @returns {Array} A new array of values returned by the callback function.
		 */
		function map(array, fn) {
			var length = array.length;
			var result = [];
			while (length--) {
				result[length] = fn(array[length]);
			}
			return result;
		}
	
		/**
		 * A simple `Array#map`-like wrapper to work with domain name strings or email
		 * addresses.
		 * @private
		 * @param {String} domain The domain name or email address.
		 * @param {Function} callback The function that gets called for every
		 * character.
		 * @returns {Array} A new string of characters returned by the callback
		 * function.
		 */
		function mapDomain(string, fn) {
			var parts = string.split('@');
			var result = '';
			if (parts.length > 1) {
				// In email addresses, only the domain name should be punycoded. Leave
				// the local part (i.e. everything up to `@`) intact.
				result = parts[0] + '@';
				string = parts[1];
			}
			// Avoid `split(regex)` for IE8 compatibility. See #17.
			string = string.replace(regexSeparators, '\x2E');
			var labels = string.split('.');
			var encoded = map(labels, fn).join('.');
			return result + encoded;
		}
	
		/**
		 * Creates an array containing the numeric code points of each Unicode
		 * character in the string. While JavaScript uses UCS-2 internally,
		 * this function will convert a pair of surrogate halves (each of which
		 * UCS-2 exposes as separate characters) into a single code point,
		 * matching UTF-16.
		 * @see `punycode.ucs2.encode`
		 * @see <https://mathiasbynens.be/notes/javascript-encoding>
		 * @memberOf punycode.ucs2
		 * @name decode
		 * @param {String} string The Unicode input string (UCS-2).
		 * @returns {Array} The new array of code points.
		 */
		function ucs2decode(string) {
			var output = [],
			    counter = 0,
			    length = string.length,
			    value,
			    extra;
			while (counter < length) {
				value = string.charCodeAt(counter++);
				if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
					// high surrogate, and there is a next character
					extra = string.charCodeAt(counter++);
					if ((extra & 0xFC00) == 0xDC00) { // low surrogate
						output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
					} else {
						// unmatched surrogate; only append this code unit, in case the next
						// code unit is the high surrogate of a surrogate pair
						output.push(value);
						counter--;
					}
				} else {
					output.push(value);
				}
			}
			return output;
		}
	
		/**
		 * Creates a string based on an array of numeric code points.
		 * @see `punycode.ucs2.decode`
		 * @memberOf punycode.ucs2
		 * @name encode
		 * @param {Array} codePoints The array of numeric code points.
		 * @returns {String} The new Unicode string (UCS-2).
		 */
		function ucs2encode(array) {
			return map(array, function(value) {
				var output = '';
				if (value > 0xFFFF) {
					value -= 0x10000;
					output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
					value = 0xDC00 | value & 0x3FF;
				}
				output += stringFromCharCode(value);
				return output;
			}).join('');
		}
	
		/**
		 * Converts a basic code point into a digit/integer.
		 * @see `digitToBasic()`
		 * @private
		 * @param {Number} codePoint The basic numeric code point value.
		 * @returns {Number} The numeric value of a basic code point (for use in
		 * representing integers) in the range `0` to `base - 1`, or `base` if
		 * the code point does not represent a value.
		 */
		function basicToDigit(codePoint) {
			if (codePoint - 48 < 10) {
				return codePoint - 22;
			}
			if (codePoint - 65 < 26) {
				return codePoint - 65;
			}
			if (codePoint - 97 < 26) {
				return codePoint - 97;
			}
			return base;
		}
	
		/**
		 * Converts a digit/integer into a basic code point.
		 * @see `basicToDigit()`
		 * @private
		 * @param {Number} digit The numeric value of a basic code point.
		 * @returns {Number} The basic code point whose value (when used for
		 * representing integers) is `digit`, which needs to be in the range
		 * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
		 * used; else, the lowercase form is used. The behavior is undefined
		 * if `flag` is non-zero and `digit` has no uppercase form.
		 */
		function digitToBasic(digit, flag) {
			//  0..25 map to ASCII a..z or A..Z
			// 26..35 map to ASCII 0..9
			return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
		}
	
		/**
		 * Bias adaptation function as per section 3.4 of RFC 3492.
		 * http://tools.ietf.org/html/rfc3492#section-3.4
		 * @private
		 */
		function adapt(delta, numPoints, firstTime) {
			var k = 0;
			delta = firstTime ? floor(delta / damp) : delta >> 1;
			delta += floor(delta / numPoints);
			for (/* no initialization */; delta > baseMinusTMin * tMax >> 1; k += base) {
				delta = floor(delta / baseMinusTMin);
			}
			return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
		}
	
		/**
		 * Converts a Punycode string of ASCII-only symbols to a string of Unicode
		 * symbols.
		 * @memberOf punycode
		 * @param {String} input The Punycode string of ASCII-only symbols.
		 * @returns {String} The resulting string of Unicode symbols.
		 */
		function decode(input) {
			// Don't use UCS-2
			var output = [],
			    inputLength = input.length,
			    out,
			    i = 0,
			    n = initialN,
			    bias = initialBias,
			    basic,
			    j,
			    index,
			    oldi,
			    w,
			    k,
			    digit,
			    t,
			    /** Cached calculation results */
			    baseMinusT;
	
			// Handle the basic code points: let `basic` be the number of input code
			// points before the last delimiter, or `0` if there is none, then copy
			// the first basic code points to the output.
	
			basic = input.lastIndexOf(delimiter);
			if (basic < 0) {
				basic = 0;
			}
	
			for (j = 0; j < basic; ++j) {
				// if it's not a basic code point
				if (input.charCodeAt(j) >= 0x80) {
					error('not-basic');
				}
				output.push(input.charCodeAt(j));
			}
	
			// Main decoding loop: start just after the last delimiter if any basic code
			// points were copied; start at the beginning otherwise.
	
			for (index = basic > 0 ? basic + 1 : 0; index < inputLength; /* no final expression */) {
	
				// `index` is the index of the next character to be consumed.
				// Decode a generalized variable-length integer into `delta`,
				// which gets added to `i`. The overflow checking is easier
				// if we increase `i` as we go, then subtract off its starting
				// value at the end to obtain `delta`.
				for (oldi = i, w = 1, k = base; /* no condition */; k += base) {
	
					if (index >= inputLength) {
						error('invalid-input');
					}
	
					digit = basicToDigit(input.charCodeAt(index++));
	
					if (digit >= base || digit > floor((maxInt - i) / w)) {
						error('overflow');
					}
	
					i += digit * w;
					t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);
	
					if (digit < t) {
						break;
					}
	
					baseMinusT = base - t;
					if (w > floor(maxInt / baseMinusT)) {
						error('overflow');
					}
	
					w *= baseMinusT;
	
				}
	
				out = output.length + 1;
				bias = adapt(i - oldi, out, oldi == 0);
	
				// `i` was supposed to wrap around from `out` to `0`,
				// incrementing `n` each time, so we'll fix that now:
				if (floor(i / out) > maxInt - n) {
					error('overflow');
				}
	
				n += floor(i / out);
				i %= out;
	
				// Insert `n` at position `i` of the output
				output.splice(i++, 0, n);
	
			}
	
			return ucs2encode(output);
		}
	
		/**
		 * Converts a string of Unicode symbols (e.g. a domain name label) to a
		 * Punycode string of ASCII-only symbols.
		 * @memberOf punycode
		 * @param {String} input The string of Unicode symbols.
		 * @returns {String} The resulting Punycode string of ASCII-only symbols.
		 */
		function encode(input) {
			var n,
			    delta,
			    handledCPCount,
			    basicLength,
			    bias,
			    j,
			    m,
			    q,
			    k,
			    t,
			    currentValue,
			    output = [],
			    /** `inputLength` will hold the number of code points in `input`. */
			    inputLength,
			    /** Cached calculation results */
			    handledCPCountPlusOne,
			    baseMinusT,
			    qMinusT;
	
			// Convert the input in UCS-2 to Unicode
			input = ucs2decode(input);
	
			// Cache the length
			inputLength = input.length;
	
			// Initialize the state
			n = initialN;
			delta = 0;
			bias = initialBias;
	
			// Handle the basic code points
			for (j = 0; j < inputLength; ++j) {
				currentValue = input[j];
				if (currentValue < 0x80) {
					output.push(stringFromCharCode(currentValue));
				}
			}
	
			handledCPCount = basicLength = output.length;
	
			// `handledCPCount` is the number of code points that have been handled;
			// `basicLength` is the number of basic code points.
	
			// Finish the basic string - if it is not empty - with a delimiter
			if (basicLength) {
				output.push(delimiter);
			}
	
			// Main encoding loop:
			while (handledCPCount < inputLength) {
	
				// All non-basic code points < n have been handled already. Find the next
				// larger one:
				for (m = maxInt, j = 0; j < inputLength; ++j) {
					currentValue = input[j];
					if (currentValue >= n && currentValue < m) {
						m = currentValue;
					}
				}
	
				// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,
				// but guard against overflow
				handledCPCountPlusOne = handledCPCount + 1;
				if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
					error('overflow');
				}
	
				delta += (m - n) * handledCPCountPlusOne;
				n = m;
	
				for (j = 0; j < inputLength; ++j) {
					currentValue = input[j];
	
					if (currentValue < n && ++delta > maxInt) {
						error('overflow');
					}
	
					if (currentValue == n) {
						// Represent delta as a generalized variable-length integer
						for (q = delta, k = base; /* no condition */; k += base) {
							t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);
							if (q < t) {
								break;
							}
							qMinusT = q - t;
							baseMinusT = base - t;
							output.push(
								stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))
							);
							q = floor(qMinusT / baseMinusT);
						}
	
						output.push(stringFromCharCode(digitToBasic(q, 0)));
						bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
						delta = 0;
						++handledCPCount;
					}
				}
	
				++delta;
				++n;
	
			}
			return output.join('');
		}
	
		/**
		 * Converts a Punycode string representing a domain name or an email address
		 * to Unicode. Only the Punycoded parts of the input will be converted, i.e.
		 * it doesn't matter if you call it on a string that has already been
		 * converted to Unicode.
		 * @memberOf punycode
		 * @param {String} input The Punycoded domain name or email address to
		 * convert to Unicode.
		 * @returns {String} The Unicode representation of the given Punycode
		 * string.
		 */
		function toUnicode(input) {
			return mapDomain(input, function(string) {
				return regexPunycode.test(string)
					? decode(string.slice(4).toLowerCase())
					: string;
			});
		}
	
		/**
		 * Converts a Unicode string representing a domain name or an email address to
		 * Punycode. Only the non-ASCII parts of the domain name will be converted,
		 * i.e. it doesn't matter if you call it with a domain that's already in
		 * ASCII.
		 * @memberOf punycode
		 * @param {String} input The domain name or email address to convert, as a
		 * Unicode string.
		 * @returns {String} The Punycode representation of the given domain name or
		 * email address.
		 */
		function toASCII(input) {
			return mapDomain(input, function(string) {
				return regexNonASCII.test(string)
					? 'xn--' + encode(string)
					: string;
			});
		}
	
		/*--------------------------------------------------------------------------*/
	
		/** Define the public API */
		punycode = {
			/**
			 * A string representing the current Punycode.js version number.
			 * @memberOf punycode
			 * @type String
			 */
			'version': '1.3.2',
			/**
			 * An object of methods to convert from JavaScript's internal character
			 * representation (UCS-2) to Unicode code points, and back.
			 * @see <https://mathiasbynens.be/notes/javascript-encoding>
			 * @memberOf punycode
			 * @type Object
			 */
			'ucs2': {
				'decode': ucs2decode,
				'encode': ucs2encode
			},
			'decode': decode,
			'encode': encode,
			'toASCII': toASCII,
			'toUnicode': toUnicode
		};
	
		/** Expose `punycode` */
		// Some AMD build optimizers, like r.js, check for specific condition patterns
		// like the following:
		if (
			true
		) {
			!(__WEBPACK_AMD_DEFINE_RESULT__ = function() {
				return punycode;
			}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
		} else if (freeExports && freeModule) {
			if (module.exports == freeExports) { // in Node.js or RingoJS v0.8.0+
				freeModule.exports = punycode;
			} else { // in Narwhal or RingoJS v0.7.0-
				for (key in punycode) {
					punycode.hasOwnProperty(key) && (freeExports[key] = punycode[key]);
				}
			}
		} else { // in Rhino or a web browser
			root.punycode = punycode;
		}
	
	}(this));
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(30)(module), (function() { return this; }())))

/***/ }),
/* 245 */
/***/ (function(module, exports) {

	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.
	
	'use strict';
	
	// If obj.hasOwnProperty has been overridden, then calling
	// obj.hasOwnProperty(prop) will break.
	// See: https://github.com/joyent/node/issues/1707
	function hasOwnProperty(obj, prop) {
	  return Object.prototype.hasOwnProperty.call(obj, prop);
	}
	
	module.exports = function(qs, sep, eq, options) {
	  sep = sep || '&';
	  eq = eq || '=';
	  var obj = {};
	
	  if (typeof qs !== 'string' || qs.length === 0) {
	    return obj;
	  }
	
	  var regexp = /\+/g;
	  qs = qs.split(sep);
	
	  var maxKeys = 1000;
	  if (options && typeof options.maxKeys === 'number') {
	    maxKeys = options.maxKeys;
	  }
	
	  var len = qs.length;
	  // maxKeys <= 0 means that we should not limit keys count
	  if (maxKeys > 0 && len > maxKeys) {
	    len = maxKeys;
	  }
	
	  for (var i = 0; i < len; ++i) {
	    var x = qs[i].replace(regexp, '%20'),
	        idx = x.indexOf(eq),
	        kstr, vstr, k, v;
	
	    if (idx >= 0) {
	      kstr = x.substr(0, idx);
	      vstr = x.substr(idx + 1);
	    } else {
	      kstr = x;
	      vstr = '';
	    }
	
	    k = decodeURIComponent(kstr);
	    v = decodeURIComponent(vstr);
	
	    if (!hasOwnProperty(obj, k)) {
	      obj[k] = v;
	    } else if (Array.isArray(obj[k])) {
	      obj[k].push(v);
	    } else {
	      obj[k] = [obj[k], v];
	    }
	  }
	
	  return obj;
	};


/***/ }),
/* 246 */
/***/ (function(module, exports) {

	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.
	
	'use strict';
	
	var stringifyPrimitive = function(v) {
	  switch (typeof v) {
	    case 'string':
	      return v;
	
	    case 'boolean':
	      return v ? 'true' : 'false';
	
	    case 'number':
	      return isFinite(v) ? v : '';
	
	    default:
	      return '';
	  }
	};
	
	module.exports = function(obj, sep, eq, name) {
	  sep = sep || '&';
	  eq = eq || '=';
	  if (obj === null) {
	    obj = undefined;
	  }
	
	  if (typeof obj === 'object') {
	    return Object.keys(obj).map(function(k) {
	      var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;
	      if (Array.isArray(obj[k])) {
	        return obj[k].map(function(v) {
	          return ks + encodeURIComponent(stringifyPrimitive(v));
	        }).join(sep);
	      } else {
	        return ks + encodeURIComponent(stringifyPrimitive(obj[k]));
	      }
	    }).join(sep);
	
	  }
	
	  if (!name) return '';
	  return encodeURIComponent(stringifyPrimitive(name)) + eq +
	         encodeURIComponent(stringifyPrimitive(obj));
	};


/***/ }),
/* 247 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.decode = exports.parse = __webpack_require__(245);
	exports.encode = exports.stringify = __webpack_require__(246);


/***/ }),
/* 248 */
/***/ (function(module, exports) {

	'use strict';
	
	var has = Object.prototype.hasOwnProperty;
	
	/**
	 * Decode a URI encoded string.
	 *
	 * @param {String} input The URI encoded string.
	 * @returns {String} The decoded string.
	 * @api private
	 */
	function decode(input) {
	  return decodeURIComponent(input.replace(/\+/g, ' '));
	}
	
	/**
	 * Simple query string parser.
	 *
	 * @param {String} query The query string that needs to be parsed.
	 * @returns {Object}
	 * @api public
	 */
	function querystring(query) {
	  var parser = /([^=?&]+)=?([^&]*)/g
	    , result = {}
	    , part;
	
	  //
	  // Little nifty parsing hack, leverage the fact that RegExp.exec increments
	  // the lastIndex property so we can continue executing this loop until we've
	  // parsed all results.
	  //
	  for (;
	    part = parser.exec(query);
	    result[decode(part[1])] = decode(part[2])
	  );
	
	  return result;
	}
	
	/**
	 * Transform a query string to an object.
	 *
	 * @param {Object} obj Object that should be transformed.
	 * @param {String} prefix Optional prefix.
	 * @returns {String}
	 * @api public
	 */
	function querystringify(obj, prefix) {
	  prefix = prefix || '';
	
	  var pairs = [];
	
	  //
	  // Optionally prefix with a '?' if needed
	  //
	  if ('string' !== typeof prefix) prefix = '?';
	
	  for (var key in obj) {
	    if (has.call(obj, key)) {
	      pairs.push(encodeURIComponent(key) +'='+ encodeURIComponent(obj[key]));
	    }
	  }
	
	  return pairs.length ? prefix + pairs.join('&') : '';
	}
	
	//
	// Expose the module.
	//
	exports.stringify = querystringify;
	exports.parse = querystring;


/***/ }),
/* 249 */
/***/ (function(module, exports) {

	'use strict';
	
	module.exports = partialSort;
	
	// Floyd-Rivest selection algorithm:
	// Rearrange items so that all items in the [left, k] range are smaller than all items in (k, right];
	// The k-th element will have the (k - left + 1)th smallest value in [left, right]
	
	function partialSort(arr, k, left, right, compare) {
	    left = left || 0;
	    right = right || (arr.length - 1);
	    compare = compare || defaultCompare;
	
	    while (right > left) {
	        if (right - left > 600) {
	            var n = right - left + 1;
	            var m = k - left + 1;
	            var z = Math.log(n);
	            var s = 0.5 * Math.exp(2 * z / 3);
	            var sd = 0.5 * Math.sqrt(z * s * (n - s) / n) * (m - n / 2 < 0 ? -1 : 1);
	            var newLeft = Math.max(left, Math.floor(k - m * s / n + sd));
	            var newRight = Math.min(right, Math.floor(k + (n - m) * s / n + sd));
	            partialSort(arr, k, newLeft, newRight, compare);
	        }
	
	        var t = arr[k];
	        var i = left;
	        var j = right;
	
	        swap(arr, left, k);
	        if (compare(arr[right], t) > 0) swap(arr, left, right);
	
	        while (i < j) {
	            swap(arr, i, j);
	            i++;
	            j--;
	            while (compare(arr[i], t) < 0) i++;
	            while (compare(arr[j], t) > 0) j--;
	        }
	
	        if (compare(arr[left], t) === 0) swap(arr, left, j);
	        else {
	            j++;
	            swap(arr, j, right);
	        }
	
	        if (j <= k) left = j + 1;
	        if (k <= j) right = j - 1;
	    }
	}
	
	function swap(arr, i, j) {
	    var tmp = arr[i];
	    arr[i] = arr[j];
	    arr[j] = tmp;
	}
	
	function defaultCompare(a, b) {
	    return a < b ? -1 : a > b ? 1 : 0;
	}


/***/ }),
/* 250 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	module.exports = rbush;
	
	var quickselect = __webpack_require__(249);
	
	function rbush(maxEntries, format) {
	    if (!(this instanceof rbush)) return new rbush(maxEntries, format);
	
	    // max entries in a node is 9 by default; min node fill is 40% for best performance
	    this._maxEntries = Math.max(4, maxEntries || 9);
	    this._minEntries = Math.max(2, Math.ceil(this._maxEntries * 0.4));
	
	    if (format) {
	        this._initFormat(format);
	    }
	
	    this.clear();
	}
	
	rbush.prototype = {
	
	    all: function () {
	        return this._all(this.data, []);
	    },
	
	    search: function (bbox) {
	
	        var node = this.data,
	            result = [],
	            toBBox = this.toBBox;
	
	        if (!intersects(bbox, node)) return result;
	
	        var nodesToSearch = [],
	            i, len, child, childBBox;
	
	        while (node) {
	            for (i = 0, len = node.children.length; i < len; i++) {
	
	                child = node.children[i];
	                childBBox = node.leaf ? toBBox(child) : child;
	
	                if (intersects(bbox, childBBox)) {
	                    if (node.leaf) result.push(child);
	                    else if (contains(bbox, childBBox)) this._all(child, result);
	                    else nodesToSearch.push(child);
	                }
	            }
	            node = nodesToSearch.pop();
	        }
	
	        return result;
	    },
	
	    collides: function (bbox) {
	
	        var node = this.data,
	            toBBox = this.toBBox;
	
	        if (!intersects(bbox, node)) return false;
	
	        var nodesToSearch = [],
	            i, len, child, childBBox;
	
	        while (node) {
	            for (i = 0, len = node.children.length; i < len; i++) {
	
	                child = node.children[i];
	                childBBox = node.leaf ? toBBox(child) : child;
	
	                if (intersects(bbox, childBBox)) {
	                    if (node.leaf || contains(bbox, childBBox)) return true;
	                    nodesToSearch.push(child);
	                }
	            }
	            node = nodesToSearch.pop();
	        }
	
	        return false;
	    },
	
	    load: function (data) {
	        if (!(data && data.length)) return this;
	
	        if (data.length < this._minEntries) {
	            for (var i = 0, len = data.length; i < len; i++) {
	                this.insert(data[i]);
	            }
	            return this;
	        }
	
	        // recursively build the tree with the given data from stratch using OMT algorithm
	        var node = this._build(data.slice(), 0, data.length - 1, 0);
	
	        if (!this.data.children.length) {
	            // save as is if tree is empty
	            this.data = node;
	
	        } else if (this.data.height === node.height) {
	            // split root if trees have the same height
	            this._splitRoot(this.data, node);
	
	        } else {
	            if (this.data.height < node.height) {
	                // swap trees if inserted one is bigger
	                var tmpNode = this.data;
	                this.data = node;
	                node = tmpNode;
	            }
	
	            // insert the small tree into the large tree at appropriate level
	            this._insert(node, this.data.height - node.height - 1, true);
	        }
	
	        return this;
	    },
	
	    insert: function (item) {
	        if (item) this._insert(item, this.data.height - 1);
	        return this;
	    },
	
	    clear: function () {
	        this.data = createNode([]);
	        return this;
	    },
	
	    remove: function (item, equalsFn) {
	        if (!item) return this;
	
	        var node = this.data,
	            bbox = this.toBBox(item),
	            path = [],
	            indexes = [],
	            i, parent, index, goingUp;
	
	        // depth-first iterative tree traversal
	        while (node || path.length) {
	
	            if (!node) { // go up
	                node = path.pop();
	                parent = path[path.length - 1];
	                i = indexes.pop();
	                goingUp = true;
	            }
	
	            if (node.leaf) { // check current node
	                index = findItem(item, node.children, equalsFn);
	
	                if (index !== -1) {
	                    // item found, remove the item and condense tree upwards
	                    node.children.splice(index, 1);
	                    path.push(node);
	                    this._condense(path);
	                    return this;
	                }
	            }
	
	            if (!goingUp && !node.leaf && contains(node, bbox)) { // go down
	                path.push(node);
	                indexes.push(i);
	                i = 0;
	                parent = node;
	                node = node.children[0];
	
	            } else if (parent) { // go right
	                i++;
	                node = parent.children[i];
	                goingUp = false;
	
	            } else node = null; // nothing found
	        }
	
	        return this;
	    },
	
	    toBBox: function (item) { return item; },
	
	    compareMinX: compareNodeMinX,
	    compareMinY: compareNodeMinY,
	
	    toJSON: function () { return this.data; },
	
	    fromJSON: function (data) {
	        this.data = data;
	        return this;
	    },
	
	    _all: function (node, result) {
	        var nodesToSearch = [];
	        while (node) {
	            if (node.leaf) result.push.apply(result, node.children);
	            else nodesToSearch.push.apply(nodesToSearch, node.children);
	
	            node = nodesToSearch.pop();
	        }
	        return result;
	    },
	
	    _build: function (items, left, right, height) {
	
	        var N = right - left + 1,
	            M = this._maxEntries,
	            node;
	
	        if (N <= M) {
	            // reached leaf level; return leaf
	            node = createNode(items.slice(left, right + 1));
	            calcBBox(node, this.toBBox);
	            return node;
	        }
	
	        if (!height) {
	            // target height of the bulk-loaded tree
	            height = Math.ceil(Math.log(N) / Math.log(M));
	
	            // target number of root entries to maximize storage utilization
	            M = Math.ceil(N / Math.pow(M, height - 1));
	        }
	
	        node = createNode([]);
	        node.leaf = false;
	        node.height = height;
	
	        // split the items into M mostly square tiles
	
	        var N2 = Math.ceil(N / M),
	            N1 = N2 * Math.ceil(Math.sqrt(M)),
	            i, j, right2, right3;
	
	        multiSelect(items, left, right, N1, this.compareMinX);
	
	        for (i = left; i <= right; i += N1) {
	
	            right2 = Math.min(i + N1 - 1, right);
	
	            multiSelect(items, i, right2, N2, this.compareMinY);
	
	            for (j = i; j <= right2; j += N2) {
	
	                right3 = Math.min(j + N2 - 1, right2);
	
	                // pack each entry recursively
	                node.children.push(this._build(items, j, right3, height - 1));
	            }
	        }
	
	        calcBBox(node, this.toBBox);
	
	        return node;
	    },
	
	    _chooseSubtree: function (bbox, node, level, path) {
	
	        var i, len, child, targetNode, area, enlargement, minArea, minEnlargement;
	
	        while (true) {
	            path.push(node);
	
	            if (node.leaf || path.length - 1 === level) break;
	
	            minArea = minEnlargement = Infinity;
	
	            for (i = 0, len = node.children.length; i < len; i++) {
	                child = node.children[i];
	                area = bboxArea(child);
	                enlargement = enlargedArea(bbox, child) - area;
	
	                // choose entry with the least area enlargement
	                if (enlargement < minEnlargement) {
	                    minEnlargement = enlargement;
	                    minArea = area < minArea ? area : minArea;
	                    targetNode = child;
	
	                } else if (enlargement === minEnlargement) {
	                    // otherwise choose one with the smallest area
	                    if (area < minArea) {
	                        minArea = area;
	                        targetNode = child;
	                    }
	                }
	            }
	
	            node = targetNode || node.children[0];
	        }
	
	        return node;
	    },
	
	    _insert: function (item, level, isNode) {
	
	        var toBBox = this.toBBox,
	            bbox = isNode ? item : toBBox(item),
	            insertPath = [];
	
	        // find the best node for accommodating the item, saving all nodes along the path too
	        var node = this._chooseSubtree(bbox, this.data, level, insertPath);
	
	        // put the item into the node
	        node.children.push(item);
	        extend(node, bbox);
	
	        // split on node overflow; propagate upwards if necessary
	        while (level >= 0) {
	            if (insertPath[level].children.length > this._maxEntries) {
	                this._split(insertPath, level);
	                level--;
	            } else break;
	        }
	
	        // adjust bboxes along the insertion path
	        this._adjustParentBBoxes(bbox, insertPath, level);
	    },
	
	    // split overflowed node into two
	    _split: function (insertPath, level) {
	
	        var node = insertPath[level],
	            M = node.children.length,
	            m = this._minEntries;
	
	        this._chooseSplitAxis(node, m, M);
	
	        var splitIndex = this._chooseSplitIndex(node, m, M);
	
	        var newNode = createNode(node.children.splice(splitIndex, node.children.length - splitIndex));
	        newNode.height = node.height;
	        newNode.leaf = node.leaf;
	
	        calcBBox(node, this.toBBox);
	        calcBBox(newNode, this.toBBox);
	
	        if (level) insertPath[level - 1].children.push(newNode);
	        else this._splitRoot(node, newNode);
	    },
	
	    _splitRoot: function (node, newNode) {
	        // split root node
	        this.data = createNode([node, newNode]);
	        this.data.height = node.height + 1;
	        this.data.leaf = false;
	        calcBBox(this.data, this.toBBox);
	    },
	
	    _chooseSplitIndex: function (node, m, M) {
	
	        var i, bbox1, bbox2, overlap, area, minOverlap, minArea, index;
	
	        minOverlap = minArea = Infinity;
	
	        for (i = m; i <= M - m; i++) {
	            bbox1 = distBBox(node, 0, i, this.toBBox);
	            bbox2 = distBBox(node, i, M, this.toBBox);
	
	            overlap = intersectionArea(bbox1, bbox2);
	            area = bboxArea(bbox1) + bboxArea(bbox2);
	
	            // choose distribution with minimum overlap
	            if (overlap < minOverlap) {
	                minOverlap = overlap;
	                index = i;
	
	                minArea = area < minArea ? area : minArea;
	
	            } else if (overlap === minOverlap) {
	                // otherwise choose distribution with minimum area
	                if (area < minArea) {
	                    minArea = area;
	                    index = i;
	                }
	            }
	        }
	
	        return index;
	    },
	
	    // sorts node children by the best axis for split
	    _chooseSplitAxis: function (node, m, M) {
	
	        var compareMinX = node.leaf ? this.compareMinX : compareNodeMinX,
	            compareMinY = node.leaf ? this.compareMinY : compareNodeMinY,
	            xMargin = this._allDistMargin(node, m, M, compareMinX),
	            yMargin = this._allDistMargin(node, m, M, compareMinY);
	
	        // if total distributions margin value is minimal for x, sort by minX,
	        // otherwise it's already sorted by minY
	        if (xMargin < yMargin) node.children.sort(compareMinX);
	    },
	
	    // total margin of all possible split distributions where each node is at least m full
	    _allDistMargin: function (node, m, M, compare) {
	
	        node.children.sort(compare);
	
	        var toBBox = this.toBBox,
	            leftBBox = distBBox(node, 0, m, toBBox),
	            rightBBox = distBBox(node, M - m, M, toBBox),
	            margin = bboxMargin(leftBBox) + bboxMargin(rightBBox),
	            i, child;
	
	        for (i = m; i < M - m; i++) {
	            child = node.children[i];
	            extend(leftBBox, node.leaf ? toBBox(child) : child);
	            margin += bboxMargin(leftBBox);
	        }
	
	        for (i = M - m - 1; i >= m; i--) {
	            child = node.children[i];
	            extend(rightBBox, node.leaf ? toBBox(child) : child);
	            margin += bboxMargin(rightBBox);
	        }
	
	        return margin;
	    },
	
	    _adjustParentBBoxes: function (bbox, path, level) {
	        // adjust bboxes along the given tree path
	        for (var i = level; i >= 0; i--) {
	            extend(path[i], bbox);
	        }
	    },
	
	    _condense: function (path) {
	        // go through the path, removing empty nodes and updating bboxes
	        for (var i = path.length - 1, siblings; i >= 0; i--) {
	            if (path[i].children.length === 0) {
	                if (i > 0) {
	                    siblings = path[i - 1].children;
	                    siblings.splice(siblings.indexOf(path[i]), 1);
	
	                } else this.clear();
	
	            } else calcBBox(path[i], this.toBBox);
	        }
	    },
	
	    _initFormat: function (format) {
	        // data format (minX, minY, maxX, maxY accessors)
	
	        // uses eval-type function compilation instead of just accepting a toBBox function
	        // because the algorithms are very sensitive to sorting functions performance,
	        // so they should be dead simple and without inner calls
	
	        var compareArr = ['return a', ' - b', ';'];
	
	        this.compareMinX = new Function('a', 'b', compareArr.join(format[0]));
	        this.compareMinY = new Function('a', 'b', compareArr.join(format[1]));
	
	        this.toBBox = new Function('a',
	            'return {minX: a' + format[0] +
	            ', minY: a' + format[1] +
	            ', maxX: a' + format[2] +
	            ', maxY: a' + format[3] + '};');
	    }
	};
	
	function findItem(item, items, equalsFn) {
	    if (!equalsFn) return items.indexOf(item);
	
	    for (var i = 0; i < items.length; i++) {
	        if (equalsFn(item, items[i])) return i;
	    }
	    return -1;
	}
	
	// calculate node's bbox from bboxes of its children
	function calcBBox(node, toBBox) {
	    distBBox(node, 0, node.children.length, toBBox, node);
	}
	
	// min bounding rectangle of node children from k to p-1
	function distBBox(node, k, p, toBBox, destNode) {
	    if (!destNode) destNode = createNode(null);
	    destNode.minX = Infinity;
	    destNode.minY = Infinity;
	    destNode.maxX = -Infinity;
	    destNode.maxY = -Infinity;
	
	    for (var i = k, child; i < p; i++) {
	        child = node.children[i];
	        extend(destNode, node.leaf ? toBBox(child) : child);
	    }
	
	    return destNode;
	}
	
	function extend(a, b) {
	    a.minX = Math.min(a.minX, b.minX);
	    a.minY = Math.min(a.minY, b.minY);
	    a.maxX = Math.max(a.maxX, b.maxX);
	    a.maxY = Math.max(a.maxY, b.maxY);
	    return a;
	}
	
	function compareNodeMinX(a, b) { return a.minX - b.minX; }
	function compareNodeMinY(a, b) { return a.minY - b.minY; }
	
	function bboxArea(a)   { return (a.maxX - a.minX) * (a.maxY - a.minY); }
	function bboxMargin(a) { return (a.maxX - a.minX) + (a.maxY - a.minY); }
	
	function enlargedArea(a, b) {
	    return (Math.max(b.maxX, a.maxX) - Math.min(b.minX, a.minX)) *
	           (Math.max(b.maxY, a.maxY) - Math.min(b.minY, a.minY));
	}
	
	function intersectionArea(a, b) {
	    var minX = Math.max(a.minX, b.minX),
	        minY = Math.max(a.minY, b.minY),
	        maxX = Math.min(a.maxX, b.maxX),
	        maxY = Math.min(a.maxY, b.maxY);
	
	    return Math.max(0, maxX - minX) *
	           Math.max(0, maxY - minY);
	}
	
	function contains(a, b) {
	    return a.minX <= b.minX &&
	           a.minY <= b.minY &&
	           b.maxX <= a.maxX &&
	           b.maxY <= a.maxY;
	}
	
	function intersects(a, b) {
	    return b.minX <= a.maxX &&
	           b.minY <= a.maxY &&
	           b.maxX >= a.minX &&
	           b.maxY >= a.minY;
	}
	
	function createNode(children) {
	    return {
	        children: children,
	        height: 1,
	        leaf: true,
	        minX: Infinity,
	        minY: Infinity,
	        maxX: -Infinity,
	        maxY: -Infinity
	    };
	}
	
	// sort an array so that items come in groups of n unsorted items, with groups sorted between each other;
	// combines selection algorithm with binary divide & conquer approach
	
	function multiSelect(arr, left, right, n, compare) {
	    var stack = [left, right],
	        mid;
	
	    while (stack.length) {
	        right = stack.pop();
	        left = stack.pop();
	
	        if (right - left <= n) continue;
	
	        mid = left + Math.ceil((right - left) / n / 2) * n;
	        quickselect(arr, mid, left, right, compare);
	
	        stack.push(left, mid, mid, right);
	    }
	}


/***/ }),
/* 251 */
/***/ (function(module, exports) {

	'use strict';
	
	/**
	 * Check if we're required to add a port number.
	 *
	 * @see https://url.spec.whatwg.org/#default-port
	 * @param {Number|String} port Port number we need to check
	 * @param {String} protocol Protocol we need to check against.
	 * @returns {Boolean} Is it a default port for the given protocol
	 * @api private
	 */
	module.exports = function required(port, protocol) {
	  protocol = protocol.split(':')[0];
	  port = +port;
	
	  if (!port) return false;
	
	  switch (protocol) {
	    case 'http':
	    case 'ws':
	    return port !== 80;
	
	    case 'https':
	    case 'wss':
	    return port !== 443;
	
	    case 'ftp':
	    return port !== 21;
	
	    case 'gopher':
	    return port !== 70;
	
	    case 'file':
	    return false;
	  }
	
	  return port !== 0;
	};


/***/ }),
/* 252 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {'use strict';
	
	var transportList = __webpack_require__(261);
	
	module.exports = __webpack_require__(259)(transportList);
	
	// TODO can't get rid of this until all servers do
	if ('_sockjs_onload' in global) {
	  setTimeout(global._sockjs_onload, 1);
	}
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ }),
/* 253 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var inherits = __webpack_require__(3)
	  , Event = __webpack_require__(51)
	  ;
	
	function CloseEvent() {
	  Event.call(this);
	  this.initEvent('close', false, false);
	  this.wasClean = false;
	  this.code = 0;
	  this.reason = '';
	}
	
	inherits(CloseEvent, Event);
	
	module.exports = CloseEvent;


/***/ }),
/* 254 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var inherits = __webpack_require__(3)
	  , Event = __webpack_require__(51)
	  ;
	
	function TransportMessageEvent(data) {
	  Event.call(this);
	  this.initEvent('message', false, false);
	  this.data = data;
	}
	
	inherits(TransportMessageEvent, Event);
	
	module.exports = TransportMessageEvent;


/***/ }),
/* 255 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var JSON3 = __webpack_require__(15)
	  , iframeUtils = __webpack_require__(29)
	  ;
	
	function FacadeJS(transport) {
	  this._transport = transport;
	  transport.on('message', this._transportMessage.bind(this));
	  transport.on('close', this._transportClose.bind(this));
	}
	
	FacadeJS.prototype._transportClose = function(code, reason) {
	  iframeUtils.postMessage('c', JSON3.stringify([code, reason]));
	};
	FacadeJS.prototype._transportMessage = function(frame) {
	  iframeUtils.postMessage('t', frame);
	};
	FacadeJS.prototype._send = function(data) {
	  this._transport.send(data);
	};
	FacadeJS.prototype._close = function() {
	  this._transport.close();
	  this._transport.removeAllListeners();
	};
	
	module.exports = FacadeJS;


/***/ }),
/* 256 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var urlUtils = __webpack_require__(10)
	  , eventUtils = __webpack_require__(17)
	  , JSON3 = __webpack_require__(15)
	  , FacadeJS = __webpack_require__(255)
	  , InfoIframeReceiver = __webpack_require__(92)
	  , iframeUtils = __webpack_require__(29)
	  , loc = __webpack_require__(93)
	  ;
	
	var debug = function() {};
	if (true) {
	  debug = __webpack_require__(6)('sockjs-client:iframe-bootstrap');
	}
	
	module.exports = function(SockJS, availableTransports) {
	  var transportMap = {};
	  availableTransports.forEach(function(at) {
	    if (at.facadeTransport) {
	      transportMap[at.facadeTransport.transportName] = at.facadeTransport;
	    }
	  });
	
	  // hard-coded for the info iframe
	  // TODO see if we can make this more dynamic
	  transportMap[InfoIframeReceiver.transportName] = InfoIframeReceiver;
	  var parentOrigin;
	
	  /* eslint-disable camelcase */
	  SockJS.bootstrap_iframe = function() {
	    /* eslint-enable camelcase */
	    var facade;
	    iframeUtils.currentWindowId = loc.hash.slice(1);
	    var onMessage = function(e) {
	      if (e.source !== parent) {
	        return;
	      }
	      if (typeof parentOrigin === 'undefined') {
	        parentOrigin = e.origin;
	      }
	      if (e.origin !== parentOrigin) {
	        return;
	      }
	
	      var iframeMessage;
	      try {
	        iframeMessage = JSON3.parse(e.data);
	      } catch (ignored) {
	        debug('bad json', e.data);
	        return;
	      }
	
	      if (iframeMessage.windowId !== iframeUtils.currentWindowId) {
	        return;
	      }
	      switch (iframeMessage.type) {
	      case 's':
	        var p;
	        try {
	          p = JSON3.parse(iframeMessage.data);
	        } catch (ignored) {
	          debug('bad json', iframeMessage.data);
	          break;
	        }
	        var version = p[0];
	        var transport = p[1];
	        var transUrl = p[2];
	        var baseUrl = p[3];
	        debug(version, transport, transUrl, baseUrl);
	        // change this to semver logic
	        if (version !== SockJS.version) {
	          throw new Error('Incompatible SockJS! Main site uses:' +
	                    ' "' + version + '", the iframe:' +
	                    ' "' + SockJS.version + '".');
	        }
	
	        if (!urlUtils.isOriginEqual(transUrl, loc.href) ||
	            !urlUtils.isOriginEqual(baseUrl, loc.href)) {
	          throw new Error('Can\'t connect to different domain from within an ' +
	                    'iframe. (' + loc.href + ', ' + transUrl + ', ' + baseUrl + ')');
	        }
	        facade = new FacadeJS(new transportMap[transport](transUrl, baseUrl));
	        break;
	      case 'm':
	        facade._send(iframeMessage.data);
	        break;
	      case 'c':
	        if (facade) {
	          facade._close();
	        }
	        facade = null;
	        break;
	      }
	    };
	
	    eventUtils.attachEvent('message', onMessage);
	
	    // Start
	    iframeUtils.postMessage('s');
	  };
	};


/***/ }),
/* 257 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {'use strict';
	
	var EventEmitter = __webpack_require__(8).EventEmitter
	  , inherits = __webpack_require__(3)
	  , JSON3 = __webpack_require__(15)
	  , utils = __webpack_require__(17)
	  , IframeTransport = __webpack_require__(98)
	  , InfoReceiverIframe = __webpack_require__(92)
	  ;
	
	var debug = function() {};
	if (true) {
	  debug = __webpack_require__(6)('sockjs-client:info-iframe');
	}
	
	function InfoIframe(baseUrl, url) {
	  var self = this;
	  EventEmitter.call(this);
	
	  var go = function() {
	    var ifr = self.ifr = new IframeTransport(InfoReceiverIframe.transportName, url, baseUrl);
	
	    ifr.once('message', function(msg) {
	      if (msg) {
	        var d;
	        try {
	          d = JSON3.parse(msg);
	        } catch (e) {
	          debug('bad json', msg);
	          self.emit('finish');
	          self.close();
	          return;
	        }
	
	        var info = d[0], rtt = d[1];
	        self.emit('finish', info, rtt);
	      }
	      self.close();
	    });
	
	    ifr.once('close', function() {
	      self.emit('finish');
	      self.close();
	    });
	  };
	
	  // TODO this seems the same as the 'needBody' from transports
	  if (!global.document.body) {
	    utils.attachEvent('load', go);
	  } else {
	    go();
	  }
	}
	
	inherits(InfoIframe, EventEmitter);
	
	InfoIframe.enabled = function() {
	  return IframeTransport.enabled();
	};
	
	InfoIframe.prototype.close = function() {
	  if (this.ifr) {
	    this.ifr.close();
	  }
	  this.removeAllListeners();
	  this.ifr = null;
	};
	
	module.exports = InfoIframe;
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ }),
/* 258 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var EventEmitter = __webpack_require__(8).EventEmitter
	  , inherits = __webpack_require__(3)
	  , urlUtils = __webpack_require__(10)
	  , XDR = __webpack_require__(53)
	  , XHRCors = __webpack_require__(42)
	  , XHRLocal = __webpack_require__(27)
	  , XHRFake = __webpack_require__(270)
	  , InfoIframe = __webpack_require__(257)
	  , InfoAjax = __webpack_require__(91)
	  ;
	
	var debug = function() {};
	if (true) {
	  debug = __webpack_require__(6)('sockjs-client:info-receiver');
	}
	
	function InfoReceiver(baseUrl, urlInfo) {
	  debug(baseUrl);
	  var self = this;
	  EventEmitter.call(this);
	
	  setTimeout(function() {
	    self.doXhr(baseUrl, urlInfo);
	  }, 0);
	}
	
	inherits(InfoReceiver, EventEmitter);
	
	// TODO this is currently ignoring the list of available transports and the whitelist
	
	InfoReceiver._getReceiver = function(baseUrl, url, urlInfo) {
	  // determine method of CORS support (if needed)
	  if (urlInfo.sameOrigin) {
	    return new InfoAjax(url, XHRLocal);
	  }
	  if (XHRCors.enabled) {
	    return new InfoAjax(url, XHRCors);
	  }
	  if (XDR.enabled && urlInfo.sameScheme) {
	    return new InfoAjax(url, XDR);
	  }
	  if (InfoIframe.enabled()) {
	    return new InfoIframe(baseUrl, url);
	  }
	  return new InfoAjax(url, XHRFake);
	};
	
	InfoReceiver.prototype.doXhr = function(baseUrl, urlInfo) {
	  var self = this
	    , url = urlUtils.addPath(baseUrl, '/info')
	    ;
	  debug('doXhr', url);
	
	  this.xo = InfoReceiver._getReceiver(baseUrl, url, urlInfo);
	
	  this.timeoutRef = setTimeout(function() {
	    debug('timeout');
	    self._cleanup(false);
	    self.emit('finish');
	  }, InfoReceiver.timeout);
	
	  this.xo.once('finish', function(info, rtt) {
	    debug('finish', info, rtt);
	    self._cleanup(true);
	    self.emit('finish', info, rtt);
	  });
	};
	
	InfoReceiver.prototype._cleanup = function(wasClean) {
	  debug('_cleanup');
	  clearTimeout(this.timeoutRef);
	  this.timeoutRef = null;
	  if (!wasClean && this.xo) {
	    this.xo.close();
	  }
	  this.xo = null;
	};
	
	InfoReceiver.prototype.close = function() {
	  debug('close');
	  this.removeAllListeners();
	  this._cleanup(false);
	};
	
	InfoReceiver.timeout = 8000;
	
	module.exports = InfoReceiver;


/***/ }),
/* 259 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {'use strict';
	
	__webpack_require__(260);
	
	var URL = __webpack_require__(104)
	  , inherits = __webpack_require__(3)
	  , JSON3 = __webpack_require__(15)
	  , random = __webpack_require__(22)
	  , escape = __webpack_require__(275)
	  , urlUtils = __webpack_require__(10)
	  , eventUtils = __webpack_require__(17)
	  , transport = __webpack_require__(277)
	  , objectUtils = __webpack_require__(54)
	  , browser = __webpack_require__(28)
	  , log = __webpack_require__(276)
	  , Event = __webpack_require__(51)
	  , EventTarget = __webpack_require__(90)
	  , loc = __webpack_require__(93)
	  , CloseEvent = __webpack_require__(253)
	  , TransportMessageEvent = __webpack_require__(254)
	  , InfoReceiver = __webpack_require__(258)
	  ;
	
	var debug = function() {};
	if (true) {
	  debug = __webpack_require__(6)('sockjs-client:main');
	}
	
	var transports;
	
	// follow constructor steps defined at http://dev.w3.org/html5/websockets/#the-websocket-interface
	function SockJS(url, protocols, options) {
	  if (!(this instanceof SockJS)) {
	    return new SockJS(url, protocols, options);
	  }
	  if (arguments.length < 1) {
	    throw new TypeError("Failed to construct 'SockJS: 1 argument required, but only 0 present");
	  }
	  EventTarget.call(this);
	
	  this.readyState = SockJS.CONNECTING;
	  this.extensions = '';
	  this.protocol = '';
	
	  // non-standard extension
	  options = options || {};
	  if (options.protocols_whitelist) {
	    log.warn("'protocols_whitelist' is DEPRECATED. Use 'transports' instead.");
	  }
	  this._transportsWhitelist = options.transports;
	  this._transportOptions = options.transportOptions || {};
	
	  var sessionId = options.sessionId || 8;
	  if (typeof sessionId === 'function') {
	    this._generateSessionId = sessionId;
	  } else if (typeof sessionId === 'number') {
	    this._generateSessionId = function() {
	      return random.string(sessionId);
	    };
	  } else {
	    throw new TypeError('If sessionId is used in the options, it needs to be a number or a function.');
	  }
	
	  this._server = options.server || random.numberString(1000);
	
	  // Step 1 of WS spec - parse and validate the url. Issue #8
	  var parsedUrl = new URL(url);
	  if (!parsedUrl.host || !parsedUrl.protocol) {
	    throw new SyntaxError("The URL '" + url + "' is invalid");
	  } else if (parsedUrl.hash) {
	    throw new SyntaxError('The URL must not contain a fragment');
	  } else if (parsedUrl.protocol !== 'http:' && parsedUrl.protocol !== 'https:') {
	    throw new SyntaxError("The URL's scheme must be either 'http:' or 'https:'. '" + parsedUrl.protocol + "' is not allowed.");
	  }
	
	  var secure = parsedUrl.protocol === 'https:';
	  // Step 2 - don't allow secure origin with an insecure protocol
	  if (loc.protocol === 'https' && !secure) {
	    throw new Error('SecurityError: An insecure SockJS connection may not be initiated from a page loaded over HTTPS');
	  }
	
	  // Step 3 - check port access - no need here
	  // Step 4 - parse protocols argument
	  if (!protocols) {
	    protocols = [];
	  } else if (!Array.isArray(protocols)) {
	    protocols = [protocols];
	  }
	
	  // Step 5 - check protocols argument
	  var sortedProtocols = protocols.sort();
	  sortedProtocols.forEach(function(proto, i) {
	    if (!proto) {
	      throw new SyntaxError("The protocols entry '" + proto + "' is invalid.");
	    }
	    if (i < (sortedProtocols.length - 1) && proto === sortedProtocols[i + 1]) {
	      throw new SyntaxError("The protocols entry '" + proto + "' is duplicated.");
	    }
	  });
	
	  // Step 6 - convert origin
	  var o = urlUtils.getOrigin(loc.href);
	  this._origin = o ? o.toLowerCase() : null;
	
	  // remove the trailing slash
	  parsedUrl.set('pathname', parsedUrl.pathname.replace(/\/+$/, ''));
	
	  // store the sanitized url
	  this.url = parsedUrl.href;
	  debug('using url', this.url);
	
	  // Step 7 - start connection in background
	  // obtain server info
	  // http://sockjs.github.io/sockjs-protocol/sockjs-protocol-0.3.3.html#section-26
	  this._urlInfo = {
	    nullOrigin: !browser.hasDomain()
	  , sameOrigin: urlUtils.isOriginEqual(this.url, loc.href)
	  , sameScheme: urlUtils.isSchemeEqual(this.url, loc.href)
	  };
	
	  this._ir = new InfoReceiver(this.url, this._urlInfo);
	  this._ir.once('finish', this._receiveInfo.bind(this));
	}
	
	inherits(SockJS, EventTarget);
	
	function userSetCode(code) {
	  return code === 1000 || (code >= 3000 && code <= 4999);
	}
	
	SockJS.prototype.close = function(code, reason) {
	  // Step 1
	  if (code && !userSetCode(code)) {
	    throw new Error('InvalidAccessError: Invalid code');
	  }
	  // Step 2.4 states the max is 123 bytes, but we are just checking length
	  if (reason && reason.length > 123) {
	    throw new SyntaxError('reason argument has an invalid length');
	  }
	
	  // Step 3.1
	  if (this.readyState === SockJS.CLOSING || this.readyState === SockJS.CLOSED) {
	    return;
	  }
	
	  // TODO look at docs to determine how to set this
	  var wasClean = true;
	  this._close(code || 1000, reason || 'Normal closure', wasClean);
	};
	
	SockJS.prototype.send = function(data) {
	  // #13 - convert anything non-string to string
	  // TODO this currently turns objects into [object Object]
	  if (typeof data !== 'string') {
	    data = '' + data;
	  }
	  if (this.readyState === SockJS.CONNECTING) {
	    throw new Error('InvalidStateError: The connection has not been established yet');
	  }
	  if (this.readyState !== SockJS.OPEN) {
	    return;
	  }
	  this._transport.send(escape.quote(data));
	};
	
	SockJS.version = __webpack_require__(102);
	
	SockJS.CONNECTING = 0;
	SockJS.OPEN = 1;
	SockJS.CLOSING = 2;
	SockJS.CLOSED = 3;
	
	SockJS.prototype._receiveInfo = function(info, rtt) {
	  debug('_receiveInfo', rtt);
	  this._ir = null;
	  if (!info) {
	    this._close(1002, 'Cannot connect to server');
	    return;
	  }
	
	  // establish a round-trip timeout (RTO) based on the
	  // round-trip time (RTT)
	  this._rto = this.countRTO(rtt);
	  // allow server to override url used for the actual transport
	  this._transUrl = info.base_url ? info.base_url : this.url;
	  info = objectUtils.extend(info, this._urlInfo);
	  debug('info', info);
	  // determine list of desired and supported transports
	  var enabledTransports = transports.filterToEnabled(this._transportsWhitelist, info);
	  this._transports = enabledTransports.main;
	  debug(this._transports.length + ' enabled transports');
	
	  this._connect();
	};
	
	SockJS.prototype._connect = function() {
	  for (var Transport = this._transports.shift(); Transport; Transport = this._transports.shift()) {
	    debug('attempt', Transport.transportName);
	    if (Transport.needBody) {
	      if (!global.document.body ||
	          (typeof global.document.readyState !== 'undefined' &&
	            global.document.readyState !== 'complete' &&
	            global.document.readyState !== 'interactive')) {
	        debug('waiting for body');
	        this._transports.unshift(Transport);
	        eventUtils.attachEvent('load', this._connect.bind(this));
	        return;
	      }
	    }
	
	    // calculate timeout based on RTO and round trips. Default to 5s
	    var timeoutMs = (this._rto * Transport.roundTrips) || 5000;
	    this._transportTimeoutId = setTimeout(this._transportTimeout.bind(this), timeoutMs);
	    debug('using timeout', timeoutMs);
	
	    var transportUrl = urlUtils.addPath(this._transUrl, '/' + this._server + '/' + this._generateSessionId());
	    var options = this._transportOptions[Transport.transportName];
	    debug('transport url', transportUrl);
	    var transportObj = new Transport(transportUrl, this._transUrl, options);
	    transportObj.on('message', this._transportMessage.bind(this));
	    transportObj.once('close', this._transportClose.bind(this));
	    transportObj.transportName = Transport.transportName;
	    this._transport = transportObj;
	
	    return;
	  }
	  this._close(2000, 'All transports failed', false);
	};
	
	SockJS.prototype._transportTimeout = function() {
	  debug('_transportTimeout');
	  if (this.readyState === SockJS.CONNECTING) {
	    this._transportClose(2007, 'Transport timed out');
	  }
	};
	
	SockJS.prototype._transportMessage = function(msg) {
	  debug('_transportMessage', msg);
	  var self = this
	    , type = msg.slice(0, 1)
	    , content = msg.slice(1)
	    , payload
	    ;
	
	  // first check for messages that don't need a payload
	  switch (type) {
	    case 'o':
	      this._open();
	      return;
	    case 'h':
	      this.dispatchEvent(new Event('heartbeat'));
	      debug('heartbeat', this.transport);
	      return;
	  }
	
	  if (content) {
	    try {
	      payload = JSON3.parse(content);
	    } catch (e) {
	      debug('bad json', content);
	    }
	  }
	
	  if (typeof payload === 'undefined') {
	    debug('empty payload', content);
	    return;
	  }
	
	  switch (type) {
	    case 'a':
	      if (Array.isArray(payload)) {
	        payload.forEach(function(p) {
	          debug('message', self.transport, p);
	          self.dispatchEvent(new TransportMessageEvent(p));
	        });
	      }
	      break;
	    case 'm':
	      debug('message', this.transport, payload);
	      this.dispatchEvent(new TransportMessageEvent(payload));
	      break;
	    case 'c':
	      if (Array.isArray(payload) && payload.length === 2) {
	        this._close(payload[0], payload[1], true);
	      }
	      break;
	  }
	};
	
	SockJS.prototype._transportClose = function(code, reason) {
	  debug('_transportClose', this.transport, code, reason);
	  if (this._transport) {
	    this._transport.removeAllListeners();
	    this._transport = null;
	    this.transport = null;
	  }
	
	  if (!userSetCode(code) && code !== 2000 && this.readyState === SockJS.CONNECTING) {
	    this._connect();
	    return;
	  }
	
	  this._close(code, reason);
	};
	
	SockJS.prototype._open = function() {
	  debug('_open', this._transport.transportName, this.readyState);
	  if (this.readyState === SockJS.CONNECTING) {
	    if (this._transportTimeoutId) {
	      clearTimeout(this._transportTimeoutId);
	      this._transportTimeoutId = null;
	    }
	    this.readyState = SockJS.OPEN;
	    this.transport = this._transport.transportName;
	    this.dispatchEvent(new Event('open'));
	    debug('connected', this.transport);
	  } else {
	    // The server might have been restarted, and lost track of our
	    // connection.
	    this._close(1006, 'Server lost session');
	  }
	};
	
	SockJS.prototype._close = function(code, reason, wasClean) {
	  debug('_close', this.transport, code, reason, wasClean, this.readyState);
	  var forceFail = false;
	
	  if (this._ir) {
	    forceFail = true;
	    this._ir.close();
	    this._ir = null;
	  }
	  if (this._transport) {
	    this._transport.close();
	    this._transport = null;
	    this.transport = null;
	  }
	
	  if (this.readyState === SockJS.CLOSED) {
	    throw new Error('InvalidStateError: SockJS has already been closed');
	  }
	
	  this.readyState = SockJS.CLOSING;
	  setTimeout(function() {
	    this.readyState = SockJS.CLOSED;
	
	    if (forceFail) {
	      this.dispatchEvent(new Event('error'));
	    }
	
	    var e = new CloseEvent('close');
	    e.wasClean = wasClean || false;
	    e.code = code || 1000;
	    e.reason = reason;
	
	    this.dispatchEvent(e);
	    this.onmessage = this.onclose = this.onerror = null;
	    debug('disconnected');
	  }.bind(this), 0);
	};
	
	// See: http://www.erg.abdn.ac.uk/~gerrit/dccp/notes/ccid2/rto_estimator/
	// and RFC 2988.
	SockJS.prototype.countRTO = function(rtt) {
	  // In a local environment, when using IE8/9 and the `jsonp-polling`
	  // transport the time needed to establish a connection (the time that pass
	  // from the opening of the transport to the call of `_dispatchOpen`) is
	  // around 200msec (the lower bound used in the article above) and this
	  // causes spurious timeouts. For this reason we calculate a value slightly
	  // larger than that used in the article.
	  if (rtt > 100) {
	    return 4 * rtt; // rto > 400msec
	  }
	  return 300 + rtt; // 300msec < rto <= 400msec
	};
	
	module.exports = function(availableTransports) {
	  transports = transport(availableTransports);
	  __webpack_require__(256)(SockJS, availableTransports);
	  return SockJS;
	};
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ }),
/* 260 */
/***/ (function(module, exports) {

	/* eslint-disable */
	/* jscs: disable */
	'use strict';
	
	// pulled specific shims from https://github.com/es-shims/es5-shim
	
	var ArrayPrototype = Array.prototype;
	var ObjectPrototype = Object.prototype;
	var FunctionPrototype = Function.prototype;
	var StringPrototype = String.prototype;
	var array_slice = ArrayPrototype.slice;
	
	var _toString = ObjectPrototype.toString;
	var isFunction = function (val) {
	    return ObjectPrototype.toString.call(val) === '[object Function]';
	};
	var isArray = function isArray(obj) {
	    return _toString.call(obj) === '[object Array]';
	};
	var isString = function isString(obj) {
	    return _toString.call(obj) === '[object String]';
	};
	
	var supportsDescriptors = Object.defineProperty && (function () {
	    try {
	        Object.defineProperty({}, 'x', {});
	        return true;
	    } catch (e) { /* this is ES3 */
	        return false;
	    }
	}());
	
	// Define configurable, writable and non-enumerable props
	// if they don't exist.
	var defineProperty;
	if (supportsDescriptors) {
	    defineProperty = function (object, name, method, forceAssign) {
	        if (!forceAssign && (name in object)) { return; }
	        Object.defineProperty(object, name, {
	            configurable: true,
	            enumerable: false,
	            writable: true,
	            value: method
	        });
	    };
	} else {
	    defineProperty = function (object, name, method, forceAssign) {
	        if (!forceAssign && (name in object)) { return; }
	        object[name] = method;
	    };
	}
	var defineProperties = function (object, map, forceAssign) {
	    for (var name in map) {
	        if (ObjectPrototype.hasOwnProperty.call(map, name)) {
	          defineProperty(object, name, map[name], forceAssign);
	        }
	    }
	};
	
	var toObject = function (o) {
	    if (o == null) { // this matches both null and undefined
	        throw new TypeError("can't convert " + o + ' to object');
	    }
	    return Object(o);
	};
	
	//
	// Util
	// ======
	//
	
	// ES5 9.4
	// http://es5.github.com/#x9.4
	// http://jsperf.com/to-integer
	
	function toInteger(num) {
	    var n = +num;
	    if (n !== n) { // isNaN
	        n = 0;
	    } else if (n !== 0 && n !== (1 / 0) && n !== -(1 / 0)) {
	        n = (n > 0 || -1) * Math.floor(Math.abs(n));
	    }
	    return n;
	}
	
	function ToUint32(x) {
	    return x >>> 0;
	}
	
	//
	// Function
	// ========
	//
	
	// ES-5 15.3.4.5
	// http://es5.github.com/#x15.3.4.5
	
	function Empty() {}
	
	defineProperties(FunctionPrototype, {
	    bind: function bind(that) { // .length is 1
	        // 1. Let Target be the this value.
	        var target = this;
	        // 2. If IsCallable(Target) is false, throw a TypeError exception.
	        if (!isFunction(target)) {
	            throw new TypeError('Function.prototype.bind called on incompatible ' + target);
	        }
	        // 3. Let A be a new (possibly empty) internal list of all of the
	        //   argument values provided after thisArg (arg1, arg2 etc), in order.
	        // XXX slicedArgs will stand in for "A" if used
	        var args = array_slice.call(arguments, 1); // for normal call
	        // 4. Let F be a new native ECMAScript object.
	        // 11. Set the [[Prototype]] internal property of F to the standard
	        //   built-in Function prototype object as specified in 15.3.3.1.
	        // 12. Set the [[Call]] internal property of F as described in
	        //   15.3.4.5.1.
	        // 13. Set the [[Construct]] internal property of F as described in
	        //   15.3.4.5.2.
	        // 14. Set the [[HasInstance]] internal property of F as described in
	        //   15.3.4.5.3.
	        var binder = function () {
	
	            if (this instanceof bound) {
	                // 15.3.4.5.2 [[Construct]]
	                // When the [[Construct]] internal method of a function object,
	                // F that was created using the bind function is called with a
	                // list of arguments ExtraArgs, the following steps are taken:
	                // 1. Let target be the value of F's [[TargetFunction]]
	                //   internal property.
	                // 2. If target has no [[Construct]] internal method, a
	                //   TypeError exception is thrown.
	                // 3. Let boundArgs be the value of F's [[BoundArgs]] internal
	                //   property.
	                // 4. Let args be a new list containing the same values as the
	                //   list boundArgs in the same order followed by the same
	                //   values as the list ExtraArgs in the same order.
	                // 5. Return the result of calling the [[Construct]] internal
	                //   method of target providing args as the arguments.
	
	                var result = target.apply(
	                    this,
	                    args.concat(array_slice.call(arguments))
	                );
	                if (Object(result) === result) {
	                    return result;
	                }
	                return this;
	
	            } else {
	                // 15.3.4.5.1 [[Call]]
	                // When the [[Call]] internal method of a function object, F,
	                // which was created using the bind function is called with a
	                // this value and a list of arguments ExtraArgs, the following
	                // steps are taken:
	                // 1. Let boundArgs be the value of F's [[BoundArgs]] internal
	                //   property.
	                // 2. Let boundThis be the value of F's [[BoundThis]] internal
	                //   property.
	                // 3. Let target be the value of F's [[TargetFunction]] internal
	                //   property.
	                // 4. Let args be a new list containing the same values as the
	                //   list boundArgs in the same order followed by the same
	                //   values as the list ExtraArgs in the same order.
	                // 5. Return the result of calling the [[Call]] internal method
	                //   of target providing boundThis as the this value and
	                //   providing args as the arguments.
	
	                // equiv: target.call(this, ...boundArgs, ...args)
	                return target.apply(
	                    that,
	                    args.concat(array_slice.call(arguments))
	                );
	
	            }
	
	        };
	
	        // 15. If the [[Class]] internal property of Target is "Function", then
	        //     a. Let L be the length property of Target minus the length of A.
	        //     b. Set the length own property of F to either 0 or L, whichever is
	        //       larger.
	        // 16. Else set the length own property of F to 0.
	
	        var boundLength = Math.max(0, target.length - args.length);
	
	        // 17. Set the attributes of the length own property of F to the values
	        //   specified in 15.3.5.1.
	        var boundArgs = [];
	        for (var i = 0; i < boundLength; i++) {
	            boundArgs.push('$' + i);
	        }
	
	        // XXX Build a dynamic function with desired amount of arguments is the only
	        // way to set the length property of a function.
	        // In environments where Content Security Policies enabled (Chrome extensions,
	        // for ex.) all use of eval or Function costructor throws an exception.
	        // However in all of these environments Function.prototype.bind exists
	        // and so this code will never be executed.
	        var bound = Function('binder', 'return function (' + boundArgs.join(',') + '){ return binder.apply(this, arguments); }')(binder);
	
	        if (target.prototype) {
	            Empty.prototype = target.prototype;
	            bound.prototype = new Empty();
	            // Clean up dangling references.
	            Empty.prototype = null;
	        }
	
	        // TODO
	        // 18. Set the [[Extensible]] internal property of F to true.
	
	        // TODO
	        // 19. Let thrower be the [[ThrowTypeError]] function Object (13.2.3).
	        // 20. Call the [[DefineOwnProperty]] internal method of F with
	        //   arguments "caller", PropertyDescriptor {[[Get]]: thrower, [[Set]]:
	        //   thrower, [[Enumerable]]: false, [[Configurable]]: false}, and
	        //   false.
	        // 21. Call the [[DefineOwnProperty]] internal method of F with
	        //   arguments "arguments", PropertyDescriptor {[[Get]]: thrower,
	        //   [[Set]]: thrower, [[Enumerable]]: false, [[Configurable]]: false},
	        //   and false.
	
	        // TODO
	        // NOTE Function objects created using Function.prototype.bind do not
	        // have a prototype property or the [[Code]], [[FormalParameters]], and
	        // [[Scope]] internal properties.
	        // XXX can't delete prototype in pure-js.
	
	        // 22. Return F.
	        return bound;
	    }
	});
	
	//
	// Array
	// =====
	//
	
	// ES5 15.4.3.2
	// http://es5.github.com/#x15.4.3.2
	// https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/isArray
	defineProperties(Array, { isArray: isArray });
	
	
	var boxedString = Object('a');
	var splitString = boxedString[0] !== 'a' || !(0 in boxedString);
	
	var properlyBoxesContext = function properlyBoxed(method) {
	    // Check node 0.6.21 bug where third parameter is not boxed
	    var properlyBoxesNonStrict = true;
	    var properlyBoxesStrict = true;
	    if (method) {
	        method.call('foo', function (_, __, context) {
	            if (typeof context !== 'object') { properlyBoxesNonStrict = false; }
	        });
	
	        method.call([1], function () {
	            'use strict';
	            properlyBoxesStrict = typeof this === 'string';
	        }, 'x');
	    }
	    return !!method && properlyBoxesNonStrict && properlyBoxesStrict;
	};
	
	defineProperties(ArrayPrototype, {
	    forEach: function forEach(fun /*, thisp*/) {
	        var object = toObject(this),
	            self = splitString && isString(this) ? this.split('') : object,
	            thisp = arguments[1],
	            i = -1,
	            length = self.length >>> 0;
	
	        // If no callback function or if callback is not a callable function
	        if (!isFunction(fun)) {
	            throw new TypeError(); // TODO message
	        }
	
	        while (++i < length) {
	            if (i in self) {
	                // Invoke the callback function with call, passing arguments:
	                // context, property value, property key, thisArg object
	                // context
	                fun.call(thisp, self[i], i, object);
	            }
	        }
	    }
	}, !properlyBoxesContext(ArrayPrototype.forEach));
	
	// ES5 15.4.4.14
	// http://es5.github.com/#x15.4.4.14
	// https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/indexOf
	var hasFirefox2IndexOfBug = Array.prototype.indexOf && [0, 1].indexOf(1, 2) !== -1;
	defineProperties(ArrayPrototype, {
	    indexOf: function indexOf(sought /*, fromIndex */ ) {
	        var self = splitString && isString(this) ? this.split('') : toObject(this),
	            length = self.length >>> 0;
	
	        if (!length) {
	            return -1;
	        }
	
	        var i = 0;
	        if (arguments.length > 1) {
	            i = toInteger(arguments[1]);
	        }
	
	        // handle negative indices
	        i = i >= 0 ? i : Math.max(0, length + i);
	        for (; i < length; i++) {
	            if (i in self && self[i] === sought) {
	                return i;
	            }
	        }
	        return -1;
	    }
	}, hasFirefox2IndexOfBug);
	
	//
	// String
	// ======
	//
	
	// ES5 15.5.4.14
	// http://es5.github.com/#x15.5.4.14
	
	// [bugfix, IE lt 9, firefox 4, Konqueror, Opera, obscure browsers]
	// Many browsers do not split properly with regular expressions or they
	// do not perform the split correctly under obscure conditions.
	// See http://blog.stevenlevithan.com/archives/cross-browser-split
	// I've tested in many browsers and this seems to cover the deviant ones:
	//    'ab'.split(/(?:ab)*/) should be ["", ""], not [""]
	//    '.'.split(/(.?)(.?)/) should be ["", ".", "", ""], not ["", ""]
	//    'tesst'.split(/(s)*/) should be ["t", undefined, "e", "s", "t"], not
	//       [undefined, "t", undefined, "e", ...]
	//    ''.split(/.?/) should be [], not [""]
	//    '.'.split(/()()/) should be ["."], not ["", "", "."]
	
	var string_split = StringPrototype.split;
	if (
	    'ab'.split(/(?:ab)*/).length !== 2 ||
	    '.'.split(/(.?)(.?)/).length !== 4 ||
	    'tesst'.split(/(s)*/)[1] === 't' ||
	    'test'.split(/(?:)/, -1).length !== 4 ||
	    ''.split(/.?/).length ||
	    '.'.split(/()()/).length > 1
	) {
	    (function () {
	        var compliantExecNpcg = /()??/.exec('')[1] === void 0; // NPCG: nonparticipating capturing group
	
	        StringPrototype.split = function (separator, limit) {
	            var string = this;
	            if (separator === void 0 && limit === 0) {
	                return [];
	            }
	
	            // If `separator` is not a regex, use native split
	            if (_toString.call(separator) !== '[object RegExp]') {
	                return string_split.call(this, separator, limit);
	            }
	
	            var output = [],
	                flags = (separator.ignoreCase ? 'i' : '') +
	                        (separator.multiline  ? 'm' : '') +
	                        (separator.extended   ? 'x' : '') + // Proposed for ES6
	                        (separator.sticky     ? 'y' : ''), // Firefox 3+
	                lastLastIndex = 0,
	                // Make `global` and avoid `lastIndex` issues by working with a copy
	                separator2, match, lastIndex, lastLength;
	            separator = new RegExp(separator.source, flags + 'g');
	            string += ''; // Type-convert
	            if (!compliantExecNpcg) {
	                // Doesn't need flags gy, but they don't hurt
	                separator2 = new RegExp('^' + separator.source + '$(?!\\s)', flags);
	            }
	            /* Values for `limit`, per the spec:
	             * If undefined: 4294967295 // Math.pow(2, 32) - 1
	             * If 0, Infinity, or NaN: 0
	             * If positive number: limit = Math.floor(limit); if (limit > 4294967295) limit -= 4294967296;
	             * If negative number: 4294967296 - Math.floor(Math.abs(limit))
	             * If other: Type-convert, then use the above rules
	             */
	            limit = limit === void 0 ?
	                -1 >>> 0 : // Math.pow(2, 32) - 1
	                ToUint32(limit);
	            while (match = separator.exec(string)) {
	                // `separator.lastIndex` is not reliable cross-browser
	                lastIndex = match.index + match[0].length;
	                if (lastIndex > lastLastIndex) {
	                    output.push(string.slice(lastLastIndex, match.index));
	                    // Fix browsers whose `exec` methods don't consistently return `undefined` for
	                    // nonparticipating capturing groups
	                    if (!compliantExecNpcg && match.length > 1) {
	                        match[0].replace(separator2, function () {
	                            for (var i = 1; i < arguments.length - 2; i++) {
	                                if (arguments[i] === void 0) {
	                                    match[i] = void 0;
	                                }
	                            }
	                        });
	                    }
	                    if (match.length > 1 && match.index < string.length) {
	                        ArrayPrototype.push.apply(output, match.slice(1));
	                    }
	                    lastLength = match[0].length;
	                    lastLastIndex = lastIndex;
	                    if (output.length >= limit) {
	                        break;
	                    }
	                }
	                if (separator.lastIndex === match.index) {
	                    separator.lastIndex++; // Avoid an infinite loop
	                }
	            }
	            if (lastLastIndex === string.length) {
	                if (lastLength || !separator.test('')) {
	                    output.push('');
	                }
	            } else {
	                output.push(string.slice(lastLastIndex));
	            }
	            return output.length > limit ? output.slice(0, limit) : output;
	        };
	    }());
	
	// [bugfix, chrome]
	// If separator is undefined, then the result array contains just one String,
	// which is the this value (converted to a String). If limit is not undefined,
	// then the output array is truncated so that it contains no more than limit
	// elements.
	// "0".split(undefined, 0) -> []
	} else if ('0'.split(void 0, 0).length) {
	    StringPrototype.split = function split(separator, limit) {
	        if (separator === void 0 && limit === 0) { return []; }
	        return string_split.call(this, separator, limit);
	    };
	}
	
	// ECMA-262, 3rd B.2.3
	// Not an ECMAScript standard, although ECMAScript 3rd Edition has a
	// non-normative section suggesting uniform semantics and it should be
	// normalized across all browsers
	// [bugfix, IE lt 9] IE < 9 substr() with negative value not working in IE
	var string_substr = StringPrototype.substr;
	var hasNegativeSubstrBug = ''.substr && '0b'.substr(-1) !== 'b';
	defineProperties(StringPrototype, {
	    substr: function substr(start, length) {
	        return string_substr.call(
	            this,
	            start < 0 ? ((start = this.length + start) < 0 ? 0 : start) : start,
	            length
	        );
	    }
	}, hasNegativeSubstrBug);


/***/ }),
/* 261 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	module.exports = [
	  // streaming transports
	  __webpack_require__(271)
	, __webpack_require__(273)
	, __webpack_require__(100)
	, __webpack_require__(96)
	, __webpack_require__(52)(__webpack_require__(96))
	
	  // polling transports
	, __webpack_require__(97)
	, __webpack_require__(52)(__webpack_require__(97))
	, __webpack_require__(101)
	, __webpack_require__(272)
	, __webpack_require__(52)(__webpack_require__(101))
	, __webpack_require__(263)
	];


/***/ }),
/* 262 */
/***/ (function(module, exports) {

	/* WEBPACK VAR INJECTION */(function(global) {'use strict';
	
	var Driver = global.WebSocket || global.MozWebSocket;
	if (Driver) {
		module.exports = function WebSocketBrowserDriver(url) {
			return new Driver(url);
		};
	} else {
		module.exports = undefined;
	}
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ }),
/* 263 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {'use strict';
	
	// The simplest and most robust transport, using the well-know cross
	// domain hack - JSONP. This transport is quite inefficient - one
	// message could use up to one http request. But at least it works almost
	// everywhere.
	// Known limitations:
	//   o you will get a spinning cursor
	//   o for Konqueror a dumb timer is needed to detect errors
	
	var inherits = __webpack_require__(3)
	  , SenderReceiver = __webpack_require__(99)
	  , JsonpReceiver = __webpack_require__(268)
	  , jsonpSender = __webpack_require__(269)
	  ;
	
	function JsonPTransport(transUrl) {
	  if (!JsonPTransport.enabled()) {
	    throw new Error('Transport created when disabled');
	  }
	  SenderReceiver.call(this, transUrl, '/jsonp', jsonpSender, JsonpReceiver);
	}
	
	inherits(JsonPTransport, SenderReceiver);
	
	JsonPTransport.enabled = function() {
	  return !!global.document;
	};
	
	JsonPTransport.transportName = 'jsonp-polling';
	JsonPTransport.roundTrips = 1;
	JsonPTransport.needBody = true;
	
	module.exports = JsonPTransport;
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ }),
/* 264 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var inherits = __webpack_require__(3)
	  , EventEmitter = __webpack_require__(8).EventEmitter
	  ;
	
	var debug = function() {};
	if (true) {
	  debug = __webpack_require__(6)('sockjs-client:buffered-sender');
	}
	
	function BufferedSender(url, sender) {
	  debug(url);
	  EventEmitter.call(this);
	  this.sendBuffer = [];
	  this.sender = sender;
	  this.url = url;
	}
	
	inherits(BufferedSender, EventEmitter);
	
	BufferedSender.prototype.send = function(message) {
	  debug('send', message);
	  this.sendBuffer.push(message);
	  if (!this.sendStop) {
	    this.sendSchedule();
	  }
	};
	
	// For polling transports in a situation when in the message callback,
	// new message is being send. If the sending connection was started
	// before receiving one, it is possible to saturate the network and
	// timeout due to the lack of receiving socket. To avoid that we delay
	// sending messages by some small time, in order to let receiving
	// connection be started beforehand. This is only a halfmeasure and
	// does not fix the big problem, but it does make the tests go more
	// stable on slow networks.
	BufferedSender.prototype.sendScheduleWait = function() {
	  debug('sendScheduleWait');
	  var self = this;
	  var tref;
	  this.sendStop = function() {
	    debug('sendStop');
	    self.sendStop = null;
	    clearTimeout(tref);
	  };
	  tref = setTimeout(function() {
	    debug('timeout');
	    self.sendStop = null;
	    self.sendSchedule();
	  }, 25);
	};
	
	BufferedSender.prototype.sendSchedule = function() {
	  debug('sendSchedule', this.sendBuffer.length);
	  var self = this;
	  if (this.sendBuffer.length > 0) {
	    var payload = '[' + this.sendBuffer.join(',') + ']';
	    this.sendStop = this.sender(this.url, payload, function(err) {
	      self.sendStop = null;
	      if (err) {
	        debug('error', err);
	        self.emit('close', err.code || 1006, 'Sending error: ' + err);
	        self.close();
	      } else {
	        self.sendScheduleWait();
	      }
	    });
	    this.sendBuffer = [];
	  }
	};
	
	BufferedSender.prototype._cleanup = function() {
	  debug('_cleanup');
	  this.removeAllListeners();
	};
	
	BufferedSender.prototype.close = function() {
	  debug('close');
	  this._cleanup();
	  if (this.sendStop) {
	    this.sendStop();
	    this.sendStop = null;
	  }
	};
	
	module.exports = BufferedSender;


/***/ }),
/* 265 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var inherits = __webpack_require__(3)
	  , EventEmitter = __webpack_require__(8).EventEmitter
	  ;
	
	var debug = function() {};
	if (true) {
	  debug = __webpack_require__(6)('sockjs-client:polling');
	}
	
	function Polling(Receiver, receiveUrl, AjaxObject) {
	  debug(receiveUrl);
	  EventEmitter.call(this);
	  this.Receiver = Receiver;
	  this.receiveUrl = receiveUrl;
	  this.AjaxObject = AjaxObject;
	  this._scheduleReceiver();
	}
	
	inherits(Polling, EventEmitter);
	
	Polling.prototype._scheduleReceiver = function() {
	  debug('_scheduleReceiver');
	  var self = this;
	  var poll = this.poll = new this.Receiver(this.receiveUrl, this.AjaxObject);
	
	  poll.on('message', function(msg) {
	    debug('message', msg);
	    self.emit('message', msg);
	  });
	
	  poll.once('close', function(code, reason) {
	    debug('close', code, reason, self.pollIsClosing);
	    self.poll = poll = null;
	
	    if (!self.pollIsClosing) {
	      if (reason === 'network') {
	        self._scheduleReceiver();
	      } else {
	        self.emit('close', code || 1006, reason);
	        self.removeAllListeners();
	      }
	    }
	  });
	};
	
	Polling.prototype.abort = function() {
	  debug('abort');
	  this.removeAllListeners();
	  this.pollIsClosing = true;
	  if (this.poll) {
	    this.poll.abort();
	  }
	};
	
	module.exports = Polling;


/***/ }),
/* 266 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var inherits = __webpack_require__(3)
	  , EventEmitter = __webpack_require__(8).EventEmitter
	  , EventSourceDriver = __webpack_require__(95)
	  ;
	
	var debug = function() {};
	if (true) {
	  debug = __webpack_require__(6)('sockjs-client:receiver:eventsource');
	}
	
	function EventSourceReceiver(url) {
	  debug(url);
	  EventEmitter.call(this);
	
	  var self = this;
	  var es = this.es = new EventSourceDriver(url);
	  es.onmessage = function(e) {
	    debug('message', e.data);
	    self.emit('message', decodeURI(e.data));
	  };
	  es.onerror = function(e) {
	    debug('error', es.readyState, e);
	    // ES on reconnection has readyState = 0 or 1.
	    // on network error it's CLOSED = 2
	    var reason = (es.readyState !== 2 ? 'network' : 'permanent');
	    self._cleanup();
	    self._close(reason);
	  };
	}
	
	inherits(EventSourceReceiver, EventEmitter);
	
	EventSourceReceiver.prototype.abort = function() {
	  debug('abort');
	  this._cleanup();
	  this._close('user');
	};
	
	EventSourceReceiver.prototype._cleanup = function() {
	  debug('cleanup');
	  var es = this.es;
	  if (es) {
	    es.onmessage = es.onerror = null;
	    es.close();
	    this.es = null;
	  }
	};
	
	EventSourceReceiver.prototype._close = function(reason) {
	  debug('close', reason);
	  var self = this;
	  // Safari and chrome < 15 crash if we close window before
	  // waiting for ES cleanup. See:
	  // https://code.google.com/p/chromium/issues/detail?id=89155
	  setTimeout(function() {
	    self.emit('close', null, reason);
	    self.removeAllListeners();
	  }, 200);
	};
	
	module.exports = EventSourceReceiver;


/***/ }),
/* 267 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {'use strict';
	
	var inherits = __webpack_require__(3)
	  , iframeUtils = __webpack_require__(29)
	  , urlUtils = __webpack_require__(10)
	  , EventEmitter = __webpack_require__(8).EventEmitter
	  , random = __webpack_require__(22)
	  ;
	
	var debug = function() {};
	if (true) {
	  debug = __webpack_require__(6)('sockjs-client:receiver:htmlfile');
	}
	
	function HtmlfileReceiver(url) {
	  debug(url);
	  EventEmitter.call(this);
	  var self = this;
	  iframeUtils.polluteGlobalNamespace();
	
	  this.id = 'a' + random.string(6);
	  url = urlUtils.addQuery(url, 'c=' + decodeURIComponent(iframeUtils.WPrefix + '.' + this.id));
	
	  debug('using htmlfile', HtmlfileReceiver.htmlfileEnabled);
	  var constructFunc = HtmlfileReceiver.htmlfileEnabled ?
	      iframeUtils.createHtmlfile : iframeUtils.createIframe;
	
	  global[iframeUtils.WPrefix][this.id] = {
	    start: function() {
	      debug('start');
	      self.iframeObj.loaded();
	    }
	  , message: function(data) {
	      debug('message', data);
	      self.emit('message', data);
	    }
	  , stop: function() {
	      debug('stop');
	      self._cleanup();
	      self._close('network');
	    }
	  };
	  this.iframeObj = constructFunc(url, function() {
	    debug('callback');
	    self._cleanup();
	    self._close('permanent');
	  });
	}
	
	inherits(HtmlfileReceiver, EventEmitter);
	
	HtmlfileReceiver.prototype.abort = function() {
	  debug('abort');
	  this._cleanup();
	  this._close('user');
	};
	
	HtmlfileReceiver.prototype._cleanup = function() {
	  debug('_cleanup');
	  if (this.iframeObj) {
	    this.iframeObj.cleanup();
	    this.iframeObj = null;
	  }
	  delete global[iframeUtils.WPrefix][this.id];
	};
	
	HtmlfileReceiver.prototype._close = function(reason) {
	  debug('_close', reason);
	  this.emit('close', null, reason);
	  this.removeAllListeners();
	};
	
	HtmlfileReceiver.htmlfileEnabled = false;
	
	// obfuscate to avoid firewalls
	var axo = ['Active'].concat('Object').join('X');
	if (axo in global) {
	  try {
	    HtmlfileReceiver.htmlfileEnabled = !!new global[axo]('htmlfile');
	  } catch (x) {
	    // intentionally empty
	  }
	}
	
	HtmlfileReceiver.enabled = HtmlfileReceiver.htmlfileEnabled || iframeUtils.iframeEnabled;
	
	module.exports = HtmlfileReceiver;
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ }),
/* 268 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {'use strict';
	
	var utils = __webpack_require__(29)
	  , random = __webpack_require__(22)
	  , browser = __webpack_require__(28)
	  , urlUtils = __webpack_require__(10)
	  , inherits = __webpack_require__(3)
	  , EventEmitter = __webpack_require__(8).EventEmitter
	  ;
	
	var debug = function() {};
	if (true) {
	  debug = __webpack_require__(6)('sockjs-client:receiver:jsonp');
	}
	
	function JsonpReceiver(url) {
	  debug(url);
	  var self = this;
	  EventEmitter.call(this);
	
	  utils.polluteGlobalNamespace();
	
	  this.id = 'a' + random.string(6);
	  var urlWithId = urlUtils.addQuery(url, 'c=' + encodeURIComponent(utils.WPrefix + '.' + this.id));
	
	  global[utils.WPrefix][this.id] = this._callback.bind(this);
	  this._createScript(urlWithId);
	
	  // Fallback mostly for Konqueror - stupid timer, 35 seconds shall be plenty.
	  this.timeoutId = setTimeout(function() {
	    debug('timeout');
	    self._abort(new Error('JSONP script loaded abnormally (timeout)'));
	  }, JsonpReceiver.timeout);
	}
	
	inherits(JsonpReceiver, EventEmitter);
	
	JsonpReceiver.prototype.abort = function() {
	  debug('abort');
	  if (global[utils.WPrefix][this.id]) {
	    var err = new Error('JSONP user aborted read');
	    err.code = 1000;
	    this._abort(err);
	  }
	};
	
	JsonpReceiver.timeout = 35000;
	JsonpReceiver.scriptErrorTimeout = 1000;
	
	JsonpReceiver.prototype._callback = function(data) {
	  debug('_callback', data);
	  this._cleanup();
	
	  if (this.aborting) {
	    return;
	  }
	
	  if (data) {
	    debug('message', data);
	    this.emit('message', data);
	  }
	  this.emit('close', null, 'network');
	  this.removeAllListeners();
	};
	
	JsonpReceiver.prototype._abort = function(err) {
	  debug('_abort', err);
	  this._cleanup();
	  this.aborting = true;
	  this.emit('close', err.code, err.message);
	  this.removeAllListeners();
	};
	
	JsonpReceiver.prototype._cleanup = function() {
	  debug('_cleanup');
	  clearTimeout(this.timeoutId);
	  if (this.script2) {
	    this.script2.parentNode.removeChild(this.script2);
	    this.script2 = null;
	  }
	  if (this.script) {
	    var script = this.script;
	    // Unfortunately, you can't really abort script loading of
	    // the script.
	    script.parentNode.removeChild(script);
	    script.onreadystatechange = script.onerror =
	        script.onload = script.onclick = null;
	    this.script = null;
	  }
	  delete global[utils.WPrefix][this.id];
	};
	
	JsonpReceiver.prototype._scriptError = function() {
	  debug('_scriptError');
	  var self = this;
	  if (this.errorTimer) {
	    return;
	  }
	
	  this.errorTimer = setTimeout(function() {
	    if (!self.loadedOkay) {
	      self._abort(new Error('JSONP script loaded abnormally (onerror)'));
	    }
	  }, JsonpReceiver.scriptErrorTimeout);
	};
	
	JsonpReceiver.prototype._createScript = function(url) {
	  debug('_createScript', url);
	  var self = this;
	  var script = this.script = global.document.createElement('script');
	  var script2;  // Opera synchronous load trick.
	
	  script.id = 'a' + random.string(8);
	  script.src = url;
	  script.type = 'text/javascript';
	  script.charset = 'UTF-8';
	  script.onerror = this._scriptError.bind(this);
	  script.onload = function() {
	    debug('onload');
	    self._abort(new Error('JSONP script loaded abnormally (onload)'));
	  };
	
	  // IE9 fires 'error' event after onreadystatechange or before, in random order.
	  // Use loadedOkay to determine if actually errored
	  script.onreadystatechange = function() {
	    debug('onreadystatechange', script.readyState);
	    if (/loaded|closed/.test(script.readyState)) {
	      if (script && script.htmlFor && script.onclick) {
	        self.loadedOkay = true;
	        try {
	          // In IE, actually execute the script.
	          script.onclick();
	        } catch (x) {
	          // intentionally empty
	        }
	      }
	      if (script) {
	        self._abort(new Error('JSONP script loaded abnormally (onreadystatechange)'));
	      }
	    }
	  };
	  // IE: event/htmlFor/onclick trick.
	  // One can't rely on proper order for onreadystatechange. In order to
	  // make sure, set a 'htmlFor' and 'event' properties, so that
	  // script code will be installed as 'onclick' handler for the
	  // script object. Later, onreadystatechange, manually execute this
	  // code. FF and Chrome doesn't work with 'event' and 'htmlFor'
	  // set. For reference see:
	  //   http://jaubourg.net/2010/07/loading-script-as-onclick-handler-of.html
	  // Also, read on that about script ordering:
	  //   http://wiki.whatwg.org/wiki/Dynamic_Script_Execution_Order
	  if (typeof script.async === 'undefined' && global.document.attachEvent) {
	    // According to mozilla docs, in recent browsers script.async defaults
	    // to 'true', so we may use it to detect a good browser:
	    // https://developer.mozilla.org/en/HTML/Element/script
	    if (!browser.isOpera()) {
	      // Naively assume we're in IE
	      try {
	        script.htmlFor = script.id;
	        script.event = 'onclick';
	      } catch (x) {
	        // intentionally empty
	      }
	      script.async = true;
	    } else {
	      // Opera, second sync script hack
	      script2 = this.script2 = global.document.createElement('script');
	      script2.text = "try{var a = document.getElementById('" + script.id + "'); if(a)a.onerror();}catch(x){};";
	      script.async = script2.async = false;
	    }
	  }
	  if (typeof script.async !== 'undefined') {
	    script.async = true;
	  }
	
	  var head = global.document.getElementsByTagName('head')[0];
	  head.insertBefore(script, head.firstChild);
	  if (script2) {
	    head.insertBefore(script2, head.firstChild);
	  }
	};
	
	module.exports = JsonpReceiver;
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ }),
/* 269 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {'use strict';
	
	var random = __webpack_require__(22)
	  , urlUtils = __webpack_require__(10)
	  ;
	
	var debug = function() {};
	if (true) {
	  debug = __webpack_require__(6)('sockjs-client:sender:jsonp');
	}
	
	var form, area;
	
	function createIframe(id) {
	  debug('createIframe', id);
	  try {
	    // ie6 dynamic iframes with target="" support (thanks Chris Lambacher)
	    return global.document.createElement('<iframe name="' + id + '">');
	  } catch (x) {
	    var iframe = global.document.createElement('iframe');
	    iframe.name = id;
	    return iframe;
	  }
	}
	
	function createForm() {
	  debug('createForm');
	  form = global.document.createElement('form');
	  form.style.display = 'none';
	  form.style.position = 'absolute';
	  form.method = 'POST';
	  form.enctype = 'application/x-www-form-urlencoded';
	  form.acceptCharset = 'UTF-8';
	
	  area = global.document.createElement('textarea');
	  area.name = 'd';
	  form.appendChild(area);
	
	  global.document.body.appendChild(form);
	}
	
	module.exports = function(url, payload, callback) {
	  debug(url, payload);
	  if (!form) {
	    createForm();
	  }
	  var id = 'a' + random.string(8);
	  form.target = id;
	  form.action = urlUtils.addQuery(urlUtils.addPath(url, '/jsonp_send'), 'i=' + id);
	
	  var iframe = createIframe(id);
	  iframe.id = id;
	  iframe.style.display = 'none';
	  form.appendChild(iframe);
	
	  try {
	    area.value = payload;
	  } catch (e) {
	    // seriously broken browsers get here
	  }
	  form.submit();
	
	  var completed = function(err) {
	    debug('completed', id, err);
	    if (!iframe.onerror) {
	      return;
	    }
	    iframe.onreadystatechange = iframe.onerror = iframe.onload = null;
	    // Opera mini doesn't like if we GC iframe
	    // immediately, thus this timeout.
	    setTimeout(function() {
	      debug('cleaning up', id);
	      iframe.parentNode.removeChild(iframe);
	      iframe = null;
	    }, 500);
	    area.value = '';
	    // It is not possible to detect if the iframe succeeded or
	    // failed to submit our form.
	    callback(err);
	  };
	  iframe.onerror = function() {
	    debug('onerror', id);
	    completed();
	  };
	  iframe.onload = function() {
	    debug('onload', id);
	    completed();
	  };
	  iframe.onreadystatechange = function(e) {
	    debug('onreadystatechange', id, iframe.readyState, e);
	    if (iframe.readyState === 'complete') {
	      completed();
	    }
	  };
	  return function() {
	    debug('aborted', id);
	    completed(new Error('Aborted'));
	  };
	};
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ }),
/* 270 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var EventEmitter = __webpack_require__(8).EventEmitter
	  , inherits = __webpack_require__(3)
	  ;
	
	function XHRFake(/* method, url, payload, opts */) {
	  var self = this;
	  EventEmitter.call(this);
	
	  this.to = setTimeout(function() {
	    self.emit('finish', 200, '{}');
	  }, XHRFake.timeout);
	}
	
	inherits(XHRFake, EventEmitter);
	
	XHRFake.prototype.close = function() {
	  clearTimeout(this.to);
	};
	
	XHRFake.timeout = 2000;
	
	module.exports = XHRFake;


/***/ }),
/* 271 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var utils = __webpack_require__(17)
	  , urlUtils = __webpack_require__(10)
	  , inherits = __webpack_require__(3)
	  , EventEmitter = __webpack_require__(8).EventEmitter
	  , WebsocketDriver = __webpack_require__(262)
	  ;
	
	var debug = function() {};
	if (true) {
	  debug = __webpack_require__(6)('sockjs-client:websocket');
	}
	
	function WebSocketTransport(transUrl, ignore, options) {
	  if (!WebSocketTransport.enabled()) {
	    throw new Error('Transport created when disabled');
	  }
	
	  EventEmitter.call(this);
	  debug('constructor', transUrl);
	
	  var self = this;
	  var url = urlUtils.addPath(transUrl, '/websocket');
	  if (url.slice(0, 5) === 'https') {
	    url = 'wss' + url.slice(5);
	  } else {
	    url = 'ws' + url.slice(4);
	  }
	  this.url = url;
	
	  this.ws = new WebsocketDriver(this.url, [], options);
	  this.ws.onmessage = function(e) {
	    debug('message event', e.data);
	    self.emit('message', e.data);
	  };
	  // Firefox has an interesting bug. If a websocket connection is
	  // created after onunload, it stays alive even when user
	  // navigates away from the page. In such situation let's lie -
	  // let's not open the ws connection at all. See:
	  // https://github.com/sockjs/sockjs-client/issues/28
	  // https://bugzilla.mozilla.org/show_bug.cgi?id=696085
	  this.unloadRef = utils.unloadAdd(function() {
	    debug('unload');
	    self.ws.close();
	  });
	  this.ws.onclose = function(e) {
	    debug('close event', e.code, e.reason);
	    self.emit('close', e.code, e.reason);
	    self._cleanup();
	  };
	  this.ws.onerror = function(e) {
	    debug('error event', e);
	    self.emit('close', 1006, 'WebSocket connection broken');
	    self._cleanup();
	  };
	}
	
	inherits(WebSocketTransport, EventEmitter);
	
	WebSocketTransport.prototype.send = function(data) {
	  var msg = '[' + data + ']';
	  debug('send', msg);
	  this.ws.send(msg);
	};
	
	WebSocketTransport.prototype.close = function() {
	  debug('close');
	  var ws = this.ws;
	  this._cleanup();
	  if (ws) {
	    ws.close();
	  }
	};
	
	WebSocketTransport.prototype._cleanup = function() {
	  debug('_cleanup');
	  var ws = this.ws;
	  if (ws) {
	    ws.onmessage = ws.onclose = ws.onerror = null;
	  }
	  utils.unloadDel(this.unloadRef);
	  this.unloadRef = this.ws = null;
	  this.removeAllListeners();
	};
	
	WebSocketTransport.enabled = function() {
	  debug('enabled');
	  return !!WebsocketDriver;
	};
	WebSocketTransport.transportName = 'websocket';
	
	// In theory, ws should require 1 round trip. But in chrome, this is
	// not very stable over SSL. Most likely a ws connection requires a
	// separate SSL connection, in which case 2 round trips are an
	// absolute minumum.
	WebSocketTransport.roundTrips = 2;
	
	module.exports = WebSocketTransport;


/***/ }),
/* 272 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var inherits = __webpack_require__(3)
	  , AjaxBasedTransport = __webpack_require__(21)
	  , XdrStreamingTransport = __webpack_require__(100)
	  , XhrReceiver = __webpack_require__(41)
	  , XDRObject = __webpack_require__(53)
	  ;
	
	function XdrPollingTransport(transUrl) {
	  if (!XDRObject.enabled) {
	    throw new Error('Transport created when disabled');
	  }
	  AjaxBasedTransport.call(this, transUrl, '/xhr', XhrReceiver, XDRObject);
	}
	
	inherits(XdrPollingTransport, AjaxBasedTransport);
	
	XdrPollingTransport.enabled = XdrStreamingTransport.enabled;
	XdrPollingTransport.transportName = 'xdr-polling';
	XdrPollingTransport.roundTrips = 2; // preflight, ajax
	
	module.exports = XdrPollingTransport;


/***/ }),
/* 273 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {'use strict';
	
	var inherits = __webpack_require__(3)
	  , AjaxBasedTransport = __webpack_require__(21)
	  , XhrReceiver = __webpack_require__(41)
	  , XHRCorsObject = __webpack_require__(42)
	  , XHRLocalObject = __webpack_require__(27)
	  , browser = __webpack_require__(28)
	  ;
	
	function XhrStreamingTransport(transUrl) {
	  if (!XHRLocalObject.enabled && !XHRCorsObject.enabled) {
	    throw new Error('Transport created when disabled');
	  }
	  AjaxBasedTransport.call(this, transUrl, '/xhr_streaming', XhrReceiver, XHRCorsObject);
	}
	
	inherits(XhrStreamingTransport, AjaxBasedTransport);
	
	XhrStreamingTransport.enabled = function(info) {
	  if (info.nullOrigin) {
	    return false;
	  }
	  // Opera doesn't support xhr-streaming #60
	  // But it might be able to #92
	  if (browser.isOpera()) {
	    return false;
	  }
	
	  return XHRCorsObject.enabled;
	};
	
	XhrStreamingTransport.transportName = 'xhr-streaming';
	XhrStreamingTransport.roundTrips = 2; // preflight, ajax
	
	// Safari gets confused when a streaming ajax request is started
	// before onload. This causes the load indicator to spin indefinetely.
	// Only require body when used in a browser
	XhrStreamingTransport.needBody = !!global.document;
	
	module.exports = XhrStreamingTransport;
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ }),
/* 274 */
/***/ (function(module, exports) {

	/* WEBPACK VAR INJECTION */(function(global) {'use strict';
	
	if (global.crypto && global.crypto.getRandomValues) {
	  module.exports.randomBytes = function(length) {
	    var bytes = new Uint8Array(length);
	    global.crypto.getRandomValues(bytes);
	    return bytes;
	  };
	} else {
	  module.exports.randomBytes = function(length) {
	    var bytes = new Array(length);
	    for (var i = 0; i < length; i++) {
	      bytes[i] = Math.floor(Math.random() * 256);
	    }
	    return bytes;
	  };
	}
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ }),
/* 275 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var JSON3 = __webpack_require__(15);
	
	// Some extra characters that Chrome gets wrong, and substitutes with
	// something else on the wire.
	// eslint-disable-next-line no-control-regex
	var extraEscapable = /[\x00-\x1f\ud800-\udfff\ufffe\uffff\u0300-\u0333\u033d-\u0346\u034a-\u034c\u0350-\u0352\u0357-\u0358\u035c-\u0362\u0374\u037e\u0387\u0591-\u05af\u05c4\u0610-\u0617\u0653-\u0654\u0657-\u065b\u065d-\u065e\u06df-\u06e2\u06eb-\u06ec\u0730\u0732-\u0733\u0735-\u0736\u073a\u073d\u073f-\u0741\u0743\u0745\u0747\u07eb-\u07f1\u0951\u0958-\u095f\u09dc-\u09dd\u09df\u0a33\u0a36\u0a59-\u0a5b\u0a5e\u0b5c-\u0b5d\u0e38-\u0e39\u0f43\u0f4d\u0f52\u0f57\u0f5c\u0f69\u0f72-\u0f76\u0f78\u0f80-\u0f83\u0f93\u0f9d\u0fa2\u0fa7\u0fac\u0fb9\u1939-\u193a\u1a17\u1b6b\u1cda-\u1cdb\u1dc0-\u1dcf\u1dfc\u1dfe\u1f71\u1f73\u1f75\u1f77\u1f79\u1f7b\u1f7d\u1fbb\u1fbe\u1fc9\u1fcb\u1fd3\u1fdb\u1fe3\u1feb\u1fee-\u1fef\u1ff9\u1ffb\u1ffd\u2000-\u2001\u20d0-\u20d1\u20d4-\u20d7\u20e7-\u20e9\u2126\u212a-\u212b\u2329-\u232a\u2adc\u302b-\u302c\uaab2-\uaab3\uf900-\ufa0d\ufa10\ufa12\ufa15-\ufa1e\ufa20\ufa22\ufa25-\ufa26\ufa2a-\ufa2d\ufa30-\ufa6d\ufa70-\ufad9\ufb1d\ufb1f\ufb2a-\ufb36\ufb38-\ufb3c\ufb3e\ufb40-\ufb41\ufb43-\ufb44\ufb46-\ufb4e\ufff0-\uffff]/g
	  , extraLookup;
	
	// This may be quite slow, so let's delay until user actually uses bad
	// characters.
	var unrollLookup = function(escapable) {
	  var i;
	  var unrolled = {};
	  var c = [];
	  for (i = 0; i < 65536; i++) {
	    c.push( String.fromCharCode(i) );
	  }
	  escapable.lastIndex = 0;
	  c.join('').replace(escapable, function(a) {
	    unrolled[ a ] = '\\u' + ('0000' + a.charCodeAt(0).toString(16)).slice(-4);
	    return '';
	  });
	  escapable.lastIndex = 0;
	  return unrolled;
	};
	
	// Quote string, also taking care of unicode characters that browsers
	// often break. Especially, take care of unicode surrogates:
	// http://en.wikipedia.org/wiki/Mapping_of_Unicode_characters#Surrogates
	module.exports = {
	  quote: function(string) {
	    var quoted = JSON3.stringify(string);
	
	    // In most cases this should be very fast and good enough.
	    extraEscapable.lastIndex = 0;
	    if (!extraEscapable.test(quoted)) {
	      return quoted;
	    }
	
	    if (!extraLookup) {
	      extraLookup = unrollLookup(extraEscapable);
	    }
	
	    return quoted.replace(extraEscapable, function(a) {
	      return extraLookup[a];
	    });
	  }
	};


/***/ }),
/* 276 */
/***/ (function(module, exports) {

	/* WEBPACK VAR INJECTION */(function(global) {'use strict';
	
	var logObject = {};
	['log', 'debug', 'warn'].forEach(function (level) {
	  var levelExists;
	
	  try {
	    levelExists = global.console && global.console[level] && global.console[level].apply;
	  } catch(e) {
	    // do nothing
	  }
	
	  logObject[level] = levelExists ? function () {
	    return global.console[level].apply(global.console, arguments);
	  } : (level === 'log' ? function () {} : logObject.log);
	});
	
	module.exports = logObject;
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ }),
/* 277 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var debug = function() {};
	if (true) {
	  debug = __webpack_require__(6)('sockjs-client:utils:transport');
	}
	
	module.exports = function(availableTransports) {
	  return {
	    filterToEnabled: function(transportsWhitelist, info) {
	      var transports = {
	        main: []
	      , facade: []
	      };
	      if (!transportsWhitelist) {
	        transportsWhitelist = [];
	      } else if (typeof transportsWhitelist === 'string') {
	        transportsWhitelist = [transportsWhitelist];
	      }
	
	      availableTransports.forEach(function(trans) {
	        if (!trans) {
	          return;
	        }
	
	        if (trans.transportName === 'websocket' && info.websocket === false) {
	          debug('disabled from server', 'websocket');
	          return;
	        }
	
	        if (transportsWhitelist.length &&
	            transportsWhitelist.indexOf(trans.transportName) === -1) {
	          debug('not in whitelist', trans.transportName);
	          return;
	        }
	
	        if (trans.enabled(info)) {
	          debug('enabled', trans.transportName);
	          transports.main.push(trans);
	          if (trans.facadeTransport) {
	            transports.facade.push(trans.facadeTransport);
	          }
	        } else {
	          debug('disabled', trans.transportName);
	        }
	      });
	      return transports;
	    }
	  };
	};


/***/ }),
/* 278 */
/***/ (function(module, exports) {

	"use strict";
	
	function hash(str) {
	  var hash = 5381,
	      i    = str.length;
	
	  while(i) {
	    hash = (hash * 33) ^ str.charCodeAt(--i);
	  }
	
	  /* JavaScript does bitwise operations (like XOR, above) on 32-bit signed
	   * integers. Since we want the results to be always positive, convert the
	   * signed int to an unsigned by doing an unsigned bitshift. */
	  return hash >>> 0;
	}
	
	module.exports = hash;


/***/ }),
/* 279 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var ansiRegex = __webpack_require__(106)();
	
	module.exports = function (str) {
		return typeof str === 'string' ? str.replace(ansiRegex, '') : str;
	};


/***/ }),
/* 280 */
/***/ (function(module, exports, __webpack_require__) {

	var inherits = __webpack_require__(3);
	var getNormals = __webpack_require__(243);
	var VERTS_PER_POINT = 2;
	
	module.exports = function createLineMesh (THREE) {
	  function LineMesh (path, opt) {
	    if (!(this instanceof LineMesh)) {
	      return new LineMesh(path, opt);
	    }
	    THREE.BufferGeometry.call(this);
	
	    if (Array.isArray(path)) {
	      opt = opt || {};
	    } else if (typeof path === 'object') {
	      opt = path;
	      path = [];
	    }
	
	    opt = opt || {};
	
	    this.addAttribute('position', new THREE.BufferAttribute(undefined, 3));
	    this.addAttribute('lineNormal', new THREE.BufferAttribute(undefined, 2));
	    this.addAttribute('lineMiter', new THREE.BufferAttribute(undefined, 1));
	    if (opt.distances) {
	      this.addAttribute('lineDistance', new THREE.BufferAttribute(undefined, 1));
	    }
	    if (typeof this.setIndex === 'function') {
	      this.setIndex(new THREE.BufferAttribute(undefined, 1));
	    } else {
	      this.addAttribute('index', new THREE.BufferAttribute(undefined, 1));
	    }
	    this.update(path, opt.closed);
	  }
	
	  inherits(LineMesh, THREE.BufferGeometry);
	
	  LineMesh.prototype.update = function (path, closed) {
	    path = path || [];
	    var normals = getNormals(path, closed);
	
	    if (closed) {
	      path = path.slice();
	      path.push(path[0]);
	      normals.push(normals[0]);
	    }
	
	    var attrPosition = this.getAttribute('position');
	    var attrNormal = this.getAttribute('lineNormal');
	    var attrMiter = this.getAttribute('lineMiter');
	    var attrDistance = this.getAttribute('lineDistance');
	    var attrIndex = typeof this.getIndex === 'function' ? this.getIndex() : this.getAttribute('index');
	
	    var indexCount = Math.max(0, (path.length - 1) * 6);
	    if (!attrPosition.array ||
	        (path.length !== attrPosition.array.length / 3 / VERTS_PER_POINT)) {
	      var count = path.length * VERTS_PER_POINT;
	      attrPosition.array = new Float32Array(count * 3);
	      attrNormal.array = new Float32Array(count * 2);
	      attrMiter.array = new Float32Array(count);
	      attrIndex.array = new Uint16Array(indexCount);
	
	      if (attrDistance) {
	        attrDistance.array = new Float32Array(count);
	      }
	    }
	
	    if (undefined !== attrPosition.count) {
	      attrPosition.count = count;
	    }
	    attrPosition.needsUpdate = true;
	
	    if (undefined !== attrNormal.count) {
	      attrNormal.count = count;
	    }
	    attrNormal.needsUpdate = true;
	
	    if (undefined !== attrMiter.count) {
	      attrMiter.count = count;
	    }
	    attrMiter.needsUpdate = true;
	
	    if (undefined !== attrIndex.count) {
	      attrIndex.count = indexCount;
	    }
	    attrIndex.needsUpdate = true;
	
	    if (attrDistance) {
	      if (undefined !== attrDistance.count) {
	        attrDistance.count = count;
	      }
	      attrDistance.needsUpdate = true;
	    }
	
	    var index = 0;
	    var c = 0;
	    var dIndex = 0;
	    var indexArray = attrIndex.array;
	
	    path.forEach(function (point, pointIndex, list) {
	      var i = index;
	      indexArray[c++] = i + 0;
	      indexArray[c++] = i + 1;
	      indexArray[c++] = i + 2;
	      indexArray[c++] = i + 2;
	      indexArray[c++] = i + 1;
	      indexArray[c++] = i + 3;
	
	      attrPosition.setXYZ(index++, point[0], point[1], 0);
	      attrPosition.setXYZ(index++, point[0], point[1], 0);
	
	      if (attrDistance) {
	        var d = pointIndex / (list.length - 1);
	        attrDistance.setX(dIndex++, d);
	        attrDistance.setX(dIndex++, d);
	      }
	    });
	
	    var nIndex = 0;
	    var mIndex = 0;
	    normals.forEach(function (n) {
	      var norm = n[0];
	      var miter = n[1];
	      attrNormal.setXY(nIndex++, norm[0], norm[1]);
	      attrNormal.setXY(nIndex++, norm[0], norm[1]);
	
	      attrMiter.setX(mIndex++, -miter);
	      attrMiter.setX(mIndex++, miter);
	    });
	  };
	
	  return LineMesh;
	};


/***/ }),
/* 281 */
/***/ (function(module, exports, __webpack_require__) {

	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.
	
	'use strict';
	
	var punycode = __webpack_require__(244);
	var util = __webpack_require__(282);
	
	exports.parse = urlParse;
	exports.resolve = urlResolve;
	exports.resolveObject = urlResolveObject;
	exports.format = urlFormat;
	
	exports.Url = Url;
	
	function Url() {
	  this.protocol = null;
	  this.slashes = null;
	  this.auth = null;
	  this.host = null;
	  this.port = null;
	  this.hostname = null;
	  this.hash = null;
	  this.search = null;
	  this.query = null;
	  this.pathname = null;
	  this.path = null;
	  this.href = null;
	}
	
	// Reference: RFC 3986, RFC 1808, RFC 2396
	
	// define these here so at least they only have to be
	// compiled once on the first module load.
	var protocolPattern = /^([a-z0-9.+-]+:)/i,
	    portPattern = /:[0-9]*$/,
	
	    // Special case for a simple path URL
	    simplePathPattern = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/,
	
	    // RFC 2396: characters reserved for delimiting URLs.
	    // We actually just auto-escape these.
	    delims = ['<', '>', '"', '`', ' ', '\r', '\n', '\t'],
	
	    // RFC 2396: characters not allowed for various reasons.
	    unwise = ['{', '}', '|', '\\', '^', '`'].concat(delims),
	
	    // Allowed by RFCs, but cause of XSS attacks.  Always escape these.
	    autoEscape = ['\''].concat(unwise),
	    // Characters that are never ever allowed in a hostname.
	    // Note that any invalid chars are also handled, but these
	    // are the ones that are *expected* to be seen, so we fast-path
	    // them.
	    nonHostChars = ['%', '/', '?', ';', '#'].concat(autoEscape),
	    hostEndingChars = ['/', '?', '#'],
	    hostnameMaxLen = 255,
	    hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/,
	    hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/,
	    // protocols that can allow "unsafe" and "unwise" chars.
	    unsafeProtocol = {
	      'javascript': true,
	      'javascript:': true
	    },
	    // protocols that never have a hostname.
	    hostlessProtocol = {
	      'javascript': true,
	      'javascript:': true
	    },
	    // protocols that always contain a // bit.
	    slashedProtocol = {
	      'http': true,
	      'https': true,
	      'ftp': true,
	      'gopher': true,
	      'file': true,
	      'http:': true,
	      'https:': true,
	      'ftp:': true,
	      'gopher:': true,
	      'file:': true
	    },
	    querystring = __webpack_require__(247);
	
	function urlParse(url, parseQueryString, slashesDenoteHost) {
	  if (url && util.isObject(url) && url instanceof Url) return url;
	
	  var u = new Url;
	  u.parse(url, parseQueryString, slashesDenoteHost);
	  return u;
	}
	
	Url.prototype.parse = function(url, parseQueryString, slashesDenoteHost) {
	  if (!util.isString(url)) {
	    throw new TypeError("Parameter 'url' must be a string, not " + typeof url);
	  }
	
	  // Copy chrome, IE, opera backslash-handling behavior.
	  // Back slashes before the query string get converted to forward slashes
	  // See: https://code.google.com/p/chromium/issues/detail?id=25916
	  var queryIndex = url.indexOf('?'),
	      splitter =
	          (queryIndex !== -1 && queryIndex < url.indexOf('#')) ? '?' : '#',
	      uSplit = url.split(splitter),
	      slashRegex = /\\/g;
	  uSplit[0] = uSplit[0].replace(slashRegex, '/');
	  url = uSplit.join(splitter);
	
	  var rest = url;
	
	  // trim before proceeding.
	  // This is to support parse stuff like "  http://foo.com  \n"
	  rest = rest.trim();
	
	  if (!slashesDenoteHost && url.split('#').length === 1) {
	    // Try fast path regexp
	    var simplePath = simplePathPattern.exec(rest);
	    if (simplePath) {
	      this.path = rest;
	      this.href = rest;
	      this.pathname = simplePath[1];
	      if (simplePath[2]) {
	        this.search = simplePath[2];
	        if (parseQueryString) {
	          this.query = querystring.parse(this.search.substr(1));
	        } else {
	          this.query = this.search.substr(1);
	        }
	      } else if (parseQueryString) {
	        this.search = '';
	        this.query = {};
	      }
	      return this;
	    }
	  }
	
	  var proto = protocolPattern.exec(rest);
	  if (proto) {
	    proto = proto[0];
	    var lowerProto = proto.toLowerCase();
	    this.protocol = lowerProto;
	    rest = rest.substr(proto.length);
	  }
	
	  // figure out if it's got a host
	  // user@server is *always* interpreted as a hostname, and url
	  // resolution will treat //foo/bar as host=foo,path=bar because that's
	  // how the browser resolves relative URLs.
	  if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
	    var slashes = rest.substr(0, 2) === '//';
	    if (slashes && !(proto && hostlessProtocol[proto])) {
	      rest = rest.substr(2);
	      this.slashes = true;
	    }
	  }
	
	  if (!hostlessProtocol[proto] &&
	      (slashes || (proto && !slashedProtocol[proto]))) {
	
	    // there's a hostname.
	    // the first instance of /, ?, ;, or # ends the host.
	    //
	    // If there is an @ in the hostname, then non-host chars *are* allowed
	    // to the left of the last @ sign, unless some host-ending character
	    // comes *before* the @-sign.
	    // URLs are obnoxious.
	    //
	    // ex:
	    // http://a@b@c/ => user:a@b host:c
	    // http://a@b?@c => user:a host:c path:/?@c
	
	    // v0.12 TODO(isaacs): This is not quite how Chrome does things.
	    // Review our test case against browsers more comprehensively.
	
	    // find the first instance of any hostEndingChars
	    var hostEnd = -1;
	    for (var i = 0; i < hostEndingChars.length; i++) {
	      var hec = rest.indexOf(hostEndingChars[i]);
	      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
	        hostEnd = hec;
	    }
	
	    // at this point, either we have an explicit point where the
	    // auth portion cannot go past, or the last @ char is the decider.
	    var auth, atSign;
	    if (hostEnd === -1) {
	      // atSign can be anywhere.
	      atSign = rest.lastIndexOf('@');
	    } else {
	      // atSign must be in auth portion.
	      // http://a@b/c@d => host:b auth:a path:/c@d
	      atSign = rest.lastIndexOf('@', hostEnd);
	    }
	
	    // Now we have a portion which is definitely the auth.
	    // Pull that off.
	    if (atSign !== -1) {
	      auth = rest.slice(0, atSign);
	      rest = rest.slice(atSign + 1);
	      this.auth = decodeURIComponent(auth);
	    }
	
	    // the host is the remaining to the left of the first non-host char
	    hostEnd = -1;
	    for (var i = 0; i < nonHostChars.length; i++) {
	      var hec = rest.indexOf(nonHostChars[i]);
	      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
	        hostEnd = hec;
	    }
	    // if we still have not hit it, then the entire thing is a host.
	    if (hostEnd === -1)
	      hostEnd = rest.length;
	
	    this.host = rest.slice(0, hostEnd);
	    rest = rest.slice(hostEnd);
	
	    // pull out port.
	    this.parseHost();
	
	    // we've indicated that there is a hostname,
	    // so even if it's empty, it has to be present.
	    this.hostname = this.hostname || '';
	
	    // if hostname begins with [ and ends with ]
	    // assume that it's an IPv6 address.
	    var ipv6Hostname = this.hostname[0] === '[' &&
	        this.hostname[this.hostname.length - 1] === ']';
	
	    // validate a little.
	    if (!ipv6Hostname) {
	      var hostparts = this.hostname.split(/\./);
	      for (var i = 0, l = hostparts.length; i < l; i++) {
	        var part = hostparts[i];
	        if (!part) continue;
	        if (!part.match(hostnamePartPattern)) {
	          var newpart = '';
	          for (var j = 0, k = part.length; j < k; j++) {
	            if (part.charCodeAt(j) > 127) {
	              // we replace non-ASCII char with a temporary placeholder
	              // we need this to make sure size of hostname is not
	              // broken by replacing non-ASCII by nothing
	              newpart += 'x';
	            } else {
	              newpart += part[j];
	            }
	          }
	          // we test again with ASCII char only
	          if (!newpart.match(hostnamePartPattern)) {
	            var validParts = hostparts.slice(0, i);
	            var notHost = hostparts.slice(i + 1);
	            var bit = part.match(hostnamePartStart);
	            if (bit) {
	              validParts.push(bit[1]);
	              notHost.unshift(bit[2]);
	            }
	            if (notHost.length) {
	              rest = '/' + notHost.join('.') + rest;
	            }
	            this.hostname = validParts.join('.');
	            break;
	          }
	        }
	      }
	    }
	
	    if (this.hostname.length > hostnameMaxLen) {
	      this.hostname = '';
	    } else {
	      // hostnames are always lower case.
	      this.hostname = this.hostname.toLowerCase();
	    }
	
	    if (!ipv6Hostname) {
	      // IDNA Support: Returns a punycoded representation of "domain".
	      // It only converts parts of the domain name that
	      // have non-ASCII characters, i.e. it doesn't matter if
	      // you call it with a domain that already is ASCII-only.
	      this.hostname = punycode.toASCII(this.hostname);
	    }
	
	    var p = this.port ? ':' + this.port : '';
	    var h = this.hostname || '';
	    this.host = h + p;
	    this.href += this.host;
	
	    // strip [ and ] from the hostname
	    // the host field still retains them, though
	    if (ipv6Hostname) {
	      this.hostname = this.hostname.substr(1, this.hostname.length - 2);
	      if (rest[0] !== '/') {
	        rest = '/' + rest;
	      }
	    }
	  }
	
	  // now rest is set to the post-host stuff.
	  // chop off any delim chars.
	  if (!unsafeProtocol[lowerProto]) {
	
	    // First, make 100% sure that any "autoEscape" chars get
	    // escaped, even if encodeURIComponent doesn't think they
	    // need to be.
	    for (var i = 0, l = autoEscape.length; i < l; i++) {
	      var ae = autoEscape[i];
	      if (rest.indexOf(ae) === -1)
	        continue;
	      var esc = encodeURIComponent(ae);
	      if (esc === ae) {
	        esc = escape(ae);
	      }
	      rest = rest.split(ae).join(esc);
	    }
	  }
	
	
	  // chop off from the tail first.
	  var hash = rest.indexOf('#');
	  if (hash !== -1) {
	    // got a fragment string.
	    this.hash = rest.substr(hash);
	    rest = rest.slice(0, hash);
	  }
	  var qm = rest.indexOf('?');
	  if (qm !== -1) {
	    this.search = rest.substr(qm);
	    this.query = rest.substr(qm + 1);
	    if (parseQueryString) {
	      this.query = querystring.parse(this.query);
	    }
	    rest = rest.slice(0, qm);
	  } else if (parseQueryString) {
	    // no query string, but parseQueryString still requested
	    this.search = '';
	    this.query = {};
	  }
	  if (rest) this.pathname = rest;
	  if (slashedProtocol[lowerProto] &&
	      this.hostname && !this.pathname) {
	    this.pathname = '/';
	  }
	
	  //to support http.request
	  if (this.pathname || this.search) {
	    var p = this.pathname || '';
	    var s = this.search || '';
	    this.path = p + s;
	  }
	
	  // finally, reconstruct the href based on what has been validated.
	  this.href = this.format();
	  return this;
	};
	
	// format a parsed object into a url string
	function urlFormat(obj) {
	  // ensure it's an object, and not a string url.
	  // If it's an obj, this is a no-op.
	  // this way, you can call url_format() on strings
	  // to clean up potentially wonky urls.
	  if (util.isString(obj)) obj = urlParse(obj);
	  if (!(obj instanceof Url)) return Url.prototype.format.call(obj);
	  return obj.format();
	}
	
	Url.prototype.format = function() {
	  var auth = this.auth || '';
	  if (auth) {
	    auth = encodeURIComponent(auth);
	    auth = auth.replace(/%3A/i, ':');
	    auth += '@';
	  }
	
	  var protocol = this.protocol || '',
	      pathname = this.pathname || '',
	      hash = this.hash || '',
	      host = false,
	      query = '';
	
	  if (this.host) {
	    host = auth + this.host;
	  } else if (this.hostname) {
	    host = auth + (this.hostname.indexOf(':') === -1 ?
	        this.hostname :
	        '[' + this.hostname + ']');
	    if (this.port) {
	      host += ':' + this.port;
	    }
	  }
	
	  if (this.query &&
	      util.isObject(this.query) &&
	      Object.keys(this.query).length) {
	    query = querystring.stringify(this.query);
	  }
	
	  var search = this.search || (query && ('?' + query)) || '';
	
	  if (protocol && protocol.substr(-1) !== ':') protocol += ':';
	
	  // only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.
	  // unless they had them to begin with.
	  if (this.slashes ||
	      (!protocol || slashedProtocol[protocol]) && host !== false) {
	    host = '//' + (host || '');
	    if (pathname && pathname.charAt(0) !== '/') pathname = '/' + pathname;
	  } else if (!host) {
	    host = '';
	  }
	
	  if (hash && hash.charAt(0) !== '#') hash = '#' + hash;
	  if (search && search.charAt(0) !== '?') search = '?' + search;
	
	  pathname = pathname.replace(/[?#]/g, function(match) {
	    return encodeURIComponent(match);
	  });
	  search = search.replace('#', '%23');
	
	  return protocol + host + pathname + search + hash;
	};
	
	function urlResolve(source, relative) {
	  return urlParse(source, false, true).resolve(relative);
	}
	
	Url.prototype.resolve = function(relative) {
	  return this.resolveObject(urlParse(relative, false, true)).format();
	};
	
	function urlResolveObject(source, relative) {
	  if (!source) return relative;
	  return urlParse(source, false, true).resolveObject(relative);
	}
	
	Url.prototype.resolveObject = function(relative) {
	  if (util.isString(relative)) {
	    var rel = new Url();
	    rel.parse(relative, false, true);
	    relative = rel;
	  }
	
	  var result = new Url();
	  var tkeys = Object.keys(this);
	  for (var tk = 0; tk < tkeys.length; tk++) {
	    var tkey = tkeys[tk];
	    result[tkey] = this[tkey];
	  }
	
	  // hash is always overridden, no matter what.
	  // even href="" will remove it.
	  result.hash = relative.hash;
	
	  // if the relative url is empty, then there's nothing left to do here.
	  if (relative.href === '') {
	    result.href = result.format();
	    return result;
	  }
	
	  // hrefs like //foo/bar always cut to the protocol.
	  if (relative.slashes && !relative.protocol) {
	    // take everything except the protocol from relative
	    var rkeys = Object.keys(relative);
	    for (var rk = 0; rk < rkeys.length; rk++) {
	      var rkey = rkeys[rk];
	      if (rkey !== 'protocol')
	        result[rkey] = relative[rkey];
	    }
	
	    //urlParse appends trailing / to urls like http://www.example.com
	    if (slashedProtocol[result.protocol] &&
	        result.hostname && !result.pathname) {
	      result.path = result.pathname = '/';
	    }
	
	    result.href = result.format();
	    return result;
	  }
	
	  if (relative.protocol && relative.protocol !== result.protocol) {
	    // if it's a known url protocol, then changing
	    // the protocol does weird things
	    // first, if it's not file:, then we MUST have a host,
	    // and if there was a path
	    // to begin with, then we MUST have a path.
	    // if it is file:, then the host is dropped,
	    // because that's known to be hostless.
	    // anything else is assumed to be absolute.
	    if (!slashedProtocol[relative.protocol]) {
	      var keys = Object.keys(relative);
	      for (var v = 0; v < keys.length; v++) {
	        var k = keys[v];
	        result[k] = relative[k];
	      }
	      result.href = result.format();
	      return result;
	    }
	
	    result.protocol = relative.protocol;
	    if (!relative.host && !hostlessProtocol[relative.protocol]) {
	      var relPath = (relative.pathname || '').split('/');
	      while (relPath.length && !(relative.host = relPath.shift()));
	      if (!relative.host) relative.host = '';
	      if (!relative.hostname) relative.hostname = '';
	      if (relPath[0] !== '') relPath.unshift('');
	      if (relPath.length < 2) relPath.unshift('');
	      result.pathname = relPath.join('/');
	    } else {
	      result.pathname = relative.pathname;
	    }
	    result.search = relative.search;
	    result.query = relative.query;
	    result.host = relative.host || '';
	    result.auth = relative.auth;
	    result.hostname = relative.hostname || relative.host;
	    result.port = relative.port;
	    // to support http.request
	    if (result.pathname || result.search) {
	      var p = result.pathname || '';
	      var s = result.search || '';
	      result.path = p + s;
	    }
	    result.slashes = result.slashes || relative.slashes;
	    result.href = result.format();
	    return result;
	  }
	
	  var isSourceAbs = (result.pathname && result.pathname.charAt(0) === '/'),
	      isRelAbs = (
	          relative.host ||
	          relative.pathname && relative.pathname.charAt(0) === '/'
	      ),
	      mustEndAbs = (isRelAbs || isSourceAbs ||
	                    (result.host && relative.pathname)),
	      removeAllDots = mustEndAbs,
	      srcPath = result.pathname && result.pathname.split('/') || [],
	      relPath = relative.pathname && relative.pathname.split('/') || [],
	      psychotic = result.protocol && !slashedProtocol[result.protocol];
	
	  // if the url is a non-slashed url, then relative
	  // links like ../.. should be able
	  // to crawl up to the hostname, as well.  This is strange.
	  // result.protocol has already been set by now.
	  // Later on, put the first path part into the host field.
	  if (psychotic) {
	    result.hostname = '';
	    result.port = null;
	    if (result.host) {
	      if (srcPath[0] === '') srcPath[0] = result.host;
	      else srcPath.unshift(result.host);
	    }
	    result.host = '';
	    if (relative.protocol) {
	      relative.hostname = null;
	      relative.port = null;
	      if (relative.host) {
	        if (relPath[0] === '') relPath[0] = relative.host;
	        else relPath.unshift(relative.host);
	      }
	      relative.host = null;
	    }
	    mustEndAbs = mustEndAbs && (relPath[0] === '' || srcPath[0] === '');
	  }
	
	  if (isRelAbs) {
	    // it's absolute.
	    result.host = (relative.host || relative.host === '') ?
	                  relative.host : result.host;
	    result.hostname = (relative.hostname || relative.hostname === '') ?
	                      relative.hostname : result.hostname;
	    result.search = relative.search;
	    result.query = relative.query;
	    srcPath = relPath;
	    // fall through to the dot-handling below.
	  } else if (relPath.length) {
	    // it's relative
	    // throw away the existing file, and take the new path instead.
	    if (!srcPath) srcPath = [];
	    srcPath.pop();
	    srcPath = srcPath.concat(relPath);
	    result.search = relative.search;
	    result.query = relative.query;
	  } else if (!util.isNullOrUndefined(relative.search)) {
	    // just pull out the search.
	    // like href='?foo'.
	    // Put this after the other two cases because it simplifies the booleans
	    if (psychotic) {
	      result.hostname = result.host = srcPath.shift();
	      //occationaly the auth can get stuck only in host
	      //this especially happens in cases like
	      //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
	      var authInHost = result.host && result.host.indexOf('@') > 0 ?
	                       result.host.split('@') : false;
	      if (authInHost) {
	        result.auth = authInHost.shift();
	        result.host = result.hostname = authInHost.shift();
	      }
	    }
	    result.search = relative.search;
	    result.query = relative.query;
	    //to support http.request
	    if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
	      result.path = (result.pathname ? result.pathname : '') +
	                    (result.search ? result.search : '');
	    }
	    result.href = result.format();
	    return result;
	  }
	
	  if (!srcPath.length) {
	    // no path at all.  easy.
	    // we've already handled the other stuff above.
	    result.pathname = null;
	    //to support http.request
	    if (result.search) {
	      result.path = '/' + result.search;
	    } else {
	      result.path = null;
	    }
	    result.href = result.format();
	    return result;
	  }
	
	  // if a url ENDs in . or .., then it must get a trailing slash.
	  // however, if it ends in anything else non-slashy,
	  // then it must NOT get a trailing slash.
	  var last = srcPath.slice(-1)[0];
	  var hasTrailingSlash = (
	      (result.host || relative.host || srcPath.length > 1) &&
	      (last === '.' || last === '..') || last === '');
	
	  // strip single dots, resolve double dots to parent dir
	  // if the path tries to go above the root, `up` ends up > 0
	  var up = 0;
	  for (var i = srcPath.length; i >= 0; i--) {
	    last = srcPath[i];
	    if (last === '.') {
	      srcPath.splice(i, 1);
	    } else if (last === '..') {
	      srcPath.splice(i, 1);
	      up++;
	    } else if (up) {
	      srcPath.splice(i, 1);
	      up--;
	    }
	  }
	
	  // if the path is allowed to go above the root, restore leading ..s
	  if (!mustEndAbs && !removeAllDots) {
	    for (; up--; up) {
	      srcPath.unshift('..');
	    }
	  }
	
	  if (mustEndAbs && srcPath[0] !== '' &&
	      (!srcPath[0] || srcPath[0].charAt(0) !== '/')) {
	    srcPath.unshift('');
	  }
	
	  if (hasTrailingSlash && (srcPath.join('/').substr(-1) !== '/')) {
	    srcPath.push('');
	  }
	
	  var isAbsolute = srcPath[0] === '' ||
	      (srcPath[0] && srcPath[0].charAt(0) === '/');
	
	  // put the host back
	  if (psychotic) {
	    result.hostname = result.host = isAbsolute ? '' :
	                                    srcPath.length ? srcPath.shift() : '';
	    //occationaly the auth can get stuck only in host
	    //this especially happens in cases like
	    //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
	    var authInHost = result.host && result.host.indexOf('@') > 0 ?
	                     result.host.split('@') : false;
	    if (authInHost) {
	      result.auth = authInHost.shift();
	      result.host = result.hostname = authInHost.shift();
	    }
	  }
	
	  mustEndAbs = mustEndAbs || (result.host && srcPath.length);
	
	  if (mustEndAbs && !isAbsolute) {
	    srcPath.unshift('');
	  }
	
	  if (!srcPath.length) {
	    result.pathname = null;
	    result.path = null;
	  } else {
	    result.pathname = srcPath.join('/');
	  }
	
	  //to support request.http
	  if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
	    result.path = (result.pathname ? result.pathname : '') +
	                  (result.search ? result.search : '');
	  }
	  result.auth = relative.auth || result.auth;
	  result.slashes = result.slashes || relative.slashes;
	  result.href = result.format();
	  return result;
	};
	
	Url.prototype.parseHost = function() {
	  var host = this.host;
	  var port = portPattern.exec(host);
	  if (port) {
	    port = port[0];
	    if (port !== ':') {
	      this.port = port.substr(1);
	    }
	    host = host.substr(0, host.length - port.length);
	  }
	  if (host) this.hostname = host;
	};


/***/ }),
/* 282 */
/***/ (function(module, exports) {

	'use strict';
	
	module.exports = {
	  isString: function(arg) {
	    return typeof(arg) === 'string';
	  },
	  isObject: function(arg) {
	    return typeof(arg) === 'object' && arg !== null;
	  },
	  isNull: function(arg) {
	    return arg === null;
	  },
	  isNullOrUndefined: function(arg) {
	    return arg == null;
	  }
	};


/***/ }),
/* 283 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(__resourceQuery) {var url = __webpack_require__(281);
	var stripAnsi = __webpack_require__(279);
	var socket = __webpack_require__(284);
	
	function getCurrentScriptSource() {
		// `document.currentScript` is the most accurate way to find the current script,
		// but is not supported in all browsers.
		if(document.currentScript)
			return document.currentScript.getAttribute("src");
		// Fall back to getting all scripts in the document.
		var scriptElements = document.scripts || [];
		var currentScript = scriptElements[scriptElements.length - 1];
		if(currentScript)
			return currentScript.getAttribute("src");
		// Fail as there was no script to use.
		throw new Error("[WDS] Failed to get current script source");
	}
	
	var urlParts;
	if(true) {
		// If this bundle is inlined, use the resource query to get the correct url.
		urlParts = url.parse(__resourceQuery.substr(1));
	} else {
		// Else, get the url from the <script> this file was called with.
		var scriptHost = getCurrentScriptSource();
		scriptHost = scriptHost.replace(/\/[^\/]+$/, "");
		urlParts = url.parse((scriptHost ? scriptHost : "/"), false, true);
	}
	
	var hot = false;
	var initial = true;
	var currentHash = "";
	var logLevel = "info";
	
	function log(level, msg) {
		if(logLevel === "info" && level === "info")
			return console.log(msg);
		if(["info", "warning"].indexOf(logLevel) >= 0 && level === "warning")
			return console.warn(msg);
		if(["info", "warning", "error"].indexOf(logLevel) >= 0 && level === "error")
			return console.error(msg);
	}
	
	var onSocketMsg = {
		hot: function() {
			hot = true;
			log("info", "[WDS] Hot Module Replacement enabled.");
		},
		invalid: function() {
			log("info", "[WDS] App updated. Recompiling...");
		},
		hash: function(hash) {
			currentHash = hash;
		},
		"still-ok": function() {
			log("info", "[WDS] Nothing changed.")
		},
		"log-level": function(level) {
			logLevel = level;
		},
		ok: function() {
			if(initial) return initial = false;
			reloadApp();
		},
		warnings: function(warnings) {
			log("info", "[WDS] Warnings while compiling.");
			for(var i = 0; i < warnings.length; i++)
				console.warn(stripAnsi(warnings[i]));
			if(initial) return initial = false;
			reloadApp();
		},
		errors: function(errors) {
			log("info", "[WDS] Errors while compiling.");
			for(var i = 0; i < errors.length; i++)
				console.error(stripAnsi(errors[i]));
			if(initial) return initial = false;
			reloadApp();
		},
		"proxy-error": function(errors) {
			log("info", "[WDS] Proxy error.");
			for(var i = 0; i < errors.length; i++)
				log("error", stripAnsi(errors[i]));
			if(initial) return initial = false;
		},
		error: function(error) {
			console.error(error);
		},
		close: function() {
			log("error", "[WDS] Disconnected!");
		}
	};
	
	var hostname = urlParts.hostname;
	var protocol = urlParts.protocol;
	
	if(urlParts.hostname === '0.0.0.0') {
		// why do we need this check?
		// hostname n/a for file protocol (example, when using electron, ionic)
		// see: https://github.com/webpack/webpack-dev-server/pull/384
		if(window.location.hostname && !!~window.location.protocol.indexOf('http')) {
			hostname = window.location.hostname;
		}
	}
	
	// `hostname` can be empty when the script path is relative. In that case, specifying
	// a protocol would result in an invalid URL.
	// When https is used in the app, secure websockets are always necessary
	// because the browser doesn't accept non-secure websockets.
	if(hostname && (window.location.protocol === "https:" || urlParts.hostname === '0.0.0.0')) {
		protocol = window.location.protocol;
	}
	
	var socketUrl = url.format({
		protocol: protocol,
		auth: urlParts.auth,
		hostname: hostname,
		port: (urlParts.port === '0') ? window.location.port : urlParts.port,
		pathname: urlParts.path == null || urlParts.path === '/' ? "/sockjs-node" : urlParts.path
	});
	
	socket(socketUrl, onSocketMsg);
	
	function reloadApp() {
		if(hot) {
			log("info", "[WDS] App hot update...");
			window.postMessage("webpackHotUpdate" + currentHash, "*");
		} else {
			log("info", "[WDS] App updated. Reloading...");
			window.location.reload();
		}
	}
	
	/* WEBPACK VAR INJECTION */}.call(exports, "?http://localhost:8080"))

/***/ }),
/* 284 */
/***/ (function(module, exports, __webpack_require__) {

	var SockJS = __webpack_require__(252);
	
	var retries = 0;
	var sock = null;
	
	function socket(url, handlers) {
		sock = new SockJS(url);
	
		sock.onopen = function() {
			retries = 0;
		}
	
		sock.onclose = function() {
			if(retries === 0)
				handlers.close();
	
			// Try to reconnect.
			sock = null;
	
			// After 10 retries stop trying, to prevent logspam.
			if(retries <= 10) {
				// Exponentially increase timeout to reconnect.
				// Respectfully copied from the package `got`.
				var retryInMs = 1000 * Math.pow(2, retries) + Math.random() * 100;
				retries += 1;
	
				setTimeout(function() {
					socket(url, handlers);
				}, retryInMs);
			}
		};
	
		sock.onmessage = function(e) {
			// This assumes that all data sent via the websocket is JSON.
			var msg = JSON.parse(e.data);
			if(handlers[msg.type])
				handlers[msg.type](msg.data);
		};
	}
	
	module.exports = socket;


/***/ }),
/* 285 */
/***/ (function(module, exports) {

	/* WEBPACK VAR INJECTION */(function(__webpack_amd_options__) {module.exports = __webpack_amd_options__;
	
	/* WEBPACK VAR INJECTION */}.call(exports, {}))

/***/ }),
/* 286 */
/***/ (function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	/*globals window __webpack_hash__ */
	if(true) {
		var lastData;
		var upToDate = function upToDate() {
			return lastData.indexOf(__webpack_require__.h()) >= 0;
		};
		var check = function check() {
			module.hot.check(true, function(err, updatedModules) {
				if(err) {
					if(module.hot.status() in {
							abort: 1,
							fail: 1
						}) {
						console.warn("[HMR] Cannot apply update. Need to do a full reload!");
						console.warn("[HMR] " + err.stack || err.message);
						window.location.reload();
					} else {
						console.warn("[HMR] Update failed: " + err.stack || err.message);
					}
					return;
				}
	
				if(!updatedModules) {
					console.warn("[HMR] Cannot find update. Need to do a full reload!");
					console.warn("[HMR] (Probably because of restarting the webpack-dev-server)");
					window.location.reload();
					return;
				}
	
				if(!upToDate()) {
					check();
				}
	
				__webpack_require__(287)(updatedModules, updatedModules);
	
				if(upToDate()) {
					console.log("[HMR] App is up to date.");
				}
	
			});
		};
		var addEventListener = window.addEventListener ? function(eventName, listener) {
			window.addEventListener(eventName, listener, false);
		} : function(eventName, listener) {
			window.attachEvent("on" + eventName, listener);
		};
		addEventListener("message", function(event) {
			if(typeof event.data === "string" && event.data.indexOf("webpackHotUpdate") === 0) {
				lastData = event.data;
				if(!upToDate() && module.hot.status() === "idle") {
					console.log("[HMR] Checking for updates on the server...");
					check();
				}
			}
		});
		console.log("[HMR] Waiting for update signal from WDS...");
	} else {
		throw new Error("[HMR] Hot Module Replacement is disabled.");
	}


/***/ }),
/* 287 */
/***/ (function(module, exports) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	module.exports = function(updatedModules, renewedModules) {
		var unacceptedModules = updatedModules.filter(function(moduleId) {
			return renewedModules && renewedModules.indexOf(moduleId) < 0;
		});
	
		if(unacceptedModules.length > 0) {
			console.warn("[HMR] The following modules couldn't be hot updated: (They would need a full reload!)");
			unacceptedModules.forEach(function(moduleId) {
				console.warn("[HMR]  - " + moduleId);
			});
		}
	
		if(!renewedModules || renewedModules.length === 0) {
			console.log("[HMR] Nothing hot updated.");
		} else {
			console.log("[HMR] Updated modules:");
			renewedModules.forEach(function(moduleId) {
				console.log("[HMR]  - " + moduleId);
			});
		}
	};


/***/ }),
/* 288 */
/***/ (function(module, exports, __webpack_require__) {

	module.exports = function() {
		return new Worker(__webpack_require__.p + "location.js");
	};

/***/ }),
/* 289 */
/***/ (function(module, exports) {

	/* (ignored) */

/***/ })
/******/ ])));
//# sourceMappingURL=main.js.map